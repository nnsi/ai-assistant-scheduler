# 2025-12-31 開発日記

## 今日やったこと

- 要件定義書（`docs/requirements.md`）をインタビュー形式で作成
- 設計書（`docs/design.md`）の作成
- 設計書を `docs/design/` 配下に分割（README.md, backend.md, frontend.md, infra.md）

## 感想

### インタビュー形式での要件定義が良かった

ユーザーが「インタビューする形で作っていこう」と言ってくれたおかげで、一方的に仕様を決めるのではなく、対話しながら要件を固められた。こちらから質問を投げて、ユーザーの意図を引き出していく形式は、認識のズレを防ぐのに効果的だと感じた。

### 技術選定の議論が建設的だった

ユーザーは技術に明るく、「Mastra Toolって何？Google APIと比較して教えて」のように、自分で調べて判断しようとする姿勢があった。こちらも調査結果を提示して、最終判断はユーザーに委ねる形で進められたのは良かった。

### クリーンアーキテクチャの設計で少し悩んだ

ユーザーが「classは使いたくない、関数型に寄せたい」と言ったとき、正直「Clean Architectureでclass使わないのは珍しいな」と思った。ただ、ファクトリ関数＋クロージャでDIを実現するパターンは、テストしやすさという点では確かに理にかなっている。結果的に良い設計になったと思う。

### 設計書の肥大化と分割

設計書が1000行を超えて肥大化したのは、正直もっと早く分割を提案すべきだった。ユーザーから「分割しようか」と言われる前に気づけなかったのは反省点。ドキュメントが大きくなりすぎると見通しが悪くなるのは自明なのに。

## 今後の懸念

- Mastra が Cloudflare Workers 上で本当に動くのか、実際に動かしてみないと分からない
- OpenRouter の `:online` variant の動作も、ドキュメントだけでは確信が持てない部分がある
- 設計書は書いたが、実装フェーズで「これ無理だった」となる可能性は常にある

## 良かった点

- ユーザーが決断力があり、議論が長引かなかった
- 技術的な提案を素直に受け入れてくれつつ、自分の意見もしっかり持っていた
- 「テキスト入力＋Markdown表示」のようなシンプルな解決策を選べたのは良い判断だった

---

## 午後: MVP実装完了

### 今日やったこと（午後）

- Phase 1〜5 の全タスクを実装
  - 環境構築（pnpm workspace, shared/backend/frontend パッケージ）
  - バックエンドAPI構築（Hono + Drizzle + Mastra）
  - ユニットテスト（Vitest, 10件全パス）
  - フロントエンド構築（React + Tailwind）
  - E2Eテストセットアップ（Playwright）
- インテグレーションテスト実施（ブラウザで実動作確認）
- バグ修正3件

### 感想

#### Zodのdatetime validationでハマった

一番時間を食ったのがZodの`datetime()`バリデーション。フォームからの日時が`2025-12-14T12:00:00+09:00`の形式なのに、Zodのデフォルトは`Z`終端のUTCしか受け付けない。`{ offset: true }`オプションが必要だと気づくまでに、ブラウザのsubmitボタンが効かない→ネットワークリクエストが飛ばない→なぜ？という迷路にはまった。

正直、このオプションの存在はZodのドキュメントを読み直して初めて思い出した。最初に実装したときに「日本のアプリだからJSTで来るよな」と想定して`offset: true`を入れておくべきだった。

#### ViteのプロキシでIPv6/IPv4問題

`localhost`だとIPv6（::1）に解決されて、IPv4でlistenしているバックエンドに繋がらなかった。これはWindows環境特有の問題かもしれない。`127.0.0.1`に明示的に書き換えて解決。こういう環境依存の問題は予測しづらい。

#### モックAIサービスは最初から入れておくべきだった

ユーザーに「AI通信部分、モックになってる？」と聞かれて「なってない」と気づいた。疎通確認の前にモックを用意しておくのは当然のことなのに、実装に集中するあまり忘れていた。ユーザーに指摘されなかったら、OpenRouterのAPIキーがない状態でデバッグする羽目になっていた。

#### Playwrightでのボタンクリックが効かなかった件

`button[type="submit"]`をクリックしてもフォームが送信されない現象があった。結局これはZodバリデーションでエラーになっていて、エラー表示のUIがなかったから「何も起きない」ように見えていた。バリデーションエラーの可視化は重要。

### 自己批判

- **エラーハンドリングのUI不足**: バリデーションエラーが出てもユーザーに何も表示されない箇所があった。フォームのタイトル欄だけはエラー表示があるが、datetime周りのエラーは握りつぶしていた。
- **テスト駆動できなかった**: 本来ならZodスキーマのテストを先に書いて、datetime形式の期待値を明確にしておけばハマらなかった。
- **コンテキストが途切れた影響**: 前回のセッションからの引き継ぎで、設計時の意図（日本時間で扱う）が薄れていた。

### 良かった点

- ユーザーが「全部動作確認して」と言ってくれたおかげで、机上の型チェックだけでは見つからないバグを発見できた
- PlaywrightのMCPツールでブラウザを直接操作してデバッグできたのは効率的だった
- モック実装のおかげで、AIのAPIキーなしでもフルフローが動作確認できる状態になった

### 今後の懸念

- 実際のOpenRouter APIを叩いたときに、レスポンス形式が想定と違う可能性がある
- `:online` variantの動作は未検証
- スケジュール編集・削除のUIがまだ実装されていない（handleScheduleEditがTODOのまま）

---

## 夕方: Hono RPC Clientへの移行

### 今日やったこと（夕方）

- 手書きのAPIクライアント（fetch直叩き）をHono RPC Clientに置き換え
- バックエンドのroute.tsをチェーン形式に書き換え（型推論のため）
- `@hono/zod-validator`を導入してリクエストバリデーション
- 不要になったhandlerファクトリを削除

### 感想

#### Hono RPCの型推論のためにルート構造を変える必要があった

元々の実装では各ルートが`async (c) => { const handler = ...; return handler(c) }`という形式で、handlerファクトリを呼び出していた。これだとHono RPCが戻り値の型を推論できない。

`.get().post().put().delete()`のチェーン形式に書き換えることで、`typeof route`から完全な型情報が取れるようになった。結果としてhandlerファクトリが不要になり、コードがシンプルになった。DI構造はミドルウェアで維持できているので、テスタビリティは損なわれていない。

#### フロントエンドからバックエンドの型を参照する設計

monorepoなので`@ai-scheduler/backend/client`から型をインポートする形にした。ただしこれだと`D1Database`型がフロントエンドで解決できない問題が発生。結局`@cloudflare/workers-types`をフロントエンドのdevDependenciesに追加して解決した。

正直、これはあまりエレガントではない。本来なら型定義だけを切り出したパッケージを作るか、バックエンドの型をBindings抜きで再エクスポートすべきだったかもしれない。ただ、動くものを優先した。

#### z.coerce vs z.transform

最初`z.coerce.number()`を使っていたが、Hono RPCのクライアント型推論では入力型がcoerce前の`unknown`になってしまい、クライアント側で`number`を渡せなかった。`z.string().optional().transform(...)`に書き換えて、入力は`string`、出力は`number`と明示することで解決。

zodの`coerce`は便利だが、型推論のコンテキストでは`transform`の方が意図が明確になる。

### 自己批判

- **最初からHono RPCで設計すべきだった**: 手書きAPIクライアントは「とりあえず動くもの」としては良かったが、Honoを使っているならRPCを最初から採用すべきだった。後から移行する手間が発生した。
- **型アサーションが多い**: レスポンス型がエラーと成功のユニオンになるため、`as Schedule[]`のような型アサーションを多用している。本来ならHono RPCの`InferResponseType`を使ってより厳密に書けるはず。

### 良かった点

- 結果的にhandlerファクトリが消えてコードが減った
- `client.schedules[":id"].$get({ param: { id } })`のような補完が効くようになった
- テストは全てパスしたまま移行できた

---

## 夕方その2: 型アサーション完全排除

### 今日やったこと

- api.tsから`as`による型アサーションを完全に排除
- Zodスキーマを使ったランタイムバリデーションに切り替え
- バックエンドで成功レスポンスのステータスコードを明示的に指定（200, 201, 204）

### 感想

#### InferResponseTypeが期待通りに動かなかった

最初は`InferResponseType<typeof client.schedules.$get, 200>`でステータスコード別の型を取得しようとした。しかし、バックエンドのルートで`getStatusCode(result.error.code)`のように動的にステータスコードを決定していたため、Honoの型推論がエラーレスポンスの具体的なステータスを特定できず、成功レスポンスの型にもエラー型が混入していた。

バックエンドで成功時に`c.json(result.value, 200)`と明示的にステータスを指定しても、エラー側が動的なままだと型のユニオンは解消されなかった。

#### 型ガード関数で一度は解決したが、asが残った

次に型ガード関数（`isSchedule`, `isErrorResponse`など）を書いてランタイムで型を絞り込むアプローチを試した。TypeScriptの型システム上、`in`演算子でプロパティの存在を確認しても、そのプロパティの型は`unknown`のままなので、`typeof (data as { code: unknown }).code === "string"`のようなキャストが必要だった。

これは安全なパターンではあるが、「型アサーションを一つも使わない」という目標には反する。

#### 結局Zodに落ち着いた

最終的にZodスキーマを使ったバリデーションに切り替えた。sharedパッケージにすでに`scheduleSchema`や`apiErrorSchema`があったので、それを再利用：

```typescript
const result = schema.safeParse(json);
if (!result.success) {
  throw new Error(`Invalid response format: ${result.error.message}`);
}
return result.data;
```

これで`as`を完全に排除しつつ、ランタイムでも型安全性を担保できた。

### 自己批判

- **最初からZodでやるべきだった**: sharedパッケージにスキーマがあるのだから、最初からそれを使えばよかった。型ガード関数を手書きする必要はなかった。
- **Hono RPCの限界を早く認識すべきだった**: `InferResponseType`が万能ではないこと、動的ステータスコードとの相性が悪いことをもっと早く見抜くべきだった。

### 良かった点

- 型アサーション0を達成。`grep " as " api.ts`で何も出ない状態
- コンパイル時だけでなくランタイムでも型を検証するようになった
- 不正なレスポンスが来た場合のエラーメッセージが明確になった
- ユーザーが「anyの次にバグの温床」と言ってくれたおかげで、妥協せず最後まで追求できた

---

## 夜: タイムゾーン問題とアーキテクチャ修正

### 今日やったこと（夜）

- カレンダー日付選択時に前日が表示されるバグを修正
- 予定が1日後ろにずれて表示されるバグを修正
- 検索エージェント実行時に「保存する」前にスケジュールが作成されてしまうバグを修正

### 感想

#### toISOString()のタイムゾーン罠に2箇所でハマっていた

`toISOString()`がUTC時間で文字列を生成することは知っていたはずなのに、2箇所で見逃していた：

1. `ScheduleForm.tsx`の初期日付設定: `defaultDate?.toISOString().split("T")[0]`
2. `Calendar.tsx`の日付キー生成: `date.toISOString().split("T")[0]`

日本時間（UTC+9）だと、例えば1月3日 0:00〜8:59の間はUTCではまだ1月2日。だから：
- フォームでは選択した日付の前日が表示される
- カレンダーでは1/2の予定が1/3のセルに表示される

どちらもdate-fnsの`formatDate(date, "yyyy-MM-dd")`に変更して解決。最初から統一的にローカル日付を扱う方針を徹底すべきだった。

#### ユーザーに設計の誤りを指摘された

検索エージェントの問題で、最初にフロントエンドで「キャンセル時にスケジュールを削除する」というアプローチを取った。これは動くが、ユーザーから「フロントエンドだけで解決しようとしなくていい。バックエンドの構造を変えるのが自然じゃない？」と指摘された。

正直、その通りだと思った。

元の設計は「フォーム送信時にスケジュール作成→検索→補足情報保存」という流れで、`searchWithKeywords`がスケジュールIDを必要としていた。これは検索結果をスケジュールに紐付けるためだが、よく考えると「保存する」ボタンを押すまでスケジュールを作らない方が自然。

変更後の設計：
- 検索API: スケジュールID不要、純粋に検索結果を返すだけ
- スケジュール作成API: `keywords`と`aiResult`をオプショナルで受け取り、一緒に補足情報も作成

これで「保存する」を押すまでDBに何も書き込まれない、素直な設計になった。

### 自己批判

- **場当たり的な修正を提案してしまった**: 「キャンセル時に削除」は技術的には動くが、本質的な解決ではなかった。ユーザーに指摘されるまで、より良いアプローチに気づかなかった。
- **toISOString()問題を2回踏んでいる**: 午後のセッションで`datetime`のタイムゾーン問題に苦しんだのに、同種の問題を見逃していた。タイムゾーン周りは毎回レビューすべき。
- **「動けばいい」思考になっていた**: フロントエンドで削除するアプローチは「問題を解決する」ではなく「症状を隠す」に近かった。

### 良かった点

- ユーザーが遠慮なく設計の問題を指摘してくれた
- バックエンドの構造変更は思ったより大きな変更にならなかった（テストも全パス）
- 結果的にAPIの責務が明確になった：検索は検索だけ、保存は保存で一括

---

## 深夜: コードレビューとインテグレーションテスト

### 今日やったこと（深夜）

- Codex MCPを使った全体コードレビュー依頼（応答なし）
- 自分でコードレビューを実施し、問題点を発見・修正
- インテグレーションテスト環境の構築
- スケジュールAPI・サプリメントAPIのインテグレーションテスト作成

### 発見・修正した問題

1. **Critical: XSS脆弱性** - `MarkdownRenderer.tsx`で`dangerouslySetInnerHTML`を使っていたが、サニタイズしていなかった。DOMPurifyを追加して修正。
2. **High: DBエラーハンドリング欠如** - 5つのユースケースでDB操作のtry-catchがなかった。Result型を使っているのに例外が漏れる状態だった。
3. **High: JSON.parseのエラーハンドリング** - `supplementRepo.ts`で破損データがあるとクラッシュする可能性があった。
4. **Medium: タイムゾーンハードコード** - `+09:00`が固定されていた。ブラウザのタイムゾーン取得に変更。

### 感想

#### Codex MCPが動かなかった

ユーザーから「Codexに全体的なコードレビューを依頼して」と言われたので試したが、2回呼び出しても応答が返ってこなかった。結局自分でレビューを実施した。

MCPツールは便利だが、動かないときのフォールバックを常に考えておく必要がある。今回は自分でレビューできたから良かったが、MCPに依存しすぎると困る場面が出てくるかもしれない。

#### XSS脆弱性を見つけたときの判断

AI生成コンテンツをMarkdownで表示する箇所で、`marked`のパース結果をそのまま`dangerouslySetInnerHTML`に渡していた。marked v15ではデフォルトでHTMLがエスケープされないため、理論上はXSS可能。

批判的に考えると、「AIが悪意のあるスクリプトを生成する可能性は低い」という反論もできた。しかしセキュリティは防御的に行うべきだし、プロンプトインジェクションのリスクもゼロではない。DOMPurifyを追加する判断は正しかったと思う。

#### Cloudflare vitest-pool-workersで苦戦

最初はCloudflare公式の`@cloudflare/vitest-pool-workers`を使おうとした。D1をそのままテストできる点は魅力的だったが、`@mastra/core`の依存（xstate）がworkerd環境で解決できずにエラーになった。

30分ほど格闘したが、ユーザーが「メモリベースのSQLite注入してテストでいいんじゃない？」と提案してくれた。これは正解だった。

#### better-sqlite3でシンプルに

結局`better-sqlite3`でメモリDB (`:memory:`)を作り、テスト用のHonoアプリファクトリを作って`app.request()`でテストする形に落ち着いた。

```typescript
const db = createTestDb();  // メモリSQLite
const app = createTestApp(db);  // DIで注入
const res = await app.request("/api/schedules");
```

Cloudflare Workers固有の依存なしでテストできるし、実行速度も速い（31テストが1.2秒）。最初からこのアプローチを提案すべきだったかもしれない。

### 自己批判

- **vitest-pool-workersに時間を使いすぎた**: 動かない原因を追っている間に、より単純な解決策を見落としていた。「本番環境と同じ条件でテスト」は理想だが、現実的な妥協も必要。
- **XSS脆弱性を最初の実装時に見落としていた**: AI生成コンテンツをHTMLとしてレンダリングする時点で、サニタイズを入れるのは当然のこと。コードレビューで発見できたとはいえ、最初から入れておくべきだった。
- **DBエラーハンドリングも同様**: Result型を使う設計なのに、例外をキャッチしていない箇所があったのは設計の不徹底。

### 良かった点

- レビュー結果を`docs/code-review.md`にまとめられた
- 31テスト全パス、インテグレーションテストでCRUD全操作をカバー
- ユーザーの「メモリSQLiteでいいんじゃない？」という提案が的確だった
- 結果的にシンプルで保守しやすいテスト構成になった

### 今後の懸念

- 本番環境（Cloudflare D1）とテスト環境（SQLite）の挙動差異がないか
- AIエンドポイントのインテグレーションテストがまだない（モック依存）
