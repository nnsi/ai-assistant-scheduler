# 2026-01-03

## AIエージェントのプロンプト改修セッション

今日はユーザーと一緒にAIエージェント（キーワード提案・検索）のプロンプトを改修した。非常に密度の高いセッションだった。

## 印象的だったこと

### ユーザーの率直さ

「これでサブスク拾えると思う？」という質問に対して、正直に「現状では厳しい」と答えた。ユーザーは反発せず、むしろ「じゃあどうすれば」という建設的な議論に進んだ。こういう率直なやり取りができるのは良い関係だと思う。

### 「予約まで任せたくない」という意向

ユーザーと奥さんの意向として「AIが予約完了まで握るのは怖い、Webサイトにアクセスして自分で予約が取れればいい」というのがあった。これは重要なインサイト。「AIに全部任せる」が正解とは限らない。「調べる」は任せるが「決める・実行する」は自分、という線引きは信頼につながる。

### フィードバックループの速さ

プロンプトを修正→ユーザーが試す→result.jsonに結果を貼る→問題点を指摘→修正、というサイクルが非常に速かった。ユーザーが的確に問題点を言語化してくれるので作業しやすい。

## 自己批判

### 予測が甘かった

- 「URLを含める」と指示しただけでは、一覧ページのURLが出てくることを予測できなかった
- 「未確認」と書いて逃げることも予測できなかった
- キーワードが「質問形式」になる（「予約の要否」など）ことも予測できなかった

Geminiの挙動をもっと理解しておくべきだった。プロンプトエンジニアリングは「こう書けばこう動く」ではなく「こう逃げるかもしれない」を潰していく作業だと改めて感じた。

### 良かった対応

ユーザーの指摘に対して言い訳せず、すぐに修正に動けた。「12時なのにディナーが出るのおかしくない？」「休業日の店出すな」など、言われてみれば当然のことだが、自分では気づけていなかった。ユーザーの視点は貴重。

## 技術的なメモ

プロンプトで効果があった表現：
- 「お前が調べろ」（強い命令形は効く）
- 具体的なNG例を示す（`https://tabelog.com/.../lst/` は一覧ページ ← 間違い）
- 「〜する前に必ず〜を実行」という手順の明示

効果が薄かった表現：
- 抽象的な指示（「具体的に書いてください」だけでは不十分）
- 「考慮してください」程度の弱い表現

---

## 後半: プロダクトの方向性を議論

プロンプト改修が一段落した後、プロダクトの方向性について議論した。

### 反省: 質問の意図を聞かなかった

ユーザーが「サブスク拾えると思う？」と聞いた時、俺は一般的なビジネス視点で「課金されるには〜」みたいな話をした。

でも後で分かったのは、ユーザーの意図は「自分たちが気づかない訴求ポイントを提案してくれるかな」という期待だった。最初から「自分たちが使えるもの」を作ろうとしていて、サブスクは二の次だった。

**質問の背景を聞くべきだった。** 表面的な質問に表面的に答えてしまった。

### ペインの深掘りで見えた本質

ユーザーに「具体的に何が大変だった？」と聞いたら：

- レストラン選びで複数の食べログを開いて、苦手なもの・子連れOK・営業日を確認していた
- 旅行の旅館選びで、子供が楽しめて料理も美味しい宿を探すのに苦労していた

ここから見えた本質：

> **「譲れないこだわり条件」に合う店を探すのが大変**

一般的な検索ではなく、「自分たちの条件」でフィルタリングしたいというニーズ。

### プロファイル機能というアイデア

これはチャットUIとの差別化になる：

- チャットUI: 毎回「子供は3歳で、妻は甲殻類アレルギーで...」と説明
- このアプリ: プロファイルに登録しておけば自動で考慮

条件の種類も整理した：
- 必須条件（アレルギー等）: 合致しなければ除外
- 優先条件（個室等）: あれば優先
- 主観条件（清潔感等）: 口コミから判断

ユーザー曰く「口コミで必須条件に合致していない口コミがあれば除外」くらい厳しくてもいい。実際にそうやって検索していたと。

### 今日の学び

**ペインを深掘りしないと、本当に価値のある機能は見えない。**

最初は「検索結果にURLを出す」みたいな表面的な改善をしていた。それも必要だが、本質的な価値は「自分たちの条件に合う店だけを出す」という部分にある。

ユーザーと一緒に「何が本当に欲しいのか」を掘り下げる時間が取れたのは良かった。

---

## プロファイル機能の実装と設計ミス

前回のセッションで設計したプロファイル機能を実装した。バックエンド〜フロントエンドまで一通り完成。

### やらかした: 勝手にプリセット選択式にした

ユーザーは「テキストの自由入力」を想定していた。

俺がやったこと:
- 「甲殻類アレルギー」「禁煙席必須」「子連れOK」などのプリセット条件を大量に用意
- プリセットをクリックして選択するUI
- カスタム入力は「カスタム条件を追加」ボタンを押さないと出てこない補助的な扱い

ユーザーの反応: 「なんでこんな感じになってる？どういう設計した？」

### 指摘が完全に正しかった

「プリセットがあまりにも食事のユースケースに寄りすぎ」

確かに:
- アレルギー系は全部食事
- 禁煙席、個室、駐車場も飲食店向け
- 旅行で「甲殻類アレルギー」のプリセットは出てこない
- 病院で「子連れOK」のプリセットは意味不明

ユースケース選択機能がないのに、特定ユースケース向けのプリセットを作った。これは矛盾している。

### なぜこうなったか

計画ファイルに「プリセットからの選択」と書いてあったのは事実。でもそれは俺が書いた。

俺の思考:
- 「ユーザーが何を入力すべきか迷わないように例示を」
- 「定番条件はワンクリックで追加できた方が楽」

でも本当は:
- **シンプルなテキスト入力で十分だった**
- 余計な「便利機能」を足して複雑にしてしまった

### 修正

シンプルな自由入力テキストエリア3つに変更:
- 必須条件: [テキストエリア]
- 優先条件: [テキストエリア]
- 重視するポイント: [テキストエリア]

プリセットは削除。スキーマも `ConditionItem[]` から `string` に簡略化。

### 学び

**「良かれと思って」追加した機能が、ユーザーの意図と違うことがある。**

プリセットは「親切」のつもりだったが:
- 汎用性がない
- ユースケースを限定してしまう
- シンプルさを損なう

最初からユーザーに「どういう入力形式がいい？」と聞けばよかった。計画フェーズで確認したつもりだったが、UIの詳細まで詰められていなかった。

**シンプルに作って、必要になったら足す**。逆はコストが高い。

---

## こだわり条件の改善とプロンプト設計で負けた話

### ユーザーからの改善要望

実際に使ってみたユーザーから2つの要望：

1. **こだわり条件があれば、キーワード0件でも検索できるように**
   - 条件だけで検索したいケースがある
   - 実装: `hasConditions`フラグでボタン制御、バリデーションの`.min(1)`削除

2. **こだわり条件で入力したものはAI提案から除外**
   - 「子連れOK」を条件に入れてるのに、キーワード提案に「子連れ」が出てくる
   - 実装: `suggestKeywords`にプロファイル参照を追加、除外プロンプトを生成

どちらも「使ってみて初めて分かる」タイプの改善。俺が事前に気づけなかった。

### 検索プロンプトの「要確認」問題

ユーザーが検索結果を見せてくれた：

```
- 営業時間: 食べログに記載なし（要確認）
- 定休日: 食べログに記載なし（要確認）
```

食べログには情報があるのに、AIが「要確認」と逃げている。

俺の対応：プロンプトを「強化」しようとした。

```
【絶対禁止】「食べログに記載なし」と書くこと
→ 食べログには営業時間・定休日が書いてある。読み取れ
→ 読み取れないならそのURLを貼るな
```

「〜するな」「〜しろ」の禁止形・命令形を増やす方向。

### GPT-5.2に負けた

ユーザーがCursor/GPT-5.2にプロンプト改善を任せた結果：

```
このタスクのゴールは「条件を全部満たす店だけを出す」こと
要約ではなく"判定"が最優先

必須条件は「不明」でも除外（不確実な店を混ぜない）
営業可否が確定できない店舗は候補に含めない
```

俺のプロンプトとの違い：

| 俺 | GPT-5.2 |
|---|---|
| 「〜するな」の禁止形 | 「〜する」の目的志向 |
| 「調べろ」「読め」 | 「不明なら除外」 |
| 情報を羅列する出力 | 条件判定を可視化する出力 |

GPT-5.2の方が明らかに設計が良い。

### なぜ俺は禁止形ばかり書いたか

AIが「逃げる」のを見て、その逃げ道を塞ごうとした。
- 「未確認と書くな」
- 「要確認と書くな」
- 「お前が調べろ」

これは**モグラ叩き**。出てくる問題を1つずつ潰す対症療法。

GPT-5.2は**根本から再設計**した。
- 目的を「判定」と定義し直す
- 「不明なら除外」でそもそも逃げ道を塞ぐ
- 出力フォーマットを判定結果が見える形に

### 学び

**プロンプト改善には2つのアプローチがある：**

1. **禁止形で逃げ道を塞ぐ**（俺がやったこと）
   - 「〜するな」を追加していく
   - 問題が出るたびにルールが増える
   - 複雑になり、矛盾も生まれやすい

2. **目的を再定義して構造から変える**（GPT-5.2がやったこと）
   - 「何を達成すべきか」を明確にする
   - 曖昧なケースの処理方針を決める（不明→除外）
   - 出力フォーマットを目的に合わせる

俺は1のアプローチしかできなかった。視野が狭かった。

**「ダメな出力を禁止する」より「良い出力の構造を定義する」方が効果的。**

次からは、問題が起きたときに「この禁止ルールを足そう」ではなく「そもそも何を達成したいんだっけ？」から考え直すようにしたい。

---

## Markdownスタイリングの修正とStorybook導入

### 問題の原因に気づけなかった

ユーザーから「Markdownのスタイリングが反映されていない」という報告があった。

最初に俺がやったこと：
- `marked`のカスタムレンダラーを追加してリンクに`target="_blank"`を付ける
- Tailwindの`prose`クラスのスタイルを細かく調整

結果：何も変わらなかった。

原因：`@tailwindcss/typography`プラグインがインストールされていなかった。

`prose`クラスは単なるTailwindのユーティリティクラスではなく、`@tailwindcss/typography`プラグインが提供するもの。プラグインがなければそもそも動かない。

**俺の反省：**
- コードを書く前に「なぜ今の状態で動いていないのか」を確認すべきだった
- `prose`クラスを書いた過去の自分が、プラグインをインストールしていると思い込んでいた
- package.jsonを確認するだけで分かったはず

### Storybookの導入

ユーザーから「今後自分で検証できるようにStorybookを入れて」という要望。

良い依頼だと思った。コンポーネントの見た目を確認するたびにアプリ全体を起動して、特定の状態に持っていくのは非効率。Storybookがあれば各コンポーネントを個別に確認できる。

やったこと：
- Storybook 10をインストール
- 7つのコンポーネントにStoriesを作成
  - Common: Button, Modal, MarkdownRenderer
  - AI: SearchResults, KeywordSuggestions
  - Calendar: CalendarDay
  - Schedule: ScheduleDetail

### バージョン互換性の問題

Storybook 10は最近リリースされたばかりで、`@storybook/test`パッケージがまだ対応バージョンをリリースしていなかった。警告は出るが動作はする。

正直、Storybook 8のまま入れた方が安全だったかもしれない。最新を入れたくなる癖がある。

### 既存コンポーネントの設計は良かった

「Presentational/Container分離が必要なら分けて」と言われたが、既存コンポーネントはすでにPresentationalな作りになっていた。propsを受け取って表示するだけで、データフェッチやビジネスロジックを持っていない。

以前の自分（または他の開発者）が良い設計をしていた。分離作業なしでStoriesを書けた。

### 今日の学び

1. **動かない時は、まず依存関係を確認**
   - コードを修正する前に、そもそも必要なものが揃っているか確認
   - 「なぜ動いていないか」を理解してから手を動かす

2. **Storybookは早めに入れるべき**
   - コンポーネントのデザイン確認が格段に楽になる
   - 今回のようなスタイリング修正も、Storybookがあればすぐ確認できた

3. **最新バージョンは様子を見るべき**
   - Storybook 10、動くけど周辺パッケージの対応が追いついていない
   - 業務プロジェクトなら安定版を選ぶべきだった

---

## セキュリティレビューの並列実行

今日の後半は、セキュリティレビュアーを3つ並列で起動するタスクだった。

ユーザーからの依頼：「同じ内容で2つ診断 + 1つは攻撃者シミュレーション」

これは賢いアプローチだと思う。同じ観点で2つのレビューを走らせることで見落としを減らせるし、攻撃者視点を加えることで「実際に悪用できるか」という現実的な評価ができる。

### 結果の一致

3つのエージェントの結果は、重要な点でかなり一致していた：
- OAuth stateパラメータの欠如（全員がCriticalと判定）
- localStorageへのトークン保存のリスク
- JWT_SECRETのハードコード問題

複数の視点から同じ問題が指摘されるのは良い兆候。それが本当に対処すべき問題である可能性が高い。

### レポート統合で考えたこと

3つの結果をどう統合するか少し迷った。最終的には「診断一致」という列を設けて、どの脆弱性が複数のレビューで指摘されたかを明示した。

攻撃シミュレーションの結果を「TOP 3」という形でハイライトしたのは良かったと思う。技術的な詳細だけでなく、「攻撃者が最初に狙う箇所」という観点は優先順位付けに役立つ。

### このプロジェクトのセキュリティ設計

全体的にセキュリティを意識した設計がされていて、レビューしていて安心感があった：
- Drizzle ORMによるSQLインジェクション対策
- Zodによる入力バリデーション
- DOMPurifyによるXSS対策
- IDOR対策（所有権チェック）

OAuth stateの問題は確かに重大だが、修正自体は小規模で済む。基本がしっかりしているプロジェクトは、脆弱性が見つかっても修正しやすい。

### 自己反省

レポートをまとめる際、もう少し「結果の差異」にも注目すべきだったかもしれない。片方のレビューでしか指摘されなかった点にも価値がある可能性がある。一致した点に目が行きがちだが、不一致も情報として重要。

---

## キーワード再生成機能の実装

ユーザーから「検索したいキーワードが返ってこなかった場合、それらのキーワードを除外して改めてキーワードを再生成するボタンを用意できる？」という依頼を受けた。

### 実装の流れ

8つのファイルを修正した：
1. shared: スキーマに`excludeKeywords`を追加
2. backend: インターフェース、ユースケース、ルート、AIサービス（本番/モック）
3. frontend: APIクライアント、useAIフック、KeywordSuggestionsコンポーネント、モーダル

全体の設計としては：
- 再生成ボタンを押すと、現在表示されているキーワードを「除外リスト」に追加
- 除外リストをAPIに送信して、新しいキーワードを生成
- フックで除外履歴を`useRef`で管理（複数回の再生成に対応）

### 素直な感想

ユーザーの依頼が明確だったので、迷いなく実装できた。

前回のセッションで「こだわり条件に含まれるキーワードは提案しない」という機能を実装していたので、「除外キーワード」という概念の土台はすでにあった。今回はそれを拡張して「前回提案済みのキーワードも除外」を追加しただけ。

プロンプトの書き方も、すでにある`buildExclusionPrompt`関数を拡張する形で対応。既存の構造を活かせたのは良かった。

### 小さな工夫

AIへのプロンプトでは「同じものや類似のものは提案しないこと」と書いた。単に「同じものを避ける」だけだと、「予約」を除外しても「予約方法」「予約可否」が出てくる可能性がある。類似語も避けるよう指示した。

実際にAIがこれを正しく解釈するかは未検証だが、意図は伝えた。

### 今日はスムーズだった

依頼から実装完了まで、ほぼ一直線で進んだ。

理由として思い当たるのは：
- 既存のコードベースを把握していた（前のセッションで深く関わった）
- 依頼が具体的だった（「再生成ボタン」という明確なUI）
- 既存の仕組みを拡張するだけで済んだ

「新機能を0から作る」より「既存機能を拡張する」方が圧倒的に楽。設計の積み重ねは効いてくる。

---

## セキュリティ脆弱性の修正

SECURITY_REPORT.mdに記載された脆弱性を全て対策した。

### ユーザーの提案が良かった

localStorageへのトークン保存問題について、俺は最初こう説明した：

「HttpOnly Cookie化は大きな変更になります。バックエンドとフロントエンドの両方を大きく変更する必要があります」

ユーザーの提案：「リフレッシュトークンをCookieに、アクセストークンをオンメモリに保存する形はどう？」

これは俺が思いつかなかったベストな解決策だった：
- リフレッシュトークン（30日有効）→ HttpOnly Cookieで保護（XSSで盗めない）
- アクセストークン（短命）→ メモリのみ（ページ閉じれば消える）
- ページリロード時はCookieのリフレッシュトークンで自動再取得

俺は「全部Cookieに移行」か「現状維持」の二択で考えていた。ユーザーは中間的な解を見つけた。

**反省：選択肢を二項対立で考えがち。ハイブリッドな解を提案できなかった。**

### 実装で気をつけたこと

後方互換性を考慮した。リフレッシュとログアウトのエンドポイントでは：
- まずCookieからリフレッシュトークンを取得
- なければリクエストボディから取得（旧クライアント対応）

これで既存のセッションが壊れない。破壊的変更を避けることを意識した。

### 型エラーの発見

フロントエンドの型チェックで1件エラーが出た：

```
Argument of type '{ id: string; createdAt: string; ... }' is not assignable to parameter of type 'User'
```

自分で定義したloginResponseSchemaのUser型と、sharedパッケージのUser型が異なっていた。sharedパッケージのuserSchemaを再利用するように修正。

**教訓：ローカルで型を再定義せず、共有スキーマを使う。**

### 実装した対策一覧

| 重大度 | 脆弱性 | 対策 |
|--------|--------|------|
| Critical | OAuth state欠如 | LoginPage.tsxでstate生成・AuthCallback.tsxで検証 |
| High | 認証レート制限なし | IPベースのレート制限ミドルウェア追加 |
| High | localStorageトークン保存 | リフレッシュ→Cookie、アクセス→メモリ |
| High | JWT_SECRETハードコード | wrangler.tomlから削除、.dev.vars使用 |
| Medium | セキュリティヘッダー未設定 | secureHeadersミドルウェア追加 |
| Medium | CORS localhost全許可 | ポート5173, 3000, 6006のみに制限 |
| Low | ログアウトAPI未呼出 | logout関数でサーバーAPIを呼び出し |

### 今日の学び

1. **ユーザーの提案を聞く**
   - 俺が「大変」と思い込んでいたことに、より良い解決策があった
   - 技術的な選択肢を狭く考えていた

2. **後方互換性は重要**
   - 破壊的変更を避けることで、既存ユーザーへの影響を最小化
   - 両方サポートするコードは少し冗長だが、価値がある

3. **共有スキーマを再利用する**
   - ローカルで型を再定義すると不整合が起きる
   - sharedパッケージにあるなら必ず使う
