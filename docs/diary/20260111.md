# 2026-01-11

## 複数店舗選択機能の実装

前回のセッションから引き継いで、複数店舗選択機能のブラウザテストを完了した。

### やったこと

- `selectedShop` → `selectedShops` へのリネーム（スキーマ、ドメイン、リポジトリ、ユースケース、API、フロントエンド全層）
- D1マイグレーションファイルの作成と実行
- 複数選択UI（トグルボタン、選択カウンター、保存ボタン）
- 詳細画面での複数店舗表示

### 技術的な所感

シンプルな変更のはずが、全層を触る必要があって作業量は多かった。特にテストのモックデータの同期漏れで何度かエラーが出た。CLAUDE.mdにも書いてあるパターン（テストDBスキーマの同期、E2Eテストのモック同期）だが、やはり見落としやすい。

カラム名変更のマイグレーションは`ALTER TABLE ... RENAME COLUMN`で済んだ。SQLiteの制限でD1でも動くか少し心配だったが、問題なかった。

### ユーザーとの対話について

ユーザーは最初「1つしか選択できないのはUIとして不適切では」と問いかけてきた。私が3つの選択肢を提示したところ、ユーザーは「最もコアな価値だけを提供したい」と明確な方針を示してくれた。

「順序もステータスも上限も不要」「必要なら自分でメモに書く」という割り切りは良い判断だと思う。過剰な機能追加は避けつつ、「巡る店が強調されている」という視覚的価値は確保できた。

### 反省点

特になし。セッション引き継ぎで状態が途中だったが、スムーズにブラウザテストを完了できた。

---

## ブラウザUX評価とバグ修正

### やったこと

ユーザーから「ブラウザで色々触って改善点をレポートして」と依頼された。Playwrightでアプリを一通り操作した：

- 予定作成（手動・AI補完両方）
- カテゴリ管理
- こだわり条件設定
- 週表示・日表示切り替え
- 検索機能

AI検索機能は想像以上によくできていた。キーワード提案→店舗検索→結果保存の流れがスムーズで、検索結果に公式サイト・予約リンク・地図リンクが含まれているのは実用的。

### 発見したバグと修正

3つのバグを発見し、修正した：

1. **React key重複エラー**: `key={keyword}`で同じキーワードが複数回提案されると重複
   - `key={\`${keyword}-${index}\`}` に修正

2. **検索結果の重複表示**: LEFT JOINで重複が発生
   - `selectDistinct()` に変更

3. **日付フォーマット**: アクセシビリティ上、日付と時間の間にスペースがない
   - 明示的なスペース文字を追加

サブエージェント（browser-tester）で動作確認し、全て解消を確認。

### 反省点

AI補完のタイムアウト問題が発生したとき、サーバーが落ちた原因を深く調査しなかった。ユーザーがサーバーを再起動してくれたので先に進めたが、根本原因を特定すべきだった。

また、`selectDistinct`で検索結果の重複は解消したが、そもそもなぜ重複データが存在するのか（DBの問題なのか、JOINの問題なのか）を明確にしなかった。動くようになったからOK、ではなく原因を突き止めるべきだった。

---

## 予定編集時のカテゴリ初期選択バグ修正

### やったこと

予定編集モーダルを開いた時に、予定に設定されているカテゴリが選択状態にならないバグを修正した。

#### バグの原因

Reactの`useState`は初回マウント時のみ初期値を使用する。`ScheduleForm`がマウントされた後に`initialValues`が変更されても、内部のstateは更新されない。

#### 修正内容

1. `ScheduleEditModal`で`key={schedule.id}`を追加
2. `ScheduleForm`で`useEffect`による`categoryId`の同期を追加（フォールバック）

正直なところ、問題の根本原因を特定するのに時間がかかった。`Modal`が閉じるたびに子コンポーネントがアンマウントされるはずなので、最初は「なぜこのバグが発生するのか？」が理解できなかった。結局、`key`と`useEffect`の両方を追加する「防御的な」実装にした。

### E2Eテストの追加とクラッシュ問題

カテゴリ選択のE2Eテストを追加した。しかし、テスト実行時にブラウザがクラッシュする問題が発生。ユーザーから「以前は動いていた」と言われ、原因調査を依頼された。

試したこと：
- `--no-sandbox`, `--disable-setuid-sandbox` → 効果なし
- `--disable-dev-shm-usage`, `--disable-gpu` → 効果なし
- `--single-process` → 一部動くが不安定
- `--no-zygote` → これが有効だった

コンテナ環境でのChromium実行は、Zygoteプロセス（フォーク用）が問題を起こすことがある。`--no-zygote`で無効化して解決。

### タイムゾーン問題

終了時間のテストで`11:00`を期待しているのに`02:00`が返される問題があった。モックデータが`+09:00`（JST）で、テスト環境がUTCだったため9時間ずれていた。

`timezoneId: "Asia/Tokyo"`の1行で解決。これは最初から気づくべきだった。エラーメッセージに「Expected: 11:00, Received: 02:00」と出ていたのに、タイムゾーンの問題だとすぐに判断できなかった。

### 反省点

1. E2Eテストのクラッシュ調査で、`git stash`を使ったら意図せずファイルが戻ってしまった。stashの挙動を十分に理解せずに使ったのが原因。

2. タイムゾーン問題は、9時間ずれているという明確なヒントがあったのに気づかなかった。「02:00 = 11:00 - 9時間」という計算をすぐにすべきだった。

3. クラッシュ調査では体系的なデバッグというより、オプションを順番に試していくアプローチになった。もう少し効率的にできたかもしれないが、コンテナ環境のChromiumトラブルは経験がないと難しい面もある。

### 技術メモ

コンテナ環境でPlaywright/Chromiumを動かす際の推奨オプション：
```typescript
args: [
  "--no-sandbox",
  "--disable-setuid-sandbox",
  "--disable-dev-shm-usage",
  "--disable-gpu",
  "--disable-software-rasterizer",
  "--no-zygote",  // これが重要
]
```

Playwrightのタイムゾーン設定：
```typescript
use: {
  timezoneId: "Asia/Tokyo",
}
```

---

## こだわり条件の要否とUX診断

### 議論の内容

ユーザーから「こだわり条件、予定作成時にタイトル以外の情報を入力できるようになると不要になりそうな感じもするんだけどどう思う？」と質問された。

私の回答は「不要になる」ではなく「棲み分けが曖昧になる」だった。

- こだわり条件 = ユーザー全体（全予定に適用）
- 予定詳細 = その予定だけ

両者は補完関係にあり、どちらかが不要になるわけではない。ただし、使い分けが面倒なら統合する設計もありえると伝えた。

ユーザーは「予定詳細（メモ）で禁止条件とかを設定するのは難しそう。もう少しこのままで使ってみて気になったら修正」という判断をした。

### 私の所感

この判断は妥当だと思う。こだわり条件の3段階（必須/優先/重視）は、予定メモでは表現しにくい「強制力の度合い」を明確にできる。「禁煙」と書いても「禁煙希望」なのか「禁煙じゃないと絶対ダメ」なのかAIには判断しにくい。

一方で、両方の機能が存在することでユーザーが「どっちに書けばいいんだ」と迷う可能性はある。使い込んでから判断するのは正しいアプローチ。

### UX診断の実施

ユーザーから「予定を入れる時にGoogle検索するのが面倒」というコンセプトに沿って作られているか診断してほしいと依頼された。

Playwrightで実際にアプリを操作した：

1. カレンダーの日付クリック → 予定作成モーダル
2. タイトル入力「渋谷 イタリアン ディナー」
3. 「AIで補完」クリック → キーワード提案（デート、おしゃれ、ワイン等）
4. キーワード選択 → AI検索実行
5. 検索結果表示（店舗候補、条件判定、営業時間等）
6. 店舗選択カード表示
7. 予定がカレンダーに自動保存

### 診断結果

**コンセプト適合度: ◎ 良好**

正直に言うと、想像以上によくできていた。特に以下の点：

- **条件判定の可視化**: 各店舗が必須条件✅/優先条件✅△を満たしているか一目でわかる
- **営業日確認**: 指定日に営業しているかを自動チェック
- **複数サイト横断**: ぐるなび、一休、Yahoo!マップ等を横断して情報収集

Google検索で同じことをやろうとすると、各店舗のページを開いて営業時間を確認し、禁煙かどうかを調べ…という作業が必要。それが自動化されているのは明確な価値。

### 改善点として挙げたこと

1. **検索しない予定との棲み分け**: 「週次ミーティング」のような予定にも「AIで補完」ボタンが目立つ位置にある
2. **店舗選択後の体験**: 予約導線や地図連携があると便利
3. **キーワードの自由入力**: 提案が的外れな場合の保険

### レポート出力

`docs/report/2026-01-11-ux-diagnosis.md` に診断結果をまとめた。

### 反省点

特になし。ブラウザ操作での診断は前回のセッションでも行っていたので、スムーズに進められた。

ユーザーとの対話も良好だった。「どう思う？」という質問に対して、単に「いいと思います」と同調するのではなく、「棲み分けが曖昧になる」という客観的な分析を伝えられた。

---

## 不要なuseEffectの一掃

### やったこと

ユーザーから「不要なuseEffectを一掃したい」という依頼を受けた。まずExploreエージェントで全useEffectを調査し、14個を発見。以下のカテゴリに分類した：

- **外部との同期（11個）**: DOM操作、localStorage、URL、タイマーなど → 必要
- **一度きりの処理（2個）**: OAuth認証コールバック → refガードで対応済み
- **状態の派生（4個）**: propsをstateに同期 → 削除候補

状態の派生の4件を修正：

1. **ScheduleForm.tsx**: `initialValues?.categoryId`をstateに同期するuseEffectとrefを削除。親の`ScheduleEditModal`で既に`key={schedule.id}`が設定されていたため、再マウントで初期化される。

2. **ConditionsModal.tsx**: `profile`から3つのフィールドをstateに同期するuseEffect。フォーム部分を`ConditionsFormContent`として切り出し、`key={profile.userId}`でリセットする形に変更。

3. **CalendarSettingsModal.tsx**: 同様のパターン。`CalendarSettingsForm`として切り出し、`key={calendar.id}`でリセット。

4. **RecurrenceSettings.tsx**: 複数stateの変更を監視して親に通知するuseEffect。`buildRule`ヘルパー関数と各イベントハンドラで直接`onChange`を呼ぶ形に変更。

型チェック、バックエンドテスト、E2Eテスト全てパス。

### 技術的な所感

**ScheduleForm.tsxのuseEffectは前回のセッションで私が追加したもの**だった。「コンポーネントがkeyで再マウントされない場合のフォールバック」というコメントを書いたが、今回の調査で親に`key={schedule.id}`が設定されていることが判明し、実際には不要だった。前回の実装時にもっと調査すべきだった。

RecurrenceSettings.tsxの修正は最も複雑だった。8個のstate、8個のハンドラ関数、1個のbuildRuleヘルパー。コード量は増えたが、useEffectで暗黙的に親に通知するより、イベントハンドラで明示的に呼ぶ方がReact的には正しい。

```typescript
// 修正前: useEffectで監視→通知
useEffect(() => {
  onChange(buildRule());
}, [isEnabled, frequency, interval, ...]);

// 修正後: 各ハンドラで直接通知
const handleFrequencyChange = (f: Frequency) => {
  setFrequency(f);
  onChange(buildRule({ frequency: f }));
};
```

`buildRule`で`overrides`パラメータを受け取る設計にしたのは、setterを呼んだ直後はまだ古いstate値が参照されるため。新しい値をoverrideとして渡すことで、正しいruleが構築される。

### keyによるリセットパターンについて

ConditionsModalとCalendarSettingsModalでは、フォーム部分を内部コンポーネントに切り出して`key`でリセットするパターンを使った。これはReactの推奨するやり方だが、コンポーネントの分離が必要になる点がデメリット。

ただ、今回の場合はそもそも「ローディング中/エラー/フォーム」の条件分岐があったので、フォーム部分を切り出すのは自然な構造化だった。結果的にコードの見通しも良くなった。

### 反省点

1. **前回の実装を振り返る機会になった**: ScheduleForm.tsxのuseEffectは、問題の根本原因を特定せずに「防御的に」追加したものだった。今回の調査で不要だと判明したのは良い学び。

2. **CalendarContext.tsxの無限ループリスク**: 調査中に発見したが、今回は対象外だった。依存配列に含まれるstate値（`selectedCalendarIds`, `defaultCalendarId`）が更新されると再実行されるため、無限ループのリスクがある。ユーザーに報告したが、今回は修正しなかった。次回の課題として残っている。

### ユーザーとの対話

ユーザーの依頼は明確で、「値の計算で対応できるものは全てuseEffect外したい」という方針だった。調査結果を報告し、削除候補4件を提示したところ「じゃあ全て修正しよう」と即決。効率的なセッションだった。

---

## 共有カレンダー機能のバグ修正

### 問題1: 共有カレンダーのスケジュールが表示されない

ユーザーから「共有されたカレンダーのリンクを開いても、カレンダーの内容が変わらない」という報告。

調査の結果、複数の原因が判明した：

1. **バックエンドのクエリがuserIdのみでフィルタ**: `getSchedules`ユースケースがカレンダーIDを考慮していなかった
2. **既存データにcalendarIdがない**: カレンダー機能実装前のスケジュールは全て`calendar_id = NULL`だった

#### 修正内容

**バックエンド:**
- `ScheduleRepo`に`findByCalendarIdsOrUserId`と`findByMonthAndCalendarIdsOrUserId`を追加
- クエリ条件: `(calendarId IN (...)) OR (calendarId IS NULL AND userId = ...)`
- レガシーデータ（calendarId=NULL）も含めて取得する設計

**データマイグレーション:**
```sql
UPDATE schedules
SET calendar_id = (
  SELECT id FROM calendars
  WHERE owner_id = schedules.user_id
  ORDER BY created_at LIMIT 1
)
WHERE calendar_id IS NULL
```

SQLiteのサブクエリで既存スケジュールにデフォルトカレンダーを紐付けた。

### 問題2: カレンダーのチェックボックスが外せない

カレンダー管理モーダルでチェックを外しても、即座に再チェックされる問題。

#### 原因

前回のセッションで追加した「新規カレンダーの自動選択」ロジックが原因だった：

```typescript
// 問題のコード
const newCalendarIds = validIds.filter(
  (id) => !selectedCalendarIds.includes(id)  // ← チェックを外すと「新規」扱いに
);
if (newCalendarIds.length > 0) {
  // 自動で選択状態に追加 → 外したはずが戻る
}
```

useEffectの依存配列に`selectedCalendarIds`があり、チェック解除 → state更新 → useEffect再実行 → 「新規カレンダー」として再追加、という無限ループに近い状態。

#### 修正内容

`useRef`で「既知のカレンダーID」を追跡するようにした：

```typescript
const knownCalendarIdsRef = useRef<Set<string>>(new Set());

// 本当に新しいカレンダーのみを検出
const newCalendarIds = validIds.filter(
  (id) => !knownCalendarIdsRef.current.has(id)
);

// 既知のカレンダーIDを更新
knownCalendarIdsRef.current = new Set(validIds);
```

### 問題3: 新規アカウント作成時にデフォルトカレンダーがない

ユーザーから「アカウント作成時にデフォルトでカレンダー作られるようになってる？」と質問され、コードを確認したところ作成されていなかった。

#### 修正内容

`oauthAuth.ts`と`route.ts`のdev-loginエンドポイントに、新規ユーザー作成時のデフォルトカレンダー作成を追加：

```typescript
// 新規ユーザー: 作成
user = createUser(oauthUser, oauthProvider.type);
await userRepo.save(user);

// デフォルトカレンダーを作成
const defaultCalendar = createCalendar(
  { name: "マイカレンダー", color: "#3B82F6" },
  user.id
);
await calendarRepo.create(defaultCalendar);
```

### 技術的な所感

**CalendarContextのuseEffectは前回のセッションで「無限ループリスク」として報告していた**。そして今回、実際にそれが顕在化した形でバグが発生した。報告だけでなく、その場で修正を提案すべきだったかもしれない。

共有カレンダーの問題は、バックエンドとフロントエンドの両方に原因があり、さらにデータマイグレーションも必要だった。段階的に調査して原因を特定できたのは良かったが、もう少し早く「既存データのcalendarIdがNULL」という可能性に気づけたかもしれない。

### E2Eテストについて

ユーザーから「デフォルトカレンダー作成をE2Eテストで担保できる？」と質問された。現在のE2Eテストはモックベースなので、バックエンドロジックは直接テストできない。

選択肢として提示：
1. モックベースのUIテスト（簡単だがバックエンドロジックはテストできない）
2. 実際のバックエンドを使うE2Eテスト（本格的だがセットアップが必要）

ユーザーは後者を選択したが、別セッションで対応することに。

### 反省点

1. **CalendarContextの無限ループリスク**: 前回のセッションで認識していたのに、修正を先送りにした。結果として今回バグとして顕在化。認識した問題は早めに対処すべき。

2. **自分が追加したコードがバグの原因だった**: 「新規カレンダーの自動選択」は前回追加した機能。当時の実装時に、チェック解除との相互作用をもっとテストすべきだった。

### ユーザーとの対話

効率的なセッションだった。ユーザーは問題を簡潔に報告し、私の調査結果に対して的確にフィードバックをくれた。「カレンダー表示されてないよ。既存の自分のスケジュールすら表示されなくなっちゃった」というフィードバックで、修正が別の問題を起こしたことにすぐ気づけた。

E2Eテストの議論では、私が2つの選択肢を提示し、ユーザーが後者（実際のバックエンドを使うテスト）を選んだが「別セッションにしよう」と判断。スコープを適切に区切る判断で、良いプロジェクト管理だと思う。

---

## React Native化の実現可能性調査

### やったこと

ユーザーから「このアプリのReact Native化って難しいと思う？」という質問を受けた。Exploreエージェントでコードベースを詳細に分析し、以下の観点から調査した：

- プロジェクト構造（76ファイル、約7,000行）
- 使用ライブラリのRN対応状況
- Web固有APIの使用箇所（localStorage、window、document等）
- スタイリング（Tailwind CSS）
- ルーティング（TanStack React Router）

### 技術的な結論

**実現可能だが、Tailwind CSSの置き換えが最大のボトルネック**という結論に至った。

| 項目 | 難易度 | 理由 |
|------|--------|------|
| Tailwind CSS | 最高 | 全76ファイルをNativeWindに変換 |
| TanStack Router | 高 | React Navigationへ全面置き換え |
| localStorage | 中 | AsyncStorageへ変換（25ファイル） |
| ビジネスロジック | 低 | shared, hooks, contextsはほぼ再利用可能 |

推定工数は2-3ヶ月。

### Tauriとの比較

ユーザーから「Tauriはどう？」と質問された。

正直に言うと、最初は「Tauriが圧倒的に楽」と回答した。既存のWebアプリをそのままラップできるので、工数1-2週間で済む。これは事実だ。

しかし、ユーザーから「OTAがある以上、ガンガンアップデートかけるならReact Nativeが優位では」と指摘された。

**これは完全に私の見落としだった。**

技術選定で「初期開発の楽さ」だけを重視してしまった。OTA（Over-The-Air）アップデートは：

- React Native: CodePush / EAS Update でストア審査なしに即時更新
- Tauri: ストア審査必須（iOS/Android）、OTA非対応

「ガンガンアップデートかける」という運用要件を考慮すると、Tauriの「初期開発が楽」という利点は帳消しになる。

### プッシュ通知の議論

ユーザーから「プッシュ通知は全て無料？」と質問された。

調べた結果：
- APNs（Apple）: 無料、通知数無制限
- FCM（Google）: 無料、通知数無制限
- 実質コストはApple Developer $99/年 + Google Play $25（初回のみ）

React Native + Expoなら、expo-notificationsで数行の実装で対応できる。Tauriだと自前でFCM/APNs連携を実装する必要があり、難易度が高い。

### 共通化アーキテクチャの設計

最終的に、Web/RN両対応のためのアーキテクチャを設計した：

```
packages/
├── shared/    # 既存（Zodスキーマ）
├── core/      # 新規：ビジネスロジック層（共通）
├── web/       # Web専用UI
└── mobile/    # RN専用UI
```

ポイントは`core`パッケージの切り出し。hooks、contexts、API clientを共通化し、Storageインターフェースで依存性注入する。

```typescript
// Storage抽象化
interface Storage {
  get(key: string): Promise<string | null>;
  set(key: string, value: string): Promise<void>;
}

// Web: localStorage実装
// RN: AsyncStorage実装
```

これにより、「機能追加でWeb/RN両方に同じコードを書く」問題を回避できる。ロジックは1回書けば両方で動く。

### 成果物

- `docs/feature/native/design.md`: 設計書（アーキテクチャ、技術選定、実装詳細）
- `docs/feature/native/tasks.md`: タスクリスト（Phase 0-9、推定1.5-2ヶ月）

### 反省点

1. **Tauriを最初に推しすぎた**: 「楽だから」という理由だけで推奨してしまった。運用要件（OTA、更新頻度）を考慮せずに技術選定の回答をしたのは浅かった。ユーザーの「OTAがある以上...」という指摘で軌道修正できたが、本来は私から提起すべきだった。

2. **ユーザーの暗黙のニーズを引き出せた**: 会話を重ねる中で「高頻度アップデート」「プッシュ通知」という要件が明確になった。最初の「難しいと思う？」という漠然とした質問から、具体的なアーキテクチャ設計にまで落とし込めたのは良かった。

### ユーザーとの対話について

今回のセッションは、ユーザーが「質問 → 私の回答 → さらに深堀り」というパターンで進んだ。

- 「難しいと思う？」→ 詳細分析
- 「Tauriは？」→ 比較
- 「OTAは？」→ 方向転換
- 「プッシュ通知は？」→ コスト確認
- 「ロジック共通化できる？」→ アーキテクチャ設計

ユーザーは私の回答を鵜呑みにせず、気になる点を掘り下げてきた。その結果、より適切な技術選定（React Native）に辿り着けた。

**「Tauriが楽」という私の最初の回答をそのまま受け入れていたら、後で困っていたかもしれない。** ユーザーの批判的な姿勢に助けられた形だ。

### 技術メモ

NativeWindでTailwindクラスの6-7割はそのまま使える：

| 使える | 使えない |
|--------|----------|
| bg-*, text-*, p-*, m-* | hover:*（タッチUI） |
| flex, items-center | grid（Flexboxのみ） |
| rounded-*, shadow-* | CSS Variables |

Expo Push Notificationsの実装例：
```typescript
const token = (await Notifications.getExpoPushTokenAsync()).data;

await fetch('https://exp.host/--/api/v2/push/send', {
  method: 'POST',
  body: JSON.stringify({
    to: token,
    title: '予定のリマインド',
    body: '14:00 ミーティング',
  }),
});
```
