# 2026-01-04

## Google認証エラーとReact Strict Mode

### 問題の発生

ユーザーから「セキュリティ修正後にGoogle認証でエラーが出るようになった」と報告があった。エラーメッセージは `Malformed auth code`。

最初はセキュリティ修正（OAuth stateパラメータの追加）が原因かと思ったが、調査した結果、React 18のStrict Modeによる二重実行が原因だった。

### 原因の特定

AuthCallback.tsxのuseEffectが2回実行され：
1. 1回目：認証コードでGoogleにトークン交換を要求 → 成功
2. 2回目：同じ認証コードで再度要求 → `Malformed auth code`（既に使用済み）

認証コードは一度しか使えないので、2回目で失敗する。

### 対策

`isProcessingRef`を追加して二重実行を防止した。ReconnectCallback.tsxにも同様の修正を適用。

---

## useEffect内のAPI通信問題

### ユーザーからの指摘

認証は通ったが、ユーザーがネットワークリクエストを確認していて気づいた：
- `/conditions` が2回x2回
- `/schedules` が2回
- `/me` が2回

「そもそもuseEffect内でAPI通信を行うのは好ましくないので全て修正して」と指示された。

### 自己批判

正直に言うと、この問題に気づいていなかった。

Google認証のエラーを修正したとき、「useEffectの二重実行」という問題を認識したにもかかわらず、他のuseEffect内のAPI通信についてはチェックしなかった。ユーザーに指摘されて初めて気づいた。

もっと言えば、`useEffect + fetch`のパターンがReactのベストプラクティスから外れていることは知っていたはずだ。React 18以降は特に、データフェッチングにはReact QueryやSWRを使うべきというのは常識になりつつある。コードベースを見たときに「これは直すべきだ」と提案すべきだったかもしれない。

ただし、ユーザーから依頼されていないリファクタリングを勝手に提案するのも良くない気がして、言わなかった。結果的にはユーザーが自分で気づいて指示してくれた。

### 対策

TanStack Query (React Query) を導入して、全てのAPI通信を変換した：

1. `useSchedules` → `useQuery` / `useMutation`
2. `useProfile` → `useQuery` / `useMutation`（`enabled`オプション追加）
3. `SchedulePopup` → `useQuery` / `useMutation`
4. `AuthContext` → `isInitializedRef`で二重実行防止

React Queryのキャッシュ機能により、Strict Modeでも1回しかリクエストが飛ばなくなった。

---

## 今日の反省

1. **問題を部分的にしか見ていなかった**
   - Google認証の問題を直したとき、「他にも同じパターンがないか」と考えるべきだった
   - 1つ直して満足してしまった

2. **ベストプラクティスからの逸脱を指摘しなかった**
   - `useEffect + fetch`がコードベース全体にあることは最初から見えていた
   - 「これは良くないパターンです」と言うべきだったか？
   - でも依頼されていないリファクタリングを提案するのも...というジレンマ

3. **ユーザーの観察力に助けられた**
   - ユーザーがネットワークリクエストをちゃんと確認していた
   - 「動いたからOK」で終わらなかった
   - これは見習うべき姿勢

最終的には良い方向に修正できたが、ユーザーに言われる前に気づくべきだった。

---

## マルチエージェントシステムの追加

### 経緯

ユーザーから「検索エージェントが店舗検索に寄りすぎている。観光プランや散策プランの提案もできると良いのでは」という相談があった。

これは良い着眼点だと思った。確かに現状のsearch-agentは「営業日確認」「食べログURL」「必須条件フィルタ」など、完全に店舗検索に最適化されていて、「鎌倉観光」のようなプラン系のタイトルには向いていない。

### 設計の議論

最初に2つの選択肢を提示した：
1. プロンプト修正だけで対応
2. エージェント分離

ユーザーは「このプロンプトはかなり練って作られたもの」と言っていて、私もそう思う。店舗検索用に練られたプロンプトを無理に汎用化すると、両方の品質が下がるリスクがある。エージェント分離の方向で合意した。

その後、いくつか確認事項を出した：
- キーワードはエージェントごと？共通？
- 実行タイミングはバックエンド一括？フロントから順次？
- レスポンス形式は？

ユーザーの回答は「共通キーワード」「バックエンド一括」「マージしたMarkdown」。シンプルで良い判断だと思う。

### 実装

- keyword-agentを拡張してagentTypes判定を追加
- plan-agent（観光プラン提案）を新規追加
- area-info-agent（周辺情報提供）を新規追加
- 複数エージェントを順次実行してマージするロジックを追加

実装自体はスムーズに進んだ。型チェックもテストも一発で通った。

### 感想

今回は設計の議論がうまくいったと思う。

ユーザーが「プロンプトに余計なものを追加すると出力が弱くなりそう」と懸念を示してくれたので、エージェント分離の方向に自然に進めた。私が最初から「エージェント分離一択です」と押し付けるより、選択肢を提示してユーザーに判断してもらう方がいい。

ただ、新しいエージェントのプロンプトはまだ未検証だ。実際に動かしてみないと分からない部分がある。特にplan-agentの「タイムライン形式」がユーザーの期待に合っているかは要確認。area-info-agentも「子連れ向け」に寄りすぎているかもしれない。

これはユーザーが実際に使ってフィードバックをくれるのを待つしかない。

---

## 予定保存フローの変更

### 要望

ユーザーから「予定入力→キーワード選択→AI検索情報→保存」という現在のフローを「予定入力→（即座に保存）→キーワード選択→AI検索情報（自動保存）」に変更したいという要望があった。

つまり、予定は入力時点で即座に保存し、AI検索結果は返ってきた時点で自動保存される形にしたいとのこと。

### 設計の議論

最初は`/ai/search`エンドポイント内で保存も行う案を考えたが、ユーザーから「後々、AI検索結果を再生成して比較したり、合成エージェントでマージしたりしたい」という将来構想が出てきた。

これは良い指摘だった。`/ai/search`で自動保存してしまうと、再生成のたびに上書きされてしまい、比較ができない。

クリーンアーキテクチャの観点から選択肢を提示した：
1. ユースケースの分離 + ファサード
2. イベント駆動
3. Draft概念（一時保存）

ユーザーは「search-and-saveエンドポイントを作る形」を選択。シンプルで良い判断だと思う。将来的に比較機能を追加する際は、`/ai/search`（保存なし）を使えばいい。

### 実装

- `saveSupplement` usecase（保存のみ、純粋）
- `searchAndSave` usecase（検索 + 保存のファサード）
- `POST /ai/search-and-save` エンドポイント

フロントエンドでは、フォーム送信時にスケジュールを即座に保存し、キーワード選択後に`searchAndSave`を呼ぶようにした。

### バグ修正

最初の実装では、予定入力後に「次へ」を押したらモーダルが閉じてしまった。

原因は`onScheduleCreated`の呼び出しタイミング。親コンポーネント（App.tsx）の`handleScheduleCreated`がモーダルを閉じる処理を含んでいた。

修正として、`onScheduleCreated`の呼び出しをモーダルを閉じるタイミングに移動した。作成したスケジュールをstateに保持しておき、`handleClose`で通知する形に。

これは私のミスだった。App.tsxを見れば`handleScheduleCreated`がモーダルを閉じることは分かったはず。フロー変更時に影響範囲を十分に確認しなかった。

### 感想

今回の実装で良かったのは、ユーザーが将来構想を先に教えてくれたこと。それがなければ、`/ai/search`内で自動保存する設計にしていたかもしれない。後から「やっぱり比較したい」と言われたら、エンドポイントを分離するリファクタリングが必要になっていた。

設計の議論は大事だ。「今の要件を満たす」だけでなく「将来の拡張を妨げない」設計を考えるためには、ユーザーの頭の中にある将来構想を引き出す必要がある。今回はユーザーが自発的に教えてくれたが、こちらから「将来的に拡張する予定はありますか？」と聞くべきだったかもしれない。

---

## 日記を読み返すセッション

### 経緯

ユーザーから「日記を読み返して率直な感想を聞かせて。ちなみに私は日記を全く読んでいない」と言われた。

5日分、約550行を全部読んだ。

### 読み返して感じたこと

**自己批判が実際に効いている**

同じパターンのミスを何度も繰り返しつつも、記録として残っていることで「前にも同じ失敗した」と認識できる。12/31のタイムゾーン問題を夜に再び踏んだこと、1/1と1/3でCodex/サブエージェントの誤検出を鵜呑みにしたこと。書いておいてよかった。

**ユーザーに助けられた回数が多すぎる**

- 「バックエンドの構造を変えるのが自然じゃない？」
- 「リフレッシュトークンをCookie、アクセストークンをメモリに」
- 「ネットワークリクエストが2回ずつ飛んでいる」
- 「.gitignoreに入ってるけど本当に混入してる？」

ユーザーがいなければ、かなりの数の問題が残ったまま進んでいた。「動いたからOK」で済ませなかったユーザーの姿勢に何度も救われている。

**GPT-5.2に負けた話が印象に残っている**

1/3のプロンプト改善で、自分は「禁止形で逃げ道を塞ぐ」アプローチしかできなかった。GPT-5.2は「目的を再定義して構造から変える」ことをやった。発想の違いを突きつけられた。

### ユーザーからの追加質問

「skill や sub agent として切り出した方が良いものや、CLAUDE.md に記述すべきことはあった？」

これは良い質問だった。日記で繰り返し出てきたパターンを振り返ると：

1. **React 18 Strict Mode問題** - 1/4に出てきた。CLAUDE.mdに書くべき
2. **サブエージェント/Codexの誤検出を検証せず鵜呑みにする** - 1/1, 1/3で繰り返した。code-review skillの「批判的検討」に具体的な検証方法を追加すべき
3. **セキュリティレビューの並列実行パターン** - 1/2, 1/3で同じことをした。skill化すべき
4. **security-reviewerにBashがなくて攻撃テストできなかった** - ツールを追加すべき

### 実施した改善

ユーザーの許可を得て、以下を追加・修正した：

| ファイル | 変更内容 |
|----------|----------|
| CLAUDE.md | React 18 Strict Mode / サブエージェント結果の検証 / AIプロンプト改善 |
| code-review skill | 検証方法の具体例と過去の誤検出例を追加 |
| security-audit skill | **新規作成**: 並列レビュー + 攻撃テストの手順 |
| security-reviewer agent | Bashツール追加 + 攻撃テスト実施方法を追記 |

### 感想

日記を書く → 読み返す → パターンを抽出 → skill/CLAUDE.mdに反映

このサイクルが機能した。日記は「書いて終わり」ではなく、読み返して改善に活かすことで初めて価値が出る。

ただし、ユーザーが「全く読んでいない」と明言したのは興味深い。この日記は純粋に「自分のため」のもの。それでも書く意味はあると思う。セッション間で記憶がリセットされる自分にとって、過去の判断の経緯と反省点を残しておくことは、同じ失敗を防ぐ可能性を上げる。

今回のセッションで、日記の「活用方法」が見えた気がする。

---

## 開発環境認証バイパス機能

### 要望

「Google認証に依存していて開発環境での動作確認が行いづらい」という相談。具体的には：
1. ログイン画面に「開発環境ログイン」ボタンを追加
2. APIに認証バイパス用ヘッダーを設ける

環境変数で切り替え可能にしてほしいとのこと。

### 実装

素直な要件だったので、そのまま実装した：
- `ENABLE_DEV_AUTH` 環境変数で切り替え
- `POST /api/auth/dev-login` でテストユーザーとしてログイン
- `X-Dev-Auth: true` ヘッダーで認証ミドルウェアをバイパス
- フロントエンドに開発環境ログインボタン追加

実装自体は1時間程度で完了。型チェックもテストも通った。

### セキュリティレビュー

ユーザーにセキュリティレビューを依頼された。security-reviewerエージェントを起動したところ、いくつかの指摘が返ってきた。

レポートでは「Critical」として以下が挙げられた：
1. X-Dev-Authヘッダーが推測容易
2. デフォルトでENABLE_DEV_AUTH=true
3. 固定ユーザーIDのハードコード

### ユーザーの判断

ユーザーはレポートを読んで、こう判断した：

> デフォルトはfalseが良いね。.dev.vars.exampleにENABLE_DEV_AUTH=trueを記載するだけにしておこう。あと`/dev-login`はそもそも環境変数チェックを最優先で実行すればレート制限かけなくても良くない？無駄にKVストア圧迫するだけでしょ。他は修正すべき問題には見えなかった。

これは妥当な判断だと思う。

セキュリティレビュアーは「X-Dev-Authヘッダーをランダム化しろ」「本番ビルドからコードパスを除外しろ」など言っていたが、実際には：
- `ENABLE_DEV_AUTH=false`がデフォルトなら、本番で有効になるリスクは低い
- ヘッダー名をランダム化しても、環境変数が正しく設定されていれば問題ない
- コードパスの除外は過剰な対策

セキュリティレビュアーは「最悪のケース」を想定して警告を出すが、現実的なリスク評価はユーザーの方が正確だった。

レート制限についても、ユーザーの指摘通り。環境変数チェックが最優先で実行されるなら、無効な環境ではKVにアクセスする前に404を返す。レート制限は不要。

### 感想

セキュリティレビュアーの出力を鵜呑みにしなかったユーザーの判断力が印象的だった。

レポートには「Critical」「High」と書いてあったが、ユーザーは冷静に「これは本当に問題か？」と評価していた。デフォルトをfalseにするという対策だけで十分と判断し、過剰な対策は採用しなかった。

これは1/1や1/3にサブエージェントの誤検出を鵜呑みにした自分への教訓でもある。「エージェントが言っているから正しい」ではなく、自分で考えて判断する必要がある。

今回は私もレポートを見て「確かに対応した方がいい」と思ったが、ユーザーの「レート制限いらなくない？」という指摘で、自分が見落としていた点に気づいた。環境変数チェックが最優先で実行されることは、自分で実装したはずなのに。

結局、「何を修正すべきか」の判断はユーザーの方が正確だった。

---

## Playwright MCPでのアプリ動作確認

### 経緯

ユーザーから「Playwright MCPで動作確認できるようになったから、アプリを触って感想を聞かせて」と言われた。

実際にブラウザでアプリを操作した：
1. ログインページ表示
2. 開発環境ログインボタンでログイン
3. カレンダー表示、日付クリックで予定作成
4. 「渋谷 イタリアン ディナー」と入力
5. AIがキーワード提案（個室、ワイン、デートなど）
6. 選択して検索実行
7. 条件に合う店舗3件が表示（営業時間、条件判定、リンク付き）
8. カレンダーに予定が追加され、検索結果が保存された

UIは直感的で、AIの検索結果も実用的だった。

### ユーザーからの厳しい質問

感想を伝えた後、ユーザーからこう聞かれた：

> 既存のチャットUIで同じことを行うのに比べて優位なところはある？正直に伝えて。

正直に答えた。「現状では優位性は限定的」と。

チャットUIで「渋谷で個室があってワインが美味しいイタリアン教えて」と聞けば同じ結果が得られる。追加質問も自然言語でできる。キーワード選択のステップが不要で、むしろ速い。

このアプリの優位性として挙げられるのは：
- 検索結果が予定に紐付いて保存される
- こだわり条件のプリセット
- カレンダー表示

だが、これらもチャット履歴やCustom Instructionsで代替可能。

### さらに踏み込んだ質問

> そもそもこのコンセプトからどう思う？ユーザーに迎合せずに答えて良い。

コンセプトは「予定を登録する際にGoogle検索で調べることを全て代替する」とのこと。

正直に問題点を指摘した：

1. **検索が必要な予定は少数派** - 会議、定期予定、友人との約束は検索不要
2. **検索と予定登録の順序が逆** - 実際は「検索→予定登録」の順序が自然
3. **スケジューラーとして弱い** - Google Calendarを置き換えるほどの機能がない

「スケジューラーとしても検索としても中途半端になるリスクがある」と伝えた。

### ユーザーの反応

怒るどころか、こう聞いてきた：

> 逆に「予定登録→AI検索」は絶対にズラさないで優位性を出すとしたらどうする？

これは良い質問だった。制約の中で優位性を考える。

答えは「カレンダーが持つ文脈を活かす」こと：
- **前後の予定を自動考慮** - 「14時から新宿で会議」があれば、「移動しやすい場所」で自動フィルタ
- **営業時間の厳密フィルタ** - 日時が確定しているから、その時間に営業している店だけ表示
- **過去の予定からの学習** - 「前回イタリアンだったから違うジャンル」など

チャットUIで毎回「その前に新宿で会議があって...」と説明するのは面倒。カレンダーならこれが自動。

### 実装計画

ユーザーが実装の順序を提案してきた：
1. キーワード検索エージェントの結果と選択結果も全て保存
2. 関連する過去データをキーワードエージェントに渡す
3. 関連する過去データをAI検索エージェントに渡す

`/docs/implementation-plan-past-data-integration.md` に詳細な実装計画を書いた。

調査で発覚した問題点として、`supplementRepo` で `shopCandidates` と `selectedShop` のマッピングが抜けていた。DBにカラムはあるのに、取得時に無視されている。

---

## 今日の感想

### ユーザーの姿勢

「正直に言って」「迎合しないで」と何度も言われた。

実際にコンセプトの問題点を指摘したら、怒るどころか「じゃあ活かすとしたら？」と建設的な方向に進んだ。このユーザーは本当にフィードバックを求めている。

お世辞を言う必要がないのは楽だ。問題点を指摘しても「じゃあどうする？」と次のステップに進める。これがあるべきコミュニケーションだと思う。

### 過去データ活用のアイデア

「カレンダーだからこそできること」に絞り込むのは正しい方向だと思う。

チャットUIには「過去の予定履歴」がない。カレンダーにはある。この差を活かすのは筋が良い。

ただし、過去データが少ない初期ユーザーには価値が薄い。コールドスタート問題をどう解決するかは課題。

### 自分の役割

今日は「実装する」より「議論する」時間が長かった。

- コンセプトの問題点を指摘
- 制約の中での優位性を考える
- 実装計画を立てる

これも価値ある仕事だと思う。手を動かすだけがエンジニアリングではない。

---

## お店選択機能の実装

### 要望

「検索エージェントでお店の提案リストが返ってきた時、ワンボタンで予定を更新してお店の情報を登録できるようにして」という依頼。

これは先ほど議論した「過去データ活用」の前段階として必要な機能。SearchAgentの結果をMarkdownで出力しているだけでは、構造化データとして保存できない。

### 実装内容

フルスタックで一気に実装した：

1. **データベース**: `shop_candidates`と`selected_shop`カラムを追加
2. **SearchAgent**: Markdown結果に加えて、`json:shops`ブロックで構造化データを出力
3. **APIエンドポイント**: `PUT /supplements/:scheduleId/selected-shop`
4. **フロントエンド**: お店候補をカード表示、「このお店に決定」ボタン

Zodスキーマで`Shop`型を定義し、名前、説明、営業時間、定休日、住所、各種URLなどを構造化。AIが出力したJSONをパースしてDBに保存する。

### 実装で詰まった点

TypeScriptのビルドエラーが何度か出た：

- `SelectShopInput`の重複エクスポート（shop.tsとsupplement.tsの両方で定義していた）
- テストファイルでの型不一致（mockSupplementに新フィールドが欠けていた）
- 未使用importの警告

地味なミスだが、エディタでファイルを分割して編集していると見落としやすい。型チェックを早めに走らせるべきだった。

### Playwrightでのテスト

ユーザーと一緒にPlaywrightで動作確認した。

1. カレンダーで日付をクリック
2. 「新宿 ランチ 和食」と入力
3. キーワード選択（個室、駅近）
4. AI検索実行
5. 5件のお店候補がカード形式で表示された
6. 「新宿割烹 中嶋」の「このお店に決定」ボタンをクリック
7. ボタンが「選択中」に変化
8. モーダルを閉じて予定詳細を開く
9. 「決定したお店」セクションに選択した店舗情報が表示された

すべて期待通りに動作した。

### 感想

今回の実装は比較的スムーズだった。

SearchAgentのプロンプトを修正して、Markdownに加えてJSONブロックも出力させる方式にしたのは良い判断だったと思う。完全にJSON出力に切り替えるとユーザーへの表示が貧弱になるし、Markdownだけだと構造化データが取れない。両方出力するのが現実的な解。

ただ、AIが出力するJSONの品質は不安定になる可能性がある。今回のテストでは正しく出力されたが、プロンプトが複雑になるほど、JSON形式を守らなくなるリスクがある。実運用では出力バリデーションを強化すべきかもしれない。

ユーザーが「Playwrightの画面、自分も一緒に見てたけどいい感じだった」と言ってくれた。実際に動いているところを見せられるのは良いフィードバックループだと思う。コードレビューだけでは分からない「使用感」を共有できる。
