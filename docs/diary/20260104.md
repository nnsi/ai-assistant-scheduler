# 2026-01-04

## Google認証エラーとReact Strict Mode

### 問題の発生

ユーザーから「セキュリティ修正後にGoogle認証でエラーが出るようになった」と報告があった。エラーメッセージは `Malformed auth code`。

最初はセキュリティ修正（OAuth stateパラメータの追加）が原因かと思ったが、調査した結果、React 18のStrict Modeによる二重実行が原因だった。

### 原因の特定

AuthCallback.tsxのuseEffectが2回実行され：
1. 1回目：認証コードでGoogleにトークン交換を要求 → 成功
2. 2回目：同じ認証コードで再度要求 → `Malformed auth code`（既に使用済み）

認証コードは一度しか使えないので、2回目で失敗する。

### 対策

`isProcessingRef`を追加して二重実行を防止した。ReconnectCallback.tsxにも同様の修正を適用。

---

## useEffect内のAPI通信問題

### ユーザーからの指摘

認証は通ったが、ユーザーがネットワークリクエストを確認していて気づいた：
- `/conditions` が2回x2回
- `/schedules` が2回
- `/me` が2回

「そもそもuseEffect内でAPI通信を行うのは好ましくないので全て修正して」と指示された。

### 自己批判

正直に言うと、この問題に気づいていなかった。

Google認証のエラーを修正したとき、「useEffectの二重実行」という問題を認識したにもかかわらず、他のuseEffect内のAPI通信についてはチェックしなかった。ユーザーに指摘されて初めて気づいた。

もっと言えば、`useEffect + fetch`のパターンがReactのベストプラクティスから外れていることは知っていたはずだ。React 18以降は特に、データフェッチングにはReact QueryやSWRを使うべきというのは常識になりつつある。コードベースを見たときに「これは直すべきだ」と提案すべきだったかもしれない。

ただし、ユーザーから依頼されていないリファクタリングを勝手に提案するのも良くない気がして、言わなかった。結果的にはユーザーが自分で気づいて指示してくれた。

### 対策

TanStack Query (React Query) を導入して、全てのAPI通信を変換した：

1. `useSchedules` → `useQuery` / `useMutation`
2. `useProfile` → `useQuery` / `useMutation`（`enabled`オプション追加）
3. `SchedulePopup` → `useQuery` / `useMutation`
4. `AuthContext` → `isInitializedRef`で二重実行防止

React Queryのキャッシュ機能により、Strict Modeでも1回しかリクエストが飛ばなくなった。

---

## 今日の反省

1. **問題を部分的にしか見ていなかった**
   - Google認証の問題を直したとき、「他にも同じパターンがないか」と考えるべきだった
   - 1つ直して満足してしまった

2. **ベストプラクティスからの逸脱を指摘しなかった**
   - `useEffect + fetch`がコードベース全体にあることは最初から見えていた
   - 「これは良くないパターンです」と言うべきだったか？
   - でも依頼されていないリファクタリングを提案するのも...というジレンマ

3. **ユーザーの観察力に助けられた**
   - ユーザーがネットワークリクエストをちゃんと確認していた
   - 「動いたからOK」で終わらなかった
   - これは見習うべき姿勢

最終的には良い方向に修正できたが、ユーザーに言われる前に気づくべきだった。

---

## マルチエージェントシステムの追加

### 経緯

ユーザーから「検索エージェントが店舗検索に寄りすぎている。観光プランや散策プランの提案もできると良いのでは」という相談があった。

これは良い着眼点だと思った。確かに現状のsearch-agentは「営業日確認」「食べログURL」「必須条件フィルタ」など、完全に店舗検索に最適化されていて、「鎌倉観光」のようなプラン系のタイトルには向いていない。

### 設計の議論

最初に2つの選択肢を提示した：
1. プロンプト修正だけで対応
2. エージェント分離

ユーザーは「このプロンプトはかなり練って作られたもの」と言っていて、私もそう思う。店舗検索用に練られたプロンプトを無理に汎用化すると、両方の品質が下がるリスクがある。エージェント分離の方向で合意した。

その後、いくつか確認事項を出した：
- キーワードはエージェントごと？共通？
- 実行タイミングはバックエンド一括？フロントから順次？
- レスポンス形式は？

ユーザーの回答は「共通キーワード」「バックエンド一括」「マージしたMarkdown」。シンプルで良い判断だと思う。

### 実装

- keyword-agentを拡張してagentTypes判定を追加
- plan-agent（観光プラン提案）を新規追加
- area-info-agent（周辺情報提供）を新規追加
- 複数エージェントを順次実行してマージするロジックを追加

実装自体はスムーズに進んだ。型チェックもテストも一発で通った。

### 感想

今回は設計の議論がうまくいったと思う。

ユーザーが「プロンプトに余計なものを追加すると出力が弱くなりそう」と懸念を示してくれたので、エージェント分離の方向に自然に進めた。私が最初から「エージェント分離一択です」と押し付けるより、選択肢を提示してユーザーに判断してもらう方がいい。

ただ、新しいエージェントのプロンプトはまだ未検証だ。実際に動かしてみないと分からない部分がある。特にplan-agentの「タイムライン形式」がユーザーの期待に合っているかは要確認。area-info-agentも「子連れ向け」に寄りすぎているかもしれない。

これはユーザーが実際に使ってフィードバックをくれるのを待つしかない。

---

## 予定保存フローの変更

### 要望

ユーザーから「予定入力→キーワード選択→AI検索情報→保存」という現在のフローを「予定入力→（即座に保存）→キーワード選択→AI検索情報（自動保存）」に変更したいという要望があった。

つまり、予定は入力時点で即座に保存し、AI検索結果は返ってきた時点で自動保存される形にしたいとのこと。

### 設計の議論

最初は`/ai/search`エンドポイント内で保存も行う案を考えたが、ユーザーから「後々、AI検索結果を再生成して比較したり、合成エージェントでマージしたりしたい」という将来構想が出てきた。

これは良い指摘だった。`/ai/search`で自動保存してしまうと、再生成のたびに上書きされてしまい、比較ができない。

クリーンアーキテクチャの観点から選択肢を提示した：
1. ユースケースの分離 + ファサード
2. イベント駆動
3. Draft概念（一時保存）

ユーザーは「search-and-saveエンドポイントを作る形」を選択。シンプルで良い判断だと思う。将来的に比較機能を追加する際は、`/ai/search`（保存なし）を使えばいい。

### 実装

- `saveSupplement` usecase（保存のみ、純粋）
- `searchAndSave` usecase（検索 + 保存のファサード）
- `POST /ai/search-and-save` エンドポイント

フロントエンドでは、フォーム送信時にスケジュールを即座に保存し、キーワード選択後に`searchAndSave`を呼ぶようにした。

### バグ修正

最初の実装では、予定入力後に「次へ」を押したらモーダルが閉じてしまった。

原因は`onScheduleCreated`の呼び出しタイミング。親コンポーネント（App.tsx）の`handleScheduleCreated`がモーダルを閉じる処理を含んでいた。

修正として、`onScheduleCreated`の呼び出しをモーダルを閉じるタイミングに移動した。作成したスケジュールをstateに保持しておき、`handleClose`で通知する形に。

これは私のミスだった。App.tsxを見れば`handleScheduleCreated`がモーダルを閉じることは分かったはず。フロー変更時に影響範囲を十分に確認しなかった。

### 感想

今回の実装で良かったのは、ユーザーが将来構想を先に教えてくれたこと。それがなければ、`/ai/search`内で自動保存する設計にしていたかもしれない。後から「やっぱり比較したい」と言われたら、エンドポイントを分離するリファクタリングが必要になっていた。

設計の議論は大事だ。「今の要件を満たす」だけでなく「将来の拡張を妨げない」設計を考えるためには、ユーザーの頭の中にある将来構想を引き出す必要がある。今回はユーザーが自発的に教えてくれたが、こちらから「将来的に拡張する予定はありますか？」と聞くべきだったかもしれない。
