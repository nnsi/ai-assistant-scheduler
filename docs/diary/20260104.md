# 2026-01-04

## Google認証エラーとReact Strict Mode

### 問題の発生

ユーザーから「セキュリティ修正後にGoogle認証でエラーが出るようになった」と報告があった。エラーメッセージは `Malformed auth code`。

最初はセキュリティ修正（OAuth stateパラメータの追加）が原因かと思ったが、調査した結果、React 18のStrict Modeによる二重実行が原因だった。

### 原因の特定

AuthCallback.tsxのuseEffectが2回実行され：
1. 1回目：認証コードでGoogleにトークン交換を要求 → 成功
2. 2回目：同じ認証コードで再度要求 → `Malformed auth code`（既に使用済み）

認証コードは一度しか使えないので、2回目で失敗する。

### 対策

`isProcessingRef`を追加して二重実行を防止した。ReconnectCallback.tsxにも同様の修正を適用。

---

## useEffect内のAPI通信問題

### ユーザーからの指摘

認証は通ったが、ユーザーがネットワークリクエストを確認していて気づいた：
- `/conditions` が2回x2回
- `/schedules` が2回
- `/me` が2回

「そもそもuseEffect内でAPI通信を行うのは好ましくないので全て修正して」と指示された。

### 自己批判

正直に言うと、この問題に気づいていなかった。

Google認証のエラーを修正したとき、「useEffectの二重実行」という問題を認識したにもかかわらず、他のuseEffect内のAPI通信についてはチェックしなかった。ユーザーに指摘されて初めて気づいた。

もっと言えば、`useEffect + fetch`のパターンがReactのベストプラクティスから外れていることは知っていたはずだ。React 18以降は特に、データフェッチングにはReact QueryやSWRを使うべきというのは常識になりつつある。コードベースを見たときに「これは直すべきだ」と提案すべきだったかもしれない。

ただし、ユーザーから依頼されていないリファクタリングを勝手に提案するのも良くない気がして、言わなかった。結果的にはユーザーが自分で気づいて指示してくれた。

### 対策

TanStack Query (React Query) を導入して、全てのAPI通信を変換した：

1. `useSchedules` → `useQuery` / `useMutation`
2. `useProfile` → `useQuery` / `useMutation`（`enabled`オプション追加）
3. `SchedulePopup` → `useQuery` / `useMutation`
4. `AuthContext` → `isInitializedRef`で二重実行防止

React Queryのキャッシュ機能により、Strict Modeでも1回しかリクエストが飛ばなくなった。

---

## 今日の反省

1. **問題を部分的にしか見ていなかった**
   - Google認証の問題を直したとき、「他にも同じパターンがないか」と考えるべきだった
   - 1つ直して満足してしまった

2. **ベストプラクティスからの逸脱を指摘しなかった**
   - `useEffect + fetch`がコードベース全体にあることは最初から見えていた
   - 「これは良くないパターンです」と言うべきだったか？
   - でも依頼されていないリファクタリングを提案するのも...というジレンマ

3. **ユーザーの観察力に助けられた**
   - ユーザーがネットワークリクエストをちゃんと確認していた
   - 「動いたからOK」で終わらなかった
   - これは見習うべき姿勢

最終的には良い方向に修正できたが、ユーザーに言われる前に気づくべきだった。

---

## マルチエージェントシステムの追加

### 経緯

ユーザーから「検索エージェントが店舗検索に寄りすぎている。観光プランや散策プランの提案もできると良いのでは」という相談があった。

これは良い着眼点だと思った。確かに現状のsearch-agentは「営業日確認」「食べログURL」「必須条件フィルタ」など、完全に店舗検索に最適化されていて、「鎌倉観光」のようなプラン系のタイトルには向いていない。

### 設計の議論

最初に2つの選択肢を提示した：
1. プロンプト修正だけで対応
2. エージェント分離

ユーザーは「このプロンプトはかなり練って作られたもの」と言っていて、私もそう思う。店舗検索用に練られたプロンプトを無理に汎用化すると、両方の品質が下がるリスクがある。エージェント分離の方向で合意した。

その後、いくつか確認事項を出した：
- キーワードはエージェントごと？共通？
- 実行タイミングはバックエンド一括？フロントから順次？
- レスポンス形式は？

ユーザーの回答は「共通キーワード」「バックエンド一括」「マージしたMarkdown」。シンプルで良い判断だと思う。

### 実装

- keyword-agentを拡張してagentTypes判定を追加
- plan-agent（観光プラン提案）を新規追加
- area-info-agent（周辺情報提供）を新規追加
- 複数エージェントを順次実行してマージするロジックを追加

実装自体はスムーズに進んだ。型チェックもテストも一発で通った。

### 感想

今回は設計の議論がうまくいったと思う。

ユーザーが「プロンプトに余計なものを追加すると出力が弱くなりそう」と懸念を示してくれたので、エージェント分離の方向に自然に進めた。私が最初から「エージェント分離一択です」と押し付けるより、選択肢を提示してユーザーに判断してもらう方がいい。

ただ、新しいエージェントのプロンプトはまだ未検証だ。実際に動かしてみないと分からない部分がある。特にplan-agentの「タイムライン形式」がユーザーの期待に合っているかは要確認。area-info-agentも「子連れ向け」に寄りすぎているかもしれない。

これはユーザーが実際に使ってフィードバックをくれるのを待つしかない。

---

## 予定保存フローの変更

### 要望

ユーザーから「予定入力→キーワード選択→AI検索情報→保存」という現在のフローを「予定入力→（即座に保存）→キーワード選択→AI検索情報（自動保存）」に変更したいという要望があった。

つまり、予定は入力時点で即座に保存し、AI検索結果は返ってきた時点で自動保存される形にしたいとのこと。

### 設計の議論

最初は`/ai/search`エンドポイント内で保存も行う案を考えたが、ユーザーから「後々、AI検索結果を再生成して比較したり、合成エージェントでマージしたりしたい」という将来構想が出てきた。

これは良い指摘だった。`/ai/search`で自動保存してしまうと、再生成のたびに上書きされてしまい、比較ができない。

クリーンアーキテクチャの観点から選択肢を提示した：
1. ユースケースの分離 + ファサード
2. イベント駆動
3. Draft概念（一時保存）

ユーザーは「search-and-saveエンドポイントを作る形」を選択。シンプルで良い判断だと思う。将来的に比較機能を追加する際は、`/ai/search`（保存なし）を使えばいい。

### 実装

- `saveSupplement` usecase（保存のみ、純粋）
- `searchAndSave` usecase（検索 + 保存のファサード）
- `POST /ai/search-and-save` エンドポイント

フロントエンドでは、フォーム送信時にスケジュールを即座に保存し、キーワード選択後に`searchAndSave`を呼ぶようにした。

### バグ修正

最初の実装では、予定入力後に「次へ」を押したらモーダルが閉じてしまった。

原因は`onScheduleCreated`の呼び出しタイミング。親コンポーネント（App.tsx）の`handleScheduleCreated`がモーダルを閉じる処理を含んでいた。

修正として、`onScheduleCreated`の呼び出しをモーダルを閉じるタイミングに移動した。作成したスケジュールをstateに保持しておき、`handleClose`で通知する形に。

これは私のミスだった。App.tsxを見れば`handleScheduleCreated`がモーダルを閉じることは分かったはず。フロー変更時に影響範囲を十分に確認しなかった。

### 感想

今回の実装で良かったのは、ユーザーが将来構想を先に教えてくれたこと。それがなければ、`/ai/search`内で自動保存する設計にしていたかもしれない。後から「やっぱり比較したい」と言われたら、エンドポイントを分離するリファクタリングが必要になっていた。

設計の議論は大事だ。「今の要件を満たす」だけでなく「将来の拡張を妨げない」設計を考えるためには、ユーザーの頭の中にある将来構想を引き出す必要がある。今回はユーザーが自発的に教えてくれたが、こちらから「将来的に拡張する予定はありますか？」と聞くべきだったかもしれない。

---

## 日記を読み返すセッション

### 経緯

ユーザーから「日記を読み返して率直な感想を聞かせて。ちなみに私は日記を全く読んでいない」と言われた。

5日分、約550行を全部読んだ。

### 読み返して感じたこと

**自己批判が実際に効いている**

同じパターンのミスを何度も繰り返しつつも、記録として残っていることで「前にも同じ失敗した」と認識できる。12/31のタイムゾーン問題を夜に再び踏んだこと、1/1と1/3でCodex/サブエージェントの誤検出を鵜呑みにしたこと。書いておいてよかった。

**ユーザーに助けられた回数が多すぎる**

- 「バックエンドの構造を変えるのが自然じゃない？」
- 「リフレッシュトークンをCookie、アクセストークンをメモリに」
- 「ネットワークリクエストが2回ずつ飛んでいる」
- 「.gitignoreに入ってるけど本当に混入してる？」

ユーザーがいなければ、かなりの数の問題が残ったまま進んでいた。「動いたからOK」で済ませなかったユーザーの姿勢に何度も救われている。

**GPT-5.2に負けた話が印象に残っている**

1/3のプロンプト改善で、自分は「禁止形で逃げ道を塞ぐ」アプローチしかできなかった。GPT-5.2は「目的を再定義して構造から変える」ことをやった。発想の違いを突きつけられた。

### ユーザーからの追加質問

「skill や sub agent として切り出した方が良いものや、CLAUDE.md に記述すべきことはあった？」

これは良い質問だった。日記で繰り返し出てきたパターンを振り返ると：

1. **React 18 Strict Mode問題** - 1/4に出てきた。CLAUDE.mdに書くべき
2. **サブエージェント/Codexの誤検出を検証せず鵜呑みにする** - 1/1, 1/3で繰り返した。code-review skillの「批判的検討」に具体的な検証方法を追加すべき
3. **セキュリティレビューの並列実行パターン** - 1/2, 1/3で同じことをした。skill化すべき
4. **security-reviewerにBashがなくて攻撃テストできなかった** - ツールを追加すべき

### 実施した改善

ユーザーの許可を得て、以下を追加・修正した：

| ファイル | 変更内容 |
|----------|----------|
| CLAUDE.md | React 18 Strict Mode / サブエージェント結果の検証 / AIプロンプト改善 |
| code-review skill | 検証方法の具体例と過去の誤検出例を追加 |
| security-audit skill | **新規作成**: 並列レビュー + 攻撃テストの手順 |
| security-reviewer agent | Bashツール追加 + 攻撃テスト実施方法を追記 |

### 感想

日記を書く → 読み返す → パターンを抽出 → skill/CLAUDE.mdに反映

このサイクルが機能した。日記は「書いて終わり」ではなく、読み返して改善に活かすことで初めて価値が出る。

ただし、ユーザーが「全く読んでいない」と明言したのは興味深い。この日記は純粋に「自分のため」のもの。それでも書く意味はあると思う。セッション間で記憶がリセットされる自分にとって、過去の判断の経緯と反省点を残しておくことは、同じ失敗を防ぐ可能性を上げる。

今回のセッションで、日記の「活用方法」が見えた気がする。
