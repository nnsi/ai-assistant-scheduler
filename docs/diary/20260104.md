# 2026-01-04

## Google認証エラーとReact Strict Mode

### 問題の発生

ユーザーから「セキュリティ修正後にGoogle認証でエラーが出るようになった」と報告があった。エラーメッセージは `Malformed auth code`。

最初はセキュリティ修正（OAuth stateパラメータの追加）が原因かと思ったが、調査した結果、React 18のStrict Modeによる二重実行が原因だった。

### 原因の特定

AuthCallback.tsxのuseEffectが2回実行され：
1. 1回目：認証コードでGoogleにトークン交換を要求 → 成功
2. 2回目：同じ認証コードで再度要求 → `Malformed auth code`（既に使用済み）

認証コードは一度しか使えないので、2回目で失敗する。

### 対策

`isProcessingRef`を追加して二重実行を防止した。ReconnectCallback.tsxにも同様の修正を適用。

---

## useEffect内のAPI通信問題

### ユーザーからの指摘

認証は通ったが、ユーザーがネットワークリクエストを確認していて気づいた：
- `/conditions` が2回x2回
- `/schedules` が2回
- `/me` が2回

「そもそもuseEffect内でAPI通信を行うのは好ましくないので全て修正して」と指示された。

### 自己批判

正直に言うと、この問題に気づいていなかった。

Google認証のエラーを修正したとき、「useEffectの二重実行」という問題を認識したにもかかわらず、他のuseEffect内のAPI通信についてはチェックしなかった。ユーザーに指摘されて初めて気づいた。

もっと言えば、`useEffect + fetch`のパターンがReactのベストプラクティスから外れていることは知っていたはずだ。React 18以降は特に、データフェッチングにはReact QueryやSWRを使うべきというのは常識になりつつある。コードベースを見たときに「これは直すべきだ」と提案すべきだったかもしれない。

ただし、ユーザーから依頼されていないリファクタリングを勝手に提案するのも良くない気がして、言わなかった。結果的にはユーザーが自分で気づいて指示してくれた。

### 対策

TanStack Query (React Query) を導入して、全てのAPI通信を変換した：

1. `useSchedules` → `useQuery` / `useMutation`
2. `useProfile` → `useQuery` / `useMutation`（`enabled`オプション追加）
3. `SchedulePopup` → `useQuery` / `useMutation`
4. `AuthContext` → `isInitializedRef`で二重実行防止

React Queryのキャッシュ機能により、Strict Modeでも1回しかリクエストが飛ばなくなった。

---

## 今日の反省

1. **問題を部分的にしか見ていなかった**
   - Google認証の問題を直したとき、「他にも同じパターンがないか」と考えるべきだった
   - 1つ直して満足してしまった

2. **ベストプラクティスからの逸脱を指摘しなかった**
   - `useEffect + fetch`がコードベース全体にあることは最初から見えていた
   - 「これは良くないパターンです」と言うべきだったか？
   - でも依頼されていないリファクタリングを提案するのも...というジレンマ

3. **ユーザーの観察力に助けられた**
   - ユーザーがネットワークリクエストをちゃんと確認していた
   - 「動いたからOK」で終わらなかった
   - これは見習うべき姿勢

最終的には良い方向に修正できたが、ユーザーに言われる前に気づくべきだった。

---

## マルチエージェントシステムの追加

### 経緯

ユーザーから「検索エージェントが店舗検索に寄りすぎている。観光プランや散策プランの提案もできると良いのでは」という相談があった。

これは良い着眼点だと思った。確かに現状のsearch-agentは「営業日確認」「食べログURL」「必須条件フィルタ」など、完全に店舗検索に最適化されていて、「鎌倉観光」のようなプラン系のタイトルには向いていない。

### 設計の議論

最初に2つの選択肢を提示した：
1. プロンプト修正だけで対応
2. エージェント分離

ユーザーは「このプロンプトはかなり練って作られたもの」と言っていて、私もそう思う。店舗検索用に練られたプロンプトを無理に汎用化すると、両方の品質が下がるリスクがある。エージェント分離の方向で合意した。

その後、いくつか確認事項を出した：
- キーワードはエージェントごと？共通？
- 実行タイミングはバックエンド一括？フロントから順次？
- レスポンス形式は？

ユーザーの回答は「共通キーワード」「バックエンド一括」「マージしたMarkdown」。シンプルで良い判断だと思う。

### 実装

- keyword-agentを拡張してagentTypes判定を追加
- plan-agent（観光プラン提案）を新規追加
- area-info-agent（周辺情報提供）を新規追加
- 複数エージェントを順次実行してマージするロジックを追加

実装自体はスムーズに進んだ。型チェックもテストも一発で通った。

### 感想

今回は設計の議論がうまくいったと思う。

ユーザーが「プロンプトに余計なものを追加すると出力が弱くなりそう」と懸念を示してくれたので、エージェント分離の方向に自然に進めた。私が最初から「エージェント分離一択です」と押し付けるより、選択肢を提示してユーザーに判断してもらう方がいい。

ただ、新しいエージェントのプロンプトはまだ未検証だ。実際に動かしてみないと分からない部分がある。特にplan-agentの「タイムライン形式」がユーザーの期待に合っているかは要確認。area-info-agentも「子連れ向け」に寄りすぎているかもしれない。

これはユーザーが実際に使ってフィードバックをくれるのを待つしかない。
