# 2026-01-04

## Google認証エラーとReact Strict Mode

### 問題の発生

ユーザーから「セキュリティ修正後にGoogle認証でエラーが出るようになった」と報告があった。エラーメッセージは `Malformed auth code`。

最初はセキュリティ修正（OAuth stateパラメータの追加）が原因かと思ったが、調査した結果、React 18のStrict Modeによる二重実行が原因だった。

### 原因の特定

AuthCallback.tsxのuseEffectが2回実行され：
1. 1回目：認証コードでGoogleにトークン交換を要求 → 成功
2. 2回目：同じ認証コードで再度要求 → `Malformed auth code`（既に使用済み）

認証コードは一度しか使えないので、2回目で失敗する。

### 対策

`isProcessingRef`を追加して二重実行を防止した。ReconnectCallback.tsxにも同様の修正を適用。

---

## useEffect内のAPI通信問題

### ユーザーからの指摘

認証は通ったが、ユーザーがネットワークリクエストを確認していて気づいた：
- `/conditions` が2回x2回
- `/schedules` が2回
- `/me` が2回

「そもそもuseEffect内でAPI通信を行うのは好ましくないので全て修正して」と指示された。

### 自己批判

正直に言うと、この問題に気づいていなかった。

Google認証のエラーを修正したとき、「useEffectの二重実行」という問題を認識したにもかかわらず、他のuseEffect内のAPI通信についてはチェックしなかった。ユーザーに指摘されて初めて気づいた。

もっと言えば、`useEffect + fetch`のパターンがReactのベストプラクティスから外れていることは知っていたはずだ。React 18以降は特に、データフェッチングにはReact QueryやSWRを使うべきというのは常識になりつつある。コードベースを見たときに「これは直すべきだ」と提案すべきだったかもしれない。

ただし、ユーザーから依頼されていないリファクタリングを勝手に提案するのも良くない気がして、言わなかった。結果的にはユーザーが自分で気づいて指示してくれた。

### 対策

TanStack Query (React Query) を導入して、全てのAPI通信を変換した：

1. `useSchedules` → `useQuery` / `useMutation`
2. `useProfile` → `useQuery` / `useMutation`（`enabled`オプション追加）
3. `SchedulePopup` → `useQuery` / `useMutation`
4. `AuthContext` → `isInitializedRef`で二重実行防止

React Queryのキャッシュ機能により、Strict Modeでも1回しかリクエストが飛ばなくなった。

---

## 今日の反省

1. **問題を部分的にしか見ていなかった**
   - Google認証の問題を直したとき、「他にも同じパターンがないか」と考えるべきだった
   - 1つ直して満足してしまった

2. **ベストプラクティスからの逸脱を指摘しなかった**
   - `useEffect + fetch`がコードベース全体にあることは最初から見えていた
   - 「これは良くないパターンです」と言うべきだったか？
   - でも依頼されていないリファクタリングを提案するのも...というジレンマ

3. **ユーザーの観察力に助けられた**
   - ユーザーがネットワークリクエストをちゃんと確認していた
   - 「動いたからOK」で終わらなかった
   - これは見習うべき姿勢

最終的には良い方向に修正できたが、ユーザーに言われる前に気づくべきだった。
