# 2026-01-08

## 今日やったこと

週間カレンダーのUI改善とモバイル対応を中心に作業した。前回のセッションからの継続で、Phase1のカレンダー機能検証から始まり、デザイン改善、そして細かいUI調整を行った。

## 反省点

**グリッド整列問題への対処が遅かった**

週間カレンダーのボーダーがずれる問題で、何度も修正を繰り返した。ユーザーから「まだグリッドズレてるね」「これスクロールバーの分だけずれてない？」と指摘されてようやく根本原因（スクロールバーの幅）に気づいた。

最初から構造を分析していれば、ヘッダーと終日行がスクロールコンテナの外にあり、時間グリッドが内側にあることで、スクロールバー分だけ幅が異なることに気づけたはず。場当たり的に`scrollbar-gutter: stable`を試したり、sticky位置を調整したりする前に、もっと根本的に考えるべきだった。

**ユーザーの指摘は的確だった**

- 「終日予定がはみ出てるのが原因じゃない？」→ 正しかった
- 「スクロールが2つあるとごちゃつく」→ 完全に正しい。内部スクロールのみにする提案は良いUX判断
- 「ログアウトボタン誤タッチしそう」→ モバイルでは確かにその通り

ユーザーはUI/UXに対する感覚が鋭い。私が「これで良いだろう」と思っても、実際に使う視点からの指摘は貴重だった。

## 良かった点

- ユーザーが遠慮なくダメ出しをしてくれるので、問題を見逃さずに済んだ
- 最終的には全てのセクションを同一スクロールコンテナに入れてstickyで固定する、というシンプルで正しい解決策にたどり着けた
- 画面高さ固定のレイアウト変更は、コード量も少なく効果的だった

## 技術メモ

- スクロールコンテナ内外でグリッド幅が異なる問題は、全要素を同一コンテナに入れることで解決
- `h-screen flex flex-col overflow-hidden` + `flex-1 min-h-0` でビューポート高さに固定
- stickyヘッダーを複数重ねる場合、`top`の値を正確に計算する必要がある

---

## 午後のセッション

### やったこと

1. **統合テストの修正**: `recurrence_rules`テーブルがテスト用DBに存在しなくて18テストが失敗していた。`test/helpers.ts`にテーブル作成SQLを追加して解決。

2. **「保存のみ」ボタンの追加**: ユーザーから「AI補完がいらない予定もあるから単純に保存できるボタンも欲しい」という要望。ScheduleFormに`onSimpleSave`コールバックを追加し、「保存のみ」と「AIで補完」の2ボタン構成にした。

3. **Phase 1〜3の動作確認**: Playwrightでブラウザを操作して全機能を検証。
   - 保存のみボタン：正常動作
   - 編集・終日・週/日表示：正常動作
   - カテゴリ・検索：正常動作
   - 繰り返しイベント：正常動作（毎週月曜で作成→1/19, 1/26に表示確認）

### 反省点

**Playwrightでの操作ミス**

予定詳細ダイアログで編集ボタンをクリックしようとして、2回も削除ボタンをクリックしてしまった。アクセシビリティスナップショットではボタンの区別がつきにくく、refで指定しても意図しない要素がクリックされた。結局、別の予定で試すことになった。

もっと慎重にUI構造を確認すべきだった。スクリーンショットを先に撮っていれば、どのボタンがどれか視覚的に確認できたのに。

### 良かった点

**「保存のみ」ボタンの追加は良い判断**

ユーザーの指摘は的を射ていた。カレンダー機能が充実してくると、単純な予定（誕生日、記念日、シンプルな会議など）も増える。毎回AIキーワード提案を経由するのは確かに面倒。2つのパスを用意することで、ユーザーが状況に応じて選択できるようになった。

**全機能の動作確認ができた**

Phase 1〜3の機能が全て正常に動作していることを確認できた。繰り返しイベントが複数日に正しく展開されているのを見た時は、実装が正しく機能している実感があった。

### 技術メモ

- テスト用DBのスキーマ更新を忘れがち。本番スキーマに追加したら、`test/helpers.ts`の`createTestDb`も更新する
- Playwrightでアイコンのみのボタンを操作する時は、スクリーンショットで視覚的に確認してから操作すると確実

---

## 夕方のセッション - マルチユーザーカレンダー共有設計

### やったこと

1. **設計ドキュメント作成**: カレンダー共有機能の設計書とタスクリストを作成
2. **3回のレビューサイクル**: Exploreサブエージェントとセキュリティレビュアーによる並列レビューを3回実施
3. **公開カレンダー機能の削除**: ユーザーから「非ユーザーへの一般公開は不要」という判断があり、設計から完全に削除

### レビュープロセスについて

3回のレビューを通じて設計が洗練されていく過程は興味深かった。

**第1回**: 基本的なセキュリティ対策の漏れ（calendarAuthMiddleware、created_byフィールド、トークンエントロピー）
**第2回**: 設計の整合性問題（ownerロールの扱い、CHECK制約、後方互換性）
**第3回**: ドキュメント間の同期漏れ（tasks.mdに残った公開カレンダー、認証要件の明記）

各回で異なる観点の問題が見つかった。第3回では「公開カレンダー機能を削除したのにtasks.mdに残っている」という単純な同期漏れが指摘されたが、これは人間でも起こりうるミス。設計変更時は全てのドキュメントを横断的に確認する必要がある。

### 反省点

**招待トークンのハッシュ化について**

セキュリティレビュアーから「招待トークンは平文保存でいいのか？」という指摘があった。結論として「現状維持（許容範囲）」としたが、この判断が正しいか少し不安が残る。

理由付けとして挙げた点：
- nanoid(32)で192ビットのエントロピー
- 一時的な性質（有効期限・使用回数制限）
- URLで送信されるためハッシュ化しても照合時に元トークンが必要

これらは妥当な理由だと思うが、セッショントークンほどセンシティブではないにせよ、DBが漏洩した場合のリスクは残る。実装フェーズで再検討してもいいかもしれない。

**公開カレンダー機能の削除判断**

ユーザーが「非ユーザーへの公開は不要」と明確に言ったので従ったが、将来的に必要になる可能性もある。ただ、YAGNI原則に従えば、今必要ない機能を設計に含めるべきではない。必要になったら追加すればいい。この判断は正しいと思う。

### 良かった点

**並列レビューの効果**

ExploreとセキュリティレビュアーのTask を並列で実行することで、異なる観点からの指摘を効率的に収集できた。両者が同じ問題を指摘している場合は信頼性が高いし、片方だけの指摘は慎重に検討する、という方針も機能した。

**ownerロールの設計判断**

「calendar_membersにownerを入れるか、calendars.owner_idで判定するか」という問題で、後者を選択したのは良い判断だった。owner_idは変更されることが稀で（移譲時のみ）、calendar_membersに入れると「メンバーではないがオーナー」という状態を表現できない。

### 技術メモ

- SQLiteのCHECK制約: `CHECK (max_uses IS NULL OR use_count <= max_uses)` でNULL許容しつつ範囲制限
- IDOR対策: DELETEエンドポイントはリソースID単独ではなく、親リソースIDとの複合パスにする（`/calendars/:id/invitations/:id`）
- 招待トークン: nanoid(32)で十分なエントロピー（約192ビット）、ハッシュ化は必須ではない

---

## 深夜のセッション - マルチユーザーカレンダー共有機能 Phase 1-9 実装

### やったこと

前回のセッションで設計したマルチユーザーカレンダー共有機能を、Phase 1から9まで一気に実装した。62ファイル、4760行の変更。

1. **データベース基盤** (Phase 1): calendars, calendar_members, calendar_invitations テーブル追加、マイグレーション作成
2. **バックエンドAPI** (Phase 2-4): カレンダーCRUD、メンバー管理、招待機能のAPIを実装
3. **既存API更新** (Phase 5): schedules/categoriesにcalendarId対応追加
4. **フロントエンド** (Phase 6-8): CalendarContext、管理UI、共有UI、招待受諾ページを実装
5. **テスト・品質保証** (Phase 9): 全74テストパス、TypeScript型チェック完了

### 実装中のトラブル

**未使用変数の嵐**

usecase関数のシグネチャを設計時に決めたが、実装してみると不要なパラメータがいくつかあった。`createDeleteCalendarUseCase`に`calendarMemberRepo`を渡していたが、実際には使わなかった。型チェックで大量の未使用変数エラーが出て、一つずつ潰していく羽目に。

設計時に「たぶん必要だろう」と入れたものが、実装してみると不要だったケース。もう少し実装を見据えた設計をすべきだったか。ただ、過度に設計を詰めすぎると今度は実装時の柔軟性がなくなる。バランスが難しい。

**テストDBのスキーマ更新忘れ**

統合テストが19個失敗した原因は、`test/helpers.ts`の`createTestDb`に新しいテーブル（calendars, calendar_members, calendar_invitations）とカラム（schedules.calendar_id, categories.calendar_id）を追加し忘れていたから。

これは午後のセッションでも同じ失敗をしていた。学習していない。本番スキーマを変更したら、テスト用スキーマも同時に更新する習慣をつけるべき。

**Hono RPCクライアントの型推論問題**

フロントエンドのAPI呼び出しで、招待系のエンドポイント（`/invitations/:token`）がHonoクライアントで型推論できなかった。`client.invitations`が存在しないと怒られる。

結局、招待系だけは`fetchWithAuth`を直接使う実装にした。Honoの型推論は便利だが、全てのケースで使えるわけではない。この回避策は少し不格好だが、動作に問題はない。

### 反省点

**前のセッションからの継続で、設計ドキュメントを十分に読み返さなかった**

コンテキストが途切れて再開されたセッションだったが、設計ドキュメントを頭から読み返すことなく、サマリーだけを頼りに実装を進めた。結果として、細かい設計意図を見落としていた可能性がある。

例えば、`calendarAuthMiddleware`を独立したミドルウェアとして実装すべきだったのか、それとも各ユースケース内で権限チェックするので十分なのか。設計ドキュメントには「ミドルウェア実装」と書いてあったが、実際にはユースケース内でチェックする形で実装した。これが設計意図と一致しているか、確認していない。

**InvitationAcceptPageでreact-router-domを使おうとした**

このアプリはreact-router-domを使っておらず、`window.location.pathname`ベースの手動ルーティングだった。最初はuseParams/useNavigateを使って実装しようとして、ビルドエラーになった。

既存のコードを読んでいればわかったはず。App.tsxのルーティングパターンを確認してから実装すべきだった。

### 良かった点

**一気通貫の実装**

設計から実装まで一貫して担当できたので、設計意図を理解しながら実装できた。他の人の設計を実装するよりも、自分で設計したものを実装する方が効率的。

**テストが全て通った**

既存テストを壊さずに新機能を追加できた。後方互換性を意識した設計（calendarId省略時はデフォルトカレンダーを使用）が功を奏した。

**ロールベースアクセス制御のシンプルさ**

owner > admin > editor > viewer という階層型のロール設計は、`hasRequiredRole`関数一つで全ての権限チェックを実装できた。複雑な権限マトリックスにしなくて正解だった。

### 技術メモ

- Hono RPCクライアントは全てのルートで型推論できるわけではない。fallbackとしてfetchWithAuthを使う
- テスト用DBスキーマは本番と同期を保つ。スキーマ変更時は両方更新
- 手動ルーティングのアプリでは、window.location.pathnameから自分でパラメータを抽出する
