# 2026-01-01 開発日記

## 新年の振り返り: Google OAuth認証実装

年をまたいで昨日の作業を振り返る。

### 変更範囲の見積もりが甘かった

「Google認証を追加して」という要求に対して、最初は「OAuthの実装 + ログインUI」程度の認識だった。実際にはDBスキーマからフロントエンドまで全層に影響が及んだ：

- usersテーブル新規作成
- schedulesテーブルにuser_id追加
- 全てのschedule usecaseの引数変更
- 全てのschedule repositoryメソッドの変更
- 既存テスト30件以上の修正
- 新規テスト30件追加

認証機能は「後から追加する」と大規模な変更になることを再認識した。ただ、MVPを早く動かすために認証をスキップしたのはユーザーの判断だったし、その時点では正しいトレードオフだったとも思う。

### テストのモック設計

Google OAuth部分のテストをどう書くか迷った。最終的にGoogleAuthServiceをモックする方針にした：

```typescript
const createMockGoogleAuthService = (): GoogleAuthService => ({
  exchangeCodeForToken: vi.fn().mockResolvedValue({ ok: true, value: "mock-access-token" }),
  getUserInfo: vi.fn().mockResolvedValue({
    ok: true,
    value: { id: "google-mock-123", email: "mock@example.com", name: "Mock User" },
  }),
});
```

これで外部依存なしにフルフローをテストできた。fetchレベルでモックするより意図が明確で、テストの可読性も高い。

### 「新規ユーザー作成画面」の質問について

テスト完了後、ユーザーから「新規ユーザー作成の画面/機能も欲しくない？」と聞かれた。

一瞬「追加タスクか」と思ったが、現在のGoogle OAuthフローでは初回ログイン時に自動でユーザーが作成される。これは標準的なOAuthパターンなので、別途作成画面は不要。

ユーザーに説明したら納得してもらえた。もし即座に「作ります」と言っていたら、不要な機能を実装するところだった。要求の背景を確認してから着手する重要性を改めて感じた。

### 自己批判

- **CORSヘッダーの漏れ**: 最初Authorizationヘッダーがブロックされていた。認証機能を追加するならCORS設定見直しは当然なのに、見落としていた。
- **既存テストへの影響調査不足**: scheduleRepoのインターフェースを変更した時点で、全ての関連テストが壊れることは予測できたはず。事前に`grep`で影響範囲を確認すべきだった。
- **環境変数のドキュメント化**: GOOGLE_CLIENT_ID等の設定方法をREADMEに書いていない。これはまだ未対応。

### 良かった点

- ScheduleEntityとScheduleを分離する設計判断は適切だった。APIレスポンスにuserIdを含めずに済んでいる
- 61テスト全パスで安定している
- ユーザーが「一旦このままでOK」とスコープを絞ってくれた

### 今後の課題

- JWTリフレッシュトークンがない（7日で強制ログアウト）
- Google Cloud Consoleの設定はユーザー任せになっている
- 他のOAuthプロバイダー対応は未実装

---

## リフレッシュトークン実装と環境変数整理

### 今日やったこと

- アクセストークン/リフレッシュトークンの分離実装
- `POST /auth/refresh` エンドポイント追加
- フロントエンドでの自動トークンリフレッシュ
- `.dev.vars.example`（バックエンド）と`.env.example`（フロントエンド）作成

### 設計判断

#### トークンの有効期限設定

- アクセストークン: 1時間
- リフレッシュトークン: 30日

1時間は短すぎるかとも思ったが、リフレッシュが自動で行われるなら問題ない。むしろセキュリティ上は短い方が良い。30日は「1ヶ月に1回はログインし直す」という想定で、特に根拠はないが一般的な値だと思う。

#### トークン種別の区別

JWTペイロードに`type: "access" | "refresh"`を含めることで、リフレッシュトークンでAPIを叩けないようにした：

```typescript
verifyAccessToken: async (token: string): Promise<JwtPayload | null> => {
  const payload = await verify(token, secret);
  if (payload.type !== "access") {
    return null;
  }
  return payload;
}
```

これがないと、リフレッシュトークンを盗まれた場合にAPIアクセスもできてしまう。テストで「リフレッシュトークンを使って/auth/meにアクセスしたら401」というケースを追加した。

#### 自動リフレッシュの実装場所

api.tsの`fetchWithAuth`ラッパーに組み込んだ：

```typescript
const res = await fetch(input, { ...init, headers });
if (res.status === 401) {
  const newToken = await refreshAccessToken();
  if (newToken) {
    headers.set("Authorization", `Bearer ${newToken}`);
    return fetch(input, { ...init, headers });
  }
}
return res;
```

AuthContextにも似たロジックがあるが、api.tsに入れたことでHono RPC Client経由のすべてのリクエストで自動リフレッシュが効く。重複があるのは少し気になるが、AuthContextは初回ロード時の検証用、api.tsは通常のAPI呼び出し用と役割が違うので許容範囲。

### 型安全性の改善

ユーザーから「`as`はなるべく使わないように」と指摘された。

最初は`(await res.json()) as TokenResponse`のように書いていたが、Zodのスキーマを使ったランタイムバリデーションに変更：

```typescript
const json: unknown = await res.json();
const result = tokenResponseSchema.safeParse(json);
if (!result.success) {
  return null;
}
return result.data.accessToken;
```

これで型アサーションなしに型安全になった。sharedパッケージにスキーマがあるのだから最初からこうすべきだった。

### 環境変数のサンプルファイル

日記で「環境変数のドキュメント化ができていない」と書いた直後に対応依頼があった。README.mdに書くほどでもないので、`.dev.vars.example`と`.env.example`を用意する形にした。

これで`cp .dev.vars.example .dev.vars`して値を埋めるだけで設定完了になる。

### 自己批判

- **リフレッシュロジックの重複**: AuthContextとapi.tsに似たコードがある。共通化すべきか迷ったが、依存関係が複雑になりそうだったのでそのままにした。
- **テスト数が増えすぎている**: 72テストになった。まだ管理可能だが、テスト実行時間が2.5秒かかるようになってきた。

### 良かった点

- ユーザーの指摘を即座に反映できた
- 「今後の課題」として挙げていた2点（リフレッシュトークン、環境変数）を同日中に解消
- 型アサーションを排除してコードが堅牢になった

---

新年初日から作業継続。昨日の深夜作業の結果が安定しているのは良い傾向。
