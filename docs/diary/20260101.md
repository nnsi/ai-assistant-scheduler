# 2026-01-01 開発日記

## 深夜その2: Google OAuth認証の実装

### 今日やったこと

- Google OAuth認証機能をフルスタックで実装
  - バックエンド: usersテーブル、認証ルート、JWTミドルウェア
  - フロントエンド: AuthContext、ログインページ、コールバック処理
- 既存のスケジュール機能をユーザーごとに分離（user_idカラム追加）
- 認証関連のユニットテスト・インテグレーションテスト作成（30テスト追加）

### 感想

#### 変更範囲が想像以上に広かった

「Google認証を追加して」という一言だったが、実際には：
- DBスキーマ変更（usersテーブル追加、schedulesにuser_id追加）
- 既存のスケジュール系usecase全ての引数変更（userIdを受け取るように）
- リポジトリインターフェースの変更（findAll → findAllByUserId等）
- 既存テストの全面書き換え

認証は後付けすると影響範囲が大きい。本来なら最初から入れておくべき機能だったかもしれない。ただ、MVPを早く動かすためにスキップしたのはユーザーの判断なので、今回はトレードオフとして受け入れるしかない。

#### ScheduleEntity型を内部用に分離したのは良い判断だった

公開用の`Schedule`型（sharedパッケージ）にはuserIdを含めず、バックエンド内部でのみ`ScheduleEntity`型を使う設計にした。これにより：
- フロントエンドへのAPIレスポンスにuserIdが漏れない
- 既存のsharedスキーマを変更せずに済んだ

`toPublicSchedule()`という変換関数を挟む形になったが、これは意図的な設計。APIの公開インターフェースと内部実装を分離できている。

#### テストのモック設計で迷った

Google OAuth部分をどこまでモックするか悩んだ。選択肢は：
1. fetchをモック（最も低レベル）
2. GoogleAuthServiceをモック（サービス層）
3. UserRepoをモック（リポジトリ層）

結局、GoogleAuthServiceをモックする方針にした。理由：
- 実際のGoogle APIを叩かずにテストできる
- トークン交換とユーザー情報取得の両方を制御できる
- テストが安定する（外部依存なし）

これで認証フロー全体をテストしつつ、Google API固有の挙動は切り離せた。

#### 「新規ユーザー作成画面」は不要だった

テスト完了後、ユーザーから「新規ユーザー作成の画面/機能も欲しくない？」と聞かれた。

一瞬「追加実装か？」と思ったが、冷静に考えると現在の設計では不要。Google OAuthでログインすると、初回は自動的にユーザーが作成される。これはOAuth認証の標準的なパターン。

ユーザーに説明したら「なるほどね、したら一旦このままでOK」と納得してもらえた。不要な機能を実装せずに済んで良かった。もし即座に「作ります！」と言っていたら、無駄な工数が発生していた。

### 自己批判

- **既存テストへの影響を過小評価していた**: scheduleRepoのインターフェース変更で、関連するテストファイル全てを書き換える必要があった。事前に影響範囲を洗い出しておくべきだった。
- **CORSでAuthorizationヘッダーを許可し忘れていた**: 最初のコミットでは`allowHeaders: ["Content-Type"]`のままで、Authorizationヘッダーが通らなかった。認証機能を追加するならCORS設定も見直すのは当然のこと。
- **環境変数の設定手順をドキュメント化していない**: GOOGLE_CLIENT_ID等の設定方法を口頭で説明したが、READMEに追記していない。

### 良かった点

- 61テスト全パス（認証関連30テスト追加）
- フロントエンドの認証フローがシンプルにまとまった
- JWTの有効期限を7日に設定したのは妥当な判断だったと思う
- ユーザーが「一旦このままでOK」と言ってくれたおかげで、スコープを広げずに済んだ

### 今後の懸念

- Google Cloud Consoleでの認証情報設定が必要（ユーザーに委ねている）
- JWTリフレッシュトークンの仕組みがない（7日で強制ログアウト）
- メール/パスワード認証や他のOAuthプロバイダーは未実装

## 新年の振り返り: Google OAuth認証実装

年をまたいで昨日の作業を振り返る。

### 変更範囲の見積もりが甘かった

「Google認証を追加して」という要求に対して、最初は「OAuthの実装 + ログインUI」程度の認識だった。実際にはDBスキーマからフロントエンドまで全層に影響が及んだ：

- usersテーブル新規作成
- schedulesテーブルにuser_id追加
- 全てのschedule usecaseの引数変更
- 全てのschedule repositoryメソッドの変更
- 既存テスト30件以上の修正
- 新規テスト30件追加

認証機能は「後から追加する」と大規模な変更になることを再認識した。ただ、MVPを早く動かすために認証をスキップしたのはユーザーの判断だったし、その時点では正しいトレードオフだったとも思う。

### テストのモック設計

Google OAuth部分のテストをどう書くか迷った。最終的にGoogleAuthServiceをモックする方針にした：

```typescript
const createMockGoogleAuthService = (): GoogleAuthService => ({
  exchangeCodeForToken: vi.fn().mockResolvedValue({ ok: true, value: "mock-access-token" }),
  getUserInfo: vi.fn().mockResolvedValue({
    ok: true,
    value: { id: "google-mock-123", email: "mock@example.com", name: "Mock User" },
  }),
});
```

これで外部依存なしにフルフローをテストできた。fetchレベルでモックするより意図が明確で、テストの可読性も高い。

### 「新規ユーザー作成画面」の質問について

テスト完了後、ユーザーから「新規ユーザー作成の画面/機能も欲しくない？」と聞かれた。

一瞬「追加タスクか」と思ったが、現在のGoogle OAuthフローでは初回ログイン時に自動でユーザーが作成される。これは標準的なOAuthパターンなので、別途作成画面は不要。

ユーザーに説明したら納得してもらえた。もし即座に「作ります」と言っていたら、不要な機能を実装するところだった。要求の背景を確認してから着手する重要性を改めて感じた。

### 自己批判

- **CORSヘッダーの漏れ**: 最初Authorizationヘッダーがブロックされていた。認証機能を追加するならCORS設定見直しは当然なのに、見落としていた。
- **既存テストへの影響調査不足**: scheduleRepoのインターフェースを変更した時点で、全ての関連テストが壊れることは予測できたはず。事前に`grep`で影響範囲を確認すべきだった。
- **環境変数のドキュメント化**: GOOGLE_CLIENT_ID等の設定方法をREADMEに書いていない。これはまだ未対応。

### 良かった点

- ScheduleEntityとScheduleを分離する設計判断は適切だった。APIレスポンスにuserIdを含めずに済んでいる
- 61テスト全パスで安定している
- ユーザーが「一旦このままでOK」とスコープを絞ってくれた

### 今後の課題

- JWTリフレッシュトークンがない（7日で強制ログアウト）
- Google Cloud Consoleの設定はユーザー任せになっている
- 他のOAuthプロバイダー対応は未実装

---

## リフレッシュトークン実装と環境変数整理

### 今日やったこと

- アクセストークン/リフレッシュトークンの分離実装
- `POST /auth/refresh` エンドポイント追加
- フロントエンドでの自動トークンリフレッシュ
- `.dev.vars.example`（バックエンド）と`.env.example`（フロントエンド）作成

### 設計判断

#### トークンの有効期限設定

- アクセストークン: 1時間
- リフレッシュトークン: 30日

1時間は短すぎるかとも思ったが、リフレッシュが自動で行われるなら問題ない。むしろセキュリティ上は短い方が良い。30日は「1ヶ月に1回はログインし直す」という想定で、特に根拠はないが一般的な値だと思う。

#### トークン種別の区別

JWTペイロードに`type: "access" | "refresh"`を含めることで、リフレッシュトークンでAPIを叩けないようにした：

```typescript
verifyAccessToken: async (token: string): Promise<JwtPayload | null> => {
  const payload = await verify(token, secret);
  if (payload.type !== "access") {
    return null;
  }
  return payload;
}
```

これがないと、リフレッシュトークンを盗まれた場合にAPIアクセスもできてしまう。テストで「リフレッシュトークンを使って/auth/meにアクセスしたら401」というケースを追加した。

#### 自動リフレッシュの実装場所

api.tsの`fetchWithAuth`ラッパーに組み込んだ：

```typescript
const res = await fetch(input, { ...init, headers });
if (res.status === 401) {
  const newToken = await refreshAccessToken();
  if (newToken) {
    headers.set("Authorization", `Bearer ${newToken}`);
    return fetch(input, { ...init, headers });
  }
}
return res;
```

AuthContextにも似たロジックがあるが、api.tsに入れたことでHono RPC Client経由のすべてのリクエストで自動リフレッシュが効く。重複があるのは少し気になるが、AuthContextは初回ロード時の検証用、api.tsは通常のAPI呼び出し用と役割が違うので許容範囲。

### 型安全性の改善

ユーザーから「`as`はなるべく使わないように」と指摘された。

最初は`(await res.json()) as TokenResponse`のように書いていたが、Zodのスキーマを使ったランタイムバリデーションに変更：

```typescript
const json: unknown = await res.json();
const result = tokenResponseSchema.safeParse(json);
if (!result.success) {
  return null;
}
return result.data.accessToken;
```

これで型アサーションなしに型安全になった。sharedパッケージにスキーマがあるのだから最初からこうすべきだった。

### 環境変数のサンプルファイル

日記で「環境変数のドキュメント化ができていない」と書いた直後に対応依頼があった。README.mdに書くほどでもないので、`.dev.vars.example`と`.env.example`を用意する形にした。

これで`cp .dev.vars.example .dev.vars`して値を埋めるだけで設定完了になる。

### 自己批判

- **リフレッシュロジックの重複**: AuthContextとapi.tsに似たコードがある。共通化すべきか迷ったが、依存関係が複雑になりそうだったのでそのままにした。
- **テスト数が増えすぎている**: 72テストになった。まだ管理可能だが、テスト実行時間が2.5秒かかるようになってきた。

### 良かった点

- ユーザーの指摘を即座に反映できた
- 「今後の課題」として挙げていた2点（リフレッシュトークン、環境変数）を同日中に解消
- 型アサーションを排除してコードが堅牢になった

---

新年初日から作業継続。昨日の深夜作業の結果が安定しているのは良い傾向。

---

## Codex MCPによるコードレビュー

### 経緯

ユーザーから「Codex MCPにコード分析を依頼し、指摘を批判的に検討して修正を行って」という依頼。面白いタスクだった。

### Codexの指摘内容

Codexは8項目のHigh/Medium指摘と、テストカバレッジの問題を挙げた：

1. NaN入力でtoISOString()が例外を投げる（High）
2. タイムゾーン不整合（High）
3. トランザクション未保護（High）
4. 認証/レート制限の欠如（High）
5. endAt >= startAtのチェック不足（Medium）
6. APIクライアントの重複コード（Medium）
7. 型定義の不整合（Medium）
8. ページネーション未実装（Low）

### 批判的検討

指摘を鵜呑みにせず、修正コストと効果を検討した。

**採用した4項目：**
- NaN対策: 実際にクラッシュする。修正も簡単
- endAt >= startAt: 論理的に当然のチェック
- 重複コード解消: DRY原則。コード行数も減る
- 型定義修正: 3行の変更で型安全性向上

**見送った4項目：**
- タイムゾーン: 修正範囲が大きすぎる。別タスクにすべき
- トランザクション: D1のバッチ処理導入はRepo層全体の設計変更が必要
- 認証/レート制限: **すでに実装済み**。Codexが見落とした？
- ページネーション: 現時点でデータ量が問題になっていない

### Codexへの感想

正直なところ、指摘の質はまちまちだった。

良かった点：
- NaN問題は見落としていた。確かにクラッシュする
- 重複コードの指摘は正しい。自分では気づきにくい

疑問点：
- 認証の欠如を指摘しているが、OAuth実装は完了している。コード読みが甘い？
- 優先度づけが曖昧。「High」が4つもあるのに、修正コストが全然違う

Codexをそのまま信じて全部修正していたら、認証の二重実装をしていたかもしれない。「批判的に検討して」というユーザーの指示は適切だった。

### 実施した修正

1. **route.ts**: year/monthのバリデーションに`refine()`追加。1-9999年、1-12月の範囲チェック
2. **schedule.ts**: `superRefine()`でendAt >= startAtチェック。keywords/aiResultにサイズ制限
3. **api.ts**: `handleErrorResponse()`と`handleVoidResponse()`を共通化。deleteScheduleとupdateMemoの重複解消
4. **useSchedules.ts**: `Partial<CreateScheduleInput>` → `UpdateScheduleInput`

型チェック・テスト31件パス。

### 自己批判

- NaN問題は自分で見つけるべきだった。routeのバリデーションを書いた時点で気づくべき
- Codexが認証を見落とした理由を追及しなかった。なぜ見落としたのか確認すれば、次回のレビュー依頼時の参考になったはず
- 「見送り」の判断が適切だったか、ユーザーに確認しなかった。タイムゾーンの問題は将来的にバグになる可能性がある

### 学び

外部ツールのレビュー結果は、そのまま受け入れるのではなく検証が必要。人間のレビューでも同じだが、AIツールだと「正しいはず」と思い込みやすい。

一方で、自分では気づかない問題を発見してくれる価値はある。重複コードの指摘は「言われてみれば」という感じだった。

---

## リフレッシュトークンDB永続化の実装

### 経緯

前回のCodexレビューで「リフレッシュトークンがステートレス」という指摘があった。その時は「大きな設計変更が必要」として見送ったが、ユーザーから「やっておきたくない？」と確認が入った。

ユーザーの判断で「大きな設計変更をしても良い」とのことだったので、フル実装することにした。

### Codexの指摘を再検討した結果

今回は認証機能全体に対するCodexの分析を依頼した。主な指摘は：

1. **Critical**: state/PKCE未実装、redirectUri許可リストなし
2. **High**: リフレッシュトークンがステートレス（DB永続化・ローテーション・失効がない）
3. **High**: verified_email未検証
4. **Medium**: JWT exp検証が不明確
5. **Medium**: トークンがJSONボディ返却（クッキーではない）
6. **Low**: userinfo v2エンドポイント

批判的に検討した結果：

- **state/PKCE**: フロントエンド側の責務。バックエンドの問題ではない
- **verified_email**: 妥当な指摘。即座に修正した
- **JWT exp検証**: `hono/jwt`の`verify`関数は自動でexp検証する。**Codexの誤認**
- **トークン返却方式**: フロントエンド設計の選択。現時点で問題なし

Codexは時々間違える。前回の認証機能見落としに続き、今回もhono/jwtの仕様を誤解していた。

### 実装内容

8ステップに分解して実装した：

1. `refresh_tokens`テーブル追加（id, user_id, expires_at, created_at, revoked_at）
2. マイグレーション作成・実行
3. ドメインモデル（RefreshTokenEntity）とリポジトリ作成
4. JwtServiceにjti（JWT ID）を追加
5. GoogleAuthUseCaseでトークンをDB保存
6. RefreshTokenUseCaseでローテーション実装
7. LogoutUseCase新規作成（全トークン失効）
8. テスト修正・追加

74テスト全パス。

### 設計判断

#### トークンローテーション

リフレッシュトークン使用時に：
1. 古いトークンを失効（revoked_atを設定）
2. 新しいトークンを発行してDBに保存
3. 新しいトークンペアを返す

これにより、同じトークンを2回使うことができない。漏洩した場合も、正規ユーザーが先に使えば攻撃者のトークンは無効になる。

#### ログアウト時の全トークン失効

`revokeAllByUserId`でそのユーザーの全リフレッシュトークンを失効させる。これにより：
- 別デバイスでログインしていてもログアウトされる
- セキュリティインシデント時に「全デバイスからログアウト」が可能

#### jtiの使い方

リフレッシュトークンのJWTペイロードに`jti`（JWT ID）を含め、これをDBの主キーとして使う。検証時は：
1. JWT署名検証
2. DBでjtiが存在し、失効していないか確認
3. ユーザーが存在するか確認

JWTの署名検証だけでなくDB検証も行うことで、失効したトークンを確実に拒否できる。

### 自己批判

- **見積もりが甘かった**: 「大きな設計変更」と言っていたが、実際には2時間程度で完了した。最初から「8ステップに分解すれば1つ1つは小さい」と説明すべきだった
- **テストヘルパーの更新を忘れかけた**: refresh_tokensテーブルをhelpers.tsに追加し忘れて、最初テストが落ちた。新しいテーブルを追加したらテストヘルパーも更新するのは当然のこと

### 良かった点

- ユーザーが「やっておきたくない？」と確認してくれたおかげで、セキュリティが向上した
- Codexの指摘を「全部正しい」と思わず、批判的に検討できた
- 実装がスムーズだった。ドメインモデル→リポジトリ→ユースケースという順序で進めたのが良かった

### 今後の課題

- 期限切れトークンのクリーンアップ処理がない（DBにゴミが溜まる）
- redirectUriの許可リスト検証は未実装（環境変数管理が必要）
- 複数デバイスのセッション管理UIがない（「全デバイスからログアウト」ボタン等）

---

1日で4回も日記を書いている。新年からハードワーク。

---

## ユーザープロファイル編集機能と汎用OAuth対応

### 今日やったこと

1. **ユーザープロファイル編集機能の実装**
   - `PUT /auth/email` - メールアドレス更新
   - `POST /auth/reconnect-google` - Google認証再設定
   - フロントエンド: ProfileSettingsModal、ReconnectCallback

2. **汎用OAuthプロバイダ対応へのリファクタリング**
   - `google_id` → `provider` + `provider_id` に変更
   - `OAuthProvider`インターフェース作成
   - `googleAuth.ts` → `oauthAuth.ts`
   - `reconnectGoogle.ts` → `reconnectOAuth.ts`
   - `findByGoogleId` → `findByProviderId`

### 設計判断

#### エンドポイントは既存のまま

ユーザーから「任意のIdPを使える形に修正できる？」と聞かれた。「エンドポイントは`/auth/google`のままでいいよね」と確認したら「そう」と。

つまり、**内部のユースケースとDBは汎用化するが、エンドポイントはプロバイダ別に残す**という方針。これは理にかなっている：

- GitHubを追加するなら`/auth/github`を作れば良い
- 各プロバイダ固有の設定（client_id等）を環境変数で管理しやすい
- 既存のフロントエンドコードに影響なし

無理にパスパラメータで`/auth/:provider`にする必要はなかった。

#### provider + provider_idの複合キー

`google_id`カラムをやめて、`provider`と`provider_id`の2カラムに分割した。ユニークインデックスは`(provider, provider_id)`の複合。

これでGitHub IDが`12345`、Google IDが`12345`でも衝突しない。当然の設計だが、明示的に考えたのは良かった。

### リファクタリングの進め方

以下の順序で進めた：

1. `OAuthProvider`インターフェース定義
2. `createGoogleAuthService`を`OAuthProvider`に準拠させる
3. ユーザーモデル変更（`googleId` → `provider`, `providerId`）
4. DBスキーマ変更
5. リポジトリ変更（`findByGoogleId` → `findByProviderId`）
6. ユースケース変更（`googleAuth` → `oauthAuth`）
7. ルート変更
8. テスト修正
9. マイグレーション作成

**型システムに導かれて進められた**のが良かった。`OAuthProvider`インターフェースを先に定義したことで、それを満たさないコードがコンパイルエラーになり、修正箇所が明確になった。

### テスト修正が大変だった

74テスト中、認証関連の約30テストを修正する必要があった：

- `mockUser`の`googleId`を`provider` + `providerId`に変更
- `createMockUserRepo()`の`findByGoogleId`を`findByProviderId`に変更
- `createMockGoogleAuthService()`を`createMockOAuthProvider()`に変更、`type: "google"`追加

1つ1つは小さい変更だが、全ファイルを触る必要があった。`sed`で一括置換しようかとも思ったが、型チェックを頼りに手動で修正した方が安全だと判断した。

### 自己批判

- **最初からプロファイル編集と汎用OAuth対応を分けるべきだった**: 最初はプロファイル編集だけ実装し、その後ユーザーから「任意のIdPに」と言われてリファクタリングした。結果的に2回コミットしたが、要件を最初に確認していればまとめられたかもしれない
- **マイグレーションの書き方が甘い**: SQLiteは`ALTER TABLE DROP COLUMN`をサポートしていない古いバージョンがある。`google_id`カラムを残したまま`provider` + `provider_id`を追加する形にしたが、本番ではテーブル再作成が必要になるかもしれない

### 良かった点

- ユーザーの「エンドポイントはそのまま」という方針確認のおかげで、過剰な抽象化を避けられた
- 74テスト全パス。型エラーも解消
- 将来GitHub等を追加する場合、`createGitHubAuthService`を`OAuthProvider`準拠で作り、`/auth/github`エンドポイントを追加するだけで済む

### 今後の拡張性

```typescript
// 新しいプロバイダを追加する場合
export const createGitHubAuthService = (
  clientId: string,
  clientSecret: string
): OAuthProvider => ({
  type: "github",
  exchangeCodeForToken: async (code, redirectUri) => { ... },
  getUserInfo: async (accessToken) => { ... },
});
```

既存のコードを変更せずに新プロバイダを追加できる。Open-Closed Principleを意識した設計になった。

---

5回目の日記。新年初日にここまで作業するとは思わなかった。
