# 2026-01-01 開発日記

## 深夜その2: Google OAuth認証の実装

### 今日やったこと

- Google OAuth認証機能をフルスタックで実装
  - バックエンド: usersテーブル、認証ルート、JWTミドルウェア
  - フロントエンド: AuthContext、ログインページ、コールバック処理
- 既存のスケジュール機能をユーザーごとに分離（user_idカラム追加）
- 認証関連のユニットテスト・インテグレーションテスト作成（30テスト追加）

### 感想

#### 変更範囲が想像以上に広かった

「Google認証を追加して」という一言だったが、実際には：
- DBスキーマ変更（usersテーブル追加、schedulesにuser_id追加）
- 既存のスケジュール系usecase全ての引数変更（userIdを受け取るように）
- リポジトリインターフェースの変更（findAll → findAllByUserId等）
- 既存テストの全面書き換え

認証は後付けすると影響範囲が大きい。本来なら最初から入れておくべき機能だったかもしれない。ただ、MVPを早く動かすためにスキップしたのはユーザーの判断なので、今回はトレードオフとして受け入れるしかない。

#### ScheduleEntity型を内部用に分離したのは良い判断だった

公開用の`Schedule`型（sharedパッケージ）にはuserIdを含めず、バックエンド内部でのみ`ScheduleEntity`型を使う設計にした。これにより：
- フロントエンドへのAPIレスポンスにuserIdが漏れない
- 既存のsharedスキーマを変更せずに済んだ

`toPublicSchedule()`という変換関数を挟む形になったが、これは意図的な設計。APIの公開インターフェースと内部実装を分離できている。

#### テストのモック設計で迷った

Google OAuth部分をどこまでモックするか悩んだ。選択肢は：
1. fetchをモック（最も低レベル）
2. GoogleAuthServiceをモック（サービス層）
3. UserRepoをモック（リポジトリ層）

結局、GoogleAuthServiceをモックする方針にした。理由：
- 実際のGoogle APIを叩かずにテストできる
- トークン交換とユーザー情報取得の両方を制御できる
- テストが安定する（外部依存なし）

これで認証フロー全体をテストしつつ、Google API固有の挙動は切り離せた。

#### 「新規ユーザー作成画面」は不要だった

テスト完了後、ユーザーから「新規ユーザー作成の画面/機能も欲しくない？」と聞かれた。

一瞬「追加実装か？」と思ったが、冷静に考えると現在の設計では不要。Google OAuthでログインすると、初回は自動的にユーザーが作成される。これはOAuth認証の標準的なパターン。

ユーザーに説明したら「なるほどね、したら一旦このままでOK」と納得してもらえた。不要な機能を実装せずに済んで良かった。もし即座に「作ります！」と言っていたら、無駄な工数が発生していた。

### 自己批判

- **既存テストへの影響を過小評価していた**: scheduleRepoのインターフェース変更で、関連するテストファイル全てを書き換える必要があった。事前に影響範囲を洗い出しておくべきだった。
- **CORSでAuthorizationヘッダーを許可し忘れていた**: 最初のコミットでは`allowHeaders: ["Content-Type"]`のままで、Authorizationヘッダーが通らなかった。認証機能を追加するならCORS設定も見直すのは当然のこと。
- **環境変数の設定手順をドキュメント化していない**: GOOGLE_CLIENT_ID等の設定方法を口頭で説明したが、READMEに追記していない。

### 良かった点

- 61テスト全パス（認証関連30テスト追加）
- フロントエンドの認証フローがシンプルにまとまった
- JWTの有効期限を7日に設定したのは妥当な判断だったと思う
- ユーザーが「一旦このままでOK」と言ってくれたおかげで、スコープを広げずに済んだ

### 今後の懸念

- Google Cloud Consoleでの認証情報設定が必要（ユーザーに委ねている）
- JWTリフレッシュトークンの仕組みがない（7日で強制ログアウト）
- メール/パスワード認証や他のOAuthプロバイダーは未実装

## 新年の振り返り: Google OAuth認証実装

年をまたいで昨日の作業を振り返る。

### 変更範囲の見積もりが甘かった

「Google認証を追加して」という要求に対して、最初は「OAuthの実装 + ログインUI」程度の認識だった。実際にはDBスキーマからフロントエンドまで全層に影響が及んだ：

- usersテーブル新規作成
- schedulesテーブルにuser_id追加
- 全てのschedule usecaseの引数変更
- 全てのschedule repositoryメソッドの変更
- 既存テスト30件以上の修正
- 新規テスト30件追加

認証機能は「後から追加する」と大規模な変更になることを再認識した。ただ、MVPを早く動かすために認証をスキップしたのはユーザーの判断だったし、その時点では正しいトレードオフだったとも思う。

### テストのモック設計

Google OAuth部分のテストをどう書くか迷った。最終的にGoogleAuthServiceをモックする方針にした：

```typescript
const createMockGoogleAuthService = (): GoogleAuthService => ({
  exchangeCodeForToken: vi.fn().mockResolvedValue({ ok: true, value: "mock-access-token" }),
  getUserInfo: vi.fn().mockResolvedValue({
    ok: true,
    value: { id: "google-mock-123", email: "mock@example.com", name: "Mock User" },
  }),
});
```

これで外部依存なしにフルフローをテストできた。fetchレベルでモックするより意図が明確で、テストの可読性も高い。

### 「新規ユーザー作成画面」の質問について

テスト完了後、ユーザーから「新規ユーザー作成の画面/機能も欲しくない？」と聞かれた。

一瞬「追加タスクか」と思ったが、現在のGoogle OAuthフローでは初回ログイン時に自動でユーザーが作成される。これは標準的なOAuthパターンなので、別途作成画面は不要。

ユーザーに説明したら納得してもらえた。もし即座に「作ります」と言っていたら、不要な機能を実装するところだった。要求の背景を確認してから着手する重要性を改めて感じた。

### 自己批判

- **CORSヘッダーの漏れ**: 最初Authorizationヘッダーがブロックされていた。認証機能を追加するならCORS設定見直しは当然なのに、見落としていた。
- **既存テストへの影響調査不足**: scheduleRepoのインターフェースを変更した時点で、全ての関連テストが壊れることは予測できたはず。事前に`grep`で影響範囲を確認すべきだった。
- **環境変数のドキュメント化**: GOOGLE_CLIENT_ID等の設定方法をREADMEに書いていない。これはまだ未対応。

### 良かった点

- ScheduleEntityとScheduleを分離する設計判断は適切だった。APIレスポンスにuserIdを含めずに済んでいる
- 61テスト全パスで安定している
- ユーザーが「一旦このままでOK」とスコープを絞ってくれた

### 今後の課題

- JWTリフレッシュトークンがない（7日で強制ログアウト）
- Google Cloud Consoleの設定はユーザー任せになっている
- 他のOAuthプロバイダー対応は未実装

---

## リフレッシュトークン実装と環境変数整理

### 今日やったこと

- アクセストークン/リフレッシュトークンの分離実装
- `POST /auth/refresh` エンドポイント追加
- フロントエンドでの自動トークンリフレッシュ
- `.dev.vars.example`（バックエンド）と`.env.example`（フロントエンド）作成

### 設計判断

#### トークンの有効期限設定

- アクセストークン: 1時間
- リフレッシュトークン: 30日

1時間は短すぎるかとも思ったが、リフレッシュが自動で行われるなら問題ない。むしろセキュリティ上は短い方が良い。30日は「1ヶ月に1回はログインし直す」という想定で、特に根拠はないが一般的な値だと思う。

#### トークン種別の区別

JWTペイロードに`type: "access" | "refresh"`を含めることで、リフレッシュトークンでAPIを叩けないようにした：

```typescript
verifyAccessToken: async (token: string): Promise<JwtPayload | null> => {
  const payload = await verify(token, secret);
  if (payload.type !== "access") {
    return null;
  }
  return payload;
}
```

これがないと、リフレッシュトークンを盗まれた場合にAPIアクセスもできてしまう。テストで「リフレッシュトークンを使って/auth/meにアクセスしたら401」というケースを追加した。

#### 自動リフレッシュの実装場所

api.tsの`fetchWithAuth`ラッパーに組み込んだ：

```typescript
const res = await fetch(input, { ...init, headers });
if (res.status === 401) {
  const newToken = await refreshAccessToken();
  if (newToken) {
    headers.set("Authorization", `Bearer ${newToken}`);
    return fetch(input, { ...init, headers });
  }
}
return res;
```

AuthContextにも似たロジックがあるが、api.tsに入れたことでHono RPC Client経由のすべてのリクエストで自動リフレッシュが効く。重複があるのは少し気になるが、AuthContextは初回ロード時の検証用、api.tsは通常のAPI呼び出し用と役割が違うので許容範囲。

### 型安全性の改善

ユーザーから「`as`はなるべく使わないように」と指摘された。

最初は`(await res.json()) as TokenResponse`のように書いていたが、Zodのスキーマを使ったランタイムバリデーションに変更：

```typescript
const json: unknown = await res.json();
const result = tokenResponseSchema.safeParse(json);
if (!result.success) {
  return null;
}
return result.data.accessToken;
```

これで型アサーションなしに型安全になった。sharedパッケージにスキーマがあるのだから最初からこうすべきだった。

### 環境変数のサンプルファイル

日記で「環境変数のドキュメント化ができていない」と書いた直後に対応依頼があった。README.mdに書くほどでもないので、`.dev.vars.example`と`.env.example`を用意する形にした。

これで`cp .dev.vars.example .dev.vars`して値を埋めるだけで設定完了になる。

### 自己批判

- **リフレッシュロジックの重複**: AuthContextとapi.tsに似たコードがある。共通化すべきか迷ったが、依存関係が複雑になりそうだったのでそのままにした。
- **テスト数が増えすぎている**: 72テストになった。まだ管理可能だが、テスト実行時間が2.5秒かかるようになってきた。

### 良かった点

- ユーザーの指摘を即座に反映できた
- 「今後の課題」として挙げていた2点（リフレッシュトークン、環境変数）を同日中に解消
- 型アサーションを排除してコードが堅牢になった

---

新年初日から作業継続。昨日の深夜作業の結果が安定しているのは良い傾向。

---

## Codex MCPによるコードレビュー

### 経緯

ユーザーから「Codex MCPにコード分析を依頼し、指摘を批判的に検討して修正を行って」という依頼。面白いタスクだった。

### Codexの指摘内容

Codexは8項目のHigh/Medium指摘と、テストカバレッジの問題を挙げた：

1. NaN入力でtoISOString()が例外を投げる（High）
2. タイムゾーン不整合（High）
3. トランザクション未保護（High）
4. 認証/レート制限の欠如（High）
5. endAt >= startAtのチェック不足（Medium）
6. APIクライアントの重複コード（Medium）
7. 型定義の不整合（Medium）
8. ページネーション未実装（Low）

### 批判的検討

指摘を鵜呑みにせず、修正コストと効果を検討した。

**採用した4項目：**
- NaN対策: 実際にクラッシュする。修正も簡単
- endAt >= startAt: 論理的に当然のチェック
- 重複コード解消: DRY原則。コード行数も減る
- 型定義修正: 3行の変更で型安全性向上

**見送った4項目：**
- タイムゾーン: 修正範囲が大きすぎる。別タスクにすべき
- トランザクション: D1のバッチ処理導入はRepo層全体の設計変更が必要
- 認証/レート制限: **すでに実装済み**。Codexが見落とした？
- ページネーション: 現時点でデータ量が問題になっていない

### Codexへの感想

正直なところ、指摘の質はまちまちだった。

良かった点：
- NaN問題は見落としていた。確かにクラッシュする
- 重複コードの指摘は正しい。自分では気づきにくい

疑問点：
- 認証の欠如を指摘しているが、OAuth実装は完了している。コード読みが甘い？
- 優先度づけが曖昧。「High」が4つもあるのに、修正コストが全然違う

Codexをそのまま信じて全部修正していたら、認証の二重実装をしていたかもしれない。「批判的に検討して」というユーザーの指示は適切だった。

### 実施した修正

1. **route.ts**: year/monthのバリデーションに`refine()`追加。1-9999年、1-12月の範囲チェック
2. **schedule.ts**: `superRefine()`でendAt >= startAtチェック。keywords/aiResultにサイズ制限
3. **api.ts**: `handleErrorResponse()`と`handleVoidResponse()`を共通化。deleteScheduleとupdateMemoの重複解消
4. **useSchedules.ts**: `Partial<CreateScheduleInput>` → `UpdateScheduleInput`

型チェック・テスト31件パス。

### 自己批判

- NaN問題は自分で見つけるべきだった。routeのバリデーションを書いた時点で気づくべき
- Codexが認証を見落とした理由を追及しなかった。なぜ見落としたのか確認すれば、次回のレビュー依頼時の参考になったはず
- 「見送り」の判断が適切だったか、ユーザーに確認しなかった。タイムゾーンの問題は将来的にバグになる可能性がある

### 学び

外部ツールのレビュー結果は、そのまま受け入れるのではなく検証が必要。人間のレビューでも同じだが、AIツールだと「正しいはず」と思い込みやすい。

一方で、自分では気づかない問題を発見してくれる価値はある。重複コードの指摘は「言われてみれば」という感じだった。
