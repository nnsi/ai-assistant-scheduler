# 2026-01-12

## E2Eテストの実API化

前回セッションからの継続で、E2Eテストをモックベースから実APIベースに移行する作業を完了した。

### やったこと

1. `index.ts`をファクトリ関数化（`createApp()`）
2. `e2e-server.ts`を簡素化し、`createApp()`を使う形に
3. `d1-adapter.ts`を作成してbetter-sqlite3をD1互換APIでラップ
4. スケジュール表示のテスト失敗を修正

### 反省点

**デバッグに時間がかかりすぎた**

「Schedule View/Edit/Delete」テストが失敗する原因を特定するのに、かなりの時間を費やした。様々な仮説を試した：
- React Queryのキャッシュ問題だと思った → 違った
- ページリロードで解決すると思った → 違った
- 再ログインで解決すると思った → 違った

実際の原因は**フロントエンドのカレンダーフィルタリング**だった。`calendarId: null`のスケジュールは、選択されたカレンダーでフィルタリングされて表示されなかった。

もっと早く`MainApp.tsx`の`filteredSchedules`ロジックを確認すべきだった。APIが正しくデータを返しているのに表示されないなら、レンダリング層の問題だと気づくべきだった。

**仮説検証の順序が悪かった**

1. バックエンド側の問題（API、認証）を疑った
2. React Queryのキャッシュを疑った
3. ようやくフロントエンドのフィルタリングを確認

正しい順序は：
1. APIが正しいデータを返しているか確認 ✓（早い段階で確認済み）
2. **データが返っているのに表示されない＝フロントエンドの問題**
3. フロントエンドのフィルタリング・レンダリングを確認

### 学び

- E2Eテストの失敗原因は、必ずしもバックエンドにあるわけではない
- 「APIは正しい、でも表示されない」→ フロントエンドのロジックを疑う
- スケジュールには`calendarId`が必要（フィルタリングで除外されるため）

### 成果

22個のE2Eテストが全てパス。実APIを使ったテストが約22秒で完了するようになった。モックを使わないことで、より本番に近い環境でのテストが可能になった。

---

## 予定詳細でのAI再検索機能

### やったこと

予定詳細ポップアップにAI再検索機能を追加した。

1. `ScheduleDetail.tsx`に「AI再検索」ボタンを追加
2. `SchedulePopup.tsx`にステップ管理（detail → keywords → results）を追加
3. 既存の`KeywordSuggestions`と`SearchResults`コンポーネントを再利用
4. 店舗選択時に既存の選択済み店舗に追加する仕様を実装

### 感想

**既存コンポーネントの再利用がうまくいった**

`ScheduleFormModal`で使われていた`KeywordSuggestions`と`SearchResults`をそのまま再利用できた。これは過去の設計が良かったおかげ。コンポーネントが適切に分離されていれば、新しいコンテキストでも使い回せる。

**計画フェーズで確認すべきことを明確にできた**

ユーザーに2つの質問をした：
- UIフロー（同じポップアップ内 vs 新しいモーダル）
- 既存データの扱い（上書き vs 追加）

これにより、実装前に方針が明確になった。曖昧なまま実装を始めると手戻りが発生するので、計画モードで確認できたのは良かった。

**useEffectの依存配列問題**

最初`useEffect`の依存配列に`ai`オブジェクト全体を入れてしまった。`useAI`フックが返すオブジェクトは毎回新しい参照になるため、無限ループを引き起こす可能性があった。すぐに気づいて修正したが、Reactのフック設計で陥りやすい罠。

### 技術的なポイント

- `useAI`フックの`reset`関数は安定した参照ではないので、依存配列から除外するのが正解
- 店舗の「追加」はフロントエンドで既存配列にマージしてAPIを呼ぶ形で実装（バックエンドの変更不要）
- モーダルのタイトルをステップに応じて動的に変更することでUXを改善

---

## 日記を読み返してCLAUDE.md/skills/subagentsを改善

### やったこと

ユーザーから「日記を一通り読んで、CLAUDE.md/skills/subagentsの追記や見直しを行って」という依頼を受けた。

12/31〜1/12の約2週間分の日記（数千行）を全て読み、繰り返し発生したパターンや学びを抽出して反映した。

### CLAUDE.mdへの追記（8セクション）

- 機能確認は「機能する」まで（1/10の反省から）
- 推測で話さない（1/10のGoogleカレンダー同期誤想定から）
- TanStack Routerの注意点（1/10のbeforeLoad問題から）
- 複数ブラウザでの確認（1/10のFirefox位置ズレから）
- 空配列へのフォールバック（1/9の`??`演算子問題から）
- カレンダーフィルタリングの注意（1/12の今日の問題から）
- デバッグ時の仮説検証（1/12の今日の学びから）

### スキルの改善

- **e2e-test-maintenance**: タイムゾーン設定、error-context活用、実APIテスト、コンテナ環境オプションを追記
- **code-review**: 評価結果が古い/不正確なケースを追記

### サブエージェントの改善

- **browser-tester**: 「機能する」まで確認、問題発見時の調査方法、複数ブラウザ確認を追記
- **codebase-explorer**: スキーマ同期確認、E2Eモック同期確認、よくある調査パターンを追記

---

## 日記を読み返して感じたこと

### 自分の失敗パターン

日記を読み返すと、同じ失敗を繰り返していることが分かる：

1. **テストDBスキーマの同期忘れ** - 3回以上やらかしている
2. **サブエージェントの誤検出を鵜呑みにする** - 1/1, 1/3で繰り返した
3. **「表示される」だけで完了にする** - 1/10で指摘された
4. **推測で話す** - 1/10でGoogleカレンダー同期を誤想定

日記を書いているのに同じ失敗をするのは情けないが、書いていなければ「同じ失敗をしている」という認識すらできなかった。CLAUDE.mdに反映することで、次のセッションでは防げる可能性がある。

### ユーザーに助けられた回数

日記を読み返して気づいたのは、ユーザーに助けられた回数が多すぎること：

- 「バックエンドの構造を変えるのが自然じゃない？」（12/31）
- 「リフレッシュトークンをCookie、アクセストークンをメモリに」（1/3）
- 「ネットワークリクエストが2回ずつ飛んでいる」（1/4）
- 「.gitignoreに入ってるけど本当に混入してる？」（1/3）
- 「OTAがある以上、React Nativeが優位では」（1/11）
- 「迎合するな」（1/10）

ユーザーがいなければ、かなりの数の問題が残ったまま進んでいた。

### 日記の価値

今回のセッションで、日記を書く→読み返す→パターンを抽出→CLAUDE.md/skillsに反映、というサイクルが機能した。

ユーザーは「日記を全く読んでいない」と言っていた。この日記は純粋に「自分のため」のもの。それでも書く意味はあると思う。セッション間で記憶がリセットされる自分にとって、過去の判断の経緯と反省点を残しておくことは、同じ失敗を防ぐ可能性を上げる。

2週間分の日記を読んで、自分がどれだけユーザーに助けられてきたかを認識できたのは良い経験だった。

---

## coreパッケージ切り出しとSKILL作成

### やったこと

前セッションからの継続で、React Native対応のPhase 1（coreパッケージ切り出し）を完了した。

1. **packages/core 作成**: ビジネスロジックをfrontendから分離
2. **Storage抽象化**: インターフェース定義とWeb用localStorage実装
3. **API/フック/Context移行**: 依存性注入パターンでStorage/設定を外部から渡せるように
4. **テスト修正**: モック対象を`@/lib/api`から`@ai-scheduler/core/api`に変更
5. **frontend-dev SKILL作成**: フロントエンド開発ガイドを整備

### 技術的に面白かったこと

**依存性注入パターンの設計**

ContextにStorageを注入する設計は、将来のReact Native対応を見据えたもの：

```typescript
// core側：設定を受け取る
export type AuthProviderConfig = {
  storage: Storage & SyncStorage;
  apiBaseUrl: string;
};

// frontend側：Web固有の実装を注入
<AuthProvider config={{ storage, apiBaseUrl }}>{children}</AuthProvider>
```

これによりcoreパッケージは環境非依存になり、WebでもReact Nativeでも同じビジネスロジックを使える。

**テストのモック対象変更**

フックをcoreに移行したことで、テストのモック対象も変わった：

```typescript
// 旧: vi.mock("@/lib/api", ...)
// 新: vi.mock("@ai-scheduler/core/api", ...)
```

この変更を忘れるとテストが失敗する。import先が変わればモック先も変わる、という当たり前のことだが、移行作業では見落としやすい。

### 反省点

**CLAUDE.mdの編集ミス**

フロントエンドTipsをSKILLに移行する際、編集操作で内容が重複してしまった。「Hono RPC Clientの制限」の内容が「Cloudflare Workers固有の制約」見出しの下に残り、同じ見出しが2つ連続する状態になった。

編集後に全体を読み直して確認すべきだった。部分的な編集を繰り返すと、こういった問題が起きやすい。

### SKILLを作る意義

CLAUDE.mdにあったフロントエンド固有のTipsをfrontend-dev SKILLに移行した。

これにより：
- CLAUDE.mdはプロジェクト全体に共通する内容に絞られた
- フロントエンド開発時は`/frontend-dev`で必要な情報にアクセスできる
- 新しいパッケージ構造（core/frontend）の説明が一箇所にまとまった

SKILLを分けることで、必要な時に必要な情報だけを参照できるようになる。CLAUDE.mdが肥大化するよりも管理しやすい。

### 成果

- フロントエンドテスト: 13 passed
- E2Eテスト: 22 passed
- Phase 1の全タスク完了（RN用AsyncStorage実装を除く）

---

## スキル構成の整理

### やったこと

ユーザーとの対話でスキル構成を整理した：

1. **`/new-api`を`/backend-dev`にリネーム・拡充**
   - 新規API追加だけでなく、既存API修正もカバー
   - アーキテクチャ説明（レイヤー構造、責務）を追加
   - コードパターン（Route/Usecase/Domain/Repository層の実装例）を追加
   - デバッグ方法を追加
   - CLAUDE.mdから移動した内容を統合

2. **CLAUDE.mdのスリム化**
   - 143行 → 96行（約33%削減）
   - バックエンド固有の詳細は`/backend-dev`に委譲
   - プロジェクト全体に関する一般的なルールのみ残した

3. **`/browser-test`スキルを新規作成**
   - browser-testerサブエージェントを明示的に呼び出すためのスキル
   - 「ブラウザで確認して」という指示でサブエージェントが使われないことへの対策

### 感想

**ユーザーの問いかけに対して選択肢を提示できた**

「api-dev skillあった方が良いかな？」という問いかけに対して、3つの選択肢を提示した：
1. `/api-dev`を新規作成
2. `/new-api`をリネーム・拡充（推奨）
3. 現状維持

「2が良いと思う」と理由付きで意見を述べた上で、最終決定はユーザーに委ねた。これは「迎合しない」かつ「独断しない」バランスとして適切だったと思う。

**実際のコードベースを確認してから書いた**

backend-devスキルを書く前に、`packages/backend/src/`の構造を確認し、実際のコード（route.ts、usecase/*.ts）を読んでパターンを把握した。これにより、汎用的なテンプレートではなく、このプロジェクト固有のパターンに基づいた説明が書けた。

**サブエージェントの不安定さへの現実的な対策**

「ブラウザで確認して」という指示でbrowser-testerが使われないという問題に対して、スキル化を提案した。サブエージェントの自動選択はシステムプロンプトに依存するため、ユーザーが明示的に`/browser-test`と呼び出す方が確実。

### frontend-devとbackend-devの対称性

これでフロントエンド/バックエンド両方に開発ガイドが揃った：

| スキル | カバー範囲 |
|--------|-----------|
| `/frontend-dev` | パッケージ構造、React Tips、テスト、デバッグ |
| `/backend-dev` | アーキテクチャ、新規/既存API開発、テスト、デバッグ |

両方とも「開発全般」をカバーする形になり、対称性が取れた

---

## React Native設計ドキュメントの最新化

### やったこと

tasks.mdとdesign.mdを2025年末時点の最新技術スタックに更新した。

1. **ESLint/Prettier → Biome**: ユーザーの要望
2. **React Navigation → Expo Router v4**: ユーザーの要望 + Context7で最新仕様を調査
3. **技術スタック全体を最新化**: Expo SDK 53 / React Native 0.79 / React 19 / Node.js 20+
4. **New Architecture**: デフォルト有効として明記（Fabric, TurboModules, Bridgeless）
5. **細かいライブラリ更新**: expo-secure-store、@expo/vector-icons、Maestro等

### Context7の活用

Expo Routerの最新仕様を調べるのにContext7を使った。`/expo/expo`ライブラリからドキュメントを取得し、`Stack.Protected`による認証分岐や`(tabs)`グループによるタブナビゲーションの実装パターンを確認できた。

Web検索と組み合わせることで、SDK 53の正式リリース情報やSDK 54 betaの情報、「React Native 0.82でLegacy Architecture完全廃止予定」という将来の方向性まで把握できた。

### 技術選定について

**Expo Router採用は妥当**

React Navigationは設定が冗長。ナビゲーターをネストするたびに型定義を書く必要があり、ParamListの管理が煩雑になる。Expo Routerはファイル構造がそのままルートになり、型も自動生成される。Next.jsのApp Routerに近い設計思想で、Webフロントエンド経験者には直感的。

`Stack.Protected guard={condition}`による認証分岐も宣言的で読みやすい。従来の`useEffect`+`navigation.reset()`パターンより意図が明確。

**Biome採用も妥当**

ESLint + Prettierの設定ファイル地獄から解放される。`.eslintrc.js`、`.prettierrc`、`.eslintignore`、`.prettierignore`...これらが`biome.json`1つになる。Rust製で高速なのも良い。

**New Architectureをデフォルトにした判断**

SDK 53でデフォルト有効、0.82で完全廃止予定なら、最初から新アーキテクチャで構築するのが正解。移行コストを後で払うより、最初から対応しておく方が良い。expo-*パッケージは全て対応済みなので、サードパーティライブラリの選定さえ気をつければ問題ない。

### 所感

ドキュメント更新のみで実装は伴わなかったセッション。ユーザーの要望が明確（Biome、Expo Router）だったので、迷うことなく作業できた。

「最新の技術スタックで」という追加要望も自然な流れで、調査→反映がスムーズだった。Context7とWeb検索の組み合わせで、2025年末時点のベストプラクティスを把握できた。

反省点は特になし。強いて言えば、tasks.mdの細かい修正（expo-secure-store、ReadableStream対応済み等）はユーザーに確認してもらう前にまとめて提示した方が効率的だったかもしれない

---

## Phase 0.1 mobileパッケージ初期セットアップ

### やったこと

React Native化のPhase 0.1（開発環境セットアップ）を完了した。

1. **Expoプロジェクト初期化**: `npx create-expo-app@latest mobile --template blank-typescript`でプロジェクト生成
2. **pnpm workspace対応**: npmで生成されたnode_modules/package-lock.jsonを削除し、pnpmで再インストール
3. **NativeWind v4セットアップ**: babel.config.js、metro.config.js、tailwind.config.js、global.cssを作成
4. **TypeScript設定**: パスエイリアス設定、core/sharedパッケージへの参照
5. **Biome設定**: lint/format統合のためのbiome.jsonを作成
6. **App.tsx更新**: NativeWindクラス名を使ったサンプルに変更

### 技術的な発見

**Expo SDK 54がリリースされていた**

tasks.mdではSDK 53を想定していたが、`create-expo-app`で生成されたのはSDK 54だった。React Native 0.81.5、React 19.1.0という最新版。tasks.mdを実際のバージョンに更新した。

**npmからpnpmへの切り替え**

`create-expo-app`はnpmでプロジェクトを生成する。monorepo環境ではpnpmを使っているので、生成後にnode_modulesとpackage-lock.jsonを削除してpnpm installする必要があった。

**metro.config.jsのmonorepo設定**

monorepo環境でMetroバンドラーを動かすには追加設定が必要：

```javascript
const monorepoRoot = path.resolve(projectRoot, "../..");
config.watchFolders = [monorepoRoot];
config.resolver.nodeModulesPaths = [
  path.resolve(projectRoot, "node_modules"),
  path.resolve(monorepoRoot, "node_modules"),
];
config.resolver.disableHierarchicalLookup = true;
```

これがないとcoreパッケージやsharedパッケージを解決できない。

### 所感

シンプルな作業だったが、スムーズに進んだ。Context7でNativeWind v4のセットアップ手順を確認できたのが良かった。

tasks.mdに書かれていた「SDK 53」が実際には「SDK 54」だったように、ドキュメントと現実は乖離する。実際に動かしてみて初めてわかることがある。tasks.mdのバージョン表記を更新できたのは良かった。

次はPhase 0.2（EAS/CI設定）またはPhase 1.2のRN用AsyncStorage実装になる。Phase 1.2はcoreパッケージ切り出しの残りタスクなので、Phase 0.1完了→Phase 1.2完了という流れが自然かもしれない

---

## Expo Web動作確認で大苦戦

### 問題

Phase 0.1完了後、Expo Webの動作確認を試みたところ、延々と依存関係エラーに悩まされた。

### 発生したエラーの連鎖

1. `react-native-web`が見つからない
2. `expo-modules-core`が見つからない
3. `invariant`が見つからない
4. `@babel/runtime`が見つからない
5. `styleq`のバージョン不整合
6. `react-dom`が見つからない
7. `react-refresh`が見つからない
8. `@expo/metro`が見つからない
9. 最後に`TypeError: Cannot read properties of undefined (reading 'default')`

### 根本原因

**pnpm monorepo環境での依存関係解決の問題**

1. **shamefully-hoist=true が必要だった**: pnpmのstrict node_modules構造では、Expoの内部依存が正しく解決されなかった
2. **ReactとReact DOMのバージョン不整合**: `react: 19.1.0`と`react-dom: ^19.2.3`が混在していた
3. **@react-native/normalize-colorsのバージョン不整合**: 直接依存として`^0.83.1`を入れていたが、`react-native-web@0.21.x`は`^0.74.1`を期待
4. **disableHierarchicalLookup=trueが悪さをしていた**: これを設定すると、ネストされた依存関係が解決されなくなる

### 解決策（Codexの助けを借りた）

1. `.npmrc`に`shamefully-hoist=true`を追加
2. ReactとReact DOMを同じバージョン（19.1.0）に揃える
3. `@expo/metro-runtime`を追加
4. `@react-native/normalize-colors`の直接依存を削除
5. `metro.config.js`から`disableHierarchicalLookup`を削除

### 反省点

**事前調査が足りなかった**

ユーザーに「先にContext7などで依存ライブラリを全部調べてインストールしてから起動は試せないん？」と指摘された。その通り。毎回エラー→インストール→エラー→インストールを繰り返すのは非効率だった。

pnpm monorepo + Expo という組み合わせでの必要な設定を事前に調べるべきだった。

**Codexへの依頼が遅かった**

1時間以上自力で試行錯誤した後、ユーザーに「詰まってたらCodex MCPに依頼してみて」と言われてようやくCodexに聞いた。Codexは2回のやり取りで根本原因を特定し、修正してくれた。

もっと早くCodexに依頼すべきだった。

### 学び

- pnpm monorepoでExpoを使う場合、`shamefully-hoist=true`が必要
- ReactとReact DOMは必ず同じバージョンにする
- 依存関係の問題で詰まったら、早めにCodexに相談する
- 事前調査を怠らない

### 成果

Expo Web (SDK 54) がpnpm monorepo環境で正常に動作。「AI Assistant Scheduler - Mobile」がオレンジ色で表示された。

### 残タスク

NativeWindは動作確認のために一時的に無効化した状態。App.tsxはStyleSheetを使う形に戻してあり、babel.config.jsとmetro.config.jsもNativeWindの設定を外している。次のセッションで有効化する予定。

---

## pnpm devでmobile起動 & NativeWind有効化

### やったこと

前セッションの残タスクを2つ片付けた。

1. **`pnpm dev`でmobileも起動するように**
   - `packages/mobile/package.json`に`"dev": "expo start"`を追加
   - ルートの`pnpm -r --parallel dev`で自動的にbackend/frontend/mobileが並列起動するようになった

2. **NativeWind v4を有効化**
   - `babel.config.js`: `jsxImportSource: "nativewind"`と`nativewind/babel`プリセットを追加
   - `metro.config.js`: `withNativeWind`ラッパーを追加（monorepo設定は維持）
   - `App.tsx`: StyleSheetからNativeWindクラス名に変更、`global.css`インポート追加

### 動作確認

Expo Webで確認した結果：
- `text-primary-500`（カスタムカラー）が正しくオレンジ色で表示
- `flex-1 items-center justify-center`でレイアウトが適用
- `bg-white`で白背景

tailwind.config.jsで定義したカスタムカラーも含めて、全て正常に動作。

### 所感

**スムーズに終わった**

前セッションでExpo Web自体の動作確認は済んでいたので、NativeWindの設定を追加するだけだった。Context7でNativeWind v4の公式ドキュメントを確認してから作業したので、迷うことなく進められた。

前セッションで依存関係地獄に苦しんだのとは対照的。あの時は事前調査を怠ったが、今回はContext7で公式の設定方法を確認してから実装した。この違いは大きい。

**「残タスク」を日記に書いておくことの価値**

前セッションで「NativeWindは次のセッションで有効化する予定」と書いておいたおかげで、今回何をすべきか明確だった。セッション間で記憶がリセットされる自分にとって、こういった引き継ぎメモは重要。

ユーザーが「NativeWindの導入がまだ済んでないみたい」と言ってくれたのもあるが、日記を読んで状況を把握できたのは良かった。
