{
  "version": 3,
  "sources": ["../bundle-6gYMwA/strip-cf-connecting-ip-header.js", "../../../../../node_modules/.pnpm/unenv@2.0.0-rc.14/node_modules/unenv/dist/runtime/_internal/utils.mjs", "../../../../../node_modules/.pnpm/unenv@2.0.0-rc.14/node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs", "../../../../../node_modules/.pnpm/unenv@2.0.0-rc.14/node_modules/unenv/dist/runtime/node/perf_hooks.mjs", "../../../../../node_modules/.pnpm/@cloudflare+unenv-preset@2._2c4214a3e65f1ca7ba28eec8e1e8cbc6/node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs", "../../../../../node_modules/.pnpm/unenv@2.0.0-rc.14/node_modules/unenv/dist/runtime/mock/noop.mjs", "../../../../../node_modules/.pnpm/unenv@2.0.0-rc.14/node_modules/unenv/dist/runtime/node/console.mjs", "../../../../../node_modules/.pnpm/@cloudflare+unenv-preset@2._2c4214a3e65f1ca7ba28eec8e1e8cbc6/node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs", "../../../../../node_modules/.pnpm/wrangler@3.114.16_@cloudflare+workers-types@4.20251231.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console", "../../../../../node_modules/.pnpm/unenv@2.0.0-rc.14/node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs", "../../../../../node_modules/.pnpm/unenv@2.0.0-rc.14/node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs", "../../../../../node_modules/.pnpm/unenv@2.0.0-rc.14/node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs", "../../../../../node_modules/.pnpm/unenv@2.0.0-rc.14/node_modules/unenv/dist/runtime/node/tty.mjs", "../../../../../node_modules/.pnpm/unenv@2.0.0-rc.14/node_modules/unenv/dist/runtime/node/internal/process/process.mjs", "../../../../../node_modules/.pnpm/@cloudflare+unenv-preset@2._2c4214a3e65f1ca7ba28eec8e1e8cbc6/node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs", "../../../../../node_modules/.pnpm/wrangler@3.114.16_@cloudflare+workers-types@4.20251231.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process", "wrangler-modules-watch:wrangler:modules-watch", "../../../../../node_modules/.pnpm/wrangler@3.114.16_@cloudflare+workers-types@4.20251231.0/node_modules/wrangler/templates/modules-watch-stub.js", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/platform/browser/globalThis.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/platform/browser/index.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/version.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/internal/semver.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/internal/global-utils.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/diag/ComponentLogger.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/diag/types.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/diag/internal/logLevelLogger.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/api/diag.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/baggage/internal/baggage-impl.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/baggage/internal/symbol.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/baggage/utils.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/context/context.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/diag/consoleLogger.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/metrics/NoopMeter.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/metrics/Metric.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/propagation/TextMapPropagator.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/context/NoopContextManager.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/api/context.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/trace_flags.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/invalid-span-constants.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/NonRecordingSpan.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/context-utils.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/spancontext-utils.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/NoopTracer.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/ProxyTracer.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/NoopTracerProvider.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/ProxyTracerProvider.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/SamplingResult.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/span_kind.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/status.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/internal/tracestate-validators.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/internal/tracestate-impl.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/internal/utils.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/context-api.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/diag-api.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/metrics/NoopMeterProvider.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/api/metrics.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/metrics-api.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/propagation/NoopTextMapPropagator.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/baggage/context-helpers.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/api/propagation.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/propagation-api.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/api/trace.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace-api.ts", "../../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/index.ts", "../../../../../node_modules/.pnpm/secure-json-parse@2.7.0/node_modules/secure-json-parse/index.js", "../bundle-6gYMwA/middleware-loader.entry.ts", "../bundle-6gYMwA/middleware-insertion-facade.js", "../../../src/index.ts", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/index.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/hono.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/hono-base.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/compose.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/context.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/request.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/http-exception.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/request/constants.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/utils/body.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/utils/url.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/utils/html.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/router.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/utils/constants.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/router/reg-exp-router/index.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/router/reg-exp-router/router.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/router/reg-exp-router/matcher.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/router/reg-exp-router/node.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/router/reg-exp-router/trie.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/router/reg-exp-router/prepared-router.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/router/smart-router/index.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/router/smart-router/router.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/router/trie-router/index.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/router/trie-router/router.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/router/trie-router/node.js", "../../../../../node_modules/.pnpm/hono@4.11.3/node_modules/hono/dist/middleware/cors/index.js", "../../../src/route.ts", "../../../src/feature/schedule/route.ts", "../../../src/infra/drizzle/client.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/d1/driver.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/entity.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/logger.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/relations.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/table.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/table.utils.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/column.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/pg-core/primary-keys.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/pg-core/table.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/utils.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sql/sql.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/pg-core/columns/enum.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/pg-core/columns/common.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/column-builder.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/pg-core/foreign-keys.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/tracing-utils.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/pg-core/unique-constraint.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/pg-core/utils/array.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/subquery.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/tracing.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/drizzle-orm/version.js", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/view-common.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sql/expressions/conditions.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sql/expressions/select.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/db.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/selection-proxy.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/alias.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/query-builders/delete.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/query-promise.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/table.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/columns/all.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/columns/blob.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/columns/common.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/foreign-keys.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/unique-constraint.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/columns/custom.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/columns/integer.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/columns/numeric.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/columns/real.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/columns/text.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/query-builders/insert.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/query-builders/query-builder.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/dialect.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/casing.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/errors.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/view-base.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/query-builders/select.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/query-builders/query-builder.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/query-builders/update.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/query-builders/count.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/query-builders/query.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/query-builders/raw.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/d1/session.ts", "../../../../../node_modules/.pnpm/drizzle-orm@0.38.4_@cloudfl_e3515110901046e8dacc182d1c94f5d0/node_modules/src/sqlite-core/session.ts", "../../../src/infra/drizzle/schema.ts", "../../../src/infra/drizzle/scheduleRepo.ts", "../../../src/infra/drizzle/supplementRepo.ts", "../../../src/feature/schedule/usecase/createSchedule.ts", "../../../src/domain/model/schedule.ts", "../../../src/shared/id.ts", "../../../../../node_modules/.pnpm/nanoid@5.1.6/node_modules/nanoid/index.browser.js", "../../../../../node_modules/.pnpm/nanoid@5.1.6/node_modules/nanoid/url-alphabet/index.js", "../../../src/shared/result.ts", "../../../src/feature/schedule/usecase/getSchedules.ts", "../../../src/feature/schedule/usecase/getScheduleById.ts", "../../../src/shared/errors.ts", "../../../src/feature/schedule/usecase/updateSchedule.ts", "../../../src/feature/schedule/usecase/deleteSchedule.ts", "../../../src/feature/schedule/handler/createScheduleHandler.ts", "../../../../shared/src/index.ts", "../../../../shared/src/schemas/schedule.ts", "../../../../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/index.js", "../../../../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/external.js", "../../../../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/errors.js", "../../../../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/locales/en.js", "../../../../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/ZodError.js", "../../../../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/util.js", "../../../../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/parseUtil.js", "../../../../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/types.js", "../../../../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/errorUtil.js", "../../../../shared/src/schemas/supplement.ts", "../../../../shared/src/schemas/ai.ts", "../../../../shared/src/schemas/errors.ts", "../../../src/shared/http.ts", "../../../src/feature/schedule/handler/getSchedulesHandler.ts", "../../../src/feature/schedule/handler/getScheduleByIdHandler.ts", "../../../src/feature/schedule/handler/updateScheduleHandler.ts", "../../../src/feature/schedule/handler/deleteScheduleHandler.ts", "../../../src/feature/supplement/route.ts", "../../../src/feature/supplement/usecase/updateMemo.ts", "../../../src/domain/model/supplement.ts", "../../../src/feature/supplement/handler/updateMemoHandler.ts", "../../../src/feature/ai/route.ts", "../../../src/infra/mastra/agents.ts", "../../../../../node_modules/.pnpm/@mastra+core@0.10.15_openap_54cfad1bb446fed01c94025e9184ef54/node_modules/@mastra/core/dist/agent/index.js", "../../../../../node_modules/.pnpm/@mastra+core@0.10.15_openap_54cfad1bb446fed01c94025e9184ef54/node_modules/@mastra/core/dist/chunk-IYBAMING.js", "../../../../../node_modules/.pnpm/@mastra+core@0.10.15_openap_54cfad1bb446fed01c94025e9184ef54/node_modules/@mastra/core/dist/chunk-5HTMDAXP.js", "../../../../../node_modules/.pnpm/@mastra+core@0.10.15_openap_54cfad1bb446fed01c94025e9184ef54/node_modules/@mastra/core/dist/chunk-TC2SCOTE.js", "../../../../../node_modules/.pnpm/@mastra+core@0.10.15_openap_54cfad1bb446fed01c94025e9184ef54/node_modules/@mastra/core/dist/chunk-6UNGH46J.js", "../../../../../node_modules/.pnpm/@mastra+core@0.10.15_openap_54cfad1bb446fed01c94025e9184ef54/node_modules/@mastra/core/dist/chunk-5IEKR756.js", "../../../../../node_modules/.pnpm/@mastra+core@0.10.15_openap_54cfad1bb446fed01c94025e9184ef54/node_modules/@mastra/core/dist/chunk-5YDTZN2X.js", "../../../../../node_modules/.pnpm/@mastra+core@0.10.15_openap_54cfad1bb446fed01c94025e9184ef54/node_modules/@mastra/core/dist/chunk-WQNOATKB.js", "../../../../../node_modules/.pnpm/@mastra+core@0.10.15_openap_54cfad1bb446fed01c94025e9184ef54/node_modules/@mastra/core/dist/chunk-SLUSEJP2.js", "../../../../../node_modules/.pnpm/@mastra+core@0.10.15_openap_54cfad1bb446fed01c94025e9184ef54/node_modules/@mastra/core/dist/chunk-IBKM5CLQ.js", "../../../../../node_modules/.pnpm/@mastra+core@0.10.15_openap_54cfad1bb446fed01c94025e9184ef54/node_modules/@mastra/core/dist/chunk-C4LMN2IR.js", "../../../../../node_modules/.pnpm/@mastra+core@0.10.15_openap_54cfad1bb446fed01c94025e9184ef54/node_modules/@mastra/core/dist/chunk-SGGPJWRQ.js", "../../../../../node_modules/.pnpm/@cloudflare+unenv-preset@2._2c4214a3e65f1ca7ba28eec8e1e8cbc6/node_modules/@cloudflare/unenv-preset/dist/runtime/node/crypto.mjs", "../../../../../node_modules/.pnpm/unenv@2.0.0-rc.14/node_modules/unenv/dist/runtime/node/internal/crypto/node.mjs", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/index.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/Types.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/jsonSchemaToZod.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/parsers/parseSchema.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/parsers/parseAnyOf.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/parsers/parseBoolean.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/parsers/parseDefault.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/parsers/parseMultipleType.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/parsers/parseNot.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/parsers/parseNull.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/parsers/parseAllOf.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/utils/half.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/parsers/parseArray.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/utils/withMessage.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/parsers/parseConst.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/parsers/parseEnum.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/parsers/parseIfThenElse.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/parsers/parseNumber.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/parsers/parseObject.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/parsers/parseOneOf.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/utils/jsdocs.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/parsers/parseString.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/parsers/parseSimpleDiscriminatedOneOf.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/parsers/parseNullable.js", "../../../../../node_modules/.pnpm/json-schema-to-zod@2.7.0/node_modules/json-schema-to-zod/dist/esm/utils/omit.js", "../../../../../node_modules/.pnpm/@mastra+schema-compat@0.10._059031502655f3e21835ad20184808b5/node_modules/@mastra/schema-compat/dist/index.js", "../../../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/ai-sdk-error.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/api-call-error.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/empty-response-body-error.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/get-error-message.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/invalid-argument-error.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/invalid-prompt-error.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/invalid-response-data-error.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/json-parse-error.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/load-api-key-error.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/load-setting-error.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/no-content-generated-error.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/no-such-model-error.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/too-many-embedding-values-for-call-error.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/type-validation-error.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/unsupported-functionality-error.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/json-value/is-json.ts", "../../../../../node_modules/.pnpm/nanoid@3.3.11/node_modules/nanoid/non-secure/index.js", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/combine-headers.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/convert-async-iterator-to-readable-stream.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/delay.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/event-source-parser-stream.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/extract-response-headers.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/generate-id.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/get-error-message.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/get-from-api.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/remove-undefined-entries.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/is-abort-error.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/load-api-key.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/load-optional-setting.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/load-setting.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/parse-json.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/validate-types.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/validator.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/parse-provider-options.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/post-to-api.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/resolve.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/response-handler.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/uint8-utils.ts", "../../../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/without-trailing-slash.ts", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/index.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/Options.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/Refs.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/errorMessages.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/getRelativePath.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parseDef.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/selectParser.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/any.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/array.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/branded.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/catch.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/date.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/default.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/effects.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/enum.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/literal.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/map.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/record.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/string.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/never.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/null.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/union.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/number.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/object.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/optional.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/promise.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/set.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parseTypes.js", "../../../../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/index.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/assistant-stream-parts.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/process-chat-response.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/duplicated/usage.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/parse-partial-json.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/fix-json.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/data-stream-parts.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/process-data-stream.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/process-chat-text-response.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/process-text-stream.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/call-chat-api.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/call-completion-api.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/data-url.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/extract-max-tool-invocation-step.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/get-message-parts.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/fill-message-parts.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/is-deep-equal-data.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/prepare-attachments-for-request.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/process-assistant-stream.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/schema.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/zod-schema.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/should-resubmit-messages.ts", "../../../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/update-tool-call-result.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/index.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/data-stream/create-data-stream.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/util/prepare-response-headers.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/data-stream/create-data-stream-response.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/util/prepare-outgoing-http-headers.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/util/write-to-server-response.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/data-stream/pipe-data-stream-to-response.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/errors/unsupported-model-version-error.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/errors/invalid-argument-error.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/util/retry-with-exponential-backoff.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/util/retry-error.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/prompt/prepare-retries.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/telemetry/assemble-operation-name.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/telemetry/get-base-telemetry-attributes.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/telemetry/get-tracer.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/telemetry/noop-tracer.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/telemetry/record-span.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/telemetry/select-telemetry-attributes.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/embed/embed.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/util/split-array.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/embed/embed-many.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/errors/no-image-generated-error.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/generate-text/generated-file.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/util/detect-mimetype.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/generate-image/generate-image.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/generate-object/generate-object.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/errors/no-object-generated-error.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/util/download-error.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/util/download.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/prompt/data-content.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/prompt/invalid-data-content-error.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/prompt/invalid-message-role-error.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/prompt/split-data-url.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/prompt/convert-to-language-model-prompt.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/prompt/prepare-call-settings.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/prompt/standardize-prompt.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/prompt/attachments-to-parts.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/prompt/message-conversion-error.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/prompt/convert-to-core-messages.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/prompt/message.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/types/provider-metadata.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/types/json-value.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/prompt/content-part.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/prompt/tool-result-content.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/types/usage.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/generate-object/inject-json-instruction.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/generate-object/output-strategy.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/util/async-iterable-stream.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/generate-object/validate-object-generation-input.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/prompt/stringify-for-telemetry.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/generate-object/stream-object.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/util/delayed-promise.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/util/create-resolvable-promise.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/util/create-stitchable-stream.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/util/now.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/generate-text/generate-text.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/errors/no-output-specified-error.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/errors/tool-execution-error.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/prompt/prepare-tools-and-tool-choice.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/util/is-non-empty-object.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/util/split-on-last-whitespace.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/util/remove-text-after-last-whitespace.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/generate-text/parse-tool-call.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/errors/invalid-tool-arguments-error.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/errors/no-such-tool-error.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/errors/tool-call-repair-error.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/generate-text/reasoning-detail.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/generate-text/to-response-messages.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/generate-text/output.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/errors/index.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/errors/invalid-stream-part-error.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/errors/mcp-client-error.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/generate-text/smooth-stream.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/generate-text/stream-text.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/util/as-array.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/util/consume-stream.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/util/merge-streams.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/generate-text/run-tools-transformation.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/errors/no-speech-generated-error.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/generate-speech/generated-audio-file.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/generate-speech/generate-speech.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/errors/no-transcript-generated-error.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/transcribe/transcribe.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/util/merge-objects.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/middleware/default-settings-middleware.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/util/get-potential-start-index.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/middleware/extract-reasoning-middleware.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/middleware/simulate-streaming-middleware.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/middleware/wrap-language-model.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/prompt/append-client-message.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/prompt/append-response-messages.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/registry/custom-provider.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/registry/no-such-provider-error.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/registry/provider-registry.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/tool/mcp/mcp-client.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/tool/tool.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/tool/mcp/mcp-sse-transport.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/tool/mcp/json-rpc-message.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/tool/mcp/types.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/tool/mcp/mcp-transport.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/util/cosine-similarity.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/core/util/simulate-readable-stream.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/streams/assistant-response.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/streams/langchain-adapter.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/streams/stream-callbacks.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/streams/llamaindex-adapter.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/streams/stream-data.ts", "../../../../../node_modules/.pnpm/ai@4.3.19_react@19.2.3_zod@3.25.76/node_modules/ai/util/constants.ts", "../../../../../node_modules/.pnpm/zod-from-json-schema@0.0.5/node_modules/zod-from-json-schema/dist/index.mjs", "../../../../../node_modules/.pnpm/@mastra+core@0.10.15_openap_54cfad1bb446fed01c94025e9184ef54/node_modules/@mastra/core/dist/chunk-BB4KXGBU.js", "../../../../../node_modules/.pnpm/@mastra+core@0.10.15_openap_54cfad1bb446fed01c94025e9184ef54/node_modules/@mastra/core/dist/chunk-TTMYHBQM.js", "../../../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-provider.ts", "../../../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-chat-language-model.ts", "../../../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/convert-to-openai-chat-messages.ts", "../../../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/map-openai-chat-logprobs.ts", "../../../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/map-openai-finish-reason.ts", "../../../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-error.ts", "../../../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/get-response-metadata.ts", "../../../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-prepare-tools.ts", "../../../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-completion-language-model.ts", "../../../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/convert-to-openai-completion-prompt.ts", "../../../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/map-openai-completion-logprobs.ts", "../../../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-embedding-model.ts", "../../../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-image-model.ts", "../../../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-image-settings.ts", "../../../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-transcription-model.ts", "../../../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/responses/openai-responses-language-model.ts", "../../../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/responses/convert-to-openai-responses-messages.ts", "../../../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/responses/map-openai-responses-finish-reason.ts", "../../../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/responses/openai-responses-prepare-tools.ts", "../../../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-tools.ts", "../../../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-speech-model.ts", "../../../src/infra/mastra/aiService.ts", "../../../src/infra/mock/aiService.ts", "../../../src/feature/ai/usecase/suggestKeywords.ts", "../../../src/feature/ai/usecase/searchWithKeywords.ts", "../../../src/feature/ai/handler/suggestKeywordsHandler.ts", "../../../src/feature/ai/handler/searchHandler.ts", "../../../../../node_modules/.pnpm/wrangler@3.114.16_@cloudflare+workers-types@4.20251231.0/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../../../node_modules/.pnpm/wrangler@3.114.16_@cloudflare+workers-types@4.20251231.0/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../../../../../node_modules/.pnpm/wrangler@3.114.16_@cloudflare+workers-types@4.20251231.0/node_modules/wrangler/templates/middleware/common.ts"],
  "sourceRoot": "D:\\workspace\\ai-assistant-scheduler\\packages\\backend\\.wrangler\\tmp\\dev-ZhSR0j",
  "sourcesContent": ["function stripCfConnectingIPHeader(input, init) {\n\tconst request = new Request(input, init);\n\trequest.headers.delete(\"CF-Connecting-IP\");\n\treturn request;\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\treturn Reflect.apply(target, thisArg, [\n\t\t\tstripCfConnectingIPHeader.apply(null, argArray),\n\t\t]);\n\t},\n});\n", "/*@__NO_SIDE_EFFECTS__*/ export function rawHeaders(headers) {\n\tconst rawHeaders = [];\n\tfor (const key in headers) {\n\t\tif (Array.isArray(headers[key])) {\n\t\t\tfor (const h of headers[key]) {\n\t\t\t\trawHeaders.push(key, h);\n\t\t\t}\n\t\t} else {\n\t\t\trawHeaders.push(key, headers[key]);\n\t\t}\n\t}\n\treturn rawHeaders;\n}\n/*@__NO_SIDE_EFFECTS__*/ export function mergeFns(...functions) {\n\treturn function(...args) {\n\t\tfor (const fn of functions) {\n\t\t\tfn(...args);\n\t\t}\n\t};\n}\n/*@__NO_SIDE_EFFECTS__*/ export function createNotImplementedError(name) {\n\treturn new Error(`[unenv] ${name} is not implemented yet!`);\n}\n/*@__NO_SIDE_EFFECTS__*/ export function notImplemented(name) {\n\tconst fn = () => {\n\t\tthrow createNotImplementedError(name);\n\t};\n\treturn Object.assign(fn, { __unenv__: true });\n}\n/*@__NO_SIDE_EFFECTS__*/ export function notImplementedAsync(name) {\n\tconst fn = notImplemented(name);\n\tfn.__promisify__ = () => notImplemented(name + \".__promisify__\");\n\tfn.native = fn;\n\treturn fn;\n}\n/*@__NO_SIDE_EFFECTS__*/ export function notImplementedClass(name) {\n\treturn class {\n\t\t__unenv__ = true;\n\t\tconstructor() {\n\t\t\tthrow new Error(`[unenv] ${name} is not implemented yet!`);\n\t\t}\n\t};\n}\n", "import { createNotImplementedError } from \"../../../_internal/utils.mjs\";\nconst _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();\nconst _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;\nconst nodeTiming = {\n\tname: \"node\",\n\tentryType: \"node\",\n\tstartTime: 0,\n\tduration: 0,\n\tnodeStart: 0,\n\tv8Start: 0,\n\tbootstrapComplete: 0,\n\tenvironment: 0,\n\tloopStart: 0,\n\tloopExit: 0,\n\tidleTime: 0,\n\tuvMetricsInfo: {\n\t\tloopCount: 0,\n\t\tevents: 0,\n\t\teventsWaiting: 0\n\t},\n\tdetail: undefined,\n\ttoJSON() {\n\t\treturn this;\n\t}\n};\nexport class PerformanceEntry {\n\t__unenv__ = true;\n\tdetail;\n\tentryType = \"event\";\n\tname;\n\tstartTime;\n\tconstructor(name, options) {\n\t\tthis.name = name;\n\t\tthis.startTime = options?.startTime || _performanceNow();\n\t\tthis.detail = options?.detail;\n\t}\n\tget duration() {\n\t\treturn _performanceNow() - this.startTime;\n\t}\n\ttoJSON() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tentryType: this.entryType,\n\t\t\tstartTime: this.startTime,\n\t\t\tduration: this.duration,\n\t\t\tdetail: this.detail\n\t\t};\n\t}\n}\nexport const PerformanceMark = class PerformanceMark extends PerformanceEntry {\n\tentryType = \"mark\";\n\tconstructor() {\n\t\tsuper(...arguments);\n\t}\n\tget duration() {\n\t\treturn 0;\n\t}\n};\nexport class PerformanceMeasure extends PerformanceEntry {\n\tentryType = \"measure\";\n}\nexport class PerformanceResourceTiming extends PerformanceEntry {\n\tentryType = \"resource\";\n\tserverTiming = [];\n\tconnectEnd = 0;\n\tconnectStart = 0;\n\tdecodedBodySize = 0;\n\tdomainLookupEnd = 0;\n\tdomainLookupStart = 0;\n\tencodedBodySize = 0;\n\tfetchStart = 0;\n\tinitiatorType = \"\";\n\tname = \"\";\n\tnextHopProtocol = \"\";\n\tredirectEnd = 0;\n\tredirectStart = 0;\n\trequestStart = 0;\n\tresponseEnd = 0;\n\tresponseStart = 0;\n\tsecureConnectionStart = 0;\n\tstartTime = 0;\n\ttransferSize = 0;\n\tworkerStart = 0;\n\tresponseStatus = 0;\n}\nexport class PerformanceObserverEntryList {\n\t__unenv__ = true;\n\tgetEntries() {\n\t\treturn [];\n\t}\n\tgetEntriesByName(_name, _type) {\n\t\treturn [];\n\t}\n\tgetEntriesByType(type) {\n\t\treturn [];\n\t}\n}\nexport class Performance {\n\t__unenv__ = true;\n\ttimeOrigin = _timeOrigin;\n\teventCounts = new Map();\n\t_entries = [];\n\t_resourceTimingBufferSize = 0;\n\tnavigation = undefined;\n\ttiming = undefined;\n\ttimerify(_fn, _options) {\n\t\tthrow createNotImplementedError(\"Performance.timerify\");\n\t}\n\tget nodeTiming() {\n\t\treturn nodeTiming;\n\t}\n\teventLoopUtilization() {\n\t\treturn {};\n\t}\n\tmarkResourceTiming() {\n\t\treturn new PerformanceResourceTiming(\"\");\n\t}\n\tonresourcetimingbufferfull = null;\n\tnow() {\n\t\tif (this.timeOrigin === _timeOrigin) {\n\t\t\treturn _performanceNow();\n\t\t}\n\t\treturn Date.now() - this.timeOrigin;\n\t}\n\tclearMarks(markName) {\n\t\tthis._entries = markName ? this._entries.filter((e) => e.name !== markName) : this._entries.filter((e) => e.entryType !== \"mark\");\n\t}\n\tclearMeasures(measureName) {\n\t\tthis._entries = measureName ? this._entries.filter((e) => e.name !== measureName) : this._entries.filter((e) => e.entryType !== \"measure\");\n\t}\n\tclearResourceTimings() {\n\t\tthis._entries = this._entries.filter((e) => e.entryType !== \"resource\" || e.entryType !== \"navigation\");\n\t}\n\tgetEntries() {\n\t\treturn this._entries;\n\t}\n\tgetEntriesByName(name, type) {\n\t\treturn this._entries.filter((e) => e.name === name && (!type || e.entryType === type));\n\t}\n\tgetEntriesByType(type) {\n\t\treturn this._entries.filter((e) => e.entryType === type);\n\t}\n\tmark(name, options) {\n\t\tconst entry = new PerformanceMark(name, options);\n\t\tthis._entries.push(entry);\n\t\treturn entry;\n\t}\n\tmeasure(measureName, startOrMeasureOptions, endMark) {\n\t\tlet start;\n\t\tlet end;\n\t\tif (typeof startOrMeasureOptions === \"string\") {\n\t\t\tstart = this.getEntriesByName(startOrMeasureOptions, \"mark\")[0]?.startTime;\n\t\t\tend = this.getEntriesByName(endMark, \"mark\")[0]?.startTime;\n\t\t} else {\n\t\t\tstart = Number.parseFloat(startOrMeasureOptions?.start) || this.now();\n\t\t\tend = Number.parseFloat(startOrMeasureOptions?.end) || this.now();\n\t\t}\n\t\tconst entry = new PerformanceMeasure(measureName, {\n\t\t\tstartTime: start,\n\t\t\tdetail: {\n\t\t\t\tstart,\n\t\t\t\tend\n\t\t\t}\n\t\t});\n\t\tthis._entries.push(entry);\n\t\treturn entry;\n\t}\n\tsetResourceTimingBufferSize(maxSize) {\n\t\tthis._resourceTimingBufferSize = maxSize;\n\t}\n\taddEventListener(type, listener, options) {\n\t\tthrow createNotImplementedError(\"Performance.addEventListener\");\n\t}\n\tremoveEventListener(type, listener, options) {\n\t\tthrow createNotImplementedError(\"Performance.removeEventListener\");\n\t}\n\tdispatchEvent(event) {\n\t\tthrow createNotImplementedError(\"Performance.dispatchEvent\");\n\t}\n\ttoJSON() {\n\t\treturn this;\n\t}\n}\nexport class PerformanceObserver {\n\t__unenv__ = true;\n\tstatic supportedEntryTypes = [];\n\t_callback = null;\n\tconstructor(callback) {\n\t\tthis._callback = callback;\n\t}\n\ttakeRecords() {\n\t\treturn [];\n\t}\n\tdisconnect() {\n\t\tthrow createNotImplementedError(\"PerformanceObserver.disconnect\");\n\t}\n\tobserve(options) {\n\t\tthrow createNotImplementedError(\"PerformanceObserver.observe\");\n\t}\n\tbind(fn) {\n\t\treturn fn;\n\t}\n\trunInAsyncScope(fn, thisArg, ...args) {\n\t\treturn fn.call(thisArg, ...args);\n\t}\n\tasyncId() {\n\t\treturn 0;\n\t}\n\ttriggerAsyncId() {\n\t\treturn 0;\n\t}\n\temitDestroy() {\n\t\treturn this;\n\t}\n}\nexport const performance = globalThis.performance && \"addEventListener\" in globalThis.performance ? globalThis.performance : new Performance();\n", "import { IntervalHistogram, RecordableHistogram } from \"./internal/perf_hooks/histogram.mjs\";\nimport { performance, Performance, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceObserverEntryList, PerformanceObserver, PerformanceResourceTiming } from \"./internal/perf_hooks/performance.mjs\";\nexport * from \"./internal/perf_hooks/performance.mjs\";\nimport { NODE_PERFORMANCE_GC_MAJOR, NODE_PERFORMANCE_GC_MINOR, NODE_PERFORMANCE_GC_INCREMENTAL, NODE_PERFORMANCE_GC_WEAKCB, NODE_PERFORMANCE_GC_FLAGS_NO, NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED, NODE_PERFORMANCE_GC_FLAGS_FORCED, NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING, NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE, NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY, NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE, NODE_PERFORMANCE_ENTRY_TYPE_GC, NODE_PERFORMANCE_ENTRY_TYPE_HTTP, NODE_PERFORMANCE_ENTRY_TYPE_HTTP2, NODE_PERFORMANCE_ENTRY_TYPE_NET, NODE_PERFORMANCE_ENTRY_TYPE_DNS, NODE_PERFORMANCE_MILESTONE_TIME_ORIGIN_TIMESTAMP, NODE_PERFORMANCE_MILESTONE_TIME_ORIGIN, NODE_PERFORMANCE_MILESTONE_ENVIRONMENT, NODE_PERFORMANCE_MILESTONE_NODE_START, NODE_PERFORMANCE_MILESTONE_V8_START, NODE_PERFORMANCE_MILESTONE_LOOP_START, NODE_PERFORMANCE_MILESTONE_LOOP_EXIT, NODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE } from \"./internal/perf_hooks/constants.mjs\";\nexport const constants = {\n\tNODE_PERFORMANCE_GC_MAJOR,\n\tNODE_PERFORMANCE_GC_MINOR,\n\tNODE_PERFORMANCE_GC_INCREMENTAL,\n\tNODE_PERFORMANCE_GC_WEAKCB,\n\tNODE_PERFORMANCE_GC_FLAGS_NO,\n\tNODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED,\n\tNODE_PERFORMANCE_GC_FLAGS_FORCED,\n\tNODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING,\n\tNODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE,\n\tNODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY,\n\tNODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE,\n\tNODE_PERFORMANCE_ENTRY_TYPE_GC,\n\tNODE_PERFORMANCE_ENTRY_TYPE_HTTP,\n\tNODE_PERFORMANCE_ENTRY_TYPE_HTTP2,\n\tNODE_PERFORMANCE_ENTRY_TYPE_NET,\n\tNODE_PERFORMANCE_ENTRY_TYPE_DNS,\n\tNODE_PERFORMANCE_MILESTONE_TIME_ORIGIN_TIMESTAMP,\n\tNODE_PERFORMANCE_MILESTONE_TIME_ORIGIN,\n\tNODE_PERFORMANCE_MILESTONE_ENVIRONMENT,\n\tNODE_PERFORMANCE_MILESTONE_NODE_START,\n\tNODE_PERFORMANCE_MILESTONE_V8_START,\n\tNODE_PERFORMANCE_MILESTONE_LOOP_START,\n\tNODE_PERFORMANCE_MILESTONE_LOOP_EXIT,\n\tNODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE\n};\nexport const monitorEventLoopDelay = function(_options) {\n\treturn new IntervalHistogram();\n};\nexport const createHistogram = function(_options) {\n\treturn new RecordableHistogram();\n};\nexport default {\n\tPerformance,\n\tPerformanceMark,\n\tPerformanceEntry,\n\tPerformanceMeasure,\n\tPerformanceObserverEntryList,\n\tPerformanceObserver,\n\tPerformanceResourceTiming,\n\tperformance,\n\tconstants,\n\tcreateHistogram,\n\tmonitorEventLoopDelay\n};\n", "import {\n  performance,\n  Performance,\n  PerformanceEntry,\n  PerformanceMark,\n  PerformanceMeasure,\n  PerformanceObserver,\n  PerformanceObserverEntryList,\n  PerformanceResourceTiming\n} from \"node:perf_hooks\";\nglobalThis.performance = performance;\nglobalThis.Performance = Performance;\nglobalThis.PerformanceEntry = PerformanceEntry;\nglobalThis.PerformanceMark = PerformanceMark;\nglobalThis.PerformanceMeasure = PerformanceMeasure;\nglobalThis.PerformanceObserver = PerformanceObserver;\nglobalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;\nglobalThis.PerformanceResourceTiming = PerformanceResourceTiming;\n", "export default Object.assign(() => {}, { __unenv__: true });\n", "import { Writable } from \"node:stream\";\nimport noop from \"../mock/noop.mjs\";\nimport { notImplemented, notImplementedClass } from \"../_internal/utils.mjs\";\nconst _console = globalThis.console;\nexport const _ignoreErrors = true;\nexport const _stderr = new Writable();\nexport const _stdout = new Writable();\nexport const log = _console?.log ?? noop;\nexport const info = _console?.info ?? log;\nexport const trace = _console?.trace ?? info;\nexport const debug = _console?.debug ?? log;\nexport const table = _console?.table ?? log;\nexport const error = _console?.error ?? log;\nexport const warn = _console?.warn ?? error;\nexport const createTask = _console?.createTask ?? /*@__PURE__*/ notImplemented(\"console.createTask\");\nexport const assert = /*@__PURE__*/ notImplemented(\"console.assert\");\nexport const clear = _console?.clear ?? noop;\nexport const count = _console?.count ?? noop;\nexport const countReset = _console?.countReset ?? noop;\nexport const dir = _console?.dir ?? noop;\nexport const dirxml = _console?.dirxml ?? noop;\nexport const group = _console?.group ?? noop;\nexport const groupEnd = _console?.groupEnd ?? noop;\nexport const groupCollapsed = _console?.groupCollapsed ?? noop;\nexport const profile = _console?.profile ?? noop;\nexport const profileEnd = _console?.profileEnd ?? noop;\nexport const time = _console?.time ?? noop;\nexport const timeEnd = _console?.timeEnd ?? noop;\nexport const timeLog = _console?.timeLog ?? noop;\nexport const timeStamp = _console?.timeStamp ?? noop;\nexport const Console = _console?.Console ?? /*@__PURE__*/ notImplementedClass(\"console.Console\");\nexport const _times = /*@__PURE__*/ new Map();\nexport function context() {\n\treturn _console;\n}\nexport const _stdoutErrorHandler = noop;\nexport const _stderrErrorHandler = noop;\nexport default {\n\t_times,\n\t_ignoreErrors,\n\t_stdoutErrorHandler,\n\t_stderrErrorHandler,\n\t_stdout,\n\t_stderr,\n\tassert,\n\tclear,\n\tConsole,\n\tcount,\n\tcountReset,\n\tdebug,\n\tdir,\n\tdirxml,\n\terror,\n\tcontext,\n\tcreateTask,\n\tgroup,\n\tgroupEnd,\n\tgroupCollapsed,\n\tinfo,\n\tlog,\n\tprofile,\n\tprofileEnd,\n\ttable,\n\ttime,\n\ttimeEnd,\n\ttimeLog,\n\ttimeStamp,\n\ttrace,\n\twarn\n};\n", "import {\n  _ignoreErrors,\n  _stderr,\n  _stderrErrorHandler,\n  _stdout,\n  _stdoutErrorHandler,\n  _times,\n  Console\n} from \"unenv/node/console\";\nexport {\n  Console,\n  _ignoreErrors,\n  _stderr,\n  _stderrErrorHandler,\n  _stdout,\n  _stdoutErrorHandler,\n  _times\n} from \"unenv/node/console\";\nconst workerdConsole = globalThis[\"console\"];\nexport const {\n  assert,\n  clear,\n  // @ts-expect-error undocumented public API\n  context,\n  count,\n  countReset,\n  // @ts-expect-error undocumented public API\n  createTask,\n  debug,\n  dir,\n  dirxml,\n  error,\n  group,\n  groupCollapsed,\n  groupEnd,\n  info,\n  log,\n  profile,\n  profileEnd,\n  table,\n  time,\n  timeEnd,\n  timeLog,\n  timeStamp,\n  trace,\n  warn\n} = workerdConsole;\nObject.assign(workerdConsole, {\n  Console,\n  _ignoreErrors,\n  _stderr,\n  _stderrErrorHandler,\n  _stdout,\n  _stdoutErrorHandler,\n  _times\n});\nexport default workerdConsole;\n", "import { default as defaultExport } from \"@cloudflare/unenv-preset/node/console\";\nglobalThis.console = defaultExport;", "export const hrtime = /*@__PURE__*/ Object.assign(function hrtime(startTime) {\n\tconst now = Date.now();\n\tconst seconds = Math.trunc(now / 1e3);\n\tconst nanos = now % 1e3 * 1e6;\n\tif (startTime) {\n\t\tlet diffSeconds = seconds - startTime[0];\n\t\tlet diffNanos = nanos - startTime[0];\n\t\tif (diffNanos < 0) {\n\t\t\tdiffSeconds = diffSeconds - 1;\n\t\t\tdiffNanos = 1e9 + diffNanos;\n\t\t}\n\t\treturn [diffSeconds, diffNanos];\n\t}\n\treturn [seconds, nanos];\n}, { bigint: function bigint() {\n\treturn BigInt(Date.now() * 1e6);\n} });\n", "import { Socket } from \"node:net\";\nexport class ReadStream extends Socket {\n\tfd;\n\tconstructor(fd) {\n\t\tsuper();\n\t\tthis.fd = fd;\n\t}\n\tisRaw = false;\n\tsetRawMode(mode) {\n\t\tthis.isRaw = mode;\n\t\treturn this;\n\t}\n\tisTTY = false;\n}\n", "import { Socket } from \"node:net\";\nexport class WriteStream extends Socket {\n\tfd;\n\tconstructor(fd) {\n\t\tsuper();\n\t\tthis.fd = fd;\n\t}\n\tclearLine(dir, callback) {\n\t\tcallback && callback();\n\t\treturn false;\n\t}\n\tclearScreenDown(callback) {\n\t\tcallback && callback();\n\t\treturn false;\n\t}\n\tcursorTo(x, y, callback) {\n\t\tcallback && typeof callback === \"function\" && callback();\n\t\treturn false;\n\t}\n\tmoveCursor(dx, dy, callback) {\n\t\tcallback && callback();\n\t\treturn false;\n\t}\n\tgetColorDepth(env) {\n\t\treturn 1;\n\t}\n\thasColors(count, env) {\n\t\treturn false;\n\t}\n\tgetWindowSize() {\n\t\treturn [this.columns, this.rows];\n\t}\n\tcolumns = 80;\n\trows = 24;\n\tisTTY = false;\n}\n", "import { ReadStream } from \"./internal/tty/read-stream.mjs\";\nimport { WriteStream } from \"./internal/tty/write-stream.mjs\";\nexport { ReadStream } from \"./internal/tty/read-stream.mjs\";\nexport { WriteStream } from \"./internal/tty/write-stream.mjs\";\nexport const isatty = function() {\n\treturn false;\n};\nexport default {\n\tReadStream,\n\tWriteStream,\n\tisatty\n};\n", "import { EventEmitter } from \"node:events\";\nimport { ReadStream, WriteStream } from \"node:tty\";\nimport { notImplemented, createNotImplementedError } from \"../../../_internal/utils.mjs\";\nexport class Process extends EventEmitter {\n\tenv;\n\thrtime;\n\tnextTick;\n\tconstructor(impl) {\n\t\tsuper();\n\t\tthis.env = impl.env;\n\t\tthis.hrtime = impl.hrtime;\n\t\tthis.nextTick = impl.nextTick;\n\t\tfor (const prop of [...Object.getOwnPropertyNames(Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {\n\t\t\tconst value = this[prop];\n\t\t\tif (typeof value === \"function\") {\n\t\t\t\tthis[prop] = value.bind(this);\n\t\t\t}\n\t\t}\n\t}\n\temitWarning(warning, type, code) {\n\t\tconsole.warn(`${code ? `[${code}] ` : \"\"}${type ? `${type}: ` : \"\"}${warning}`);\n\t}\n\temit(...args) {\n\t\treturn super.emit(...args);\n\t}\n\tlisteners(eventName) {\n\t\treturn super.listeners(eventName);\n\t}\n\t#stdin;\n\t#stdout;\n\t#stderr;\n\tget stdin() {\n\t\treturn this.#stdin ??= new ReadStream(0);\n\t}\n\tget stdout() {\n\t\treturn this.#stdout ??= new WriteStream(1);\n\t}\n\tget stderr() {\n\t\treturn this.#stderr ??= new WriteStream(2);\n\t}\n\t#cwd = \"/\";\n\tchdir(cwd) {\n\t\tthis.#cwd = cwd;\n\t}\n\tcwd() {\n\t\treturn this.#cwd;\n\t}\n\tarch = \"\";\n\tplatform = \"\";\n\targv = [];\n\targv0 = \"\";\n\texecArgv = [];\n\texecPath = \"\";\n\ttitle = \"\";\n\tpid = 200;\n\tppid = 100;\n\tget version() {\n\t\treturn \"\";\n\t}\n\tget versions() {\n\t\treturn {};\n\t}\n\tget allowedNodeEnvironmentFlags() {\n\t\treturn new Set();\n\t}\n\tget sourceMapsEnabled() {\n\t\treturn false;\n\t}\n\tget debugPort() {\n\t\treturn 0;\n\t}\n\tget throwDeprecation() {\n\t\treturn false;\n\t}\n\tget traceDeprecation() {\n\t\treturn false;\n\t}\n\tget features() {\n\t\treturn {};\n\t}\n\tget release() {\n\t\treturn {};\n\t}\n\tget connected() {\n\t\treturn false;\n\t}\n\tget config() {\n\t\treturn {};\n\t}\n\tget moduleLoadList() {\n\t\treturn [];\n\t}\n\tconstrainedMemory() {\n\t\treturn 0;\n\t}\n\tavailableMemory() {\n\t\treturn 0;\n\t}\n\tuptime() {\n\t\treturn 0;\n\t}\n\tresourceUsage() {\n\t\treturn {};\n\t}\n\tref() {}\n\tunref() {}\n\tumask() {\n\t\tthrow createNotImplementedError(\"process.umask\");\n\t}\n\tgetBuiltinModule() {\n\t\treturn undefined;\n\t}\n\tgetActiveResourcesInfo() {\n\t\tthrow createNotImplementedError(\"process.getActiveResourcesInfo\");\n\t}\n\texit() {\n\t\tthrow createNotImplementedError(\"process.exit\");\n\t}\n\treallyExit() {\n\t\tthrow createNotImplementedError(\"process.reallyExit\");\n\t}\n\tkill() {\n\t\tthrow createNotImplementedError(\"process.kill\");\n\t}\n\tabort() {\n\t\tthrow createNotImplementedError(\"process.abort\");\n\t}\n\tdlopen() {\n\t\tthrow createNotImplementedError(\"process.dlopen\");\n\t}\n\tsetSourceMapsEnabled() {\n\t\tthrow createNotImplementedError(\"process.setSourceMapsEnabled\");\n\t}\n\tloadEnvFile() {\n\t\tthrow createNotImplementedError(\"process.loadEnvFile\");\n\t}\n\tdisconnect() {\n\t\tthrow createNotImplementedError(\"process.disconnect\");\n\t}\n\tcpuUsage() {\n\t\tthrow createNotImplementedError(\"process.cpuUsage\");\n\t}\n\tsetUncaughtExceptionCaptureCallback() {\n\t\tthrow createNotImplementedError(\"process.setUncaughtExceptionCaptureCallback\");\n\t}\n\thasUncaughtExceptionCaptureCallback() {\n\t\tthrow createNotImplementedError(\"process.hasUncaughtExceptionCaptureCallback\");\n\t}\n\tinitgroups() {\n\t\tthrow createNotImplementedError(\"process.initgroups\");\n\t}\n\topenStdin() {\n\t\tthrow createNotImplementedError(\"process.openStdin\");\n\t}\n\tassert() {\n\t\tthrow createNotImplementedError(\"process.assert\");\n\t}\n\tbinding() {\n\t\tthrow createNotImplementedError(\"process.binding\");\n\t}\n\tpermission = { has: /*@__PURE__*/ notImplemented(\"process.permission.has\") };\n\treport = {\n\t\tdirectory: \"\",\n\t\tfilename: \"\",\n\t\tsignal: \"SIGUSR2\",\n\t\tcompact: false,\n\t\treportOnFatalError: false,\n\t\treportOnSignal: false,\n\t\treportOnUncaughtException: false,\n\t\tgetReport: /*@__PURE__*/ notImplemented(\"process.report.getReport\"),\n\t\twriteReport: /*@__PURE__*/ notImplemented(\"process.report.writeReport\")\n\t};\n\tfinalization = {\n\t\tregister: /*@__PURE__*/ notImplemented(\"process.finalization.register\"),\n\t\tunregister: /*@__PURE__*/ notImplemented(\"process.finalization.unregister\"),\n\t\tregisterBeforeExit: /*@__PURE__*/ notImplemented(\"process.finalization.registerBeforeExit\")\n\t};\n\tmemoryUsage = Object.assign(() => ({\n\t\tarrayBuffers: 0,\n\t\trss: 0,\n\t\texternal: 0,\n\t\theapTotal: 0,\n\t\theapUsed: 0\n\t}), { rss: () => 0 });\n\tmainModule = undefined;\n\tdomain = undefined;\n\tsend = undefined;\n\texitCode = undefined;\n\tchannel = undefined;\n\tgetegid = undefined;\n\tgeteuid = undefined;\n\tgetgid = undefined;\n\tgetgroups = undefined;\n\tgetuid = undefined;\n\tsetegid = undefined;\n\tseteuid = undefined;\n\tsetgid = undefined;\n\tsetgroups = undefined;\n\tsetuid = undefined;\n\t_events = undefined;\n\t_eventsCount = undefined;\n\t_exiting = undefined;\n\t_maxListeners = undefined;\n\t_debugEnd = undefined;\n\t_debugProcess = undefined;\n\t_fatalException = undefined;\n\t_getActiveHandles = undefined;\n\t_getActiveRequests = undefined;\n\t_kill = undefined;\n\t_preload_modules = undefined;\n\t_rawDebug = undefined;\n\t_startProfilerIdleNotifier = undefined;\n\t_stopProfilerIdleNotifier = undefined;\n\t_tickCallback = undefined;\n\t_disconnect = undefined;\n\t_handleQueue = undefined;\n\t_pendingMessage = undefined;\n\t_channel = undefined;\n\t_send = undefined;\n\t_linkedBinding = undefined;\n}\n", "import { hrtime as UnenvHrTime } from \"unenv/node/internal/process/hrtime\";\nimport { Process as UnenvProcess } from \"unenv/node/internal/process/process\";\nconst globalProcess = globalThis[\"process\"];\nexport const getBuiltinModule = globalProcess.getBuiltinModule;\nexport const { exit, platform, nextTick } = getBuiltinModule(\n  \"node:process\"\n);\nconst unenvProcess = new UnenvProcess({\n  env: globalProcess.env,\n  hrtime: UnenvHrTime,\n  nextTick\n});\nexport const {\n  abort,\n  addListener,\n  allowedNodeEnvironmentFlags,\n  hasUncaughtExceptionCaptureCallback,\n  setUncaughtExceptionCaptureCallback,\n  loadEnvFile,\n  sourceMapsEnabled,\n  arch,\n  argv,\n  argv0,\n  chdir,\n  config,\n  connected,\n  constrainedMemory,\n  availableMemory,\n  cpuUsage,\n  cwd,\n  debugPort,\n  dlopen,\n  disconnect,\n  emit,\n  emitWarning,\n  env,\n  eventNames,\n  execArgv,\n  execPath,\n  finalization,\n  features,\n  getActiveResourcesInfo,\n  getMaxListeners,\n  hrtime,\n  kill,\n  listeners,\n  listenerCount,\n  memoryUsage,\n  on,\n  off,\n  once,\n  pid,\n  ppid,\n  prependListener,\n  prependOnceListener,\n  rawListeners,\n  release,\n  removeAllListeners,\n  removeListener,\n  report,\n  resourceUsage,\n  setMaxListeners,\n  setSourceMapsEnabled,\n  stderr,\n  stdin,\n  stdout,\n  title,\n  throwDeprecation,\n  traceDeprecation,\n  umask,\n  uptime,\n  version,\n  versions,\n  domain,\n  initgroups,\n  moduleLoadList,\n  reallyExit,\n  openStdin,\n  assert,\n  binding,\n  send,\n  exitCode,\n  channel,\n  getegid,\n  geteuid,\n  getgid,\n  getgroups,\n  getuid,\n  setegid,\n  seteuid,\n  setgid,\n  setgroups,\n  setuid,\n  permission,\n  mainModule,\n  _events,\n  _eventsCount,\n  _exiting,\n  _maxListeners,\n  _debugEnd,\n  _debugProcess,\n  _fatalException,\n  _getActiveHandles,\n  _getActiveRequests,\n  _kill,\n  _preload_modules,\n  _rawDebug,\n  _startProfilerIdleNotifier,\n  _stopProfilerIdleNotifier,\n  _tickCallback,\n  _disconnect,\n  _handleQueue,\n  _pendingMessage,\n  _channel,\n  _send,\n  _linkedBinding\n} = unenvProcess;\nconst _process = {\n  abort,\n  addListener,\n  allowedNodeEnvironmentFlags,\n  hasUncaughtExceptionCaptureCallback,\n  setUncaughtExceptionCaptureCallback,\n  loadEnvFile,\n  sourceMapsEnabled,\n  arch,\n  argv,\n  argv0,\n  chdir,\n  config,\n  connected,\n  constrainedMemory,\n  availableMemory,\n  cpuUsage,\n  cwd,\n  debugPort,\n  dlopen,\n  disconnect,\n  emit,\n  emitWarning,\n  env,\n  eventNames,\n  execArgv,\n  execPath,\n  exit,\n  finalization,\n  features,\n  getBuiltinModule,\n  getActiveResourcesInfo,\n  getMaxListeners,\n  hrtime,\n  kill,\n  listeners,\n  listenerCount,\n  memoryUsage,\n  nextTick,\n  on,\n  off,\n  once,\n  pid,\n  platform,\n  ppid,\n  prependListener,\n  prependOnceListener,\n  rawListeners,\n  release,\n  removeAllListeners,\n  removeListener,\n  report,\n  resourceUsage,\n  setMaxListeners,\n  setSourceMapsEnabled,\n  stderr,\n  stdin,\n  stdout,\n  title,\n  throwDeprecation,\n  traceDeprecation,\n  umask,\n  uptime,\n  version,\n  versions,\n  // @ts-expect-error old API\n  domain,\n  initgroups,\n  moduleLoadList,\n  reallyExit,\n  openStdin,\n  assert,\n  binding,\n  send,\n  exitCode,\n  channel,\n  getegid,\n  geteuid,\n  getgid,\n  getgroups,\n  getuid,\n  setegid,\n  seteuid,\n  setgid,\n  setgroups,\n  setuid,\n  permission,\n  mainModule,\n  _events,\n  _eventsCount,\n  _exiting,\n  _maxListeners,\n  _debugEnd,\n  _debugProcess,\n  _fatalException,\n  _getActiveHandles,\n  _getActiveRequests,\n  _kill,\n  _preload_modules,\n  _rawDebug,\n  _startProfilerIdleNotifier,\n  _stopProfilerIdleNotifier,\n  _tickCallback,\n  _disconnect,\n  _handleQueue,\n  _pendingMessage,\n  _channel,\n  _send,\n  _linkedBinding\n};\nexport default _process;\n", "import { default as defaultExport } from \"@cloudflare/unenv-preset/node/process\";\nglobalThis.process = defaultExport;", "", "// `esbuild` doesn't support returning `watch*` options from `onStart()`\n// plugin callbacks. Instead, we define an empty virtual module that is\n// imported by this injected file. Importing the module registers watchers.\nimport \"wrangler:modules-watch\";\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Updates to this file should also be replicated to @opentelemetry/core too.\n\n/**\n * - globalThis (New standard)\n * - self (Will return the current window instance for supported browsers)\n * - window (fallback for older browser implementations)\n * - global (NodeJS implementation)\n * - <object> (When all else fails)\n */\n\n/** only globals that common to node and browsers are allowed */\n// eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef\nexport const _globalThis: typeof globalThis =\n  typeof globalThis === 'object'\n    ? globalThis\n    : typeof self === 'object'\n    ? self\n    : typeof window === 'object'\n    ? window\n    : typeof global === 'object'\n    ? global\n    : ({} as typeof globalThis);\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport * from './globalThis';\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// this is autogenerated file, see scripts/version-update.js\nexport const VERSION = '1.9.0';\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { VERSION } from '../version';\n\nconst re = /^(\\d+)\\.(\\d+)\\.(\\d+)(-(.+))?$/;\n\n/**\n * Create a function to test an API version to see if it is compatible with the provided ownVersion.\n *\n * The returned function has the following semantics:\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param ownVersion version which should be checked against\n */\nexport function _makeCompatibilityCheck(\n  ownVersion: string\n): (globalVersion: string) => boolean {\n  const acceptedVersions = new Set<string>([ownVersion]);\n  const rejectedVersions = new Set<string>();\n\n  const myVersionMatch = ownVersion.match(re);\n  if (!myVersionMatch) {\n    // we cannot guarantee compatibility so we always return noop\n    return () => false;\n  }\n\n  const ownVersionParsed = {\n    major: +myVersionMatch[1],\n    minor: +myVersionMatch[2],\n    patch: +myVersionMatch[3],\n    prerelease: myVersionMatch[4],\n  };\n\n  // if ownVersion has a prerelease tag, versions must match exactly\n  if (ownVersionParsed.prerelease != null) {\n    return function isExactmatch(globalVersion: string): boolean {\n      return globalVersion === ownVersion;\n    };\n  }\n\n  function _reject(v: string) {\n    rejectedVersions.add(v);\n    return false;\n  }\n\n  function _accept(v: string) {\n    acceptedVersions.add(v);\n    return true;\n  }\n\n  return function isCompatible(globalVersion: string): boolean {\n    if (acceptedVersions.has(globalVersion)) {\n      return true;\n    }\n\n    if (rejectedVersions.has(globalVersion)) {\n      return false;\n    }\n\n    const globalVersionMatch = globalVersion.match(re);\n    if (!globalVersionMatch) {\n      // cannot parse other version\n      // we cannot guarantee compatibility so we always noop\n      return _reject(globalVersion);\n    }\n\n    const globalVersionParsed = {\n      major: +globalVersionMatch[1],\n      minor: +globalVersionMatch[2],\n      patch: +globalVersionMatch[3],\n      prerelease: globalVersionMatch[4],\n    };\n\n    // if globalVersion has a prerelease tag, versions must match exactly\n    if (globalVersionParsed.prerelease != null) {\n      return _reject(globalVersion);\n    }\n\n    // major versions must match\n    if (ownVersionParsed.major !== globalVersionParsed.major) {\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.major === 0) {\n      if (\n        ownVersionParsed.minor === globalVersionParsed.minor &&\n        ownVersionParsed.patch <= globalVersionParsed.patch\n      ) {\n        return _accept(globalVersion);\n      }\n\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.minor <= globalVersionParsed.minor) {\n      return _accept(globalVersion);\n    }\n\n    return _reject(globalVersion);\n  };\n}\n\n/**\n * Test an API version to see if it is compatible with this API.\n *\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param version version of the API requesting an instance of the global API\n */\nexport const isCompatible = _makeCompatibilityCheck(VERSION);\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MeterProvider } from '../metrics/MeterProvider';\nimport { ContextManager } from '../context/types';\nimport { DiagLogger } from '../diag/types';\nimport { _globalThis } from '../platform';\nimport { TextMapPropagator } from '../propagation/TextMapPropagator';\nimport type { TracerProvider } from '../trace/tracer_provider';\nimport { VERSION } from '../version';\nimport { isCompatible } from './semver';\n\nconst major = VERSION.split('.')[0];\nconst GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(\n  `opentelemetry.js.api.${major}`\n);\n\nconst _global = _globalThis as OTelGlobal;\n\nexport function registerGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type,\n  instance: OTelGlobalAPI[Type],\n  diag: DiagLogger,\n  allowOverride = false\n): boolean {\n  const api = (_global[GLOBAL_OPENTELEMETRY_API_KEY] = _global[\n    GLOBAL_OPENTELEMETRY_API_KEY\n  ] ?? {\n    version: VERSION,\n  });\n\n  if (!allowOverride && api[type]) {\n    // already registered an API of this type\n    const err = new Error(\n      `@opentelemetry/api: Attempted duplicate registration of API: ${type}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  if (api.version !== VERSION) {\n    // All registered APIs must be of the same version exactly\n    const err = new Error(\n      `@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${VERSION}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  api[type] = instance;\n  diag.debug(\n    `@opentelemetry/api: Registered a global for ${type} v${VERSION}.`\n  );\n\n  return true;\n}\n\nexport function getGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type\n): OTelGlobalAPI[Type] | undefined {\n  const globalVersion = _global[GLOBAL_OPENTELEMETRY_API_KEY]?.version;\n  if (!globalVersion || !isCompatible(globalVersion)) {\n    return;\n  }\n  return _global[GLOBAL_OPENTELEMETRY_API_KEY]?.[type];\n}\n\nexport function unregisterGlobal(type: keyof OTelGlobalAPI, diag: DiagLogger) {\n  diag.debug(\n    `@opentelemetry/api: Unregistering a global for ${type} v${VERSION}.`\n  );\n  const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];\n\n  if (api) {\n    delete api[type];\n  }\n}\n\ntype OTelGlobal = {\n  [GLOBAL_OPENTELEMETRY_API_KEY]?: OTelGlobalAPI;\n};\n\ntype OTelGlobalAPI = {\n  version: string;\n\n  diag?: DiagLogger;\n  trace?: TracerProvider;\n  context?: ContextManager;\n  metrics?: MeterProvider;\n  propagation?: TextMapPropagator;\n};\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getGlobal } from '../internal/global-utils';\nimport { ComponentLoggerOptions, DiagLogger, DiagLogFunction } from './types';\n\n/**\n * Component Logger which is meant to be used as part of any component which\n * will add automatically additional namespace in front of the log message.\n * It will then forward all message to global diag logger\n * @example\n * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });\n * cLogger.debug('test');\n * // @opentelemetry/instrumentation-http test\n */\nexport class DiagComponentLogger implements DiagLogger {\n  private _namespace: string;\n\n  constructor(props: ComponentLoggerOptions) {\n    this._namespace = props.namespace || 'DiagComponentLogger';\n  }\n\n  public debug(...args: any[]): void {\n    return logProxy('debug', this._namespace, args);\n  }\n\n  public error(...args: any[]): void {\n    return logProxy('error', this._namespace, args);\n  }\n\n  public info(...args: any[]): void {\n    return logProxy('info', this._namespace, args);\n  }\n\n  public warn(...args: any[]): void {\n    return logProxy('warn', this._namespace, args);\n  }\n\n  public verbose(...args: any[]): void {\n    return logProxy('verbose', this._namespace, args);\n  }\n}\n\nfunction logProxy(\n  funcName: keyof DiagLogger,\n  namespace: string,\n  args: any\n): void {\n  const logger = getGlobal('diag');\n  // shortcut if logger not set\n  if (!logger) {\n    return;\n  }\n\n  args.unshift(namespace);\n  return logger[funcName](...(args as Parameters<DiagLogFunction>));\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport type DiagLogFunction = (message: string, ...args: unknown[]) => void;\n\n/**\n * Defines an internal diagnostic logger interface which is used to log internal diagnostic\n * messages, you can set the default diagnostic logger via the {@link DiagAPI} setLogger function.\n * API provided implementations include :-\n * - a No-Op {@link createNoopDiagLogger}\n * - a {@link DiagLogLevel} filtering wrapper {@link createLogLevelDiagLogger}\n * - a general Console {@link DiagConsoleLogger} version.\n */\nexport interface DiagLogger {\n  /** Log an error scenario that was not expected and caused the requested operation to fail. */\n  error: DiagLogFunction;\n\n  /**\n   * Log a warning scenario to inform the developer of an issues that should be investigated.\n   * The requested operation may or may not have succeeded or completed.\n   */\n  warn: DiagLogFunction;\n\n  /**\n   * Log a general informational message, this should not affect functionality.\n   * This is also the default logging level so this should NOT be used for logging\n   * debugging level information.\n   */\n  info: DiagLogFunction;\n\n  /**\n   * Log a general debug message that can be useful for identifying a failure.\n   * Information logged at this level may include diagnostic details that would\n   * help identify a failure scenario.\n   * For example: Logging the order of execution of async operations.\n   */\n  debug: DiagLogFunction;\n\n  /**\n   * Log a detailed (verbose) trace level logging that can be used to identify failures\n   * where debug level logging would be insufficient, this level of tracing can include\n   * input and output parameters and as such may include PII information passing through\n   * the API. As such it is recommended that this level of tracing should not be enabled\n   * in a production environment.\n   */\n  verbose: DiagLogFunction;\n}\n\n/**\n * Defines the available internal logging levels for the diagnostic logger, the numeric values\n * of the levels are defined to match the original values from the initial LogLevel to avoid\n * compatibility/migration issues for any implementation that assume the numeric ordering.\n */\nexport enum DiagLogLevel {\n  /** Diagnostic Logging level setting to disable all logging (except and forced logs) */\n  NONE = 0,\n\n  /** Identifies an error scenario */\n  ERROR = 30,\n\n  /** Identifies a warning scenario */\n  WARN = 50,\n\n  /** General informational log message */\n  INFO = 60,\n\n  /** General debug log message */\n  DEBUG = 70,\n\n  /**\n   * Detailed trace level logging should only be used for development, should only be set\n   * in a development environment.\n   */\n  VERBOSE = 80,\n\n  /** Used to set the logging level to include all logging */\n  ALL = 9999,\n}\n\n/**\n * Defines options for ComponentLogger\n */\nexport interface ComponentLoggerOptions {\n  namespace: string;\n}\n\nexport interface DiagLoggerOptions {\n  /**\n   * The {@link DiagLogLevel} used to filter logs sent to the logger.\n   *\n   * @defaultValue DiagLogLevel.INFO\n   */\n  logLevel?: DiagLogLevel;\n\n  /**\n   * Setting this value to `true` will suppress the warning message normally emitted when registering a logger when another logger is already registered.\n   */\n  suppressOverrideMessage?: boolean;\n}\n\nexport interface DiagLoggerApi {\n  /**\n   * Set the global DiagLogger and DiagLogLevel.\n   * If a global diag logger is already set, this will override it.\n   *\n   * @param logger - The {@link DiagLogger} instance to set as the default logger.\n   * @param options - A {@link DiagLoggerOptions} object. If not provided, default values will be set.\n   * @returns `true` if the logger was successfully registered, else `false`\n   */\n  setLogger(logger: DiagLogger, options?: DiagLoggerOptions): boolean;\n\n  /**\n   *\n   * @param logger - The {@link DiagLogger} instance to set as the default logger.\n   * @param logLevel - The {@link DiagLogLevel} used to filter logs sent to the logger. If not provided it will default to {@link DiagLogLevel.INFO}.\n   * @returns `true` if the logger was successfully registered, else `false`\n   */\n  setLogger(logger: DiagLogger, logLevel?: DiagLogLevel): boolean;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagLogFunction, DiagLogger, DiagLogLevel } from '../types';\n\nexport function createLogLevelDiagLogger(\n  maxLevel: DiagLogLevel,\n  logger: DiagLogger\n): DiagLogger {\n  if (maxLevel < DiagLogLevel.NONE) {\n    maxLevel = DiagLogLevel.NONE;\n  } else if (maxLevel > DiagLogLevel.ALL) {\n    maxLevel = DiagLogLevel.ALL;\n  }\n\n  // In case the logger is null or undefined\n  logger = logger || {};\n\n  function _filterFunc(\n    funcName: keyof DiagLogger,\n    theLevel: DiagLogLevel\n  ): DiagLogFunction {\n    const theFunc = logger[funcName];\n\n    if (typeof theFunc === 'function' && maxLevel >= theLevel) {\n      return theFunc.bind(logger);\n    }\n    return function () {};\n  }\n\n  return {\n    error: _filterFunc('error', DiagLogLevel.ERROR),\n    warn: _filterFunc('warn', DiagLogLevel.WARN),\n    info: _filterFunc('info', DiagLogLevel.INFO),\n    debug: _filterFunc('debug', DiagLogLevel.DEBUG),\n    verbose: _filterFunc('verbose', DiagLogLevel.VERBOSE),\n  };\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagComponentLogger } from '../diag/ComponentLogger';\nimport { createLogLevelDiagLogger } from '../diag/internal/logLevelLogger';\nimport {\n  ComponentLoggerOptions,\n  DiagLogFunction,\n  DiagLogger,\n  DiagLoggerApi,\n  DiagLogLevel,\n} from '../diag/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\n\nconst API_NAME = 'diag';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry internal\n * diagnostic API\n */\nexport class DiagAPI implements DiagLogger, DiagLoggerApi {\n  private static _instance?: DiagAPI;\n\n  /** Get the singleton instance of the DiagAPI API */\n  public static instance(): DiagAPI {\n    if (!this._instance) {\n      this._instance = new DiagAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Private internal constructor\n   * @private\n   */\n  private constructor() {\n    function _logProxy(funcName: keyof DiagLogger): DiagLogFunction {\n      return function (...args) {\n        const logger = getGlobal('diag');\n        // shortcut if logger not set\n        if (!logger) return;\n        return logger[funcName](...args);\n      };\n    }\n\n    // Using self local variable for minification purposes as 'this' cannot be minified\n    const self = this;\n\n    // DiagAPI specific functions\n\n    const setLogger: DiagLoggerApi['setLogger'] = (\n      logger,\n      optionsOrLogLevel = { logLevel: DiagLogLevel.INFO }\n    ) => {\n      if (logger === self) {\n        // There isn't much we can do here.\n        // Logging to the console might break the user application.\n        // Try to log to self. If a logger was previously registered it will receive the log.\n        const err = new Error(\n          'Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation'\n        );\n        self.error(err.stack ?? err.message);\n        return false;\n      }\n\n      if (typeof optionsOrLogLevel === 'number') {\n        optionsOrLogLevel = {\n          logLevel: optionsOrLogLevel,\n        };\n      }\n\n      const oldLogger = getGlobal('diag');\n      const newLogger = createLogLevelDiagLogger(\n        optionsOrLogLevel.logLevel ?? DiagLogLevel.INFO,\n        logger\n      );\n      // There already is an logger registered. We'll let it know before overwriting it.\n      if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {\n        const stack = new Error().stack ?? '<failed to generate stacktrace>';\n        oldLogger.warn(`Current logger will be overwritten from ${stack}`);\n        newLogger.warn(\n          `Current logger will overwrite one already registered from ${stack}`\n        );\n      }\n\n      return registerGlobal('diag', newLogger, self, true);\n    };\n\n    self.setLogger = setLogger;\n\n    self.disable = () => {\n      unregisterGlobal(API_NAME, self);\n    };\n\n    self.createComponentLogger = (options: ComponentLoggerOptions) => {\n      return new DiagComponentLogger(options);\n    };\n\n    self.verbose = _logProxy('verbose');\n    self.debug = _logProxy('debug');\n    self.info = _logProxy('info');\n    self.warn = _logProxy('warn');\n    self.error = _logProxy('error');\n  }\n\n  public setLogger!: DiagLoggerApi['setLogger'];\n  /**\n   *\n   */\n  public createComponentLogger!: (\n    options: ComponentLoggerOptions\n  ) => DiagLogger;\n\n  // DiagLogger implementation\n  public verbose!: DiagLogFunction;\n  public debug!: DiagLogFunction;\n  public info!: DiagLogFunction;\n  public warn!: DiagLogFunction;\n  public error!: DiagLogFunction;\n\n  /**\n   * Unregister the global logger and return to Noop\n   */\n  public disable!: () => void;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Baggage, BaggageEntry } from '../types';\n\nexport class BaggageImpl implements Baggage {\n  private _entries: Map<string, BaggageEntry>;\n\n  constructor(entries?: Map<string, BaggageEntry>) {\n    this._entries = entries ? new Map(entries) : new Map();\n  }\n\n  getEntry(key: string): BaggageEntry | undefined {\n    const entry = this._entries.get(key);\n    if (!entry) {\n      return undefined;\n    }\n\n    return Object.assign({}, entry);\n  }\n\n  getAllEntries(): [string, BaggageEntry][] {\n    return Array.from(this._entries.entries()).map(([k, v]) => [k, v]);\n  }\n\n  setEntry(key: string, entry: BaggageEntry): BaggageImpl {\n    const newBaggage = new BaggageImpl(this._entries);\n    newBaggage._entries.set(key, entry);\n    return newBaggage;\n  }\n\n  removeEntry(key: string): BaggageImpl {\n    const newBaggage = new BaggageImpl(this._entries);\n    newBaggage._entries.delete(key);\n    return newBaggage;\n  }\n\n  removeEntries(...keys: string[]): BaggageImpl {\n    const newBaggage = new BaggageImpl(this._entries);\n    for (const key of keys) {\n      newBaggage._entries.delete(key);\n    }\n    return newBaggage;\n  }\n\n  clear(): BaggageImpl {\n    return new BaggageImpl();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Symbol used to make BaggageEntryMetadata an opaque type\n */\nexport const baggageEntryMetadataSymbol = Symbol('BaggageEntryMetadata');\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagAPI } from '../api/diag';\nimport { BaggageImpl } from './internal/baggage-impl';\nimport { baggageEntryMetadataSymbol } from './internal/symbol';\nimport { Baggage, BaggageEntry, BaggageEntryMetadata } from './types';\n\nconst diag = DiagAPI.instance();\n\n/**\n * Create a new Baggage with optional entries\n *\n * @param entries An array of baggage entries the new baggage should contain\n */\nexport function createBaggage(\n  entries: Record<string, BaggageEntry> = {}\n): Baggage {\n  return new BaggageImpl(new Map(Object.entries(entries)));\n}\n\n/**\n * Create a serializable BaggageEntryMetadata object from a string.\n *\n * @param str string metadata. Format is currently not defined by the spec and has no special meaning.\n *\n */\nexport function baggageEntryMetadataFromString(\n  str: string\n): BaggageEntryMetadata {\n  if (typeof str !== 'string') {\n    diag.error(\n      `Cannot create baggage metadata from unknown type: ${typeof str}`\n    );\n    str = '';\n  }\n\n  return {\n    __TYPE__: baggageEntryMetadataSymbol,\n    toString() {\n      return str;\n    },\n  };\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from './types';\n\n/** Get a key to uniquely identify a context value */\nexport function createContextKey(description: string) {\n  // The specification states that for the same input, multiple calls should\n  // return different keys. Due to the nature of the JS dependency management\n  // system, this creates problems where multiple versions of some package\n  // could hold different keys for the same property.\n  //\n  // Therefore, we use Symbol.for which returns the same key for the same input.\n  return Symbol.for(description);\n}\n\nclass BaseContext implements Context {\n  private _currentContext!: Map<symbol, unknown>;\n\n  /**\n   * Construct a new context which inherits values from an optional parent context.\n   *\n   * @param parentContext a context from which to inherit values\n   */\n  constructor(parentContext?: Map<symbol, unknown>) {\n    // for minification\n    const self = this;\n\n    self._currentContext = parentContext ? new Map(parentContext) : new Map();\n\n    self.getValue = (key: symbol) => self._currentContext.get(key);\n\n    self.setValue = (key: symbol, value: unknown): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.set(key, value);\n      return context;\n    };\n\n    self.deleteValue = (key: symbol): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.delete(key);\n      return context;\n    };\n  }\n\n  /**\n   * Get a value from the context.\n   *\n   * @param key key which identifies a context value\n   */\n  public getValue!: (key: symbol) => unknown;\n\n  /**\n   * Create a new context which inherits from this context and has\n   * the given key set to the given value.\n   *\n   * @param key context key for which to set the value\n   * @param value value to set for the given key\n   */\n  public setValue!: (key: symbol, value: unknown) => Context;\n\n  /**\n   * Return a new context which inherits from this context but does\n   * not contain a value for the given key.\n   *\n   * @param key context key for which to clear a value\n   */\n  public deleteValue!: (key: symbol) => Context;\n}\n\n/** The root context is used as the default parent context when there is no active context */\nexport const ROOT_CONTEXT: Context = new BaseContext();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagLogger, DiagLogFunction } from './types';\n\ntype ConsoleMapKeys = 'error' | 'warn' | 'info' | 'debug' | 'trace';\nconst consoleMap: { n: keyof DiagLogger; c: ConsoleMapKeys }[] = [\n  { n: 'error', c: 'error' },\n  { n: 'warn', c: 'warn' },\n  { n: 'info', c: 'info' },\n  { n: 'debug', c: 'debug' },\n  { n: 'verbose', c: 'trace' },\n];\n\n/**\n * A simple Immutable Console based diagnostic logger which will output any messages to the Console.\n * If you want to limit the amount of logging to a specific level or lower use the\n * {@link createLogLevelDiagLogger}\n */\nexport class DiagConsoleLogger implements DiagLogger {\n  constructor() {\n    function _consoleFunc(funcName: ConsoleMapKeys): DiagLogFunction {\n      return function (...args) {\n        if (console) {\n          // Some environments only expose the console when the F12 developer console is open\n          // eslint-disable-next-line no-console\n          let theFunc = console[funcName];\n          if (typeof theFunc !== 'function') {\n            // Not all environments support all functions\n            // eslint-disable-next-line no-console\n            theFunc = console.log;\n          }\n\n          // One last final check\n          if (typeof theFunc === 'function') {\n            return theFunc.apply(console, args);\n          }\n        }\n      };\n    }\n\n    for (let i = 0; i < consoleMap.length; i++) {\n      this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);\n    }\n  }\n\n  /** Log an error scenario that was not expected and caused the requested operation to fail. */\n  public error!: DiagLogFunction;\n\n  /**\n   * Log a warning scenario to inform the developer of an issues that should be investigated.\n   * The requested operation may or may not have succeeded or completed.\n   */\n  public warn!: DiagLogFunction;\n\n  /**\n   * Log a general informational message, this should not affect functionality.\n   * This is also the default logging level so this should NOT be used for logging\n   * debugging level information.\n   */\n  public info!: DiagLogFunction;\n\n  /**\n   * Log a general debug message that can be useful for identifying a failure.\n   * Information logged at this level may include diagnostic details that would\n   * help identify a failure scenario. Useful scenarios would be to log the execution\n   * order of async operations\n   */\n  public debug!: DiagLogFunction;\n\n  /**\n   * Log a detailed (verbose) trace level logging that can be used to identify failures\n   * where debug level logging would be insufficient, this level of tracing can include\n   * input and output parameters and as such may include PII information passing through\n   * the API. As such it is recommended that this level of tracing should not be enabled\n   * in a production environment.\n   */\n  public verbose!: DiagLogFunction;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Meter } from './Meter';\nimport {\n  BatchObservableCallback,\n  Counter,\n  Gauge,\n  Histogram,\n  MetricAttributes,\n  MetricOptions,\n  Observable,\n  ObservableCallback,\n  ObservableCounter,\n  ObservableGauge,\n  ObservableUpDownCounter,\n  UpDownCounter,\n} from './Metric';\n\n/**\n * NoopMeter is a noop implementation of the {@link Meter} interface. It reuses\n * constant NoopMetrics for all of its methods.\n */\nexport class NoopMeter implements Meter {\n  constructor() {}\n\n  /**\n   * @see {@link Meter.createGauge}\n   */\n  createGauge(_name: string, _options?: MetricOptions): Gauge {\n    return NOOP_GAUGE_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createHistogram}\n   */\n  createHistogram(_name: string, _options?: MetricOptions): Histogram {\n    return NOOP_HISTOGRAM_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createCounter}\n   */\n  createCounter(_name: string, _options?: MetricOptions): Counter {\n    return NOOP_COUNTER_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createUpDownCounter}\n   */\n  createUpDownCounter(_name: string, _options?: MetricOptions): UpDownCounter {\n    return NOOP_UP_DOWN_COUNTER_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createObservableGauge}\n   */\n  createObservableGauge(\n    _name: string,\n    _options?: MetricOptions\n  ): ObservableGauge {\n    return NOOP_OBSERVABLE_GAUGE_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createObservableCounter}\n   */\n  createObservableCounter(\n    _name: string,\n    _options?: MetricOptions\n  ): ObservableCounter {\n    return NOOP_OBSERVABLE_COUNTER_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createObservableUpDownCounter}\n   */\n  createObservableUpDownCounter(\n    _name: string,\n    _options?: MetricOptions\n  ): ObservableUpDownCounter {\n    return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.addBatchObservableCallback}\n   */\n  addBatchObservableCallback(\n    _callback: BatchObservableCallback,\n    _observables: Observable[]\n  ): void {}\n\n  /**\n   * @see {@link Meter.removeBatchObservableCallback}\n   */\n  removeBatchObservableCallback(_callback: BatchObservableCallback): void {}\n}\n\nexport class NoopMetric {}\n\nexport class NoopCounterMetric extends NoopMetric implements Counter {\n  add(_value: number, _attributes: MetricAttributes): void {}\n}\n\nexport class NoopUpDownCounterMetric\n  extends NoopMetric\n  implements UpDownCounter\n{\n  add(_value: number, _attributes: MetricAttributes): void {}\n}\n\nexport class NoopGaugeMetric extends NoopMetric implements Gauge {\n  record(_value: number, _attributes: MetricAttributes): void {}\n}\n\nexport class NoopHistogramMetric extends NoopMetric implements Histogram {\n  record(_value: number, _attributes: MetricAttributes): void {}\n}\n\nexport class NoopObservableMetric {\n  addCallback(_callback: ObservableCallback) {}\n\n  removeCallback(_callback: ObservableCallback) {}\n}\n\nexport class NoopObservableCounterMetric\n  extends NoopObservableMetric\n  implements ObservableCounter {}\n\nexport class NoopObservableGaugeMetric\n  extends NoopObservableMetric\n  implements ObservableGauge {}\n\nexport class NoopObservableUpDownCounterMetric\n  extends NoopObservableMetric\n  implements ObservableUpDownCounter {}\n\nexport const NOOP_METER = new NoopMeter();\n\n// Synchronous instruments\nexport const NOOP_COUNTER_METRIC = new NoopCounterMetric();\nexport const NOOP_GAUGE_METRIC = new NoopGaugeMetric();\nexport const NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();\nexport const NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();\n\n// Asynchronous instruments\nexport const NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();\nexport const NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();\nexport const NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC =\n  new NoopObservableUpDownCounterMetric();\n\n/**\n * Create a no-op Meter\n */\nexport function createNoopMeter(): Meter {\n  return NOOP_METER;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Attributes, AttributeValue } from '../common/Attributes';\nimport { Context } from '../context/types';\nimport { BatchObservableResult, ObservableResult } from './ObservableResult';\n\n/**\n * Advisory options influencing aggregation configuration parameters.\n * @experimental\n */\nexport interface MetricAdvice {\n  /**\n   * Hint the explicit bucket boundaries for SDK if the metric is been\n   * aggregated with a HistogramAggregator.\n   */\n  explicitBucketBoundaries?: number[];\n}\n\n/**\n * Options needed for metric creation\n */\nexport interface MetricOptions {\n  /**\n   * The description of the Metric.\n   * @default ''\n   */\n  description?: string;\n\n  /**\n   * The unit of the Metric values.\n   * @default ''\n   */\n  unit?: string;\n\n  /**\n   * Indicates the type of the recorded value.\n   * @default {@link ValueType.DOUBLE}\n   */\n  valueType?: ValueType;\n\n  /**\n   * The advice influencing aggregation configuration parameters.\n   * @experimental\n   */\n  advice?: MetricAdvice;\n}\n\n/** The Type of value. It describes how the data is reported. */\nexport enum ValueType {\n  INT,\n  DOUBLE,\n}\n\n/**\n * Counter is the most common synchronous instrument. This instrument supports\n * an `Add(increment)` function for reporting a sum, and is restricted to\n * non-negative increments. The default aggregation is Sum, as for any additive\n * instrument.\n *\n * Example uses for Counter:\n * <ol>\n *   <li> count the number of bytes received. </li>\n *   <li> count the number of requests completed. </li>\n *   <li> count the number of accounts created. </li>\n *   <li> count the number of checkpoints run. </li>\n *   <li> count the number of 5xx errors. </li>\n * <ol>\n */\nexport interface Counter<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Increment value of counter by the input. Inputs must not be negative.\n   */\n  add(value: number, attributes?: AttributesTypes, context?: Context): void;\n}\n\nexport interface UpDownCounter<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Increment value of counter by the input. Inputs may be negative.\n   */\n  add(value: number, attributes?: AttributesTypes, context?: Context): void;\n}\n\nexport interface Gauge<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Records a measurement.\n   */\n  record(value: number, attributes?: AttributesTypes, context?: Context): void;\n}\n\nexport interface Histogram<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Records a measurement. Value of the measurement must not be negative.\n   */\n  record(value: number, attributes?: AttributesTypes, context?: Context): void;\n}\n\n/**\n * @deprecated please use {@link Attributes}\n */\nexport type MetricAttributes = Attributes;\n\n/**\n * @deprecated please use {@link AttributeValue}\n */\nexport type MetricAttributeValue = AttributeValue;\n\n/**\n * The observable callback for Observable instruments.\n */\nexport type ObservableCallback<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = (\n  observableResult: ObservableResult<AttributesTypes>\n) => void | Promise<void>;\n\n/**\n * The observable callback for a batch of Observable instruments.\n */\nexport type BatchObservableCallback<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = (\n  observableResult: BatchObservableResult<AttributesTypes>\n) => void | Promise<void>;\n\nexport interface Observable<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Sets up a function that will be called whenever a metric collection is initiated.\n   *\n   * If the function is already in the list of callbacks for this Observable, the function is not added a second time.\n   */\n  addCallback(callback: ObservableCallback<AttributesTypes>): void;\n\n  /**\n   * Removes a callback previously registered with {@link Observable.addCallback}.\n   */\n  removeCallback(callback: ObservableCallback<AttributesTypes>): void;\n}\n\nexport type ObservableCounter<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = Observable<AttributesTypes>;\nexport type ObservableUpDownCounter<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = Observable<AttributesTypes>;\nexport type ObservableGauge<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = Observable<AttributesTypes>;\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\n\n/**\n * Injects `Context` into and extracts it from carriers that travel\n * in-band across process boundaries. Encoding is expected to conform to the\n * HTTP Header Field semantics. Values are often encoded as RPC/HTTP request\n * headers.\n *\n * The carrier of propagated data on both the client (injector) and server\n * (extractor) side is usually an object such as http headers. Propagation is\n * usually implemented via library-specific request interceptors, where the\n * client-side injects values and the server-side extracts them.\n */\nexport interface TextMapPropagator<Carrier = any> {\n  /**\n   * Injects values from a given `Context` into a carrier.\n   *\n   * OpenTelemetry defines a common set of format values (TextMapPropagator),\n   * and each has an expected `carrier` type.\n   *\n   * @param context the Context from which to extract values to transmit over\n   *     the wire.\n   * @param carrier the carrier of propagation fields, such as http request\n   *     headers.\n   * @param setter an optional {@link TextMapSetter}. If undefined, values will be\n   *     set by direct object assignment.\n   */\n  inject(\n    context: Context,\n    carrier: Carrier,\n    setter: TextMapSetter<Carrier>\n  ): void;\n\n  /**\n   * Given a `Context` and a carrier, extract context values from a\n   * carrier and return a new context, created from the old context, with the\n   * extracted values.\n   *\n   * @param context the Context from which to extract values to transmit over\n   *     the wire.\n   * @param carrier the carrier of propagation fields, such as http request\n   *     headers.\n   * @param getter an optional {@link TextMapGetter}. If undefined, keys will be all\n   *     own properties, and keys will be accessed by direct object access.\n   */\n  extract(\n    context: Context,\n    carrier: Carrier,\n    getter: TextMapGetter<Carrier>\n  ): Context;\n\n  /**\n   * Return a list of all fields which may be used by the propagator.\n   */\n  fields(): string[];\n}\n\n/**\n * A setter is specified by the caller to define a specific method\n * to set key/value pairs on the carrier within a propagator.\n */\nexport interface TextMapSetter<Carrier = any> {\n  /**\n   * Callback used to set a key/value pair on an object.\n   *\n   * Should be called by the propagator each time a key/value pair\n   * should be set, and should set that key/value pair on the propagator.\n   *\n   * @param carrier object or class which carries key/value pairs\n   * @param key string key to modify\n   * @param value value to be set to the key on the carrier\n   */\n  set(carrier: Carrier, key: string, value: string): void;\n}\n\n/**\n * A getter is specified by the caller to define a specific method\n * to get the value of a key from a carrier.\n */\nexport interface TextMapGetter<Carrier = any> {\n  /**\n   * Get a list of all keys available on the carrier.\n   *\n   * @param carrier\n   */\n  keys(carrier: Carrier): string[];\n\n  /**\n   * Get the value of a specific key from the carrier.\n   *\n   * @param carrier\n   * @param key\n   */\n  get(carrier: Carrier, key: string): undefined | string | string[];\n}\n\nexport const defaultTextMapGetter: TextMapGetter = {\n  get(carrier, key) {\n    if (carrier == null) {\n      return undefined;\n    }\n    return carrier[key];\n  },\n\n  keys(carrier) {\n    if (carrier == null) {\n      return [];\n    }\n    return Object.keys(carrier);\n  },\n};\n\nexport const defaultTextMapSetter: TextMapSetter = {\n  set(carrier, key, value) {\n    if (carrier == null) {\n      return;\n    }\n\n    carrier[key] = value;\n  },\n};\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ROOT_CONTEXT } from './context';\nimport * as types from './types';\n\nexport class NoopContextManager implements types.ContextManager {\n  active(): types.Context {\n    return ROOT_CONTEXT;\n  }\n\n  with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    _context: types.Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return fn.call(thisArg, ...args);\n  }\n\n  bind<T>(_context: types.Context, target: T): T {\n    return target;\n  }\n\n  enable(): this {\n    return this;\n  }\n\n  disable(): this {\n    return this;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopContextManager } from '../context/NoopContextManager';\nimport { Context, ContextManager } from '../context/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'context';\nconst NOOP_CONTEXT_MANAGER = new NoopContextManager();\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Context API\n */\nexport class ContextAPI {\n  private static _instance?: ContextAPI;\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Context API */\n  public static getInstance(): ContextAPI {\n    if (!this._instance) {\n      this._instance = new ContextAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current context manager.\n   *\n   * @returns true if the context manager was successfully registered, else false\n   */\n  public setGlobalContextManager(contextManager: ContextManager): boolean {\n    return registerGlobal(API_NAME, contextManager, DiagAPI.instance());\n  }\n\n  /**\n   * Get the currently active context\n   */\n  public active(): Context {\n    return this._getContextManager().active();\n  }\n\n  /**\n   * Execute a function with an active context\n   *\n   * @param context context to be active during function execution\n   * @param fn function to execute in a context\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n  public with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    context: Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return this._getContextManager().with(context, fn, thisArg, ...args);\n  }\n\n  /**\n   * Bind a context to a target function or event emitter\n   *\n   * @param context context to bind to the event emitter or function. Defaults to the currently active context\n   * @param target function or event emitter to bind\n   */\n  public bind<T>(context: Context, target: T): T {\n    return this._getContextManager().bind(context, target);\n  }\n\n  private _getContextManager(): ContextManager {\n    return getGlobal(API_NAME) || NOOP_CONTEXT_MANAGER;\n  }\n\n  /** Disable and remove the global context manager */\n  public disable() {\n    this._getContextManager().disable();\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum TraceFlags {\n  /** Represents no flag set. */\n  NONE = 0x0,\n  /** Bit to represent whether trace is sampled in trace flags. */\n  SAMPLED = 0x1 << 0,\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanContext } from './span_context';\nimport { TraceFlags } from './trace_flags';\n\nexport const INVALID_SPANID = '0000000000000000';\nexport const INVALID_TRACEID = '00000000000000000000000000000000';\nexport const INVALID_SPAN_CONTEXT: SpanContext = {\n  traceId: INVALID_TRACEID,\n  spanId: INVALID_SPANID,\n  traceFlags: TraceFlags.NONE,\n};\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Exception } from '../common/Exception';\nimport { TimeInput } from '../common/Time';\nimport { SpanAttributes } from './attributes';\nimport { INVALID_SPAN_CONTEXT } from './invalid-span-constants';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { SpanStatus } from './status';\nimport { Link } from './link';\n\n/**\n * The NonRecordingSpan is the default {@link Span} that is used when no Span\n * implementation is available. All operations are no-op including context\n * propagation.\n */\nexport class NonRecordingSpan implements Span {\n  constructor(\n    private readonly _spanContext: SpanContext = INVALID_SPAN_CONTEXT\n  ) {}\n\n  // Returns a SpanContext.\n  spanContext(): SpanContext {\n    return this._spanContext;\n  }\n\n  // By default does nothing\n  setAttribute(_key: string, _value: unknown): this {\n    return this;\n  }\n\n  // By default does nothing\n  setAttributes(_attributes: SpanAttributes): this {\n    return this;\n  }\n\n  // By default does nothing\n  addEvent(_name: string, _attributes?: SpanAttributes): this {\n    return this;\n  }\n\n  addLink(_link: Link): this {\n    return this;\n  }\n\n  addLinks(_links: Link[]): this {\n    return this;\n  }\n\n  // By default does nothing\n  setStatus(_status: SpanStatus): this {\n    return this;\n  }\n\n  // By default does nothing\n  updateName(_name: string): this {\n    return this;\n  }\n\n  // By default does nothing\n  end(_endTime?: TimeInput): void {}\n\n  // isRecording always returns false for NonRecordingSpan.\n  isRecording(): boolean {\n    return false;\n  }\n\n  // By default does nothing\n  recordException(_exception: Exception, _time?: TimeInput): void {}\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createContextKey } from '../context/context';\nimport { Context } from '../context/types';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { ContextAPI } from '../api/context';\n\n/**\n * span key\n */\nconst SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');\n\n/**\n * Return the span if one exists\n *\n * @param context context to get span from\n */\nexport function getSpan(context: Context): Span | undefined {\n  return (context.getValue(SPAN_KEY) as Span) || undefined;\n}\n\n/**\n * Gets the span from the current context, if one exists.\n */\nexport function getActiveSpan(): Span | undefined {\n  return getSpan(ContextAPI.getInstance().active());\n}\n\n/**\n * Set the span on a context\n *\n * @param context context to use as parent\n * @param span span to set active\n */\nexport function setSpan(context: Context, span: Span): Context {\n  return context.setValue(SPAN_KEY, span);\n}\n\n/**\n * Remove current span stored in the context\n *\n * @param context context to delete span from\n */\nexport function deleteSpan(context: Context): Context {\n  return context.deleteValue(SPAN_KEY);\n}\n\n/**\n * Wrap span context in a NoopSpan and set as span in a new\n * context\n *\n * @param context context to set active span on\n * @param spanContext span context to be wrapped\n */\nexport function setSpanContext(\n  context: Context,\n  spanContext: SpanContext\n): Context {\n  return setSpan(context, new NonRecordingSpan(spanContext));\n}\n\n/**\n * Get the span context of the span if it exists.\n *\n * @param context context to get values from\n */\nexport function getSpanContext(context: Context): SpanContext | undefined {\n  return getSpan(context)?.spanContext();\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { INVALID_SPANID, INVALID_TRACEID } from './invalid-span-constants';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\n\nconst VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;\nconst VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;\n\nexport function isValidTraceId(traceId: string): boolean {\n  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;\n}\n\nexport function isValidSpanId(spanId: string): boolean {\n  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;\n}\n\n/**\n * Returns true if this {@link SpanContext} is valid.\n * @return true if this {@link SpanContext} is valid.\n */\nexport function isSpanContextValid(spanContext: SpanContext): boolean {\n  return (\n    isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId)\n  );\n}\n\n/**\n * Wrap the given {@link SpanContext} in a new non-recording {@link Span}\n *\n * @param spanContext span context to be wrapped\n * @returns a new non-recording {@link Span} with the provided context\n */\nexport function wrapSpanContext(spanContext: SpanContext): Span {\n  return new NonRecordingSpan(spanContext);\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContextAPI } from '../api/context';\nimport { Context } from '../context/types';\nimport { getSpanContext, setSpan } from '../trace/context-utils';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { isSpanContextValid } from './spancontext-utils';\nimport { SpanOptions } from './SpanOptions';\nimport { SpanContext } from './span_context';\nimport { Tracer } from './tracer';\n\nconst contextApi = ContextAPI.getInstance();\n\n/**\n * No-op implementations of {@link Tracer}.\n */\nexport class NoopTracer implements Tracer {\n  // startSpan starts a noop span.\n  startSpan(\n    name: string,\n    options?: SpanOptions,\n    context = contextApi.active()\n  ): Span {\n    const root = Boolean(options?.root);\n    if (root) {\n      return new NonRecordingSpan();\n    }\n\n    const parentFromContext = context && getSpanContext(context);\n\n    if (\n      isSpanContext(parentFromContext) &&\n      isSpanContextValid(parentFromContext)\n    ) {\n      return new NonRecordingSpan(parentFromContext);\n    } else {\n      return new NonRecordingSpan();\n    }\n  }\n\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    ctx: Context | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    arg2?: F | SpanOptions,\n    arg3?: F | Context,\n    arg4?: F\n  ): ReturnType<F> | undefined {\n    let opts: SpanOptions | undefined;\n    let ctx: Context | undefined;\n    let fn: F;\n\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2 as F;\n    } else if (arguments.length === 3) {\n      opts = arg2 as SpanOptions | undefined;\n      fn = arg3 as F;\n    } else {\n      opts = arg2 as SpanOptions | undefined;\n      ctx = arg3 as Context | undefined;\n      fn = arg4 as F;\n    }\n\n    const parentContext = ctx ?? contextApi.active();\n    const span = this.startSpan(name, opts, parentContext);\n    const contextWithSpanSet = setSpan(parentContext, span);\n\n    return contextApi.with(contextWithSpanSet, fn, undefined, span);\n  }\n}\n\nfunction isSpanContext(spanContext: any): spanContext is SpanContext {\n  return (\n    typeof spanContext === 'object' &&\n    typeof spanContext['spanId'] === 'string' &&\n    typeof spanContext['traceId'] === 'string' &&\n    typeof spanContext['traceFlags'] === 'number'\n  );\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\nimport { NoopTracer } from './NoopTracer';\nimport { Span } from './span';\nimport { SpanOptions } from './SpanOptions';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER = new NoopTracer();\n\n/**\n * Proxy tracer provided by the proxy tracer provider\n */\nexport class ProxyTracer implements Tracer {\n  // When a real implementation is provided, this will be it\n  private _delegate?: Tracer;\n\n  constructor(\n    private _provider: TracerDelegator,\n    public readonly name: string,\n    public readonly version?: string,\n    public readonly options?: TracerOptions\n  ) {}\n\n  startSpan(name: string, options?: SpanOptions, context?: Context): Span {\n    return this._getTracer().startSpan(name, options, context);\n  }\n\n  startActiveSpan<F extends (span: Span) => unknown>(\n    _name: string,\n    _options: F | SpanOptions,\n    _context?: F | Context,\n    _fn?: F\n  ): ReturnType<F> {\n    const tracer = this._getTracer();\n    return Reflect.apply(tracer.startActiveSpan, tracer, arguments);\n  }\n\n  /**\n   * Try to get a tracer from the proxy tracer provider.\n   * If the proxy tracer provider has no delegate, return a noop tracer.\n   */\n  private _getTracer() {\n    if (this._delegate) {\n      return this._delegate;\n    }\n\n    const tracer = this._provider.getDelegateTracer(\n      this.name,\n      this.version,\n      this.options\n    );\n\n    if (!tracer) {\n      return NOOP_TRACER;\n    }\n\n    this._delegate = tracer;\n    return this._delegate;\n  }\n}\n\nexport interface TracerDelegator {\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopTracer } from './NoopTracer';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\nimport { TracerProvider } from './tracer_provider';\n\n/**\n * An implementation of the {@link TracerProvider} which returns an impotent\n * Tracer for all calls to `getTracer`.\n *\n * All operations are no-op.\n */\nexport class NoopTracerProvider implements TracerProvider {\n  getTracer(\n    _name?: string,\n    _version?: string,\n    _options?: TracerOptions\n  ): Tracer {\n    return new NoopTracer();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Tracer } from './tracer';\nimport { TracerProvider } from './tracer_provider';\nimport { ProxyTracer } from './ProxyTracer';\nimport { NoopTracerProvider } from './NoopTracerProvider';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER_PROVIDER = new NoopTracerProvider();\n\n/**\n * Tracer provider which provides {@link ProxyTracer}s.\n *\n * Before a delegate is set, tracers provided are NoOp.\n *   When a delegate is set, traces are provided from the delegate.\n *   When a delegate is set after tracers have already been provided,\n *   all tracers already provided will use the provided delegate implementation.\n */\nexport class ProxyTracerProvider implements TracerProvider {\n  private _delegate?: TracerProvider;\n\n  /**\n   * Get a {@link ProxyTracer}\n   */\n  getTracer(name: string, version?: string, options?: TracerOptions): Tracer {\n    return (\n      this.getDelegateTracer(name, version, options) ??\n      new ProxyTracer(this, name, version, options)\n    );\n  }\n\n  getDelegate(): TracerProvider {\n    return this._delegate ?? NOOP_TRACER_PROVIDER;\n  }\n\n  /**\n   * Set the delegate tracer provider\n   */\n  setDelegate(delegate: TracerProvider) {\n    this._delegate = delegate;\n  }\n\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined {\n    return this._delegate?.getTracer(name, version, options);\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanAttributes } from './attributes';\nimport { TraceState } from './trace_state';\n\n/**\n * @deprecated use the one declared in @opentelemetry/sdk-trace-base instead.\n * A sampling decision that determines how a {@link Span} will be recorded\n * and collected.\n */\nexport enum SamplingDecision {\n  /**\n   * `Span.isRecording() === false`, span will not be recorded and all events\n   * and attributes will be dropped.\n   */\n  NOT_RECORD,\n  /**\n   * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}\n   * MUST NOT be set.\n   */\n  RECORD,\n  /**\n   * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}\n   * MUST be set.\n   */\n  RECORD_AND_SAMPLED,\n}\n\n/**\n * @deprecated use the one declared in @opentelemetry/sdk-trace-base instead.\n * A sampling result contains a decision for a {@link Span} and additional\n * attributes the sampler would like to added to the Span.\n */\nexport interface SamplingResult {\n  /**\n   * A sampling decision, refer to {@link SamplingDecision} for details.\n   */\n  decision: SamplingDecision;\n  /**\n   * The list of attributes returned by SamplingResult MUST be immutable.\n   * Caller may call {@link Sampler}.shouldSample any number of times and\n   * can safely cache the returned value.\n   */\n  attributes?: Readonly<SpanAttributes>;\n  /**\n   * A {@link TraceState} that will be associated with the {@link Span} through\n   * the new {@link SpanContext}. Samplers SHOULD return the TraceState from\n   * the passed-in {@link Context} if they do not intend to change it. Leaving\n   * the value undefined will also leave the TraceState unchanged.\n   */\n  traceState?: TraceState;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum SpanKind {\n  /** Default value. Indicates that the span is used internally. */\n  INTERNAL = 0,\n\n  /**\n   * Indicates that the span covers server-side handling of an RPC or other\n   * remote request.\n   */\n  SERVER = 1,\n\n  /**\n   * Indicates that the span covers the client-side wrapper around an RPC or\n   * other remote request.\n   */\n  CLIENT = 2,\n\n  /**\n   * Indicates that the span describes producer sending a message to a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  PRODUCER = 3,\n\n  /**\n   * Indicates that the span describes consumer receiving a message from a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  CONSUMER = 4,\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport interface SpanStatus {\n  /** The status code of this message. */\n  code: SpanStatusCode;\n  /** A developer-facing error message. */\n  message?: string;\n}\n\n/**\n * An enumeration of status codes.\n */\nexport enum SpanStatusCode {\n  /**\n   * The default status.\n   */\n  UNSET = 0,\n  /**\n   * The operation has been validated by an Application developer or\n   * Operator to have completed successfully.\n   */\n  OK = 1,\n  /**\n   * The operation contains an error.\n   */\n  ERROR = 2,\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';\nconst VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;\nconst VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;\nconst VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);\nconst VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;\nconst INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;\n\n/**\n * Key is opaque string up to 256 characters printable. It MUST begin with a\n * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,\n * underscores _, dashes -, asterisks *, and forward slashes /.\n * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the\n * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.\n * see https://www.w3.org/TR/trace-context/#key\n */\nexport function validateKey(key: string): boolean {\n  return VALID_KEY_REGEX.test(key);\n}\n\n/**\n * Value is opaque string up to 256 characters printable ASCII RFC0020\n * characters (i.e., the range 0x20 to 0x7E) except comma , and =.\n */\nexport function validateValue(value: string): boolean {\n  return (\n    VALID_VALUE_BASE_REGEX.test(value) &&\n    !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value)\n  );\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TraceState } from '../trace_state';\nimport { validateKey, validateValue } from './tracestate-validators';\n\nconst MAX_TRACE_STATE_ITEMS = 32;\nconst MAX_TRACE_STATE_LEN = 512;\nconst LIST_MEMBERS_SEPARATOR = ',';\nconst LIST_MEMBER_KEY_VALUE_SPLITTER = '=';\n\n/**\n * TraceState must be a class and not a simple object type because of the spec\n * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).\n *\n * Here is the list of allowed mutations:\n * - New key-value pair should be added into the beginning of the list\n * - The value of any key can be updated. Modified keys MUST be moved to the\n * beginning of the list.\n */\nexport class TraceStateImpl implements TraceState {\n  private _internalState: Map<string, string> = new Map();\n\n  constructor(rawTraceState?: string) {\n    if (rawTraceState) this._parse(rawTraceState);\n  }\n\n  set(key: string, value: string): TraceStateImpl {\n    // TODO: Benchmark the different approaches(map vs list) and\n    // use the faster one.\n    const traceState = this._clone();\n    if (traceState._internalState.has(key)) {\n      traceState._internalState.delete(key);\n    }\n    traceState._internalState.set(key, value);\n    return traceState;\n  }\n\n  unset(key: string): TraceStateImpl {\n    const traceState = this._clone();\n    traceState._internalState.delete(key);\n    return traceState;\n  }\n\n  get(key: string): string | undefined {\n    return this._internalState.get(key);\n  }\n\n  serialize(): string {\n    return this._keys()\n      .reduce((agg: string[], key) => {\n        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));\n        return agg;\n      }, [])\n      .join(LIST_MEMBERS_SEPARATOR);\n  }\n\n  private _parse(rawTraceState: string) {\n    if (rawTraceState.length > MAX_TRACE_STATE_LEN) return;\n    this._internalState = rawTraceState\n      .split(LIST_MEMBERS_SEPARATOR)\n      .reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning\n      .reduce((agg: Map<string, string>, part: string) => {\n        const listMember = part.trim(); // Optional Whitespace (OWS) handling\n        const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);\n        if (i !== -1) {\n          const key = listMember.slice(0, i);\n          const value = listMember.slice(i + 1, part.length);\n          if (validateKey(key) && validateValue(value)) {\n            agg.set(key, value);\n          } else {\n            // TODO: Consider to add warning log\n          }\n        }\n        return agg;\n      }, new Map());\n\n    // Because of the reverse() requirement, trunc must be done after map is created\n    if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {\n      this._internalState = new Map(\n        Array.from(this._internalState.entries())\n          .reverse() // Use reverse same as original tracestate parse chain\n          .slice(0, MAX_TRACE_STATE_ITEMS)\n      );\n    }\n  }\n\n  private _keys(): string[] {\n    return Array.from(this._internalState.keys()).reverse();\n  }\n\n  private _clone(): TraceStateImpl {\n    const traceState = new TraceStateImpl();\n    traceState._internalState = new Map(this._internalState);\n    return traceState;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TraceState } from '../trace_state';\nimport { TraceStateImpl } from './tracestate-impl';\n\nexport function createTraceState(rawTraceState?: string): TraceState {\n  return new TraceStateImpl(rawTraceState);\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { ContextAPI } from './api/context';\n/** Entrypoint for context API */\nexport const context = ContextAPI.getInstance();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { DiagAPI } from './api/diag';\n/**\n * Entrypoint for Diag API.\n * Defines Diagnostic handler used for internal diagnostic logging operations.\n * The default provides a Noop DiagLogger implementation which may be changed via the\n * diag.setLogger(logger: DiagLogger) function.\n */\nexport const diag = DiagAPI.instance();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Meter, MeterOptions } from './Meter';\nimport { MeterProvider } from './MeterProvider';\nimport { NOOP_METER } from './NoopMeter';\n\n/**\n * An implementation of the {@link MeterProvider} which returns an impotent Meter\n * for all calls to `getMeter`\n */\nexport class NoopMeterProvider implements MeterProvider {\n  getMeter(_name: string, _version?: string, _options?: MeterOptions): Meter {\n    return NOOP_METER;\n  }\n}\n\nexport const NOOP_METER_PROVIDER = new NoopMeterProvider();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Meter, MeterOptions } from '../metrics/Meter';\nimport { MeterProvider } from '../metrics/MeterProvider';\nimport { NOOP_METER_PROVIDER } from '../metrics/NoopMeterProvider';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'metrics';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Metrics API\n */\nexport class MetricsAPI {\n  private static _instance?: MetricsAPI;\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Metrics API */\n  public static getInstance(): MetricsAPI {\n    if (!this._instance) {\n      this._instance = new MetricsAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current global meter provider.\n   * Returns true if the meter provider was successfully registered, else false.\n   */\n  public setGlobalMeterProvider(provider: MeterProvider): boolean {\n    return registerGlobal(API_NAME, provider, DiagAPI.instance());\n  }\n\n  /**\n   * Returns the global meter provider.\n   */\n  public getMeterProvider(): MeterProvider {\n    return getGlobal(API_NAME) || NOOP_METER_PROVIDER;\n  }\n\n  /**\n   * Returns a meter from the global meter provider.\n   */\n  public getMeter(\n    name: string,\n    version?: string,\n    options?: MeterOptions\n  ): Meter {\n    return this.getMeterProvider().getMeter(name, version, options);\n  }\n\n  /** Remove the global meter provider */\n  public disable(): void {\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { MetricsAPI } from './api/metrics';\n/** Entrypoint for metrics API */\nexport const metrics = MetricsAPI.getInstance();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\nimport { TextMapPropagator } from './TextMapPropagator';\n\n/**\n * No-op implementations of {@link TextMapPropagator}.\n */\nexport class NoopTextMapPropagator implements TextMapPropagator {\n  /** Noop inject function does nothing */\n  inject(_context: Context, _carrier: unknown): void {}\n  /** Noop extract function does nothing and returns the input context */\n  extract(context: Context, _carrier: unknown): Context {\n    return context;\n  }\n  fields(): string[] {\n    return [];\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContextAPI } from '../api/context';\nimport { createContextKey } from '../context/context';\nimport { Context } from '../context/types';\nimport { Baggage } from './types';\n\n/**\n * Baggage key\n */\nconst BAGGAGE_KEY = createContextKey('OpenTelemetry Baggage Key');\n\n/**\n * Retrieve the current baggage from the given context\n *\n * @param {Context} Context that manage all context values\n * @returns {Baggage} Extracted baggage from the context\n */\nexport function getBaggage(context: Context): Baggage | undefined {\n  return (context.getValue(BAGGAGE_KEY) as Baggage) || undefined;\n}\n\n/**\n * Retrieve the current baggage from the active/current context\n *\n * @returns {Baggage} Extracted baggage from the context\n */\nexport function getActiveBaggage(): Baggage | undefined {\n  return getBaggage(ContextAPI.getInstance().active());\n}\n\n/**\n * Store a baggage in the given context\n *\n * @param {Context} Context that manage all context values\n * @param {Baggage} baggage that will be set in the actual context\n */\nexport function setBaggage(context: Context, baggage: Baggage): Context {\n  return context.setValue(BAGGAGE_KEY, baggage);\n}\n\n/**\n * Delete the baggage stored in the given context\n *\n * @param {Context} Context that manage all context values\n */\nexport function deleteBaggage(context: Context): Context {\n  return context.deleteValue(BAGGAGE_KEY);\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { NoopTextMapPropagator } from '../propagation/NoopTextMapPropagator';\nimport {\n  defaultTextMapGetter,\n  defaultTextMapSetter,\n  TextMapGetter,\n  TextMapPropagator,\n  TextMapSetter,\n} from '../propagation/TextMapPropagator';\nimport {\n  getBaggage,\n  getActiveBaggage,\n  setBaggage,\n  deleteBaggage,\n} from '../baggage/context-helpers';\nimport { createBaggage } from '../baggage/utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'propagation';\nconst NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Propagation API\n */\nexport class PropagationAPI {\n  private static _instance?: PropagationAPI;\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Propagator API */\n  public static getInstance(): PropagationAPI {\n    if (!this._instance) {\n      this._instance = new PropagationAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current propagator.\n   *\n   * @returns true if the propagator was successfully registered, else false\n   */\n  public setGlobalPropagator(propagator: TextMapPropagator): boolean {\n    return registerGlobal(API_NAME, propagator, DiagAPI.instance());\n  }\n\n  /**\n   * Inject context into a carrier to be propagated inter-process\n   *\n   * @param context Context carrying tracing data to inject\n   * @param carrier carrier to inject context into\n   * @param setter Function used to set values on the carrier\n   */\n  public inject<Carrier>(\n    context: Context,\n    carrier: Carrier,\n    setter: TextMapSetter<Carrier> = defaultTextMapSetter\n  ): void {\n    return this._getGlobalPropagator().inject(context, carrier, setter);\n  }\n\n  /**\n   * Extract context from a carrier\n   *\n   * @param context Context which the newly created context will inherit from\n   * @param carrier Carrier to extract context from\n   * @param getter Function used to extract keys from a carrier\n   */\n  public extract<Carrier>(\n    context: Context,\n    carrier: Carrier,\n    getter: TextMapGetter<Carrier> = defaultTextMapGetter\n  ): Context {\n    return this._getGlobalPropagator().extract(context, carrier, getter);\n  }\n\n  /**\n   * Return a list of all fields which may be used by the propagator.\n   */\n  public fields(): string[] {\n    return this._getGlobalPropagator().fields();\n  }\n\n  /** Remove the global propagator */\n  public disable() {\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n  }\n\n  public createBaggage = createBaggage;\n\n  public getBaggage = getBaggage;\n\n  public getActiveBaggage = getActiveBaggage;\n\n  public setBaggage = setBaggage;\n\n  public deleteBaggage = deleteBaggage;\n\n  private _getGlobalPropagator(): TextMapPropagator {\n    return getGlobal(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { PropagationAPI } from './api/propagation';\n/** Entrypoint for propagation API */\nexport const propagation = PropagationAPI.getInstance();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { ProxyTracerProvider } from '../trace/ProxyTracerProvider';\nimport {\n  isSpanContextValid,\n  wrapSpanContext,\n} from '../trace/spancontext-utils';\nimport { Tracer } from '../trace/tracer';\nimport { TracerProvider } from '../trace/tracer_provider';\nimport {\n  deleteSpan,\n  getActiveSpan,\n  getSpan,\n  getSpanContext,\n  setSpan,\n  setSpanContext,\n} from '../trace/context-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'trace';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Tracing API\n */\nexport class TraceAPI {\n  private static _instance?: TraceAPI;\n\n  private _proxyTracerProvider = new ProxyTracerProvider();\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Trace API */\n  public static getInstance(): TraceAPI {\n    if (!this._instance) {\n      this._instance = new TraceAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current global tracer.\n   *\n   * @returns true if the tracer provider was successfully registered, else false\n   */\n  public setGlobalTracerProvider(provider: TracerProvider): boolean {\n    const success = registerGlobal(\n      API_NAME,\n      this._proxyTracerProvider,\n      DiagAPI.instance()\n    );\n    if (success) {\n      this._proxyTracerProvider.setDelegate(provider);\n    }\n    return success;\n  }\n\n  /**\n   * Returns the global tracer provider.\n   */\n  public getTracerProvider(): TracerProvider {\n    return getGlobal(API_NAME) || this._proxyTracerProvider;\n  }\n\n  /**\n   * Returns a tracer from the global tracer provider.\n   */\n  public getTracer(name: string, version?: string): Tracer {\n    return this.getTracerProvider().getTracer(name, version);\n  }\n\n  /** Remove the global tracer provider */\n  public disable() {\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n    this._proxyTracerProvider = new ProxyTracerProvider();\n  }\n\n  public wrapSpanContext = wrapSpanContext;\n\n  public isSpanContextValid = isSpanContextValid;\n\n  public deleteSpan = deleteSpan;\n\n  public getSpan = getSpan;\n\n  public getActiveSpan = getActiveSpan;\n\n  public getSpanContext = getSpanContext;\n\n  public setSpan = setSpan;\n\n  public setSpanContext = setSpanContext;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { TraceAPI } from './api/trace';\n/** Entrypoint for trace API */\nexport const trace = TraceAPI.getInstance();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport { BaggageEntry, BaggageEntryMetadata, Baggage } from './baggage/types';\nexport { baggageEntryMetadataFromString } from './baggage/utils';\nexport { Exception } from './common/Exception';\nexport { HrTime, TimeInput } from './common/Time';\nexport { Attributes, AttributeValue } from './common/Attributes';\n\n// Context APIs\nexport { createContextKey, ROOT_CONTEXT } from './context/context';\nexport { Context, ContextManager } from './context/types';\nexport type { ContextAPI } from './api/context';\n\n// Diag APIs\nexport { DiagConsoleLogger } from './diag/consoleLogger';\nexport {\n  DiagLogFunction,\n  DiagLogger,\n  DiagLogLevel,\n  ComponentLoggerOptions,\n  DiagLoggerOptions,\n} from './diag/types';\nexport type { DiagAPI } from './api/diag';\n\n// Metrics APIs\nexport { createNoopMeter } from './metrics/NoopMeter';\nexport { MeterOptions, Meter } from './metrics/Meter';\nexport { MeterProvider } from './metrics/MeterProvider';\nexport {\n  ValueType,\n  Counter,\n  Gauge,\n  Histogram,\n  MetricOptions,\n  Observable,\n  ObservableCounter,\n  ObservableGauge,\n  ObservableUpDownCounter,\n  UpDownCounter,\n  BatchObservableCallback,\n  MetricAdvice,\n  MetricAttributes,\n  MetricAttributeValue,\n  ObservableCallback,\n} from './metrics/Metric';\nexport {\n  BatchObservableResult,\n  ObservableResult,\n} from './metrics/ObservableResult';\nexport type { MetricsAPI } from './api/metrics';\n\n// Propagation APIs\nexport {\n  TextMapPropagator,\n  TextMapSetter,\n  TextMapGetter,\n  defaultTextMapGetter,\n  defaultTextMapSetter,\n} from './propagation/TextMapPropagator';\nexport type { PropagationAPI } from './api/propagation';\n\n// Trace APIs\nexport { SpanAttributes, SpanAttributeValue } from './trace/attributes';\nexport { Link } from './trace/link';\nexport { ProxyTracer, TracerDelegator } from './trace/ProxyTracer';\nexport { ProxyTracerProvider } from './trace/ProxyTracerProvider';\nexport { Sampler } from './trace/Sampler';\nexport { SamplingDecision, SamplingResult } from './trace/SamplingResult';\nexport { SpanContext } from './trace/span_context';\nexport { SpanKind } from './trace/span_kind';\nexport { Span } from './trace/span';\nexport { SpanOptions } from './trace/SpanOptions';\nexport { SpanStatus, SpanStatusCode } from './trace/status';\nexport { TraceFlags } from './trace/trace_flags';\nexport { TraceState } from './trace/trace_state';\nexport { createTraceState } from './trace/internal/utils';\nexport { TracerProvider } from './trace/tracer_provider';\nexport { Tracer } from './trace/tracer';\nexport { TracerOptions } from './trace/tracer_options';\nexport {\n  isSpanContextValid,\n  isValidTraceId,\n  isValidSpanId,\n} from './trace/spancontext-utils';\nexport {\n  INVALID_SPANID,\n  INVALID_TRACEID,\n  INVALID_SPAN_CONTEXT,\n} from './trace/invalid-span-constants';\nexport type { TraceAPI } from './api/trace';\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { context } from './context-api';\nimport { diag } from './diag-api';\nimport { metrics } from './metrics-api';\nimport { propagation } from './propagation-api';\nimport { trace } from './trace-api';\n\n// Named export.\nexport { context, diag, metrics, propagation, trace };\n// Default export.\nexport default {\n  context,\n  diag,\n  metrics,\n  propagation,\n  trace,\n};\n", "'use strict'\n\nconst hasBuffer = typeof Buffer !== 'undefined'\nconst suspectProtoRx = /\"(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])(?:p|\\\\u0070)(?:r|\\\\u0072)(?:o|\\\\u006[Ff])(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])\"\\s*:/\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/\n\nfunction _parse (text, reviver, options) {\n  // Normalize arguments\n  if (options == null) {\n    if (reviver !== null && typeof reviver === 'object') {\n      options = reviver\n      reviver = undefined\n    }\n  }\n\n  if (hasBuffer && Buffer.isBuffer(text)) {\n    text = text.toString()\n  }\n\n  // BOM checker\n  if (text && text.charCodeAt(0) === 0xFEFF) {\n    text = text.slice(1)\n  }\n\n  // Parse normally, allowing exceptions\n  const obj = JSON.parse(text, reviver)\n\n  // Ignore null and non-objects\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  const protoAction = (options && options.protoAction) || 'error'\n  const constructorAction = (options && options.constructorAction) || 'error'\n\n  // options: 'error' (default) / 'remove' / 'ignore'\n  if (protoAction === 'ignore' && constructorAction === 'ignore') {\n    return obj\n  }\n\n  if (protoAction !== 'ignore' && constructorAction !== 'ignore') {\n    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {\n    if (suspectProtoRx.test(text) === false) {\n      return obj\n    }\n  } else {\n    if (suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  }\n\n  // Scan result for proto keys\n  return filter(obj, { protoAction, constructorAction, safe: options && options.safe })\n}\n\nfunction filter (obj, { protoAction = 'error', constructorAction = 'error', safe } = {}) {\n  let next = [obj]\n\n  while (next.length) {\n    const nodes = next\n    next = []\n\n    for (const node of nodes) {\n      if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (protoAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.__proto__ // eslint-disable-line no-proto\n      }\n\n      if (constructorAction !== 'ignore' &&\n          Object.prototype.hasOwnProperty.call(node, 'constructor') &&\n          Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (constructorAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.constructor\n      }\n\n      for (const key in node) {\n        const value = node[key]\n        if (value && typeof value === 'object') {\n          next.push(value)\n        }\n      }\n    }\n  }\n  return obj\n}\n\nfunction parse (text, reviver, options) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, options)\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nfunction safeParse (text, reviver) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, { safe: true })\n  } catch (_e) {\n    return null\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nmodule.exports = parse\nmodule.exports.default = parse\nmodule.exports.parse = parse\nmodule.exports.safeParse = safeParse\nmodule.exports.scan = filter\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"D:\\\\workspace\\\\ai-assistant-scheduler\\\\packages\\\\backend\\\\.wrangler\\\\tmp\\\\bundle-6gYMwA\\\\middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"D:\\\\workspace\\\\ai-assistant-scheduler\\\\node_modules\\\\.pnpm\\\\wrangler@3.114.16_@cloudflare+workers-types@4.20251231.0\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\common.ts\";\nimport type { WorkerEntrypointConstructor } from \"D:\\\\workspace\\\\ai-assistant-scheduler\\\\packages\\\\backend\\\\.wrangler\\\\tmp\\\\bundle-6gYMwA\\\\middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"D:\\\\workspace\\\\ai-assistant-scheduler\\\\packages\\\\backend\\\\.wrangler\\\\tmp\\\\bundle-6gYMwA\\\\middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"D:\\\\workspace\\\\ai-assistant-scheduler\\\\packages\\\\backend\\\\src\\\\index.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"D:\\\\workspace\\\\ai-assistant-scheduler\\\\node_modules\\\\.pnpm\\\\wrangler@3.114.16_@cloudflare+workers-types@4.20251231.0\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"D:\\\\workspace\\\\ai-assistant-scheduler\\\\node_modules\\\\.pnpm\\\\wrangler@3.114.16_@cloudflare+workers-types@4.20251231.0\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"D:\\\\workspace\\\\ai-assistant-scheduler\\\\packages\\\\backend\\\\src\\\\index.ts\";\n\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "import { Hono } from \"hono\";\nimport { cors } from \"hono/cors\";\nimport { apiRoutes } from \"./route\";\n\ntype Bindings = {\n  DB: D1Database;\n  OPENROUTER_API_KEY: string;\n  FRONTEND_URL?: string;\n};\n\nconst app = new Hono<{ Bindings: Bindings }>();\n\n// CORS\u8A2D\u5B9A\napp.use(\n  \"*\",\n  cors({\n    origin: (origin, c) => {\n      const frontendUrl = c.env.FRONTEND_URL || \"http://localhost:5173\";\n      return origin === frontendUrl ? origin : frontendUrl;\n    },\n    allowMethods: [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"],\n    allowHeaders: [\"Content-Type\"],\n  })\n);\n\n// \u30D8\u30EB\u30B9\u30C1\u30A7\u30C3\u30AF\napp.get(\"/health\", (c) => {\n  return c.json({ status: \"ok\" });\n});\n\n// API\u30EB\u30FC\u30C8\napp.route(\"/api\", apiRoutes);\n\nexport default app;\n", "// src/index.ts\nimport { Hono } from \"./hono.js\";\nexport {\n  Hono\n};\n", "// src/hono.ts\nimport { HonoBase } from \"./hono-base.js\";\nimport { RegExpRouter } from \"./router/reg-exp-router/index.js\";\nimport { SmartRouter } from \"./router/smart-router/index.js\";\nimport { TrieRouter } from \"./router/trie-router/index.js\";\nvar Hono = class extends HonoBase {\n  /**\n   * Creates an instance of the Hono class.\n   *\n   * @param options - Optional configuration options for the Hono instance.\n   */\n  constructor(options = {}) {\n    super(options);\n    this.router = options.router ?? new SmartRouter({\n      routers: [new RegExpRouter(), new TrieRouter()]\n    });\n  }\n};\nexport {\n  Hono\n};\n", "// src/hono-base.ts\nimport { compose } from \"./compose.js\";\nimport { Context } from \"./context.js\";\nimport { METHODS, METHOD_NAME_ALL, METHOD_NAME_ALL_LOWERCASE } from \"./router.js\";\nimport { COMPOSED_HANDLER } from \"./utils/constants.js\";\nimport { getPath, getPathNoStrict, mergePath } from \"./utils/url.js\";\nvar notFoundHandler = (c) => {\n  return c.text(\"404 Not Found\", 404);\n};\nvar errorHandler = (err, c) => {\n  if (\"getResponse\" in err) {\n    const res = err.getResponse();\n    return c.newResponse(res.body, res);\n  }\n  console.error(err);\n  return c.text(\"Internal Server Error\", 500);\n};\nvar Hono = class _Hono {\n  get;\n  post;\n  put;\n  delete;\n  options;\n  patch;\n  all;\n  on;\n  use;\n  /*\n    This class is like an abstract class and does not have a router.\n    To use it, inherit the class and implement router in the constructor.\n  */\n  router;\n  getPath;\n  // Cannot use `#` because it requires visibility at JavaScript runtime.\n  _basePath = \"/\";\n  #path = \"/\";\n  routes = [];\n  constructor(options = {}) {\n    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];\n    allMethods.forEach((method) => {\n      this[method] = (args1, ...args) => {\n        if (typeof args1 === \"string\") {\n          this.#path = args1;\n        } else {\n          this.#addRoute(method, this.#path, args1);\n        }\n        args.forEach((handler) => {\n          this.#addRoute(method, this.#path, handler);\n        });\n        return this;\n      };\n    });\n    this.on = (method, path, ...handlers) => {\n      for (const p of [path].flat()) {\n        this.#path = p;\n        for (const m of [method].flat()) {\n          handlers.map((handler) => {\n            this.#addRoute(m.toUpperCase(), this.#path, handler);\n          });\n        }\n      }\n      return this;\n    };\n    this.use = (arg1, ...handlers) => {\n      if (typeof arg1 === \"string\") {\n        this.#path = arg1;\n      } else {\n        this.#path = \"*\";\n        handlers.unshift(arg1);\n      }\n      handlers.forEach((handler) => {\n        this.#addRoute(METHOD_NAME_ALL, this.#path, handler);\n      });\n      return this;\n    };\n    const { strict, ...optionsWithoutStrict } = options;\n    Object.assign(this, optionsWithoutStrict);\n    this.getPath = strict ?? true ? options.getPath ?? getPath : getPathNoStrict;\n  }\n  #clone() {\n    const clone = new _Hono({\n      router: this.router,\n      getPath: this.getPath\n    });\n    clone.errorHandler = this.errorHandler;\n    clone.#notFoundHandler = this.#notFoundHandler;\n    clone.routes = this.routes;\n    return clone;\n  }\n  #notFoundHandler = notFoundHandler;\n  // Cannot use `#` because it requires visibility at JavaScript runtime.\n  errorHandler = errorHandler;\n  /**\n   * `.route()` allows grouping other Hono instance in routes.\n   *\n   * @see {@link https://hono.dev/docs/api/routing#grouping}\n   *\n   * @param {string} path - base Path\n   * @param {Hono} app - other Hono instance\n   * @returns {Hono} routed Hono instance\n   *\n   * @example\n   * ```ts\n   * const app = new Hono()\n   * const app2 = new Hono()\n   *\n   * app2.get(\"/user\", (c) => c.text(\"user\"))\n   * app.route(\"/api\", app2) // GET /api/user\n   * ```\n   */\n  route(path, app) {\n    const subApp = this.basePath(path);\n    app.routes.map((r) => {\n      let handler;\n      if (app.errorHandler === errorHandler) {\n        handler = r.handler;\n      } else {\n        handler = async (c, next) => (await compose([], app.errorHandler)(c, () => r.handler(c, next))).res;\n        handler[COMPOSED_HANDLER] = r.handler;\n      }\n      subApp.#addRoute(r.method, r.path, handler);\n    });\n    return this;\n  }\n  /**\n   * `.basePath()` allows base paths to be specified.\n   *\n   * @see {@link https://hono.dev/docs/api/routing#base-path}\n   *\n   * @param {string} path - base Path\n   * @returns {Hono} changed Hono instance\n   *\n   * @example\n   * ```ts\n   * const api = new Hono().basePath('/api')\n   * ```\n   */\n  basePath(path) {\n    const subApp = this.#clone();\n    subApp._basePath = mergePath(this._basePath, path);\n    return subApp;\n  }\n  /**\n   * `.onError()` handles an error and returns a customized Response.\n   *\n   * @see {@link https://hono.dev/docs/api/hono#error-handling}\n   *\n   * @param {ErrorHandler} handler - request Handler for error\n   * @returns {Hono} changed Hono instance\n   *\n   * @example\n   * ```ts\n   * app.onError((err, c) => {\n   *   console.error(`${err}`)\n   *   return c.text('Custom Error Message', 500)\n   * })\n   * ```\n   */\n  onError = (handler) => {\n    this.errorHandler = handler;\n    return this;\n  };\n  /**\n   * `.notFound()` allows you to customize a Not Found Response.\n   *\n   * @see {@link https://hono.dev/docs/api/hono#not-found}\n   *\n   * @param {NotFoundHandler} handler - request handler for not-found\n   * @returns {Hono} changed Hono instance\n   *\n   * @example\n   * ```ts\n   * app.notFound((c) => {\n   *   return c.text('Custom 404 Message', 404)\n   * })\n   * ```\n   */\n  notFound = (handler) => {\n    this.#notFoundHandler = handler;\n    return this;\n  };\n  /**\n   * `.mount()` allows you to mount applications built with other frameworks into your Hono application.\n   *\n   * @see {@link https://hono.dev/docs/api/hono#mount}\n   *\n   * @param {string} path - base Path\n   * @param {Function} applicationHandler - other Request Handler\n   * @param {MountOptions} [options] - options of `.mount()`\n   * @returns {Hono} mounted Hono instance\n   *\n   * @example\n   * ```ts\n   * import { Router as IttyRouter } from 'itty-router'\n   * import { Hono } from 'hono'\n   * // Create itty-router application\n   * const ittyRouter = IttyRouter()\n   * // GET /itty-router/hello\n   * ittyRouter.get('/hello', () => new Response('Hello from itty-router'))\n   *\n   * const app = new Hono()\n   * app.mount('/itty-router', ittyRouter.handle)\n   * ```\n   *\n   * @example\n   * ```ts\n   * const app = new Hono()\n   * // Send the request to another application without modification.\n   * app.mount('/app', anotherApp, {\n   *   replaceRequest: (req) => req,\n   * })\n   * ```\n   */\n  mount(path, applicationHandler, options) {\n    let replaceRequest;\n    let optionHandler;\n    if (options) {\n      if (typeof options === \"function\") {\n        optionHandler = options;\n      } else {\n        optionHandler = options.optionHandler;\n        if (options.replaceRequest === false) {\n          replaceRequest = (request) => request;\n        } else {\n          replaceRequest = options.replaceRequest;\n        }\n      }\n    }\n    const getOptions = optionHandler ? (c) => {\n      const options2 = optionHandler(c);\n      return Array.isArray(options2) ? options2 : [options2];\n    } : (c) => {\n      let executionContext = void 0;\n      try {\n        executionContext = c.executionCtx;\n      } catch {\n      }\n      return [c.env, executionContext];\n    };\n    replaceRequest ||= (() => {\n      const mergedPath = mergePath(this._basePath, path);\n      const pathPrefixLength = mergedPath === \"/\" ? 0 : mergedPath.length;\n      return (request) => {\n        const url = new URL(request.url);\n        url.pathname = url.pathname.slice(pathPrefixLength) || \"/\";\n        return new Request(url, request);\n      };\n    })();\n    const handler = async (c, next) => {\n      const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));\n      if (res) {\n        return res;\n      }\n      await next();\n    };\n    this.#addRoute(METHOD_NAME_ALL, mergePath(path, \"*\"), handler);\n    return this;\n  }\n  #addRoute(method, path, handler) {\n    method = method.toUpperCase();\n    path = mergePath(this._basePath, path);\n    const r = { basePath: this._basePath, path, method, handler };\n    this.router.add(method, path, [handler, r]);\n    this.routes.push(r);\n  }\n  #handleError(err, c) {\n    if (err instanceof Error) {\n      return this.errorHandler(err, c);\n    }\n    throw err;\n  }\n  #dispatch(request, executionCtx, env, method) {\n    if (method === \"HEAD\") {\n      return (async () => new Response(null, await this.#dispatch(request, executionCtx, env, \"GET\")))();\n    }\n    const path = this.getPath(request, { env });\n    const matchResult = this.router.match(method, path);\n    const c = new Context(request, {\n      path,\n      matchResult,\n      env,\n      executionCtx,\n      notFoundHandler: this.#notFoundHandler\n    });\n    if (matchResult[0].length === 1) {\n      let res;\n      try {\n        res = matchResult[0][0][0][0](c, async () => {\n          c.res = await this.#notFoundHandler(c);\n        });\n      } catch (err) {\n        return this.#handleError(err, c);\n      }\n      return res instanceof Promise ? res.then(\n        (resolved) => resolved || (c.finalized ? c.res : this.#notFoundHandler(c))\n      ).catch((err) => this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);\n    }\n    const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);\n    return (async () => {\n      try {\n        const context = await composed(c);\n        if (!context.finalized) {\n          throw new Error(\n            \"Context is not finalized. Did you forget to return a Response object or `await next()`?\"\n          );\n        }\n        return context.res;\n      } catch (err) {\n        return this.#handleError(err, c);\n      }\n    })();\n  }\n  /**\n   * `.fetch()` will be entry point of your app.\n   *\n   * @see {@link https://hono.dev/docs/api/hono#fetch}\n   *\n   * @param {Request} request - request Object of request\n   * @param {Env} Env - env Object\n   * @param {ExecutionContext} - context of execution\n   * @returns {Response | Promise<Response>} response of request\n   *\n   */\n  fetch = (request, ...rest) => {\n    return this.#dispatch(request, rest[1], rest[0], request.method);\n  };\n  /**\n   * `.request()` is a useful method for testing.\n   * You can pass a URL or pathname to send a GET request.\n   * app will return a Response object.\n   * ```ts\n   * test('GET /hello is ok', async () => {\n   *   const res = await app.request('/hello')\n   *   expect(res.status).toBe(200)\n   * })\n   * ```\n   * @see https://hono.dev/docs/api/hono#request\n   */\n  request = (input, requestInit, Env, executionCtx) => {\n    if (input instanceof Request) {\n      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);\n    }\n    input = input.toString();\n    return this.fetch(\n      new Request(\n        /^https?:\\/\\//.test(input) ? input : `http://localhost${mergePath(\"/\", input)}`,\n        requestInit\n      ),\n      Env,\n      executionCtx\n    );\n  };\n  /**\n   * `.fire()` automatically adds a global fetch event listener.\n   * This can be useful for environments that adhere to the Service Worker API, such as non-ES module Cloudflare Workers.\n   * @deprecated\n   * Use `fire` from `hono/service-worker` instead.\n   * ```ts\n   * import { Hono } from 'hono'\n   * import { fire } from 'hono/service-worker'\n   *\n   * const app = new Hono()\n   * // ...\n   * fire(app)\n   * ```\n   * @see https://hono.dev/docs/api/hono#fire\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API\n   * @see https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/\n   */\n  fire = () => {\n    addEventListener(\"fetch\", (event) => {\n      event.respondWith(this.#dispatch(event.request, event, void 0, event.request.method));\n    });\n  };\n};\nexport {\n  Hono as HonoBase\n};\n", "// src/compose.ts\nvar compose = (middleware, onError, onNotFound) => {\n  return (context, next) => {\n    let index = -1;\n    return dispatch(0);\n    async function dispatch(i) {\n      if (i <= index) {\n        throw new Error(\"next() called multiple times\");\n      }\n      index = i;\n      let res;\n      let isError = false;\n      let handler;\n      if (middleware[i]) {\n        handler = middleware[i][0][0];\n        context.req.routeIndex = i;\n      } else {\n        handler = i === middleware.length && next || void 0;\n      }\n      if (handler) {\n        try {\n          res = await handler(context, () => dispatch(i + 1));\n        } catch (err) {\n          if (err instanceof Error && onError) {\n            context.error = err;\n            res = await onError(err, context);\n            isError = true;\n          } else {\n            throw err;\n          }\n        }\n      } else {\n        if (context.finalized === false && onNotFound) {\n          res = await onNotFound(context);\n        }\n      }\n      if (res && (context.finalized === false || isError)) {\n        context.res = res;\n      }\n      return context;\n    }\n  };\n};\nexport {\n  compose\n};\n", "// src/context.ts\nimport { HonoRequest } from \"./request.js\";\nimport { HtmlEscapedCallbackPhase, resolveCallback } from \"./utils/html.js\";\nvar TEXT_PLAIN = \"text/plain; charset=UTF-8\";\nvar setDefaultContentType = (contentType, headers) => {\n  return {\n    \"Content-Type\": contentType,\n    ...headers\n  };\n};\nvar Context = class {\n  #rawRequest;\n  #req;\n  /**\n   * `.env` can get bindings (environment variables, secrets, KV namespaces, D1 database, R2 bucket etc.) in Cloudflare Workers.\n   *\n   * @see {@link https://hono.dev/docs/api/context#env}\n   *\n   * @example\n   * ```ts\n   * // Environment object for Cloudflare Workers\n   * app.get('*', async c => {\n   *   const counter = c.env.COUNTER\n   * })\n   * ```\n   */\n  env = {};\n  #var;\n  finalized = false;\n  /**\n   * `.error` can get the error object from the middleware if the Handler throws an error.\n   *\n   * @see {@link https://hono.dev/docs/api/context#error}\n   *\n   * @example\n   * ```ts\n   * app.use('*', async (c, next) => {\n   *   await next()\n   *   if (c.error) {\n   *     // do something...\n   *   }\n   * })\n   * ```\n   */\n  error;\n  #status;\n  #executionCtx;\n  #res;\n  #layout;\n  #renderer;\n  #notFoundHandler;\n  #preparedHeaders;\n  #matchResult;\n  #path;\n  /**\n   * Creates an instance of the Context class.\n   *\n   * @param req - The Request object.\n   * @param options - Optional configuration options for the context.\n   */\n  constructor(req, options) {\n    this.#rawRequest = req;\n    if (options) {\n      this.#executionCtx = options.executionCtx;\n      this.env = options.env;\n      this.#notFoundHandler = options.notFoundHandler;\n      this.#path = options.path;\n      this.#matchResult = options.matchResult;\n    }\n  }\n  /**\n   * `.req` is the instance of {@link HonoRequest}.\n   */\n  get req() {\n    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);\n    return this.#req;\n  }\n  /**\n   * @see {@link https://hono.dev/docs/api/context#event}\n   * The FetchEvent associated with the current request.\n   *\n   * @throws Will throw an error if the context does not have a FetchEvent.\n   */\n  get event() {\n    if (this.#executionCtx && \"respondWith\" in this.#executionCtx) {\n      return this.#executionCtx;\n    } else {\n      throw Error(\"This context has no FetchEvent\");\n    }\n  }\n  /**\n   * @see {@link https://hono.dev/docs/api/context#executionctx}\n   * The ExecutionContext associated with the current request.\n   *\n   * @throws Will throw an error if the context does not have an ExecutionContext.\n   */\n  get executionCtx() {\n    if (this.#executionCtx) {\n      return this.#executionCtx;\n    } else {\n      throw Error(\"This context has no ExecutionContext\");\n    }\n  }\n  /**\n   * @see {@link https://hono.dev/docs/api/context#res}\n   * The Response object for the current request.\n   */\n  get res() {\n    return this.#res ||= new Response(null, {\n      headers: this.#preparedHeaders ??= new Headers()\n    });\n  }\n  /**\n   * Sets the Response object for the current request.\n   *\n   * @param _res - The Response object to set.\n   */\n  set res(_res) {\n    if (this.#res && _res) {\n      _res = new Response(_res.body, _res);\n      for (const [k, v] of this.#res.headers.entries()) {\n        if (k === \"content-type\") {\n          continue;\n        }\n        if (k === \"set-cookie\") {\n          const cookies = this.#res.headers.getSetCookie();\n          _res.headers.delete(\"set-cookie\");\n          for (const cookie of cookies) {\n            _res.headers.append(\"set-cookie\", cookie);\n          }\n        } else {\n          _res.headers.set(k, v);\n        }\n      }\n    }\n    this.#res = _res;\n    this.finalized = true;\n  }\n  /**\n   * `.render()` can create a response within a layout.\n   *\n   * @see {@link https://hono.dev/docs/api/context#render-setrenderer}\n   *\n   * @example\n   * ```ts\n   * app.get('/', (c) => {\n   *   return c.render('Hello!')\n   * })\n   * ```\n   */\n  render = (...args) => {\n    this.#renderer ??= (content) => this.html(content);\n    return this.#renderer(...args);\n  };\n  /**\n   * Sets the layout for the response.\n   *\n   * @param layout - The layout to set.\n   * @returns The layout function.\n   */\n  setLayout = (layout) => this.#layout = layout;\n  /**\n   * Gets the current layout for the response.\n   *\n   * @returns The current layout function.\n   */\n  getLayout = () => this.#layout;\n  /**\n   * `.setRenderer()` can set the layout in the custom middleware.\n   *\n   * @see {@link https://hono.dev/docs/api/context#render-setrenderer}\n   *\n   * @example\n   * ```tsx\n   * app.use('*', async (c, next) => {\n   *   c.setRenderer((content) => {\n   *     return c.html(\n   *       <html>\n   *         <body>\n   *           <p>{content}</p>\n   *         </body>\n   *       </html>\n   *     )\n   *   })\n   *   await next()\n   * })\n   * ```\n   */\n  setRenderer = (renderer) => {\n    this.#renderer = renderer;\n  };\n  /**\n   * `.header()` can set headers.\n   *\n   * @see {@link https://hono.dev/docs/api/context#header}\n   *\n   * @example\n   * ```ts\n   * app.get('/welcome', (c) => {\n   *   // Set headers\n   *   c.header('X-Message', 'Hello!')\n   *   c.header('Content-Type', 'text/plain')\n   *\n   *   return c.body('Thank you for coming')\n   * })\n   * ```\n   */\n  header = (name, value, options) => {\n    if (this.finalized) {\n      this.#res = new Response(this.#res.body, this.#res);\n    }\n    const headers = this.#res ? this.#res.headers : this.#preparedHeaders ??= new Headers();\n    if (value === void 0) {\n      headers.delete(name);\n    } else if (options?.append) {\n      headers.append(name, value);\n    } else {\n      headers.set(name, value);\n    }\n  };\n  status = (status) => {\n    this.#status = status;\n  };\n  /**\n   * `.set()` can set the value specified by the key.\n   *\n   * @see {@link https://hono.dev/docs/api/context#set-get}\n   *\n   * @example\n   * ```ts\n   * app.use('*', async (c, next) => {\n   *   c.set('message', 'Hono is hot!!')\n   *   await next()\n   * })\n   * ```\n   */\n  set = (key, value) => {\n    this.#var ??= /* @__PURE__ */ new Map();\n    this.#var.set(key, value);\n  };\n  /**\n   * `.get()` can use the value specified by the key.\n   *\n   * @see {@link https://hono.dev/docs/api/context#set-get}\n   *\n   * @example\n   * ```ts\n   * app.get('/', (c) => {\n   *   const message = c.get('message')\n   *   return c.text(`The message is \"${message}\"`)\n   * })\n   * ```\n   */\n  get = (key) => {\n    return this.#var ? this.#var.get(key) : void 0;\n  };\n  /**\n   * `.var` can access the value of a variable.\n   *\n   * @see {@link https://hono.dev/docs/api/context#var}\n   *\n   * @example\n   * ```ts\n   * const result = c.var.client.oneMethod()\n   * ```\n   */\n  // c.var.propName is a read-only\n  get var() {\n    if (!this.#var) {\n      return {};\n    }\n    return Object.fromEntries(this.#var);\n  }\n  #newResponse(data, arg, headers) {\n    const responseHeaders = this.#res ? new Headers(this.#res.headers) : this.#preparedHeaders ?? new Headers();\n    if (typeof arg === \"object\" && \"headers\" in arg) {\n      const argHeaders = arg.headers instanceof Headers ? arg.headers : new Headers(arg.headers);\n      for (const [key, value] of argHeaders) {\n        if (key.toLowerCase() === \"set-cookie\") {\n          responseHeaders.append(key, value);\n        } else {\n          responseHeaders.set(key, value);\n        }\n      }\n    }\n    if (headers) {\n      for (const [k, v] of Object.entries(headers)) {\n        if (typeof v === \"string\") {\n          responseHeaders.set(k, v);\n        } else {\n          responseHeaders.delete(k);\n          for (const v2 of v) {\n            responseHeaders.append(k, v2);\n          }\n        }\n      }\n    }\n    const status = typeof arg === \"number\" ? arg : arg?.status ?? this.#status;\n    return new Response(data, { status, headers: responseHeaders });\n  }\n  newResponse = (...args) => this.#newResponse(...args);\n  /**\n   * `.body()` can return the HTTP response.\n   * You can set headers with `.header()` and set HTTP status code with `.status`.\n   * This can also be set in `.text()`, `.json()` and so on.\n   *\n   * @see {@link https://hono.dev/docs/api/context#body}\n   *\n   * @example\n   * ```ts\n   * app.get('/welcome', (c) => {\n   *   // Set headers\n   *   c.header('X-Message', 'Hello!')\n   *   c.header('Content-Type', 'text/plain')\n   *   // Set HTTP status code\n   *   c.status(201)\n   *\n   *   // Return the response body\n   *   return c.body('Thank you for coming')\n   * })\n   * ```\n   */\n  body = (data, arg, headers) => this.#newResponse(data, arg, headers);\n  /**\n   * `.text()` can render text as `Content-Type:text/plain`.\n   *\n   * @see {@link https://hono.dev/docs/api/context#text}\n   *\n   * @example\n   * ```ts\n   * app.get('/say', (c) => {\n   *   return c.text('Hello!')\n   * })\n   * ```\n   */\n  text = (text, arg, headers) => {\n    return !this.#preparedHeaders && !this.#status && !arg && !headers && !this.finalized ? new Response(text) : this.#newResponse(\n      text,\n      arg,\n      setDefaultContentType(TEXT_PLAIN, headers)\n    );\n  };\n  /**\n   * `.json()` can render JSON as `Content-Type:application/json`.\n   *\n   * @see {@link https://hono.dev/docs/api/context#json}\n   *\n   * @example\n   * ```ts\n   * app.get('/api', (c) => {\n   *   return c.json({ message: 'Hello!' })\n   * })\n   * ```\n   */\n  json = (object, arg, headers) => {\n    return this.#newResponse(\n      JSON.stringify(object),\n      arg,\n      setDefaultContentType(\"application/json\", headers)\n    );\n  };\n  html = (html, arg, headers) => {\n    const res = (html2) => this.#newResponse(html2, arg, setDefaultContentType(\"text/html; charset=UTF-8\", headers));\n    return typeof html === \"object\" ? resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then(res) : res(html);\n  };\n  /**\n   * `.redirect()` can Redirect, default status code is 302.\n   *\n   * @see {@link https://hono.dev/docs/api/context#redirect}\n   *\n   * @example\n   * ```ts\n   * app.get('/redirect', (c) => {\n   *   return c.redirect('/')\n   * })\n   * app.get('/redirect-permanently', (c) => {\n   *   return c.redirect('/', 301)\n   * })\n   * ```\n   */\n  redirect = (location, status) => {\n    const locationString = String(location);\n    this.header(\n      \"Location\",\n      // Multibyes should be encoded\n      // eslint-disable-next-line no-control-regex\n      !/[^\\x00-\\xFF]/.test(locationString) ? locationString : encodeURI(locationString)\n    );\n    return this.newResponse(null, status ?? 302);\n  };\n  /**\n   * `.notFound()` can return the Not Found Response.\n   *\n   * @see {@link https://hono.dev/docs/api/context#notfound}\n   *\n   * @example\n   * ```ts\n   * app.get('/notfound', (c) => {\n   *   return c.notFound()\n   * })\n   * ```\n   */\n  notFound = () => {\n    this.#notFoundHandler ??= () => new Response();\n    return this.#notFoundHandler(this);\n  };\n};\nexport {\n  Context,\n  TEXT_PLAIN\n};\n", "// src/request.ts\nimport { HTTPException } from \"./http-exception.js\";\nimport { GET_MATCH_RESULT } from \"./request/constants.js\";\nimport { parseBody } from \"./utils/body.js\";\nimport { decodeURIComponent_, getQueryParam, getQueryParams, tryDecode } from \"./utils/url.js\";\nvar tryDecodeURIComponent = (str) => tryDecode(str, decodeURIComponent_);\nvar HonoRequest = class {\n  /**\n   * `.raw` can get the raw Request object.\n   *\n   * @see {@link https://hono.dev/docs/api/request#raw}\n   *\n   * @example\n   * ```ts\n   * // For Cloudflare Workers\n   * app.post('/', async (c) => {\n   *   const metadata = c.req.raw.cf?.hostMetadata?\n   *   ...\n   * })\n   * ```\n   */\n  raw;\n  #validatedData;\n  // Short name of validatedData\n  #matchResult;\n  routeIndex = 0;\n  /**\n   * `.path` can get the pathname of the request.\n   *\n   * @see {@link https://hono.dev/docs/api/request#path}\n   *\n   * @example\n   * ```ts\n   * app.get('/about/me', (c) => {\n   *   const pathname = c.req.path // `/about/me`\n   * })\n   * ```\n   */\n  path;\n  bodyCache = {};\n  constructor(request, path = \"/\", matchResult = [[]]) {\n    this.raw = request;\n    this.path = path;\n    this.#matchResult = matchResult;\n    this.#validatedData = {};\n  }\n  param(key) {\n    return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();\n  }\n  #getDecodedParam(key) {\n    const paramKey = this.#matchResult[0][this.routeIndex][1][key];\n    const param = this.#getParamValue(paramKey);\n    return param && /\\%/.test(param) ? tryDecodeURIComponent(param) : param;\n  }\n  #getAllDecodedParams() {\n    const decoded = {};\n    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);\n    for (const key of keys) {\n      const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);\n      if (value !== void 0) {\n        decoded[key] = /\\%/.test(value) ? tryDecodeURIComponent(value) : value;\n      }\n    }\n    return decoded;\n  }\n  #getParamValue(paramKey) {\n    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;\n  }\n  query(key) {\n    return getQueryParam(this.url, key);\n  }\n  queries(key) {\n    return getQueryParams(this.url, key);\n  }\n  header(name) {\n    if (name) {\n      return this.raw.headers.get(name) ?? void 0;\n    }\n    const headerData = {};\n    this.raw.headers.forEach((value, key) => {\n      headerData[key] = value;\n    });\n    return headerData;\n  }\n  async parseBody(options) {\n    return this.bodyCache.parsedBody ??= await parseBody(this, options);\n  }\n  #cachedBody = (key) => {\n    const { bodyCache, raw } = this;\n    const cachedBody = bodyCache[key];\n    if (cachedBody) {\n      return cachedBody;\n    }\n    const anyCachedKey = Object.keys(bodyCache)[0];\n    if (anyCachedKey) {\n      return bodyCache[anyCachedKey].then((body) => {\n        if (anyCachedKey === \"json\") {\n          body = JSON.stringify(body);\n        }\n        return new Response(body)[key]();\n      });\n    }\n    return bodyCache[key] = raw[key]();\n  };\n  /**\n   * `.json()` can parse Request body of type `application/json`\n   *\n   * @see {@link https://hono.dev/docs/api/request#json}\n   *\n   * @example\n   * ```ts\n   * app.post('/entry', async (c) => {\n   *   const body = await c.req.json()\n   * })\n   * ```\n   */\n  json() {\n    return this.#cachedBody(\"text\").then((text) => JSON.parse(text));\n  }\n  /**\n   * `.text()` can parse Request body of type `text/plain`\n   *\n   * @see {@link https://hono.dev/docs/api/request#text}\n   *\n   * @example\n   * ```ts\n   * app.post('/entry', async (c) => {\n   *   const body = await c.req.text()\n   * })\n   * ```\n   */\n  text() {\n    return this.#cachedBody(\"text\");\n  }\n  /**\n   * `.arrayBuffer()` parse Request body as an `ArrayBuffer`\n   *\n   * @see {@link https://hono.dev/docs/api/request#arraybuffer}\n   *\n   * @example\n   * ```ts\n   * app.post('/entry', async (c) => {\n   *   const body = await c.req.arrayBuffer()\n   * })\n   * ```\n   */\n  arrayBuffer() {\n    return this.#cachedBody(\"arrayBuffer\");\n  }\n  /**\n   * Parses the request body as a `Blob`.\n   * @example\n   * ```ts\n   * app.post('/entry', async (c) => {\n   *   const body = await c.req.blob();\n   * });\n   * ```\n   * @see https://hono.dev/docs/api/request#blob\n   */\n  blob() {\n    return this.#cachedBody(\"blob\");\n  }\n  /**\n   * Parses the request body as `FormData`.\n   * @example\n   * ```ts\n   * app.post('/entry', async (c) => {\n   *   const body = await c.req.formData();\n   * });\n   * ```\n   * @see https://hono.dev/docs/api/request#formdata\n   */\n  formData() {\n    return this.#cachedBody(\"formData\");\n  }\n  /**\n   * Adds validated data to the request.\n   *\n   * @param target - The target of the validation.\n   * @param data - The validated data to add.\n   */\n  addValidatedData(target, data) {\n    this.#validatedData[target] = data;\n  }\n  valid(target) {\n    return this.#validatedData[target];\n  }\n  /**\n   * `.url()` can get the request url strings.\n   *\n   * @see {@link https://hono.dev/docs/api/request#url}\n   *\n   * @example\n   * ```ts\n   * app.get('/about/me', (c) => {\n   *   const url = c.req.url // `http://localhost:8787/about/me`\n   *   ...\n   * })\n   * ```\n   */\n  get url() {\n    return this.raw.url;\n  }\n  /**\n   * `.method()` can get the method name of the request.\n   *\n   * @see {@link https://hono.dev/docs/api/request#method}\n   *\n   * @example\n   * ```ts\n   * app.get('/about/me', (c) => {\n   *   const method = c.req.method // `GET`\n   * })\n   * ```\n   */\n  get method() {\n    return this.raw.method;\n  }\n  get [GET_MATCH_RESULT]() {\n    return this.#matchResult;\n  }\n  /**\n   * `.matchedRoutes()` can return a matched route in the handler\n   *\n   * @deprecated\n   *\n   * Use matchedRoutes helper defined in \"hono/route\" instead.\n   *\n   * @see {@link https://hono.dev/docs/api/request#matchedroutes}\n   *\n   * @example\n   * ```ts\n   * app.use('*', async function logger(c, next) {\n   *   await next()\n   *   c.req.matchedRoutes.forEach(({ handler, method, path }, i) => {\n   *     const name = handler.name || (handler.length < 2 ? '[handler]' : '[middleware]')\n   *     console.log(\n   *       method,\n   *       ' ',\n   *       path,\n   *       ' '.repeat(Math.max(10 - path.length, 0)),\n   *       name,\n   *       i === c.req.routeIndex ? '<- respond from here' : ''\n   *     )\n   *   })\n   * })\n   * ```\n   */\n  get matchedRoutes() {\n    return this.#matchResult[0].map(([[, route]]) => route);\n  }\n  /**\n   * `routePath()` can retrieve the path registered within the handler\n   *\n   * @deprecated\n   *\n   * Use routePath helper defined in \"hono/route\" instead.\n   *\n   * @see {@link https://hono.dev/docs/api/request#routepath}\n   *\n   * @example\n   * ```ts\n   * app.get('/posts/:id', (c) => {\n   *   return c.json({ path: c.req.routePath })\n   * })\n   * ```\n   */\n  get routePath() {\n    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;\n  }\n};\nvar cloneRawRequest = async (req) => {\n  if (!req.raw.bodyUsed) {\n    return req.raw.clone();\n  }\n  const cacheKey = Object.keys(req.bodyCache)[0];\n  if (!cacheKey) {\n    throw new HTTPException(500, {\n      message: \"Cannot clone request: body was already consumed and not cached. Please use HonoRequest methods (e.g., req.json(), req.text()) instead of consuming req.raw directly.\"\n    });\n  }\n  const requestInit = {\n    body: await req[cacheKey](),\n    cache: req.raw.cache,\n    credentials: req.raw.credentials,\n    headers: req.header(),\n    integrity: req.raw.integrity,\n    keepalive: req.raw.keepalive,\n    method: req.method,\n    mode: req.raw.mode,\n    redirect: req.raw.redirect,\n    referrer: req.raw.referrer,\n    referrerPolicy: req.raw.referrerPolicy,\n    signal: req.raw.signal\n  };\n  return new Request(req.url, requestInit);\n};\nexport {\n  HonoRequest,\n  cloneRawRequest\n};\n", "// src/http-exception.ts\nvar HTTPException = class extends Error {\n  res;\n  status;\n  /**\n   * Creates an instance of `HTTPException`.\n   * @param status - HTTP status code for the exception. Defaults to 500.\n   * @param options - Additional options for the exception.\n   */\n  constructor(status = 500, options) {\n    super(options?.message, { cause: options?.cause });\n    this.res = options?.res;\n    this.status = status;\n  }\n  /**\n   * Returns the response object associated with the exception.\n   * If a response object is not provided, a new response is created with the error message and status code.\n   * @returns The response object.\n   */\n  getResponse() {\n    if (this.res) {\n      const newResponse = new Response(this.res.body, {\n        status: this.status,\n        headers: this.res.headers\n      });\n      return newResponse;\n    }\n    return new Response(this.message, {\n      status: this.status\n    });\n  }\n};\nexport {\n  HTTPException\n};\n", "// src/request/constants.ts\nvar GET_MATCH_RESULT = /* @__PURE__ */ Symbol();\nexport {\n  GET_MATCH_RESULT\n};\n", "// src/utils/body.ts\nimport { HonoRequest } from \"../request.js\";\nvar parseBody = async (request, options = /* @__PURE__ */ Object.create(null)) => {\n  const { all = false, dot = false } = options;\n  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;\n  const contentType = headers.get(\"Content-Type\");\n  if (contentType?.startsWith(\"multipart/form-data\") || contentType?.startsWith(\"application/x-www-form-urlencoded\")) {\n    return parseFormData(request, { all, dot });\n  }\n  return {};\n};\nasync function parseFormData(request, options) {\n  const formData = await request.formData();\n  if (formData) {\n    return convertFormDataToBodyData(formData, options);\n  }\n  return {};\n}\nfunction convertFormDataToBodyData(formData, options) {\n  const form = /* @__PURE__ */ Object.create(null);\n  formData.forEach((value, key) => {\n    const shouldParseAllValues = options.all || key.endsWith(\"[]\");\n    if (!shouldParseAllValues) {\n      form[key] = value;\n    } else {\n      handleParsingAllValues(form, key, value);\n    }\n  });\n  if (options.dot) {\n    Object.entries(form).forEach(([key, value]) => {\n      const shouldParseDotValues = key.includes(\".\");\n      if (shouldParseDotValues) {\n        handleParsingNestedValues(form, key, value);\n        delete form[key];\n      }\n    });\n  }\n  return form;\n}\nvar handleParsingAllValues = (form, key, value) => {\n  if (form[key] !== void 0) {\n    if (Array.isArray(form[key])) {\n      ;\n      form[key].push(value);\n    } else {\n      form[key] = [form[key], value];\n    }\n  } else {\n    if (!key.endsWith(\"[]\")) {\n      form[key] = value;\n    } else {\n      form[key] = [value];\n    }\n  }\n};\nvar handleParsingNestedValues = (form, key, value) => {\n  let nestedForm = form;\n  const keys = key.split(\".\");\n  keys.forEach((key2, index) => {\n    if (index === keys.length - 1) {\n      nestedForm[key2] = value;\n    } else {\n      if (!nestedForm[key2] || typeof nestedForm[key2] !== \"object\" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {\n        nestedForm[key2] = /* @__PURE__ */ Object.create(null);\n      }\n      nestedForm = nestedForm[key2];\n    }\n  });\n};\nexport {\n  parseBody\n};\n", "// src/utils/url.ts\nvar splitPath = (path) => {\n  const paths = path.split(\"/\");\n  if (paths[0] === \"\") {\n    paths.shift();\n  }\n  return paths;\n};\nvar splitRoutingPath = (routePath) => {\n  const { groups, path } = extractGroupsFromPath(routePath);\n  const paths = splitPath(path);\n  return replaceGroupMarks(paths, groups);\n};\nvar extractGroupsFromPath = (path) => {\n  const groups = [];\n  path = path.replace(/\\{[^}]+\\}/g, (match, index) => {\n    const mark = `@${index}`;\n    groups.push([mark, match]);\n    return mark;\n  });\n  return { groups, path };\n};\nvar replaceGroupMarks = (paths, groups) => {\n  for (let i = groups.length - 1; i >= 0; i--) {\n    const [mark] = groups[i];\n    for (let j = paths.length - 1; j >= 0; j--) {\n      if (paths[j].includes(mark)) {\n        paths[j] = paths[j].replace(mark, groups[i][1]);\n        break;\n      }\n    }\n  }\n  return paths;\n};\nvar patternCache = {};\nvar getPattern = (label, next) => {\n  if (label === \"*\") {\n    return \"*\";\n  }\n  const match = label.match(/^\\:([^\\{\\}]+)(?:\\{(.+)\\})?$/);\n  if (match) {\n    const cacheKey = `${label}#${next}`;\n    if (!patternCache[cacheKey]) {\n      if (match[2]) {\n        patternCache[cacheKey] = next && next[0] !== \":\" && next[0] !== \"*\" ? [cacheKey, match[1], new RegExp(`^${match[2]}(?=/${next})`)] : [label, match[1], new RegExp(`^${match[2]}$`)];\n      } else {\n        patternCache[cacheKey] = [label, match[1], true];\n      }\n    }\n    return patternCache[cacheKey];\n  }\n  return null;\n};\nvar tryDecode = (str, decoder) => {\n  try {\n    return decoder(str);\n  } catch {\n    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match) => {\n      try {\n        return decoder(match);\n      } catch {\n        return match;\n      }\n    });\n  }\n};\nvar tryDecodeURI = (str) => tryDecode(str, decodeURI);\nvar getPath = (request) => {\n  const url = request.url;\n  const start = url.indexOf(\"/\", url.indexOf(\":\") + 4);\n  let i = start;\n  for (; i < url.length; i++) {\n    const charCode = url.charCodeAt(i);\n    if (charCode === 37) {\n      const queryIndex = url.indexOf(\"?\", i);\n      const path = url.slice(start, queryIndex === -1 ? void 0 : queryIndex);\n      return tryDecodeURI(path.includes(\"%25\") ? path.replace(/%25/g, \"%2525\") : path);\n    } else if (charCode === 63) {\n      break;\n    }\n  }\n  return url.slice(start, i);\n};\nvar getQueryStrings = (url) => {\n  const queryIndex = url.indexOf(\"?\", 8);\n  return queryIndex === -1 ? \"\" : \"?\" + url.slice(queryIndex + 1);\n};\nvar getPathNoStrict = (request) => {\n  const result = getPath(request);\n  return result.length > 1 && result.at(-1) === \"/\" ? result.slice(0, -1) : result;\n};\nvar mergePath = (base, sub, ...rest) => {\n  if (rest.length) {\n    sub = mergePath(sub, ...rest);\n  }\n  return `${base?.[0] === \"/\" ? \"\" : \"/\"}${base}${sub === \"/\" ? \"\" : `${base?.at(-1) === \"/\" ? \"\" : \"/\"}${sub?.[0] === \"/\" ? sub.slice(1) : sub}`}`;\n};\nvar checkOptionalParameter = (path) => {\n  if (path.charCodeAt(path.length - 1) !== 63 || !path.includes(\":\")) {\n    return null;\n  }\n  const segments = path.split(\"/\");\n  const results = [];\n  let basePath = \"\";\n  segments.forEach((segment) => {\n    if (segment !== \"\" && !/\\:/.test(segment)) {\n      basePath += \"/\" + segment;\n    } else if (/\\:/.test(segment)) {\n      if (/\\?/.test(segment)) {\n        if (results.length === 0 && basePath === \"\") {\n          results.push(\"/\");\n        } else {\n          results.push(basePath);\n        }\n        const optionalSegment = segment.replace(\"?\", \"\");\n        basePath += \"/\" + optionalSegment;\n        results.push(basePath);\n      } else {\n        basePath += \"/\" + segment;\n      }\n    }\n  });\n  return results.filter((v, i, a) => a.indexOf(v) === i);\n};\nvar _decodeURI = (value) => {\n  if (!/[%+]/.test(value)) {\n    return value;\n  }\n  if (value.indexOf(\"+\") !== -1) {\n    value = value.replace(/\\+/g, \" \");\n  }\n  return value.indexOf(\"%\") !== -1 ? tryDecode(value, decodeURIComponent_) : value;\n};\nvar _getQueryParam = (url, key, multiple) => {\n  let encoded;\n  if (!multiple && key && !/[%+]/.test(key)) {\n    let keyIndex2 = url.indexOf(\"?\", 8);\n    if (keyIndex2 === -1) {\n      return void 0;\n    }\n    if (!url.startsWith(key, keyIndex2 + 1)) {\n      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);\n    }\n    while (keyIndex2 !== -1) {\n      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);\n      if (trailingKeyCode === 61) {\n        const valueIndex = keyIndex2 + key.length + 2;\n        const endIndex = url.indexOf(\"&\", valueIndex);\n        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));\n      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {\n        return \"\";\n      }\n      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);\n    }\n    encoded = /[%+]/.test(url);\n    if (!encoded) {\n      return void 0;\n    }\n  }\n  const results = {};\n  encoded ??= /[%+]/.test(url);\n  let keyIndex = url.indexOf(\"?\", 8);\n  while (keyIndex !== -1) {\n    const nextKeyIndex = url.indexOf(\"&\", keyIndex + 1);\n    let valueIndex = url.indexOf(\"=\", keyIndex);\n    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {\n      valueIndex = -1;\n    }\n    let name = url.slice(\n      keyIndex + 1,\n      valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex\n    );\n    if (encoded) {\n      name = _decodeURI(name);\n    }\n    keyIndex = nextKeyIndex;\n    if (name === \"\") {\n      continue;\n    }\n    let value;\n    if (valueIndex === -1) {\n      value = \"\";\n    } else {\n      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);\n      if (encoded) {\n        value = _decodeURI(value);\n      }\n    }\n    if (multiple) {\n      if (!(results[name] && Array.isArray(results[name]))) {\n        results[name] = [];\n      }\n      ;\n      results[name].push(value);\n    } else {\n      results[name] ??= value;\n    }\n  }\n  return key ? results[key] : results;\n};\nvar getQueryParam = _getQueryParam;\nvar getQueryParams = (url, key) => {\n  return _getQueryParam(url, key, true);\n};\nvar decodeURIComponent_ = decodeURIComponent;\nexport {\n  checkOptionalParameter,\n  decodeURIComponent_,\n  getPath,\n  getPathNoStrict,\n  getPattern,\n  getQueryParam,\n  getQueryParams,\n  getQueryStrings,\n  mergePath,\n  splitPath,\n  splitRoutingPath,\n  tryDecode\n};\n", "// src/utils/html.ts\nvar HtmlEscapedCallbackPhase = {\n  Stringify: 1,\n  BeforeStream: 2,\n  Stream: 3\n};\nvar raw = (value, callbacks) => {\n  const escapedString = new String(value);\n  escapedString.isEscaped = true;\n  escapedString.callbacks = callbacks;\n  return escapedString;\n};\nvar escapeRe = /[&<>'\"]/;\nvar stringBufferToString = async (buffer, callbacks) => {\n  let str = \"\";\n  callbacks ||= [];\n  const resolvedBuffer = await Promise.all(buffer);\n  for (let i = resolvedBuffer.length - 1; ; i--) {\n    str += resolvedBuffer[i];\n    i--;\n    if (i < 0) {\n      break;\n    }\n    let r = resolvedBuffer[i];\n    if (typeof r === \"object\") {\n      callbacks.push(...r.callbacks || []);\n    }\n    const isEscaped = r.isEscaped;\n    r = await (typeof r === \"object\" ? r.toString() : r);\n    if (typeof r === \"object\") {\n      callbacks.push(...r.callbacks || []);\n    }\n    if (r.isEscaped ?? isEscaped) {\n      str += r;\n    } else {\n      const buf = [str];\n      escapeToBuffer(r, buf);\n      str = buf[0];\n    }\n  }\n  return raw(str, callbacks);\n};\nvar escapeToBuffer = (str, buffer) => {\n  const match = str.search(escapeRe);\n  if (match === -1) {\n    buffer[0] += str;\n    return;\n  }\n  let escape;\n  let index;\n  let lastIndex = 0;\n  for (index = match; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34:\n        escape = \"&quot;\";\n        break;\n      case 39:\n        escape = \"&#39;\";\n        break;\n      case 38:\n        escape = \"&amp;\";\n        break;\n      case 60:\n        escape = \"&lt;\";\n        break;\n      case 62:\n        escape = \"&gt;\";\n        break;\n      default:\n        continue;\n    }\n    buffer[0] += str.substring(lastIndex, index) + escape;\n    lastIndex = index + 1;\n  }\n  buffer[0] += str.substring(lastIndex, index);\n};\nvar resolveCallbackSync = (str) => {\n  const callbacks = str.callbacks;\n  if (!callbacks?.length) {\n    return str;\n  }\n  const buffer = [str];\n  const context = {};\n  callbacks.forEach((c) => c({ phase: HtmlEscapedCallbackPhase.Stringify, buffer, context }));\n  return buffer[0];\n};\nvar resolveCallback = async (str, phase, preserveCallbacks, context, buffer) => {\n  if (typeof str === \"object\" && !(str instanceof String)) {\n    if (!(str instanceof Promise)) {\n      str = str.toString();\n    }\n    if (str instanceof Promise) {\n      str = await str;\n    }\n  }\n  const callbacks = str.callbacks;\n  if (!callbacks?.length) {\n    return Promise.resolve(str);\n  }\n  if (buffer) {\n    buffer[0] += str;\n  } else {\n    buffer = [str];\n  }\n  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context }))).then(\n    (res) => Promise.all(\n      res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))\n    ).then(() => buffer[0])\n  );\n  if (preserveCallbacks) {\n    return raw(await resStr, callbacks);\n  } else {\n    return resStr;\n  }\n};\nexport {\n  HtmlEscapedCallbackPhase,\n  escapeToBuffer,\n  raw,\n  resolveCallback,\n  resolveCallbackSync,\n  stringBufferToString\n};\n", "// src/router.ts\nvar METHOD_NAME_ALL = \"ALL\";\nvar METHOD_NAME_ALL_LOWERCASE = \"all\";\nvar METHODS = [\"get\", \"post\", \"put\", \"delete\", \"options\", \"patch\"];\nvar MESSAGE_MATCHER_IS_ALREADY_BUILT = \"Can not add a route since the matcher is already built.\";\nvar UnsupportedPathError = class extends Error {\n};\nexport {\n  MESSAGE_MATCHER_IS_ALREADY_BUILT,\n  METHODS,\n  METHOD_NAME_ALL,\n  METHOD_NAME_ALL_LOWERCASE,\n  UnsupportedPathError\n};\n", "// src/utils/constants.ts\nvar COMPOSED_HANDLER = \"__COMPOSED_HANDLER\";\nexport {\n  COMPOSED_HANDLER\n};\n", "// src/router/reg-exp-router/index.ts\nimport { RegExpRouter } from \"./router.js\";\nimport { PreparedRegExpRouter, buildInitParams, serializeInitParams } from \"./prepared-router.js\";\nexport {\n  PreparedRegExpRouter,\n  RegExpRouter,\n  buildInitParams,\n  serializeInitParams\n};\n", "// src/router/reg-exp-router/router.ts\nimport {\n  MESSAGE_MATCHER_IS_ALREADY_BUILT,\n  METHOD_NAME_ALL,\n  UnsupportedPathError\n} from \"../../router.js\";\nimport { checkOptionalParameter } from \"../../utils/url.js\";\nimport { match, emptyParam } from \"./matcher.js\";\nimport { PATH_ERROR } from \"./node.js\";\nimport { Trie } from \"./trie.js\";\nvar nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];\nvar wildcardRegExpCache = /* @__PURE__ */ Object.create(null);\nfunction buildWildcardRegExp(path) {\n  return wildcardRegExpCache[path] ??= new RegExp(\n    path === \"*\" ? \"\" : `^${path.replace(\n      /\\/\\*$|([.\\\\+*[^\\]$()])/g,\n      (_, metaChar) => metaChar ? `\\\\${metaChar}` : \"(?:|/.*)\"\n    )}$`\n  );\n}\nfunction clearWildcardRegExpCache() {\n  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);\n}\nfunction buildMatcherFromPreprocessedRoutes(routes) {\n  const trie = new Trie();\n  const handlerData = [];\n  if (routes.length === 0) {\n    return nullMatcher;\n  }\n  const routesWithStaticPathFlag = routes.map(\n    (route) => [!/\\*|\\/:/.test(route[0]), ...route]\n  ).sort(\n    ([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length\n  );\n  const staticMap = /* @__PURE__ */ Object.create(null);\n  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length; i < len; i++) {\n    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];\n    if (pathErrorCheckOnly) {\n      staticMap[path] = [handlers.map(([h]) => [h, /* @__PURE__ */ Object.create(null)]), emptyParam];\n    } else {\n      j++;\n    }\n    let paramAssoc;\n    try {\n      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);\n    } catch (e) {\n      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;\n    }\n    if (pathErrorCheckOnly) {\n      continue;\n    }\n    handlerData[j] = handlers.map(([h, paramCount]) => {\n      const paramIndexMap = /* @__PURE__ */ Object.create(null);\n      paramCount -= 1;\n      for (; paramCount >= 0; paramCount--) {\n        const [key, value] = paramAssoc[paramCount];\n        paramIndexMap[key] = value;\n      }\n      return [h, paramIndexMap];\n    });\n  }\n  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();\n  for (let i = 0, len = handlerData.length; i < len; i++) {\n    for (let j = 0, len2 = handlerData[i].length; j < len2; j++) {\n      const map = handlerData[i][j]?.[1];\n      if (!map) {\n        continue;\n      }\n      const keys = Object.keys(map);\n      for (let k = 0, len3 = keys.length; k < len3; k++) {\n        map[keys[k]] = paramReplacementMap[map[keys[k]]];\n      }\n    }\n  }\n  const handlerMap = [];\n  for (const i in indexReplacementMap) {\n    handlerMap[i] = handlerData[indexReplacementMap[i]];\n  }\n  return [regexp, handlerMap, staticMap];\n}\nfunction findMiddleware(middleware, path) {\n  if (!middleware) {\n    return void 0;\n  }\n  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {\n    if (buildWildcardRegExp(k).test(path)) {\n      return [...middleware[k]];\n    }\n  }\n  return void 0;\n}\nvar RegExpRouter = class {\n  name = \"RegExpRouter\";\n  #middleware;\n  #routes;\n  constructor() {\n    this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };\n    this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };\n  }\n  add(method, path, handler) {\n    const middleware = this.#middleware;\n    const routes = this.#routes;\n    if (!middleware || !routes) {\n      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);\n    }\n    if (!middleware[method]) {\n      ;\n      [middleware, routes].forEach((handlerMap) => {\n        handlerMap[method] = /* @__PURE__ */ Object.create(null);\n        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {\n          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];\n        });\n      });\n    }\n    if (path === \"/*\") {\n      path = \"*\";\n    }\n    const paramCount = (path.match(/\\/:/g) || []).length;\n    if (/\\*$/.test(path)) {\n      const re = buildWildcardRegExp(path);\n      if (method === METHOD_NAME_ALL) {\n        Object.keys(middleware).forEach((m) => {\n          middleware[m][path] ||= findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];\n        });\n      } else {\n        middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];\n      }\n      Object.keys(middleware).forEach((m) => {\n        if (method === METHOD_NAME_ALL || method === m) {\n          Object.keys(middleware[m]).forEach((p) => {\n            re.test(p) && middleware[m][p].push([handler, paramCount]);\n          });\n        }\n      });\n      Object.keys(routes).forEach((m) => {\n        if (method === METHOD_NAME_ALL || method === m) {\n          Object.keys(routes[m]).forEach(\n            (p) => re.test(p) && routes[m][p].push([handler, paramCount])\n          );\n        }\n      });\n      return;\n    }\n    const paths = checkOptionalParameter(path) || [path];\n    for (let i = 0, len = paths.length; i < len; i++) {\n      const path2 = paths[i];\n      Object.keys(routes).forEach((m) => {\n        if (method === METHOD_NAME_ALL || method === m) {\n          routes[m][path2] ||= [\n            ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []\n          ];\n          routes[m][path2].push([handler, paramCount - len + i + 1]);\n        }\n      });\n    }\n  }\n  match = match;\n  buildAllMatchers() {\n    const matchers = /* @__PURE__ */ Object.create(null);\n    Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {\n      matchers[method] ||= this.#buildMatcher(method);\n    });\n    this.#middleware = this.#routes = void 0;\n    clearWildcardRegExpCache();\n    return matchers;\n  }\n  #buildMatcher(method) {\n    const routes = [];\n    let hasOwnRoute = method === METHOD_NAME_ALL;\n    [this.#middleware, this.#routes].forEach((r) => {\n      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];\n      if (ownRoute.length !== 0) {\n        hasOwnRoute ||= true;\n        routes.push(...ownRoute);\n      } else if (method !== METHOD_NAME_ALL) {\n        routes.push(\n          ...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]])\n        );\n      }\n    });\n    if (!hasOwnRoute) {\n      return null;\n    } else {\n      return buildMatcherFromPreprocessedRoutes(routes);\n    }\n  }\n};\nexport {\n  RegExpRouter\n};\n", "// src/router/reg-exp-router/matcher.ts\nimport { METHOD_NAME_ALL } from \"../../router.js\";\nvar emptyParam = [];\nfunction match(method, path) {\n  const matchers = this.buildAllMatchers();\n  const match2 = ((method2, path2) => {\n    const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];\n    const staticMatch = matcher[2][path2];\n    if (staticMatch) {\n      return staticMatch;\n    }\n    const match3 = path2.match(matcher[0]);\n    if (!match3) {\n      return [[], emptyParam];\n    }\n    const index = match3.indexOf(\"\", 1);\n    return [matcher[1][index], match3];\n  });\n  this.match = match2;\n  return match2(method, path);\n}\nexport {\n  emptyParam,\n  match\n};\n", "// src/router/reg-exp-router/node.ts\nvar LABEL_REG_EXP_STR = \"[^/]+\";\nvar ONLY_WILDCARD_REG_EXP_STR = \".*\";\nvar TAIL_WILDCARD_REG_EXP_STR = \"(?:|/.*)\";\nvar PATH_ERROR = /* @__PURE__ */ Symbol();\nvar regExpMetaChars = new Set(\".\\\\+*[^]$()\");\nfunction compareKey(a, b) {\n  if (a.length === 1) {\n    return b.length === 1 ? a < b ? -1 : 1 : -1;\n  }\n  if (b.length === 1) {\n    return 1;\n  }\n  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {\n    return 1;\n  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {\n    return -1;\n  }\n  if (a === LABEL_REG_EXP_STR) {\n    return 1;\n  } else if (b === LABEL_REG_EXP_STR) {\n    return -1;\n  }\n  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;\n}\nvar Node = class _Node {\n  #index;\n  #varIndex;\n  #children = /* @__PURE__ */ Object.create(null);\n  insert(tokens, index, paramMap, context, pathErrorCheckOnly) {\n    if (tokens.length === 0) {\n      if (this.#index !== void 0) {\n        throw PATH_ERROR;\n      }\n      if (pathErrorCheckOnly) {\n        return;\n      }\n      this.#index = index;\n      return;\n    }\n    const [token, ...restTokens] = tokens;\n    const pattern = token === \"*\" ? restTokens.length === 0 ? [\"\", \"\", ONLY_WILDCARD_REG_EXP_STR] : [\"\", \"\", LABEL_REG_EXP_STR] : token === \"/*\" ? [\"\", \"\", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\\:([^\\{\\}]+)(?:\\{(.+)\\})?$/);\n    let node;\n    if (pattern) {\n      const name = pattern[1];\n      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;\n      if (name && pattern[2]) {\n        if (regexpStr === \".*\") {\n          throw PATH_ERROR;\n        }\n        regexpStr = regexpStr.replace(/^\\((?!\\?:)(?=[^)]+\\)$)/, \"(?:\");\n        if (/\\((?!\\?:)/.test(regexpStr)) {\n          throw PATH_ERROR;\n        }\n      }\n      node = this.#children[regexpStr];\n      if (!node) {\n        if (Object.keys(this.#children).some(\n          (k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR\n        )) {\n          throw PATH_ERROR;\n        }\n        if (pathErrorCheckOnly) {\n          return;\n        }\n        node = this.#children[regexpStr] = new _Node();\n        if (name !== \"\") {\n          node.#varIndex = context.varIndex++;\n        }\n      }\n      if (!pathErrorCheckOnly && name !== \"\") {\n        paramMap.push([name, node.#varIndex]);\n      }\n    } else {\n      node = this.#children[token];\n      if (!node) {\n        if (Object.keys(this.#children).some(\n          (k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR\n        )) {\n          throw PATH_ERROR;\n        }\n        if (pathErrorCheckOnly) {\n          return;\n        }\n        node = this.#children[token] = new _Node();\n      }\n    }\n    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);\n  }\n  buildRegExpStr() {\n    const childKeys = Object.keys(this.#children).sort(compareKey);\n    const strList = childKeys.map((k) => {\n      const c = this.#children[k];\n      return (typeof c.#varIndex === \"number\" ? `(${k})@${c.#varIndex}` : regExpMetaChars.has(k) ? `\\\\${k}` : k) + c.buildRegExpStr();\n    });\n    if (typeof this.#index === \"number\") {\n      strList.unshift(`#${this.#index}`);\n    }\n    if (strList.length === 0) {\n      return \"\";\n    }\n    if (strList.length === 1) {\n      return strList[0];\n    }\n    return \"(?:\" + strList.join(\"|\") + \")\";\n  }\n};\nexport {\n  Node,\n  PATH_ERROR\n};\n", "// src/router/reg-exp-router/trie.ts\nimport { Node } from \"./node.js\";\nvar Trie = class {\n  #context = { varIndex: 0 };\n  #root = new Node();\n  insert(path, index, pathErrorCheckOnly) {\n    const paramAssoc = [];\n    const groups = [];\n    for (let i = 0; ; ) {\n      let replaced = false;\n      path = path.replace(/\\{[^}]+\\}/g, (m) => {\n        const mark = `@\\\\${i}`;\n        groups[i] = [mark, m];\n        i++;\n        replaced = true;\n        return mark;\n      });\n      if (!replaced) {\n        break;\n      }\n    }\n    const tokens = path.match(/(?::[^\\/]+)|(?:\\/\\*$)|./g) || [];\n    for (let i = groups.length - 1; i >= 0; i--) {\n      const [mark] = groups[i];\n      for (let j = tokens.length - 1; j >= 0; j--) {\n        if (tokens[j].indexOf(mark) !== -1) {\n          tokens[j] = tokens[j].replace(mark, groups[i][1]);\n          break;\n        }\n      }\n    }\n    this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);\n    return paramAssoc;\n  }\n  buildRegExp() {\n    let regexp = this.#root.buildRegExpStr();\n    if (regexp === \"\") {\n      return [/^$/, [], []];\n    }\n    let captureIndex = 0;\n    const indexReplacementMap = [];\n    const paramReplacementMap = [];\n    regexp = regexp.replace(/#(\\d+)|@(\\d+)|\\.\\*\\$/g, (_, handlerIndex, paramIndex) => {\n      if (handlerIndex !== void 0) {\n        indexReplacementMap[++captureIndex] = Number(handlerIndex);\n        return \"$()\";\n      }\n      if (paramIndex !== void 0) {\n        paramReplacementMap[Number(paramIndex)] = ++captureIndex;\n        return \"\";\n      }\n      return \"\";\n    });\n    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];\n  }\n};\nexport {\n  Trie\n};\n", "// src/router/reg-exp-router/prepared-router.ts\nimport { METHOD_NAME_ALL } from \"../../router.js\";\nimport { match, emptyParam } from \"./matcher.js\";\nimport { RegExpRouter } from \"./router.js\";\nvar PreparedRegExpRouter = class {\n  name = \"PreparedRegExpRouter\";\n  #matchers;\n  #relocateMap;\n  constructor(matchers, relocateMap) {\n    this.#matchers = matchers;\n    this.#relocateMap = relocateMap;\n  }\n  #addWildcard(method, handlerData) {\n    const matcher = this.#matchers[method];\n    matcher[1].forEach((list) => list && list.push(handlerData));\n    Object.values(matcher[2]).forEach((list) => list[0].push(handlerData));\n  }\n  #addPath(method, path, handler, indexes, map) {\n    const matcher = this.#matchers[method];\n    if (!map) {\n      matcher[2][path][0].push([handler, {}]);\n    } else {\n      indexes.forEach((index) => {\n        if (typeof index === \"number\") {\n          matcher[1][index].push([handler, map]);\n        } else {\n          ;\n          matcher[2][index || path][0].push([handler, map]);\n        }\n      });\n    }\n  }\n  add(method, path, handler) {\n    if (!this.#matchers[method]) {\n      const all = this.#matchers[METHOD_NAME_ALL];\n      const staticMap = {};\n      for (const key in all[2]) {\n        staticMap[key] = [all[2][key][0].slice(), emptyParam];\n      }\n      this.#matchers[method] = [\n        all[0],\n        all[1].map((list) => Array.isArray(list) ? list.slice() : 0),\n        staticMap\n      ];\n    }\n    if (path === \"/*\" || path === \"*\") {\n      const handlerData = [handler, {}];\n      if (method === METHOD_NAME_ALL) {\n        for (const m in this.#matchers) {\n          this.#addWildcard(m, handlerData);\n        }\n      } else {\n        this.#addWildcard(method, handlerData);\n      }\n      return;\n    }\n    const data = this.#relocateMap[path];\n    if (!data) {\n      throw new Error(`Path ${path} is not registered`);\n    }\n    for (const [indexes, map] of data) {\n      if (method === METHOD_NAME_ALL) {\n        for (const m in this.#matchers) {\n          this.#addPath(m, path, handler, indexes, map);\n        }\n      } else {\n        this.#addPath(method, path, handler, indexes, map);\n      }\n    }\n  }\n  buildAllMatchers() {\n    return this.#matchers;\n  }\n  match = match;\n};\nvar buildInitParams = ({ paths }) => {\n  const RegExpRouterWithMatcherExport = class extends RegExpRouter {\n    buildAndExportAllMatchers() {\n      return this.buildAllMatchers();\n    }\n  };\n  const router = new RegExpRouterWithMatcherExport();\n  for (const path of paths) {\n    router.add(METHOD_NAME_ALL, path, path);\n  }\n  const matchers = router.buildAndExportAllMatchers();\n  const all = matchers[METHOD_NAME_ALL];\n  const relocateMap = {};\n  for (const path of paths) {\n    if (path === \"/*\" || path === \"*\") {\n      continue;\n    }\n    all[1].forEach((list, i) => {\n      list.forEach(([p, map]) => {\n        if (p === path) {\n          if (relocateMap[path]) {\n            relocateMap[path][0][1] = {\n              ...relocateMap[path][0][1],\n              ...map\n            };\n          } else {\n            relocateMap[path] = [[[], map]];\n          }\n          if (relocateMap[path][0][0].findIndex((j) => j === i) === -1) {\n            relocateMap[path][0][0].push(i);\n          }\n        }\n      });\n    });\n    for (const path2 in all[2]) {\n      all[2][path2][0].forEach(([p]) => {\n        if (p === path) {\n          relocateMap[path] ||= [[[]]];\n          const value = path2 === path ? \"\" : path2;\n          if (relocateMap[path][0][0].findIndex((v) => v === value) === -1) {\n            relocateMap[path][0][0].push(value);\n          }\n        }\n      });\n    }\n  }\n  for (let i = 0, len = all[1].length; i < len; i++) {\n    all[1][i] = all[1][i] ? [] : 0;\n  }\n  for (const path in all[2]) {\n    all[2][path][0] = [];\n  }\n  return [matchers, relocateMap];\n};\nvar serializeInitParams = ([matchers, relocateMap]) => {\n  const matchersStr = JSON.stringify(\n    matchers,\n    (_, value) => value instanceof RegExp ? `##${value.toString()}##` : value\n  ).replace(/\"##(.+?)##\"/g, (_, str) => str.replace(/\\\\\\\\/g, \"\\\\\"));\n  const relocateMapStr = JSON.stringify(relocateMap);\n  return `[${matchersStr},${relocateMapStr}]`;\n};\nexport {\n  PreparedRegExpRouter,\n  buildInitParams,\n  serializeInitParams\n};\n", "// src/router/smart-router/index.ts\nimport { SmartRouter } from \"./router.js\";\nexport {\n  SmartRouter\n};\n", "// src/router/smart-router/router.ts\nimport { MESSAGE_MATCHER_IS_ALREADY_BUILT, UnsupportedPathError } from \"../../router.js\";\nvar SmartRouter = class {\n  name = \"SmartRouter\";\n  #routers = [];\n  #routes = [];\n  constructor(init) {\n    this.#routers = init.routers;\n  }\n  add(method, path, handler) {\n    if (!this.#routes) {\n      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);\n    }\n    this.#routes.push([method, path, handler]);\n  }\n  match(method, path) {\n    if (!this.#routes) {\n      throw new Error(\"Fatal error\");\n    }\n    const routers = this.#routers;\n    const routes = this.#routes;\n    const len = routers.length;\n    let i = 0;\n    let res;\n    for (; i < len; i++) {\n      const router = routers[i];\n      try {\n        for (let i2 = 0, len2 = routes.length; i2 < len2; i2++) {\n          router.add(...routes[i2]);\n        }\n        res = router.match(method, path);\n      } catch (e) {\n        if (e instanceof UnsupportedPathError) {\n          continue;\n        }\n        throw e;\n      }\n      this.match = router.match.bind(router);\n      this.#routers = [router];\n      this.#routes = void 0;\n      break;\n    }\n    if (i === len) {\n      throw new Error(\"Fatal error\");\n    }\n    this.name = `SmartRouter + ${this.activeRouter.name}`;\n    return res;\n  }\n  get activeRouter() {\n    if (this.#routes || this.#routers.length !== 1) {\n      throw new Error(\"No active router has been determined yet.\");\n    }\n    return this.#routers[0];\n  }\n};\nexport {\n  SmartRouter\n};\n", "// src/router/trie-router/index.ts\nimport { TrieRouter } from \"./router.js\";\nexport {\n  TrieRouter\n};\n", "// src/router/trie-router/router.ts\nimport { checkOptionalParameter } from \"../../utils/url.js\";\nimport { Node } from \"./node.js\";\nvar TrieRouter = class {\n  name = \"TrieRouter\";\n  #node;\n  constructor() {\n    this.#node = new Node();\n  }\n  add(method, path, handler) {\n    const results = checkOptionalParameter(path);\n    if (results) {\n      for (let i = 0, len = results.length; i < len; i++) {\n        this.#node.insert(method, results[i], handler);\n      }\n      return;\n    }\n    this.#node.insert(method, path, handler);\n  }\n  match(method, path) {\n    return this.#node.search(method, path);\n  }\n};\nexport {\n  TrieRouter\n};\n", "// src/router/trie-router/node.ts\nimport { METHOD_NAME_ALL } from \"../../router.js\";\nimport { getPattern, splitPath, splitRoutingPath } from \"../../utils/url.js\";\nvar emptyParams = /* @__PURE__ */ Object.create(null);\nvar Node = class _Node {\n  #methods;\n  #children;\n  #patterns;\n  #order = 0;\n  #params = emptyParams;\n  constructor(method, handler, children) {\n    this.#children = children || /* @__PURE__ */ Object.create(null);\n    this.#methods = [];\n    if (method && handler) {\n      const m = /* @__PURE__ */ Object.create(null);\n      m[method] = { handler, possibleKeys: [], score: 0 };\n      this.#methods = [m];\n    }\n    this.#patterns = [];\n  }\n  insert(method, path, handler) {\n    this.#order = ++this.#order;\n    let curNode = this;\n    const parts = splitRoutingPath(path);\n    const possibleKeys = [];\n    for (let i = 0, len = parts.length; i < len; i++) {\n      const p = parts[i];\n      const nextP = parts[i + 1];\n      const pattern = getPattern(p, nextP);\n      const key = Array.isArray(pattern) ? pattern[0] : p;\n      if (key in curNode.#children) {\n        curNode = curNode.#children[key];\n        if (pattern) {\n          possibleKeys.push(pattern[1]);\n        }\n        continue;\n      }\n      curNode.#children[key] = new _Node();\n      if (pattern) {\n        curNode.#patterns.push(pattern);\n        possibleKeys.push(pattern[1]);\n      }\n      curNode = curNode.#children[key];\n    }\n    curNode.#methods.push({\n      [method]: {\n        handler,\n        possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),\n        score: this.#order\n      }\n    });\n    return curNode;\n  }\n  #getHandlerSets(node, method, nodeParams, params) {\n    const handlerSets = [];\n    for (let i = 0, len = node.#methods.length; i < len; i++) {\n      const m = node.#methods[i];\n      const handlerSet = m[method] || m[METHOD_NAME_ALL];\n      const processedSet = {};\n      if (handlerSet !== void 0) {\n        handlerSet.params = /* @__PURE__ */ Object.create(null);\n        handlerSets.push(handlerSet);\n        if (nodeParams !== emptyParams || params && params !== emptyParams) {\n          for (let i2 = 0, len2 = handlerSet.possibleKeys.length; i2 < len2; i2++) {\n            const key = handlerSet.possibleKeys[i2];\n            const processed = processedSet[handlerSet.score];\n            handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];\n            processedSet[handlerSet.score] = true;\n          }\n        }\n      }\n    }\n    return handlerSets;\n  }\n  search(method, path) {\n    const handlerSets = [];\n    this.#params = emptyParams;\n    const curNode = this;\n    let curNodes = [curNode];\n    const parts = splitPath(path);\n    const curNodesQueue = [];\n    for (let i = 0, len = parts.length; i < len; i++) {\n      const part = parts[i];\n      const isLast = i === len - 1;\n      const tempNodes = [];\n      for (let j = 0, len2 = curNodes.length; j < len2; j++) {\n        const node = curNodes[j];\n        const nextNode = node.#children[part];\n        if (nextNode) {\n          nextNode.#params = node.#params;\n          if (isLast) {\n            if (nextNode.#children[\"*\"]) {\n              handlerSets.push(\n                ...this.#getHandlerSets(nextNode.#children[\"*\"], method, node.#params)\n              );\n            }\n            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));\n          } else {\n            tempNodes.push(nextNode);\n          }\n        }\n        for (let k = 0, len3 = node.#patterns.length; k < len3; k++) {\n          const pattern = node.#patterns[k];\n          const params = node.#params === emptyParams ? {} : { ...node.#params };\n          if (pattern === \"*\") {\n            const astNode = node.#children[\"*\"];\n            if (astNode) {\n              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));\n              astNode.#params = params;\n              tempNodes.push(astNode);\n            }\n            continue;\n          }\n          const [key, name, matcher] = pattern;\n          if (!part && !(matcher instanceof RegExp)) {\n            continue;\n          }\n          const child = node.#children[key];\n          const restPathString = parts.slice(i).join(\"/\");\n          if (matcher instanceof RegExp) {\n            const m = matcher.exec(restPathString);\n            if (m) {\n              params[name] = m[0];\n              handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));\n              if (Object.keys(child.#children).length) {\n                child.#params = params;\n                const componentCount = m[0].match(/\\//)?.length ?? 0;\n                const targetCurNodes = curNodesQueue[componentCount] ||= [];\n                targetCurNodes.push(child);\n              }\n              continue;\n            }\n          }\n          if (matcher === true || matcher.test(part)) {\n            params[name] = part;\n            if (isLast) {\n              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));\n              if (child.#children[\"*\"]) {\n                handlerSets.push(\n                  ...this.#getHandlerSets(child.#children[\"*\"], method, params, node.#params)\n                );\n              }\n            } else {\n              child.#params = params;\n              tempNodes.push(child);\n            }\n          }\n        }\n      }\n      curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);\n    }\n    if (handlerSets.length > 1) {\n      handlerSets.sort((a, b) => {\n        return a.score - b.score;\n      });\n    }\n    return [handlerSets.map(({ handler, params }) => [handler, params])];\n  }\n};\nexport {\n  Node\n};\n", "// src/middleware/cors/index.ts\nvar cors = (options) => {\n  const defaults = {\n    origin: \"*\",\n    allowMethods: [\"GET\", \"HEAD\", \"PUT\", \"POST\", \"DELETE\", \"PATCH\"],\n    allowHeaders: [],\n    exposeHeaders: []\n  };\n  const opts = {\n    ...defaults,\n    ...options\n  };\n  const findAllowOrigin = ((optsOrigin) => {\n    if (typeof optsOrigin === \"string\") {\n      if (optsOrigin === \"*\") {\n        return () => optsOrigin;\n      } else {\n        return (origin) => optsOrigin === origin ? origin : null;\n      }\n    } else if (typeof optsOrigin === \"function\") {\n      return optsOrigin;\n    } else {\n      return (origin) => optsOrigin.includes(origin) ? origin : null;\n    }\n  })(opts.origin);\n  const findAllowMethods = ((optsAllowMethods) => {\n    if (typeof optsAllowMethods === \"function\") {\n      return optsAllowMethods;\n    } else if (Array.isArray(optsAllowMethods)) {\n      return () => optsAllowMethods;\n    } else {\n      return () => [];\n    }\n  })(opts.allowMethods);\n  return async function cors2(c, next) {\n    function set(key, value) {\n      c.res.headers.set(key, value);\n    }\n    const allowOrigin = await findAllowOrigin(c.req.header(\"origin\") || \"\", c);\n    if (allowOrigin) {\n      set(\"Access-Control-Allow-Origin\", allowOrigin);\n    }\n    if (opts.credentials) {\n      set(\"Access-Control-Allow-Credentials\", \"true\");\n    }\n    if (opts.exposeHeaders?.length) {\n      set(\"Access-Control-Expose-Headers\", opts.exposeHeaders.join(\",\"));\n    }\n    if (c.req.method === \"OPTIONS\") {\n      if (opts.origin !== \"*\") {\n        set(\"Vary\", \"Origin\");\n      }\n      if (opts.maxAge != null) {\n        set(\"Access-Control-Max-Age\", opts.maxAge.toString());\n      }\n      const allowMethods = await findAllowMethods(c.req.header(\"origin\") || \"\", c);\n      if (allowMethods.length) {\n        set(\"Access-Control-Allow-Methods\", allowMethods.join(\",\"));\n      }\n      let headers = opts.allowHeaders;\n      if (!headers?.length) {\n        const requestHeaders = c.req.header(\"Access-Control-Request-Headers\");\n        if (requestHeaders) {\n          headers = requestHeaders.split(/\\s*,\\s*/);\n        }\n      }\n      if (headers?.length) {\n        set(\"Access-Control-Allow-Headers\", headers.join(\",\"));\n        c.res.headers.append(\"Vary\", \"Access-Control-Request-Headers\");\n      }\n      c.res.headers.delete(\"Content-Length\");\n      c.res.headers.delete(\"Content-Type\");\n      return new Response(null, {\n        headers: c.res.headers,\n        status: 204,\n        statusText: \"No Content\"\n      });\n    }\n    await next();\n    if (opts.origin !== \"*\") {\n      c.header(\"Vary\", \"Origin\", { append: true });\n    }\n  };\n};\nexport {\n  cors\n};\n", "import { Hono } from \"hono\";\nimport { scheduleRoute } from \"./feature/schedule/route\";\nimport { supplementRoute } from \"./feature/supplement/route\";\nimport { aiRoute } from \"./feature/ai/route\";\n\ntype Bindings = {\n  DB: D1Database;\n  OPENROUTER_API_KEY: string;\n};\n\nexport const apiRoutes = new Hono<{ Bindings: Bindings }>();\n\n// \u5404feature\u306E\u30EB\u30FC\u30C8\u3092\u96C6\u7D04\napiRoutes.route(\"/schedules\", scheduleRoute);\napiRoutes.route(\"/supplements\", supplementRoute);\napiRoutes.route(\"/ai\", aiRoute);\n", "import { Hono } from \"hono\";\nimport { createDb } from \"../../infra/drizzle/client\";\nimport { createScheduleRepo } from \"../../infra/drizzle/scheduleRepo\";\nimport { createSupplementRepo } from \"../../infra/drizzle/supplementRepo\";\nimport { createCreateScheduleUseCase } from \"./usecase/createSchedule\";\nimport { createGetSchedulesUseCase } from \"./usecase/getSchedules\";\nimport { createGetScheduleByIdUseCase } from \"./usecase/getScheduleById\";\nimport { createUpdateScheduleUseCase } from \"./usecase/updateSchedule\";\nimport { createDeleteScheduleUseCase } from \"./usecase/deleteSchedule\";\nimport { createCreateScheduleHandler } from \"./handler/createScheduleHandler\";\nimport { createGetSchedulesHandler } from \"./handler/getSchedulesHandler\";\nimport { createGetScheduleByIdHandler } from \"./handler/getScheduleByIdHandler\";\nimport { createUpdateScheduleHandler } from \"./handler/updateScheduleHandler\";\nimport { createDeleteScheduleHandler } from \"./handler/deleteScheduleHandler\";\n\ntype Bindings = {\n  DB: D1Database;\n};\n\ntype Variables = {\n  createSchedule: ReturnType<typeof createCreateScheduleUseCase>;\n  getSchedules: ReturnType<typeof createGetSchedulesUseCase>;\n  getScheduleById: ReturnType<typeof createGetScheduleByIdUseCase>;\n  updateSchedule: ReturnType<typeof createUpdateScheduleUseCase>;\n  deleteSchedule: ReturnType<typeof createDeleteScheduleUseCase>;\n};\n\nexport const scheduleRoute = new Hono<{\n  Bindings: Bindings;\n  Variables: Variables;\n}>();\n\n// \u30DF\u30C9\u30EB\u30A6\u30A7\u30A2\u3067DI\u3092\u89E3\u6C7A\nscheduleRoute.use(\"*\", async (c, next) => {\n  const db = createDb(c.env.DB);\n  const scheduleRepo = createScheduleRepo(db);\n  const supplementRepo = createSupplementRepo(db);\n\n  c.set(\"createSchedule\", createCreateScheduleUseCase(scheduleRepo));\n  c.set(\"getSchedules\", createGetSchedulesUseCase(scheduleRepo));\n  c.set(\"getScheduleById\", createGetScheduleByIdUseCase(scheduleRepo, supplementRepo));\n  c.set(\"updateSchedule\", createUpdateScheduleUseCase(scheduleRepo));\n  c.set(\"deleteSchedule\", createDeleteScheduleUseCase(scheduleRepo));\n\n  await next();\n});\n\n// GET /schedules\nscheduleRoute.get(\"/\", async (c) => {\n  const handler = createGetSchedulesHandler(c.get(\"getSchedules\"));\n  return handler(c);\n});\n\n// POST /schedules\nscheduleRoute.post(\"/\", async (c) => {\n  const handler = createCreateScheduleHandler(c.get(\"createSchedule\"));\n  return handler(c);\n});\n\n// GET /schedules/:id\nscheduleRoute.get(\"/:id\", async (c) => {\n  const handler = createGetScheduleByIdHandler(c.get(\"getScheduleById\"));\n  return handler(c);\n});\n\n// PUT /schedules/:id\nscheduleRoute.put(\"/:id\", async (c) => {\n  const handler = createUpdateScheduleHandler(c.get(\"updateSchedule\"));\n  return handler(c);\n});\n\n// DELETE /schedules/:id\nscheduleRoute.delete(\"/:id\", async (c) => {\n  const handler = createDeleteScheduleHandler(c.get(\"deleteSchedule\"));\n  return handler(c);\n});\n", "import { drizzle } from \"drizzle-orm/d1\";\nimport * as schema from \"./schema\";\n\nexport const createDb = (d1: D1Database) => {\n  return drizzle(d1, { schema });\n};\n\nexport type Database = ReturnType<typeof createDb>;\n", "/// <reference types=\"@cloudflare/workers-types\" />\nimport type { D1Database as MiniflareD1Database } from '@miniflare/d1';\nimport type { BatchItem, BatchResponse } from '~/batch.ts';\nimport { entityKind } from '~/entity.ts';\nimport { DefaultLogger } from '~/logger.ts';\nimport {\n\tcreateTableRelationsHelpers,\n\textractTablesRelationalConfig,\n\ttype ExtractTablesWithRelations,\n\ttype RelationalSchemaConfig,\n\ttype TablesRelationalConfig,\n} from '~/relations.ts';\nimport { BaseSQLiteDatabase } from '~/sqlite-core/db.ts';\nimport { SQLiteAsyncDialect } from '~/sqlite-core/dialect.ts';\nimport type { DrizzleConfig, IfNotImported } from '~/utils.ts';\nimport { SQLiteD1Session } from './session.ts';\n\nexport type AnyD1Database = IfNotImported<\n\tD1Database,\n\tMiniflareD1Database,\n\tD1Database | IfNotImported<MiniflareD1Database, never, MiniflareD1Database>\n>;\n\nexport class DrizzleD1Database<\n\tTSchema extends Record<string, unknown> = Record<string, never>,\n> extends BaseSQLiteDatabase<'async', D1Result, TSchema> {\n\tstatic override readonly [entityKind]: string = 'D1Database';\n\n\t/** @internal */\n\tdeclare readonly session: SQLiteD1Session<TSchema, ExtractTablesWithRelations<TSchema>>;\n\n\tasync batch<U extends BatchItem<'sqlite'>, T extends Readonly<[U, ...U[]]>>(\n\t\tbatch: T,\n\t): Promise<BatchResponse<T>> {\n\t\treturn this.session.batch(batch) as Promise<BatchResponse<T>>;\n\t}\n}\n\nexport function drizzle<\n\tTSchema extends Record<string, unknown> = Record<string, never>,\n\tTClient extends AnyD1Database = AnyD1Database,\n>(\n\tclient: TClient,\n\tconfig: DrizzleConfig<TSchema> = {},\n): DrizzleD1Database<TSchema> & {\n\t$client: TClient;\n} {\n\tconst dialect = new SQLiteAsyncDialect({ casing: config.casing });\n\tlet logger;\n\tif (config.logger === true) {\n\t\tlogger = new DefaultLogger();\n\t} else if (config.logger !== false) {\n\t\tlogger = config.logger;\n\t}\n\n\tlet schema: RelationalSchemaConfig<TablesRelationalConfig> | undefined;\n\tif (config.schema) {\n\t\tconst tablesConfig = extractTablesRelationalConfig(\n\t\t\tconfig.schema,\n\t\t\tcreateTableRelationsHelpers,\n\t\t);\n\t\tschema = {\n\t\t\tfullSchema: config.schema,\n\t\t\tschema: tablesConfig.tables,\n\t\t\ttableNamesMap: tablesConfig.tableNamesMap,\n\t\t};\n\t}\n\n\tconst session = new SQLiteD1Session(client as D1Database, dialect, schema, { logger });\n\tconst db = new DrizzleD1Database('async', dialect, session, schema) as DrizzleD1Database<TSchema>;\n\t(<any> db).$client = client;\n\n\treturn db as any;\n}\n", "export const entityKind = Symbol.for('drizzle:entityKind');\nexport const hasOwnEntityKind = Symbol.for('drizzle:hasOwnEntityKind');\n\nexport interface DrizzleEntity {\n\t[entityKind]: string;\n}\n\nexport type DrizzleEntityClass<T> =\n\t& ((abstract new(...args: any[]) => T) | (new(...args: any[]) => T))\n\t& DrizzleEntity;\n\nexport function is<T extends DrizzleEntityClass<any>>(value: any, type: T): value is InstanceType<T> {\n\tif (!value || typeof value !== 'object') {\n\t\treturn false;\n\t}\n\n\tif (value instanceof type) { // eslint-disable-line no-instanceof/no-instanceof\n\t\treturn true;\n\t}\n\n\tif (!Object.prototype.hasOwnProperty.call(type, entityKind)) {\n\t\tthrow new Error(\n\t\t\t`Class \"${\n\t\t\t\ttype.name ?? '<unknown>'\n\t\t\t}\" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`,\n\t\t);\n\t}\n\n\tlet cls = Object.getPrototypeOf(value).constructor;\n\tif (cls) {\n\t\t// Traverse the prototype chain to find the entityKind\n\t\twhile (cls) {\n\t\t\tif (entityKind in cls && cls[entityKind] === type[entityKind]) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tcls = Object.getPrototypeOf(cls);\n\t\t}\n\t}\n\n\treturn false;\n}\n", "import { entityKind } from '~/entity.ts';\n\nexport interface Logger {\n\tlogQuery(query: string, params: unknown[]): void;\n}\n\nexport interface LogWriter {\n\twrite(message: string): void;\n}\n\nexport class ConsoleLogWriter implements LogWriter {\n\tstatic readonly [entityKind]: string = 'ConsoleLogWriter';\n\n\twrite(message: string) {\n\t\tconsole.log(message);\n\t}\n}\n\nexport class DefaultLogger implements Logger {\n\tstatic readonly [entityKind]: string = 'DefaultLogger';\n\n\treadonly writer: LogWriter;\n\n\tconstructor(config?: { writer: LogWriter }) {\n\t\tthis.writer = config?.writer ?? new ConsoleLogWriter();\n\t}\n\n\tlogQuery(query: string, params: unknown[]): void {\n\t\tconst stringifiedParams = params.map((p) => {\n\t\t\ttry {\n\t\t\t\treturn JSON.stringify(p);\n\t\t\t} catch {\n\t\t\t\treturn String(p);\n\t\t\t}\n\t\t});\n\t\tconst paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(', ')}]` : '';\n\t\tthis.writer.write(`Query: ${query}${paramsStr}`);\n\t}\n}\n\nexport class NoopLogger implements Logger {\n\tstatic readonly [entityKind]: string = 'NoopLogger';\n\n\tlogQuery(): void {\n\t\t// noop\n\t}\n}\n", "import { type AnyTable, getTableUniqueName, type InferModelFromColumns, Table } from '~/table.ts';\nimport { type AnyColumn, Column } from './column.ts';\nimport { entityKind, is } from './entity.ts';\nimport { PrimaryKeyBuilder } from './pg-core/primary-keys.ts';\nimport {\n\tand,\n\tasc,\n\tbetween,\n\tdesc,\n\teq,\n\texists,\n\tgt,\n\tgte,\n\tilike,\n\tinArray,\n\tisNotNull,\n\tisNull,\n\tlike,\n\tlt,\n\tlte,\n\tne,\n\tnot,\n\tnotBetween,\n\tnotExists,\n\tnotIlike,\n\tnotInArray,\n\tnotLike,\n\tor,\n} from './sql/expressions/index.ts';\nimport { type Placeholder, SQL, sql } from './sql/sql.ts';\nimport type { Assume, ColumnsWithTable, Equal, Simplify, ValueOrArray } from './utils.ts';\n\nexport abstract class Relation<TTableName extends string = string> {\n\tstatic readonly [entityKind]: string = 'Relation';\n\n\tdeclare readonly $brand: 'Relation';\n\treadonly referencedTableName: TTableName;\n\tfieldName!: string;\n\n\tconstructor(\n\t\treadonly sourceTable: Table,\n\t\treadonly referencedTable: AnyTable<{ name: TTableName }>,\n\t\treadonly relationName: string | undefined,\n\t) {\n\t\tthis.referencedTableName = referencedTable[Table.Symbol.Name] as TTableName;\n\t}\n\n\tabstract withFieldName(fieldName: string): Relation<TTableName>;\n}\n\nexport class Relations<\n\tTTableName extends string = string,\n\tTConfig extends Record<string, Relation> = Record<string, Relation>,\n> {\n\tstatic readonly [entityKind]: string = 'Relations';\n\n\tdeclare readonly $brand: 'Relations';\n\n\tconstructor(\n\t\treadonly table: AnyTable<{ name: TTableName }>,\n\t\treadonly config: (helpers: TableRelationsHelpers<TTableName>) => TConfig,\n\t) {}\n}\n\nexport class One<\n\tTTableName extends string = string,\n\tTIsNullable extends boolean = boolean,\n> extends Relation<TTableName> {\n\tstatic override readonly [entityKind]: string = 'One';\n\n\tdeclare protected $relationBrand: 'One';\n\n\tconstructor(\n\t\tsourceTable: Table,\n\t\treferencedTable: AnyTable<{ name: TTableName }>,\n\t\treadonly config:\n\t\t\t| RelationConfig<\n\t\t\t\tTTableName,\n\t\t\t\tstring,\n\t\t\t\tAnyColumn<{ tableName: TTableName }>[]\n\t\t\t>\n\t\t\t| undefined,\n\t\treadonly isNullable: TIsNullable,\n\t) {\n\t\tsuper(sourceTable, referencedTable, config?.relationName);\n\t}\n\n\twithFieldName(fieldName: string): One<TTableName> {\n\t\tconst relation = new One(\n\t\t\tthis.sourceTable,\n\t\t\tthis.referencedTable,\n\t\t\tthis.config,\n\t\t\tthis.isNullable,\n\t\t);\n\t\trelation.fieldName = fieldName;\n\t\treturn relation;\n\t}\n}\n\nexport class Many<TTableName extends string> extends Relation<TTableName> {\n\tstatic override readonly [entityKind]: string = 'Many';\n\n\tdeclare protected $relationBrand: 'Many';\n\n\tconstructor(\n\t\tsourceTable: Table,\n\t\treferencedTable: AnyTable<{ name: TTableName }>,\n\t\treadonly config: { relationName: string } | undefined,\n\t) {\n\t\tsuper(sourceTable, referencedTable, config?.relationName);\n\t}\n\n\twithFieldName(fieldName: string): Many<TTableName> {\n\t\tconst relation = new Many(\n\t\t\tthis.sourceTable,\n\t\t\tthis.referencedTable,\n\t\t\tthis.config,\n\t\t);\n\t\trelation.fieldName = fieldName;\n\t\treturn relation;\n\t}\n}\n\nexport type TableRelationsKeysOnly<\n\tTSchema extends Record<string, unknown>,\n\tTTableName extends string,\n\tK extends keyof TSchema,\n> = TSchema[K] extends Relations<TTableName> ? K : never;\n\nexport type ExtractTableRelationsFromSchema<\n\tTSchema extends Record<string, unknown>,\n\tTTableName extends string,\n> = ExtractObjectValues<\n\t{\n\t\t[\n\t\t\tK in keyof TSchema as TableRelationsKeysOnly<\n\t\t\t\tTSchema,\n\t\t\t\tTTableName,\n\t\t\t\tK\n\t\t\t>\n\t\t]: TSchema[K] extends Relations<TTableName, infer TConfig> ? TConfig : never;\n\t}\n>;\n\nexport type ExtractObjectValues<T> = T[keyof T];\n\nexport type ExtractRelationsFromTableExtraConfigSchema<\n\tTConfig extends unknown[],\n> = ExtractObjectValues<\n\t{\n\t\t[\n\t\t\tK in keyof TConfig as TConfig[K] extends Relations<any> ? K\n\t\t\t\t: never\n\t\t]: TConfig[K] extends Relations<infer TRelationConfig> ? TRelationConfig\n\t\t\t: never;\n\t}\n>;\n\nexport function getOperators() {\n\treturn {\n\t\tand,\n\t\tbetween,\n\t\teq,\n\t\texists,\n\t\tgt,\n\t\tgte,\n\t\tilike,\n\t\tinArray,\n\t\tisNull,\n\t\tisNotNull,\n\t\tlike,\n\t\tlt,\n\t\tlte,\n\t\tne,\n\t\tnot,\n\t\tnotBetween,\n\t\tnotExists,\n\t\tnotLike,\n\t\tnotIlike,\n\t\tnotInArray,\n\t\tor,\n\t\tsql,\n\t};\n}\n\nexport type Operators = ReturnType<typeof getOperators>;\n\nexport function getOrderByOperators() {\n\treturn {\n\t\tsql,\n\t\tasc,\n\t\tdesc,\n\t};\n}\n\nexport type OrderByOperators = ReturnType<typeof getOrderByOperators>;\n\nexport type FindTableByDBName<\n\tTSchema extends TablesRelationalConfig,\n\tTTableName extends string,\n> = ExtractObjectValues<\n\t{\n\t\t[\n\t\t\tK in keyof TSchema as TSchema[K]['dbName'] extends TTableName ? K\n\t\t\t\t: never\n\t\t]: TSchema[K];\n\t}\n>;\n\nexport type DBQueryConfig<\n\tTRelationType extends 'one' | 'many' = 'one' | 'many',\n\tTIsRoot extends boolean = boolean,\n\tTSchema extends TablesRelationalConfig = TablesRelationalConfig,\n\tTTableConfig extends TableRelationalConfig = TableRelationalConfig,\n> =\n\t& {\n\t\tcolumns?:\n\t\t\t| {\n\t\t\t\t[K in keyof TTableConfig['columns']]?: boolean;\n\t\t\t}\n\t\t\t| undefined;\n\t\twith?:\n\t\t\t| {\n\t\t\t\t[K in keyof TTableConfig['relations']]?:\n\t\t\t\t\t| true\n\t\t\t\t\t| DBQueryConfig<\n\t\t\t\t\t\tTTableConfig['relations'][K] extends One ? 'one' : 'many',\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tTSchema,\n\t\t\t\t\t\tFindTableByDBName<\n\t\t\t\t\t\t\tTSchema,\n\t\t\t\t\t\t\tTTableConfig['relations'][K]['referencedTableName']\n\t\t\t\t\t\t>\n\t\t\t\t\t>\n\t\t\t\t\t| undefined;\n\t\t\t}\n\t\t\t| undefined;\n\t\textras?:\n\t\t\t| Record<string, SQL.Aliased>\n\t\t\t| ((\n\t\t\t\tfields: Simplify<\n\t\t\t\t\t[TTableConfig['columns']] extends [never] ? {}\n\t\t\t\t\t\t: TTableConfig['columns']\n\t\t\t\t>,\n\t\t\t\toperators: { sql: Operators['sql'] },\n\t\t\t) => Record<string, SQL.Aliased>)\n\t\t\t| undefined;\n\t}\n\t& (TRelationType extends 'many' ?\n\t\t\t& {\n\t\t\t\twhere?:\n\t\t\t\t\t| SQL\n\t\t\t\t\t| undefined\n\t\t\t\t\t| ((\n\t\t\t\t\t\tfields: Simplify<\n\t\t\t\t\t\t\t[TTableConfig['columns']] extends [never] ? {}\n\t\t\t\t\t\t\t\t: TTableConfig['columns']\n\t\t\t\t\t\t>,\n\t\t\t\t\t\toperators: Operators,\n\t\t\t\t\t) => SQL | undefined);\n\t\t\t\torderBy?:\n\t\t\t\t\t| ValueOrArray<AnyColumn | SQL>\n\t\t\t\t\t| ((\n\t\t\t\t\t\tfields: Simplify<\n\t\t\t\t\t\t\t[TTableConfig['columns']] extends [never] ? {}\n\t\t\t\t\t\t\t\t: TTableConfig['columns']\n\t\t\t\t\t\t>,\n\t\t\t\t\t\toperators: OrderByOperators,\n\t\t\t\t\t) => ValueOrArray<AnyColumn | SQL>)\n\t\t\t\t\t| undefined;\n\t\t\t\tlimit?: number | Placeholder | undefined;\n\t\t\t}\n\t\t\t& (TIsRoot extends true ? {\n\t\t\t\t\toffset?: number | Placeholder | undefined;\n\t\t\t\t}\n\t\t\t\t: {})\n\t\t: {});\n\nexport interface TableRelationalConfig {\n\ttsName: string;\n\tdbName: string;\n\tcolumns: Record<string, Column>;\n\trelations: Record<string, Relation>;\n\tprimaryKey: AnyColumn[];\n\tschema?: string;\n}\n\nexport type TablesRelationalConfig = Record<string, TableRelationalConfig>;\n\nexport interface RelationalSchemaConfig<\n\tTSchema extends TablesRelationalConfig,\n> {\n\tfullSchema: Record<string, unknown>;\n\tschema: TSchema;\n\ttableNamesMap: Record<string, string>;\n}\n\nexport type ExtractTablesWithRelations<\n\tTSchema extends Record<string, unknown>,\n> = {\n\t[\n\t\tK in keyof TSchema as TSchema[K] extends Table ? K\n\t\t\t: never\n\t]: TSchema[K] extends Table ? {\n\t\t\ttsName: K & string;\n\t\t\tdbName: TSchema[K]['_']['name'];\n\t\t\tcolumns: TSchema[K]['_']['columns'];\n\t\t\trelations: ExtractTableRelationsFromSchema<\n\t\t\t\tTSchema,\n\t\t\t\tTSchema[K]['_']['name']\n\t\t\t>;\n\t\t\tprimaryKey: AnyColumn[];\n\t\t}\n\t\t: never;\n};\n\nexport type ReturnTypeOrValue<T> = T extends (...args: any[]) => infer R ? R\n\t: T;\n\nexport type BuildRelationResult<\n\tTSchema extends TablesRelationalConfig,\n\tTInclude,\n\tTRelations extends Record<string, Relation>,\n> = {\n\t[\n\t\tK in\n\t\t\t& NonUndefinedKeysOnly<TInclude>\n\t\t\t& keyof TRelations\n\t]: TRelations[K] extends infer TRel extends Relation ? BuildQueryResult<\n\t\t\tTSchema,\n\t\t\tFindTableByDBName<TSchema, TRel['referencedTableName']>,\n\t\t\tAssume<TInclude[K], true | Record<string, unknown>>\n\t\t> extends infer TResult ? TRel extends One ?\n\t\t\t\t\t| TResult\n\t\t\t\t\t| (Equal<TRel['isNullable'], false> extends true ? null : never)\n\t\t\t: TResult[]\n\t\t: never\n\t\t: never;\n};\n\nexport type NonUndefinedKeysOnly<T> =\n\t& ExtractObjectValues<\n\t\t{\n\t\t\t[K in keyof T as T[K] extends undefined ? never : K]: K;\n\t\t}\n\t>\n\t& keyof T;\n\nexport type BuildQueryResult<\n\tTSchema extends TablesRelationalConfig,\n\tTTableConfig extends TableRelationalConfig,\n\tTFullSelection extends true | Record<string, unknown>,\n> = Equal<TFullSelection, true> extends true ? InferModelFromColumns<TTableConfig['columns']>\n\t: TFullSelection extends Record<string, unknown> ? Simplify<\n\t\t\t& (TFullSelection['columns'] extends Record<string, unknown> ? InferModelFromColumns<\n\t\t\t\t\t{\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tK in Equal<\n\t\t\t\t\t\t\t\tExclude<\n\t\t\t\t\t\t\t\t\tTFullSelection['columns'][\n\t\t\t\t\t\t\t\t\t\t& keyof TFullSelection['columns']\n\t\t\t\t\t\t\t\t\t\t& keyof TTableConfig['columns']\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\tundefined\n\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t> extends true ? Exclude<\n\t\t\t\t\t\t\t\t\tkeyof TTableConfig['columns'],\n\t\t\t\t\t\t\t\t\tNonUndefinedKeysOnly<TFullSelection['columns']>\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t:\n\t\t\t\t\t\t\t\t\t& {\n\t\t\t\t\t\t\t\t\t\t[K in keyof TFullSelection['columns']]: Equal<\n\t\t\t\t\t\t\t\t\t\t\tTFullSelection['columns'][K],\n\t\t\t\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t\t\t> extends true ? K\n\t\t\t\t\t\t\t\t\t\t\t: never;\n\t\t\t\t\t\t\t\t\t}[keyof TFullSelection['columns']]\n\t\t\t\t\t\t\t\t\t& keyof TTableConfig['columns']\n\t\t\t\t\t\t]: TTableConfig['columns'][K];\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t\t: InferModelFromColumns<TTableConfig['columns']>)\n\t\t\t& (TFullSelection['extras'] extends\n\t\t\t\t| Record<string, unknown>\n\t\t\t\t| ((...args: any[]) => Record<string, unknown>) ? {\n\t\t\t\t\t[\n\t\t\t\t\t\tK in NonUndefinedKeysOnly<\n\t\t\t\t\t\t\tReturnTypeOrValue<TFullSelection['extras']>\n\t\t\t\t\t\t>\n\t\t\t\t\t]: Assume<\n\t\t\t\t\t\tReturnTypeOrValue<TFullSelection['extras']>[K],\n\t\t\t\t\t\tSQL.Aliased\n\t\t\t\t\t>['_']['type'];\n\t\t\t\t}\n\t\t\t\t: {})\n\t\t\t& (TFullSelection['with'] extends Record<string, unknown> ? BuildRelationResult<\n\t\t\t\t\tTSchema,\n\t\t\t\t\tTFullSelection['with'],\n\t\t\t\t\tTTableConfig['relations']\n\t\t\t\t>\n\t\t\t\t: {})\n\t\t>\n\t: never;\n\nexport interface RelationConfig<\n\tTTableName extends string,\n\tTForeignTableName extends string,\n\tTColumns extends AnyColumn<{ tableName: TTableName }>[],\n> {\n\trelationName?: string;\n\tfields: TColumns;\n\treferences: ColumnsWithTable<TTableName, TForeignTableName, TColumns>;\n}\n\nexport function extractTablesRelationalConfig<\n\tTTables extends TablesRelationalConfig,\n>(\n\tschema: Record<string, unknown>,\n\tconfigHelpers: (table: Table) => any,\n): { tables: TTables; tableNamesMap: Record<string, string> } {\n\tif (\n\t\tObject.keys(schema).length === 1\n\t\t&& 'default' in schema\n\t\t&& !is(schema['default'], Table)\n\t) {\n\t\tschema = schema['default'] as Record<string, unknown>;\n\t}\n\n\t// table DB name -> schema table key\n\tconst tableNamesMap: Record<string, string> = {};\n\t// Table relations found before their tables - need to buffer them until we know the schema table key\n\tconst relationsBuffer: Record<\n\t\tstring,\n\t\t{ relations: Record<string, Relation>; primaryKey?: AnyColumn[] }\n\t> = {};\n\tconst tablesConfig: TablesRelationalConfig = {};\n\tfor (const [key, value] of Object.entries(schema)) {\n\t\tif (is(value, Table)) {\n\t\t\tconst dbName = getTableUniqueName(value);\n\t\t\tconst bufferedRelations = relationsBuffer[dbName];\n\t\t\ttableNamesMap[dbName] = key;\n\t\t\ttablesConfig[key] = {\n\t\t\t\ttsName: key,\n\t\t\t\tdbName: value[Table.Symbol.Name],\n\t\t\t\tschema: value[Table.Symbol.Schema],\n\t\t\t\tcolumns: value[Table.Symbol.Columns],\n\t\t\t\trelations: bufferedRelations?.relations ?? {},\n\t\t\t\tprimaryKey: bufferedRelations?.primaryKey ?? [],\n\t\t\t};\n\n\t\t\t// Fill in primary keys\n\t\t\tfor (\n\t\t\t\tconst column of Object.values(\n\t\t\t\t\t(value as Table)[Table.Symbol.Columns],\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tif (column.primary) {\n\t\t\t\t\ttablesConfig[key]!.primaryKey.push(column);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.((value as Table)[Table.Symbol.ExtraConfigColumns]);\n\t\t\tif (extraConfig) {\n\t\t\t\tfor (const configEntry of Object.values(extraConfig)) {\n\t\t\t\t\tif (is(configEntry, PrimaryKeyBuilder)) {\n\t\t\t\t\t\ttablesConfig[key]!.primaryKey.push(...configEntry.columns);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (is(value, Relations)) {\n\t\t\tconst dbName = getTableUniqueName(value.table);\n\t\t\tconst tableName = tableNamesMap[dbName];\n\t\t\tconst relations: Record<string, Relation> = value.config(\n\t\t\t\tconfigHelpers(value.table),\n\t\t\t);\n\t\t\tlet primaryKey: AnyColumn[] | undefined;\n\n\t\t\tfor (const [relationName, relation] of Object.entries(relations)) {\n\t\t\t\tif (tableName) {\n\t\t\t\t\tconst tableConfig = tablesConfig[tableName]!;\n\t\t\t\t\ttableConfig.relations[relationName] = relation;\n\t\t\t\t\tif (primaryKey) {\n\t\t\t\t\t\ttableConfig.primaryKey.push(...primaryKey);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!(dbName in relationsBuffer)) {\n\t\t\t\t\t\trelationsBuffer[dbName] = {\n\t\t\t\t\t\t\trelations: {},\n\t\t\t\t\t\t\tprimaryKey,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\trelationsBuffer[dbName]!.relations[relationName] = relation;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { tables: tablesConfig as TTables, tableNamesMap };\n}\n\nexport function relations<\n\tTTableName extends string,\n\tTRelations extends Record<string, Relation<any>>,\n>(\n\ttable: AnyTable<{ name: TTableName }>,\n\trelations: (helpers: TableRelationsHelpers<TTableName>) => TRelations,\n): Relations<TTableName, TRelations> {\n\treturn new Relations<TTableName, TRelations>(\n\t\ttable,\n\t\t(helpers: TableRelationsHelpers<TTableName>) =>\n\t\t\tObject.fromEntries(\n\t\t\t\tObject.entries(relations(helpers)).map(([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tvalue.withFieldName(key),\n\t\t\t\t]),\n\t\t\t) as TRelations,\n\t);\n}\n\nexport function createOne<TTableName extends string>(sourceTable: Table) {\n\treturn function one<\n\t\tTForeignTable extends Table,\n\t\tTColumns extends [\n\t\t\tAnyColumn<{ tableName: TTableName }>,\n\t\t\t...AnyColumn<{ tableName: TTableName }>[],\n\t\t],\n\t>(\n\t\ttable: TForeignTable,\n\t\tconfig?: RelationConfig<TTableName, TForeignTable['_']['name'], TColumns>,\n\t): One<\n\t\tTForeignTable['_']['name'],\n\t\tEqual<TColumns[number]['_']['notNull'], true>\n\t> {\n\t\treturn new One(\n\t\t\tsourceTable,\n\t\t\ttable,\n\t\t\tconfig,\n\t\t\t(config?.fields.reduce<boolean>((res, f) => res && f.notNull, true)\n\t\t\t\t?? false) as Equal<TColumns[number]['_']['notNull'], true>,\n\t\t);\n\t};\n}\n\nexport function createMany(sourceTable: Table) {\n\treturn function many<TForeignTable extends Table>(\n\t\treferencedTable: TForeignTable,\n\t\tconfig?: { relationName: string },\n\t): Many<TForeignTable['_']['name']> {\n\t\treturn new Many(sourceTable, referencedTable, config);\n\t};\n}\n\nexport interface NormalizedRelation {\n\tfields: AnyColumn[];\n\treferences: AnyColumn[];\n}\n\nexport function normalizeRelation(\n\tschema: TablesRelationalConfig,\n\ttableNamesMap: Record<string, string>,\n\trelation: Relation,\n): NormalizedRelation {\n\tif (is(relation, One) && relation.config) {\n\t\treturn {\n\t\t\tfields: relation.config.fields,\n\t\t\treferences: relation.config.references,\n\t\t};\n\t}\n\n\tconst referencedTableTsName = tableNamesMap[getTableUniqueName(relation.referencedTable)];\n\tif (!referencedTableTsName) {\n\t\tthrow new Error(\n\t\t\t`Table \"${relation.referencedTable[Table.Symbol.Name]}\" not found in schema`,\n\t\t);\n\t}\n\n\tconst referencedTableConfig = schema[referencedTableTsName];\n\tif (!referencedTableConfig) {\n\t\tthrow new Error(`Table \"${referencedTableTsName}\" not found in schema`);\n\t}\n\n\tconst sourceTable = relation.sourceTable;\n\tconst sourceTableTsName = tableNamesMap[getTableUniqueName(sourceTable)];\n\tif (!sourceTableTsName) {\n\t\tthrow new Error(\n\t\t\t`Table \"${sourceTable[Table.Symbol.Name]}\" not found in schema`,\n\t\t);\n\t}\n\n\tconst reverseRelations: Relation[] = [];\n\tfor (\n\t\tconst referencedTableRelation of Object.values(\n\t\t\treferencedTableConfig.relations,\n\t\t)\n\t) {\n\t\tif (\n\t\t\t(relation.relationName\n\t\t\t\t&& relation !== referencedTableRelation\n\t\t\t\t&& referencedTableRelation.relationName === relation.relationName)\n\t\t\t|| (!relation.relationName\n\t\t\t\t&& referencedTableRelation.referencedTable === relation.sourceTable)\n\t\t) {\n\t\t\treverseRelations.push(referencedTableRelation);\n\t\t}\n\t}\n\n\tif (reverseRelations.length > 1) {\n\t\tthrow relation.relationName\n\t\t\t? new Error(\n\t\t\t\t`There are multiple relations with name \"${relation.relationName}\" in table \"${referencedTableTsName}\"`,\n\t\t\t)\n\t\t\t: new Error(\n\t\t\t\t`There are multiple relations between \"${referencedTableTsName}\" and \"${\n\t\t\t\t\trelation.sourceTable[Table.Symbol.Name]\n\t\t\t\t}\". Please specify relation name`,\n\t\t\t);\n\t}\n\n\tif (\n\t\treverseRelations[0]\n\t\t&& is(reverseRelations[0], One)\n\t\t&& reverseRelations[0].config\n\t) {\n\t\treturn {\n\t\t\tfields: reverseRelations[0].config.references,\n\t\t\treferences: reverseRelations[0].config.fields,\n\t\t};\n\t}\n\n\tthrow new Error(\n\t\t`There is not enough information to infer relation \"${sourceTableTsName}.${relation.fieldName}\"`,\n\t);\n}\n\nexport function createTableRelationsHelpers<TTableName extends string>(\n\tsourceTable: AnyTable<{ name: TTableName }>,\n) {\n\treturn {\n\t\tone: createOne<TTableName>(sourceTable),\n\t\tmany: createMany(sourceTable),\n\t};\n}\n\nexport type TableRelationsHelpers<TTableName extends string> = ReturnType<\n\ttypeof createTableRelationsHelpers<TTableName>\n>;\n\nexport interface BuildRelationalQueryResult<\n\tTTable extends Table = Table,\n\tTColumn extends Column = Column,\n> {\n\ttableTsKey: string;\n\tselection: {\n\t\tdbKey: string;\n\t\ttsKey: string;\n\t\tfield: TColumn | SQL | SQL.Aliased;\n\t\trelationTableTsKey: string | undefined;\n\t\tisJson: boolean;\n\t\tisExtra?: boolean;\n\t\tselection: BuildRelationalQueryResult<TTable>['selection'];\n\t}[];\n\tsql: TTable | SQL;\n}\n\nexport function mapRelationalRow(\n\ttablesConfig: TablesRelationalConfig,\n\ttableConfig: TableRelationalConfig,\n\trow: unknown[],\n\tbuildQueryResultSelection: BuildRelationalQueryResult['selection'],\n\tmapColumnValue: (value: unknown) => unknown = (value) => value,\n): Record<string, unknown> {\n\tconst result: Record<string, unknown> = {};\n\n\tfor (\n\t\tconst [\n\t\t\tselectionItemIndex,\n\t\t\tselectionItem,\n\t\t] of buildQueryResultSelection.entries()\n\t) {\n\t\tif (selectionItem.isJson) {\n\t\t\tconst relation = tableConfig.relations[selectionItem.tsKey]!;\n\t\t\tconst rawSubRows = row[selectionItemIndex] as\n\t\t\t\t| unknown[]\n\t\t\t\t| null\n\t\t\t\t| [null]\n\t\t\t\t| string;\n\t\t\tconst subRows = typeof rawSubRows === 'string'\n\t\t\t\t? (JSON.parse(rawSubRows) as unknown[])\n\t\t\t\t: rawSubRows;\n\t\t\tresult[selectionItem.tsKey] = is(relation, One)\n\t\t\t\t? subRows\n\t\t\t\t\t&& mapRelationalRow(\n\t\t\t\t\t\ttablesConfig,\n\t\t\t\t\t\ttablesConfig[selectionItem.relationTableTsKey!]!,\n\t\t\t\t\t\tsubRows,\n\t\t\t\t\t\tselectionItem.selection,\n\t\t\t\t\t\tmapColumnValue,\n\t\t\t\t\t)\n\t\t\t\t: (subRows as unknown[][]).map((subRow) =>\n\t\t\t\t\tmapRelationalRow(\n\t\t\t\t\t\ttablesConfig,\n\t\t\t\t\t\ttablesConfig[selectionItem.relationTableTsKey!]!,\n\t\t\t\t\t\tsubRow,\n\t\t\t\t\t\tselectionItem.selection,\n\t\t\t\t\t\tmapColumnValue,\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t} else {\n\t\t\tconst value = mapColumnValue(row[selectionItemIndex]);\n\t\t\tconst field = selectionItem.field!;\n\t\t\tlet decoder;\n\t\t\tif (is(field, Column)) {\n\t\t\t\tdecoder = field;\n\t\t\t} else if (is(field, SQL)) {\n\t\t\t\tdecoder = field.decoder;\n\t\t\t} else {\n\t\t\t\tdecoder = field.sql.decoder;\n\t\t\t}\n\t\t\tresult[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);\n\t\t}\n\t}\n\n\treturn result;\n}\n", "import type { Column, GetColumnData } from './column.ts';\nimport { entityKind } from './entity.ts';\nimport type { OptionalKeyOnly, RequiredKeyOnly } from './operations.ts';\nimport type { ExtraConfigColumn } from './pg-core/index.ts';\nimport type { SQLWrapper } from './sql/sql.ts';\nimport { TableName } from './table.utils.ts';\nimport type { Simplify, Update } from './utils.ts';\n\nexport interface TableConfig<TColumn extends Column = Column<any>> {\n\tname: string;\n\tschema: string | undefined;\n\tcolumns: Record<string, TColumn>;\n\tdialect: string;\n}\n\nexport type UpdateTableConfig<T extends TableConfig, TUpdate extends Partial<TableConfig>> = Required<\n\tUpdate<T, TUpdate>\n>;\n\n/** @internal */\nexport const Schema = Symbol.for('drizzle:Schema');\n\n/** @internal */\nexport const Columns = Symbol.for('drizzle:Columns');\n\n/** @internal */\nexport const ExtraConfigColumns = Symbol.for('drizzle:ExtraConfigColumns');\n\n/** @internal */\nexport const OriginalName = Symbol.for('drizzle:OriginalName');\n\n/** @internal */\nexport const BaseName = Symbol.for('drizzle:BaseName');\n\n/** @internal */\nexport const IsAlias = Symbol.for('drizzle:IsAlias');\n\n/** @internal */\nexport const ExtraConfigBuilder = Symbol.for('drizzle:ExtraConfigBuilder');\n\nconst IsDrizzleTable = Symbol.for('drizzle:IsDrizzleTable');\n\nexport interface Table<\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tT extends TableConfig = TableConfig,\n> extends SQLWrapper {\n\t// SQLWrapper runtime implementation is defined in 'sql/sql.ts'\n}\n\nexport class Table<T extends TableConfig = TableConfig> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Table';\n\n\tdeclare readonly _: {\n\t\treadonly brand: 'Table';\n\t\treadonly config: T;\n\t\treadonly name: T['name'];\n\t\treadonly schema: T['schema'];\n\t\treadonly columns: T['columns'];\n\t\treadonly inferSelect: InferSelectModel<Table<T>>;\n\t\treadonly inferInsert: InferInsertModel<Table<T>>;\n\t};\n\n\tdeclare readonly $inferSelect: InferSelectModel<Table<T>>;\n\tdeclare readonly $inferInsert: InferInsertModel<Table<T>>;\n\n\t/** @internal */\n\tstatic readonly Symbol = {\n\t\tName: TableName as typeof TableName,\n\t\tSchema: Schema as typeof Schema,\n\t\tOriginalName: OriginalName as typeof OriginalName,\n\t\tColumns: Columns as typeof Columns,\n\t\tExtraConfigColumns: ExtraConfigColumns as typeof ExtraConfigColumns,\n\t\tBaseName: BaseName as typeof BaseName,\n\t\tIsAlias: IsAlias as typeof IsAlias,\n\t\tExtraConfigBuilder: ExtraConfigBuilder as typeof ExtraConfigBuilder,\n\t};\n\n\t/**\n\t * @internal\n\t * Can be changed if the table is aliased.\n\t */\n\t[TableName]: string;\n\n\t/**\n\t * @internal\n\t * Used to store the original name of the table, before any aliasing.\n\t */\n\t[OriginalName]: string;\n\n\t/** @internal */\n\t[Schema]: string | undefined;\n\n\t/** @internal */\n\t[Columns]!: T['columns'];\n\n\t/** @internal */\n\t[ExtraConfigColumns]!: Record<string, ExtraConfigColumn>;\n\n\t/**\n\t *  @internal\n\t * Used to store the table name before the transformation via the `tableCreator` functions.\n\t */\n\t[BaseName]: string;\n\n\t/** @internal */\n\t[IsAlias] = false;\n\n\t/** @internal */\n\t[IsDrizzleTable] = true;\n\n\t/** @internal */\n\t[ExtraConfigBuilder]: ((self: any) => Record<string, unknown> | unknown[]) | undefined = undefined;\n\n\tconstructor(name: string, schema: string | undefined, baseName: string) {\n\t\tthis[TableName] = this[OriginalName] = name;\n\t\tthis[Schema] = schema;\n\t\tthis[BaseName] = baseName;\n\t}\n}\n\nexport function isTable(table: unknown): table is Table {\n\treturn typeof table === 'object' && table !== null && IsDrizzleTable in table;\n}\n\n/**\n * Any table with a specified boundary.\n *\n * @example\n\t```ts\n\t// Any table with a specific name\n\ttype AnyUsersTable = AnyTable<{ name: 'users' }>;\n\t```\n *\n * To describe any table with any config, simply use `Table` without any type arguments, like this:\n *\n\t```ts\n\tfunction needsTable(table: Table) {\n\t\t...\n\t}\n\t```\n */\nexport type AnyTable<TPartial extends Partial<TableConfig>> = Table<UpdateTableConfig<TableConfig, TPartial>>;\n\nexport function getTableName<T extends Table>(table: T): T['_']['name'] {\n\treturn table[TableName];\n}\n\nexport function getTableUniqueName<T extends Table>(table: T): `${T['_']['schema']}.${T['_']['name']}` {\n\treturn `${table[Schema] ?? 'public'}.${table[TableName]}`;\n}\n\nexport type MapColumnName<TName extends string, TColumn extends Column, TDBColumNames extends boolean> =\n\tTDBColumNames extends true ? TColumn['_']['name']\n\t\t: TName;\n\nexport type InferModelFromColumns<\n\tTColumns extends Record<string, Column>,\n\tTInferMode extends 'select' | 'insert' = 'select',\n\tTConfig extends { dbColumnNames: boolean; override?: boolean } = { dbColumnNames: false; override: false },\n> = Simplify<\n\tTInferMode extends 'insert' ?\n\t\t\t& {\n\t\t\t\t[\n\t\t\t\t\tKey in keyof TColumns & string as RequiredKeyOnly<\n\t\t\t\t\t\tMapColumnName<Key, TColumns[Key], TConfig['dbColumnNames']>,\n\t\t\t\t\t\tTColumns[Key]\n\t\t\t\t\t>\n\t\t\t\t]: GetColumnData<TColumns[Key], 'query'>;\n\t\t\t}\n\t\t\t& {\n\t\t\t\t[\n\t\t\t\t\tKey in keyof TColumns & string as OptionalKeyOnly<\n\t\t\t\t\t\tMapColumnName<Key, TColumns[Key], TConfig['dbColumnNames']>,\n\t\t\t\t\t\tTColumns[Key],\n\t\t\t\t\t\tTConfig['override']\n\t\t\t\t\t>\n\t\t\t\t]?: GetColumnData<TColumns[Key], 'query'> | undefined;\n\t\t\t}\n\t\t: {\n\t\t\t[\n\t\t\t\tKey in keyof TColumns & string as MapColumnName<\n\t\t\t\t\tKey,\n\t\t\t\t\tTColumns[Key],\n\t\t\t\t\tTConfig['dbColumnNames']\n\t\t\t\t>\n\t\t\t]: GetColumnData<TColumns[Key], 'query'>;\n\t\t}\n>;\n\n/** @deprecated Use one of the alternatives: {@link InferSelectModel} / {@link InferInsertModel}, or `table.$inferSelect` / `table.$inferInsert`\n */\nexport type InferModel<\n\tTTable extends Table,\n\tTInferMode extends 'select' | 'insert' = 'select',\n\tTConfig extends { dbColumnNames: boolean } = { dbColumnNames: false },\n> = InferModelFromColumns<TTable['_']['columns'], TInferMode, TConfig>;\n\nexport type InferSelectModel<\n\tTTable extends Table,\n\tTConfig extends { dbColumnNames: boolean } = { dbColumnNames: false },\n> = InferModelFromColumns<TTable['_']['columns'], 'select', TConfig>;\n\nexport type InferInsertModel<\n\tTTable extends Table,\n\tTConfig extends { dbColumnNames: boolean; override?: boolean } = { dbColumnNames: false; override: false },\n> = InferModelFromColumns<TTable['_']['columns'], 'insert', TConfig>;\n", "/** @internal */\nexport const TableName = Symbol.for('drizzle:Name');\n", "import type {\n\tColumnBuilderBaseConfig,\n\tColumnBuilderRuntimeConfig,\n\tColumnDataType,\n\tGeneratedColumnConfig,\n\tGeneratedIdentityConfig,\n} from './column-builder.ts';\nimport { entityKind } from './entity.ts';\nimport type { DriverValueMapper, SQL, SQLWrapper } from './sql/sql.ts';\nimport type { Table } from './table.ts';\nimport type { Update } from './utils.ts';\n\nexport interface ColumnBaseConfig<\n\tTDataType extends ColumnDataType,\n\tTColumnType extends string,\n> extends ColumnBuilderBaseConfig<TDataType, TColumnType> {\n\ttableName: string;\n\tnotNull: boolean;\n\thasDefault: boolean;\n\tisPrimaryKey: boolean;\n\tisAutoincrement: boolean;\n\thasRuntimeDefault: boolean;\n}\n\nexport type ColumnTypeConfig<T extends ColumnBaseConfig<ColumnDataType, string>, TTypeConfig extends object> = T & {\n\tbrand: 'Column';\n\ttableName: T['tableName'];\n\tname: T['name'];\n\tdataType: T['dataType'];\n\tcolumnType: T['columnType'];\n\tdata: T['data'];\n\tdriverParam: T['driverParam'];\n\tnotNull: T['notNull'];\n\thasDefault: T['hasDefault'];\n\tisPrimaryKey: T['isPrimaryKey'];\n\tisAutoincrement: T['isAutoincrement'];\n\thasRuntimeDefault: T['hasRuntimeDefault'];\n\tenumValues: T['enumValues'];\n\tbaseColumn: T extends { baseColumn: infer U } ? U : unknown;\n\tgenerated: GeneratedColumnConfig<T['data']> | undefined;\n\tidentity: undefined | 'always' | 'byDefault';\n} & TTypeConfig;\n\nexport type ColumnRuntimeConfig<TData, TRuntimeConfig extends object> = ColumnBuilderRuntimeConfig<\n\tTData,\n\tTRuntimeConfig\n>;\n\nexport interface Column<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTRuntimeConfig extends object = object,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTTypeConfig extends object = object,\n> extends DriverValueMapper<T['data'], T['driverParam']>, SQLWrapper {\n\t// SQLWrapper runtime implementation is defined in 'sql/sql.ts'\n}\n/*\n\t`Column` only accepts a full `ColumnConfig` as its generic.\n\tTo infer parts of the config, use `AnyColumn` that accepts a partial config.\n\tSee `GetColumnData` for example usage of inferring.\n*/\nexport abstract class Column<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n\tTTypeConfig extends object = object,\n> implements DriverValueMapper<T['data'], T['driverParam']>, SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Column';\n\n\tdeclare readonly _: ColumnTypeConfig<T, TTypeConfig>;\n\n\treadonly name: string;\n\treadonly keyAsName: boolean;\n\treadonly primary: boolean;\n\treadonly notNull: boolean;\n\treadonly default: T['data'] | SQL | undefined;\n\treadonly defaultFn: (() => T['data'] | SQL) | undefined;\n\treadonly onUpdateFn: (() => T['data'] | SQL) | undefined;\n\treadonly hasDefault: boolean;\n\treadonly isUnique: boolean;\n\treadonly uniqueName: string | undefined;\n\treadonly uniqueType: string | undefined;\n\treadonly dataType: T['dataType'];\n\treadonly columnType: T['columnType'];\n\treadonly enumValues: T['enumValues'] = undefined;\n\treadonly generated: GeneratedColumnConfig<T['data']> | undefined = undefined;\n\treadonly generatedIdentity: GeneratedIdentityConfig | undefined = undefined;\n\n\tprotected config: ColumnRuntimeConfig<T['data'], TRuntimeConfig>;\n\n\tconstructor(\n\t\treadonly table: Table,\n\t\tconfig: ColumnRuntimeConfig<T['data'], TRuntimeConfig>,\n\t) {\n\t\tthis.config = config;\n\t\tthis.name = config.name;\n\t\tthis.keyAsName = config.keyAsName;\n\t\tthis.notNull = config.notNull;\n\t\tthis.default = config.default;\n\t\tthis.defaultFn = config.defaultFn;\n\t\tthis.onUpdateFn = config.onUpdateFn;\n\t\tthis.hasDefault = config.hasDefault;\n\t\tthis.primary = config.primaryKey;\n\t\tthis.isUnique = config.isUnique;\n\t\tthis.uniqueName = config.uniqueName;\n\t\tthis.uniqueType = config.uniqueType;\n\t\tthis.dataType = config.dataType as T['dataType'];\n\t\tthis.columnType = config.columnType;\n\t\tthis.generated = config.generated;\n\t\tthis.generatedIdentity = config.generatedIdentity;\n\t}\n\n\tabstract getSQLType(): string;\n\n\tmapFromDriverValue(value: unknown): unknown {\n\t\treturn value;\n\t}\n\n\tmapToDriverValue(value: unknown): unknown {\n\t\treturn value;\n\t}\n\n\t// ** @internal */\n\tshouldDisableInsert(): boolean {\n\t\treturn this.config.generated !== undefined && this.config.generated.type !== 'byDefault';\n\t}\n}\n\nexport type UpdateColConfig<\n\tT extends ColumnBaseConfig<ColumnDataType, string>,\n\tTUpdate extends Partial<ColumnBaseConfig<ColumnDataType, string>>,\n> = Update<T, TUpdate>;\n\nexport type AnyColumn<TPartial extends Partial<ColumnBaseConfig<ColumnDataType, string>> = {}> = Column<\n\tRequired<Update<ColumnBaseConfig<ColumnDataType, string>, TPartial>>\n>;\n\nexport type GetColumnData<TColumn extends Column, TInferMode extends 'query' | 'raw' = 'query'> =\n\t// dprint-ignore\n\tTInferMode extends 'raw' // Raw mode\n\t\t? TColumn['_']['data'] // Just return the underlying type\n\t\t: TColumn['_']['notNull'] extends true // Query mode\n\t\t? TColumn['_']['data'] // Query mode, not null\n\t\t: TColumn['_']['data'] | null; // Query mode, nullable\n\nexport type InferColumnsDataTypes<TColumns extends Record<string, Column>> = {\n\t[Key in keyof TColumns]: GetColumnData<TColumns[Key], 'query'>;\n};\n", "import { entityKind } from '~/entity.ts';\nimport type { AnyPgColumn, PgColumn } from './columns/index.ts';\nimport { PgTable } from './table.ts';\n\nexport function primaryKey<\n\tTTableName extends string,\n\tTColumn extends AnyPgColumn<{ tableName: TTableName }>,\n\tTColumns extends AnyPgColumn<{ tableName: TTableName }>[],\n>(config: { name?: string; columns: [TColumn, ...TColumns] }): PrimaryKeyBuilder;\n/**\n * @deprecated: Please use primaryKey({ columns: [] }) instead of this function\n * @param columns\n */\nexport function primaryKey<\n\tTTableName extends string,\n\tTColumns extends AnyPgColumn<{ tableName: TTableName }>[],\n>(...columns: TColumns): PrimaryKeyBuilder;\nexport function primaryKey(...config: any) {\n\tif (config[0].columns) {\n\t\treturn new PrimaryKeyBuilder(config[0].columns, config[0].name);\n\t}\n\treturn new PrimaryKeyBuilder(config);\n}\n\nexport class PrimaryKeyBuilder {\n\tstatic readonly [entityKind]: string = 'PgPrimaryKeyBuilder';\n\n\t/** @internal */\n\tcolumns: PgColumn[];\n\n\t/** @internal */\n\tname?: string;\n\n\tconstructor(\n\t\tcolumns: PgColumn[],\n\t\tname?: string,\n\t) {\n\t\tthis.columns = columns;\n\t\tthis.name = name;\n\t}\n\n\t/** @internal */\n\tbuild(table: PgTable): PrimaryKey {\n\t\treturn new PrimaryKey(table, this.columns, this.name);\n\t}\n}\n\nexport class PrimaryKey {\n\tstatic readonly [entityKind]: string = 'PgPrimaryKey';\n\n\treadonly columns: AnyPgColumn<{}>[];\n\treadonly name?: string;\n\n\tconstructor(readonly table: PgTable, columns: AnyPgColumn<{}>[], name?: string) {\n\t\tthis.columns = columns;\n\t\tthis.name = name;\n\t}\n\n\tgetName(): string {\n\t\treturn this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join('_')}_pk`;\n\t}\n}\n", "import type { BuildColumns, BuildExtraConfigColumns } from '~/column-builder.ts';\nimport { entityKind } from '~/entity.ts';\nimport { Table, type TableConfig as TableConfigBase, type UpdateTableConfig } from '~/table.ts';\nimport type { CheckBuilder } from './checks.ts';\nimport { getPgColumnBuilders, type PgColumnsBuilders } from './columns/all.ts';\nimport type { PgColumn, PgColumnBuilder, PgColumnBuilderBase } from './columns/common.ts';\nimport type { ForeignKey, ForeignKeyBuilder } from './foreign-keys.ts';\nimport type { AnyIndexBuilder } from './indexes.ts';\nimport type { PgPolicy } from './policies.ts';\nimport type { PrimaryKeyBuilder } from './primary-keys.ts';\nimport type { UniqueConstraintBuilder } from './unique-constraint.ts';\n\nexport type PgTableExtraConfigValue =\n\t| AnyIndexBuilder\n\t| CheckBuilder\n\t| ForeignKeyBuilder\n\t| PrimaryKeyBuilder\n\t| UniqueConstraintBuilder\n\t| PgPolicy;\n\nexport type PgTableExtraConfig = Record<\n\tstring,\n\tPgTableExtraConfigValue\n>;\n\nexport type TableConfig = TableConfigBase<PgColumn>;\n\n/** @internal */\nexport const InlineForeignKeys = Symbol.for('drizzle:PgInlineForeignKeys');\n/** @internal */\nexport const EnableRLS = Symbol.for('drizzle:EnableRLS');\n\nexport class PgTable<T extends TableConfig = TableConfig> extends Table<T> {\n\tstatic override readonly [entityKind]: string = 'PgTable';\n\n\t/** @internal */\n\tstatic override readonly Symbol = Object.assign({}, Table.Symbol, {\n\t\tInlineForeignKeys: InlineForeignKeys as typeof InlineForeignKeys,\n\t\tEnableRLS: EnableRLS as typeof EnableRLS,\n\t});\n\n\t/**@internal */\n\t[InlineForeignKeys]: ForeignKey[] = [];\n\n\t/** @internal */\n\t[EnableRLS]: boolean = false;\n\n\t/** @internal */\n\toverride [Table.Symbol.ExtraConfigBuilder]: ((self: Record<string, PgColumn>) => PgTableExtraConfig) | undefined =\n\t\tundefined;\n}\n\nexport type AnyPgTable<TPartial extends Partial<TableConfig> = {}> = PgTable<UpdateTableConfig<TableConfig, TPartial>>;\n\nexport type PgTableWithColumns<T extends TableConfig> =\n\t& PgTable<T>\n\t& {\n\t\t[Key in keyof T['columns']]: T['columns'][Key];\n\t}\n\t& {\n\t\tenableRLS: () => Omit<\n\t\t\tPgTableWithColumns<T>,\n\t\t\t'enableRLS'\n\t\t>;\n\t};\n\n/** @internal */\nexport function pgTableWithSchema<\n\tTTableName extends string,\n\tTSchemaName extends string | undefined,\n\tTColumnsMap extends Record<string, PgColumnBuilderBase>,\n>(\n\tname: TTableName,\n\tcolumns: TColumnsMap | ((columnTypes: PgColumnsBuilders) => TColumnsMap),\n\textraConfig:\n\t\t| ((self: BuildExtraConfigColumns<TTableName, TColumnsMap, 'pg'>) => PgTableExtraConfig | PgTableExtraConfigValue[])\n\t\t| undefined,\n\tschema: TSchemaName,\n\tbaseName = name,\n): PgTableWithColumns<{\n\tname: TTableName;\n\tschema: TSchemaName;\n\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\tdialect: 'pg';\n}> {\n\tconst rawTable = new PgTable<{\n\t\tname: TTableName;\n\t\tschema: TSchemaName;\n\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\t\tdialect: 'pg';\n\t}>(name, schema, baseName);\n\n\tconst parsedColumns: TColumnsMap = typeof columns === 'function' ? columns(getPgColumnBuilders()) : columns;\n\n\tconst builtColumns = Object.fromEntries(\n\t\tObject.entries(parsedColumns).map(([name, colBuilderBase]) => {\n\t\t\tconst colBuilder = colBuilderBase as PgColumnBuilder;\n\t\t\tcolBuilder.setName(name);\n\t\t\tconst column = colBuilder.build(rawTable);\n\t\t\trawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));\n\t\t\treturn [name, column];\n\t\t}),\n\t) as unknown as BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\n\tconst builtColumnsForExtraConfig = Object.fromEntries(\n\t\tObject.entries(parsedColumns).map(([name, colBuilderBase]) => {\n\t\t\tconst colBuilder = colBuilderBase as PgColumnBuilder;\n\t\t\tcolBuilder.setName(name);\n\t\t\tconst column = colBuilder.buildExtraConfigColumn(rawTable);\n\t\t\treturn [name, column];\n\t\t}),\n\t) as unknown as BuildExtraConfigColumns<TTableName, TColumnsMap, 'pg'>;\n\n\tconst table = Object.assign(rawTable, builtColumns);\n\n\ttable[Table.Symbol.Columns] = builtColumns;\n\ttable[Table.Symbol.ExtraConfigColumns] = builtColumnsForExtraConfig;\n\n\tif (extraConfig) {\n\t\ttable[PgTable.Symbol.ExtraConfigBuilder] = extraConfig as any;\n\t}\n\n\treturn Object.assign(table, {\n\t\tenableRLS: () => {\n\t\t\ttable[PgTable.Symbol.EnableRLS] = true;\n\t\t\treturn table as PgTableWithColumns<{\n\t\t\t\tname: TTableName;\n\t\t\t\tschema: TSchemaName;\n\t\t\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\t\t\t\tdialect: 'pg';\n\t\t\t}>;\n\t\t},\n\t});\n}\n\nexport interface PgTableFn<TSchema extends string | undefined = undefined> {\n\t<\n\t\tTTableName extends string,\n\t\tTColumnsMap extends Record<string, PgColumnBuilderBase>,\n\t>(\n\t\tname: TTableName,\n\t\tcolumns: TColumnsMap,\n\t\textraConfig?: (\n\t\t\tself: BuildExtraConfigColumns<TTableName, TColumnsMap, 'pg'>,\n\t\t) => PgTableExtraConfigValue[],\n\t): PgTableWithColumns<{\n\t\tname: TTableName;\n\t\tschema: TSchema;\n\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\t\tdialect: 'pg';\n\t}>;\n\n\t<\n\t\tTTableName extends string,\n\t\tTColumnsMap extends Record<string, PgColumnBuilderBase>,\n\t>(\n\t\tname: TTableName,\n\t\tcolumns: (columnTypes: PgColumnsBuilders) => TColumnsMap,\n\t\textraConfig?: (self: BuildExtraConfigColumns<TTableName, TColumnsMap, 'pg'>) => PgTableExtraConfigValue[],\n\t): PgTableWithColumns<{\n\t\tname: TTableName;\n\t\tschema: TSchema;\n\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\t\tdialect: 'pg';\n\t}>;\n\t/**\n\t * @deprecated The third parameter of pgTable is changing and will only accept an array instead of an object\n\t *\n\t * @example\n\t * Deprecated version:\n\t * ```ts\n\t * export const users = pgTable(\"users\", {\n\t * \tid: integer(),\n\t * }, (t) => ({\n\t * \tidx: index('custom_name').on(t.id)\n\t * }));\n\t * ```\n\t *\n\t * New API:\n\t * ```ts\n\t * export const users = pgTable(\"users\", {\n\t * \tid: integer(),\n\t * }, (t) => [\n\t * \tindex('custom_name').on(t.id)\n\t * ]);\n\t * ```\n\t */\n\t<\n\t\tTTableName extends string,\n\t\tTColumnsMap extends Record<string, PgColumnBuilderBase>,\n\t>(\n\t\tname: TTableName,\n\t\tcolumns: TColumnsMap,\n\t\textraConfig: (\n\t\t\tself: BuildExtraConfigColumns<TTableName, TColumnsMap, 'pg'>,\n\t\t) => PgTableExtraConfig,\n\t): PgTableWithColumns<{\n\t\tname: TTableName;\n\t\tschema: TSchema;\n\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\t\tdialect: 'pg';\n\t}>;\n\n\t/**\n\t * @deprecated The third parameter of pgTable is changing and will only accept an array instead of an object\n\t *\n\t * @example\n\t * Deprecated version:\n\t * ```ts\n\t * export const users = pgTable(\"users\", {\n\t * \tid: integer(),\n\t * }, (t) => ({\n\t * \tidx: index('custom_name').on(t.id)\n\t * }));\n\t * ```\n\t *\n\t * New API:\n\t * ```ts\n\t * export const users = pgTable(\"users\", {\n\t * \tid: integer(),\n\t * }, (t) => [\n\t * \tindex('custom_name').on(t.id)\n\t * ]);\n\t * ```\n\t */\n\t<\n\t\tTTableName extends string,\n\t\tTColumnsMap extends Record<string, PgColumnBuilderBase>,\n\t>(\n\t\tname: TTableName,\n\t\tcolumns: (columnTypes: PgColumnsBuilders) => TColumnsMap,\n\t\textraConfig: (self: BuildExtraConfigColumns<TTableName, TColumnsMap, 'pg'>) => PgTableExtraConfig,\n\t): PgTableWithColumns<{\n\t\tname: TTableName;\n\t\tschema: TSchema;\n\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\t\tdialect: 'pg';\n\t}>;\n}\n\nexport const pgTable: PgTableFn = (name, columns, extraConfig) => {\n\treturn pgTableWithSchema(name, columns, extraConfig, undefined);\n};\n\nexport function pgTableCreator(customizeTableName: (name: string) => string): PgTableFn {\n\treturn (name, columns, extraConfig) => {\n\t\treturn pgTableWithSchema(customizeTableName(name) as typeof name, columns, extraConfig, undefined, name);\n\t};\n}\n", "import type { AnyColumn } from './column.ts';\nimport { Column } from './column.ts';\nimport { is } from './entity.ts';\nimport type { Logger } from './logger.ts';\nimport type { SelectedFieldsOrdered } from './operations.ts';\nimport type { TableLike } from './query-builders/select.types.ts';\nimport { Param, SQL, View } from './sql/sql.ts';\nimport type { DriverValueDecoder } from './sql/sql.ts';\nimport { Subquery } from './subquery.ts';\nimport { getTableName, Table } from './table.ts';\nimport { ViewBaseConfig } from './view-common.ts';\n\n/** @internal */\nexport function mapResultRow<TResult>(\n\tcolumns: SelectedFieldsOrdered<AnyColumn>,\n\trow: unknown[],\n\tjoinsNotNullableMap: Record<string, boolean> | undefined,\n): TResult {\n\t// Key -> nested object key, value -> table name if all fields in the nested object are from the same table, false otherwise\n\tconst nullifyMap: Record<string, string | false> = {};\n\n\tconst result = columns.reduce<Record<string, any>>(\n\t\t(result, { path, field }, columnIndex) => {\n\t\t\tlet decoder: DriverValueDecoder<unknown, unknown>;\n\t\t\tif (is(field, Column)) {\n\t\t\t\tdecoder = field;\n\t\t\t} else if (is(field, SQL)) {\n\t\t\t\tdecoder = field.decoder;\n\t\t\t} else {\n\t\t\t\tdecoder = field.sql.decoder;\n\t\t\t}\n\t\t\tlet node = result;\n\t\t\tfor (const [pathChunkIndex, pathChunk] of path.entries()) {\n\t\t\t\tif (pathChunkIndex < path.length - 1) {\n\t\t\t\t\tif (!(pathChunk in node)) {\n\t\t\t\t\t\tnode[pathChunk] = {};\n\t\t\t\t\t}\n\t\t\t\t\tnode = node[pathChunk];\n\t\t\t\t} else {\n\t\t\t\t\tconst rawValue = row[columnIndex]!;\n\t\t\t\t\tconst value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);\n\n\t\t\t\t\tif (joinsNotNullableMap && is(field, Column) && path.length === 2) {\n\t\t\t\t\t\tconst objectName = path[0]!;\n\t\t\t\t\t\tif (!(objectName in nullifyMap)) {\n\t\t\t\t\t\t\tnullifyMap[objectName] = value === null ? getTableName(field.table) : false;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\ttypeof nullifyMap[objectName] === 'string' && nullifyMap[objectName] !== getTableName(field.table)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnullifyMap[objectName] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\t{},\n\t);\n\n\t// Nullify all nested objects from nullifyMap that are nullable\n\tif (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {\n\t\tfor (const [objectName, tableName] of Object.entries(nullifyMap)) {\n\t\t\tif (typeof tableName === 'string' && !joinsNotNullableMap[tableName]) {\n\t\t\t\tresult[objectName] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result as TResult;\n}\n\n/** @internal */\nexport function orderSelectedFields<TColumn extends AnyColumn>(\n\tfields: Record<string, unknown>,\n\tpathPrefix?: string[],\n): SelectedFieldsOrdered<TColumn> {\n\treturn Object.entries(fields).reduce<SelectedFieldsOrdered<AnyColumn>>((result, [name, field]) => {\n\t\tif (typeof name !== 'string') {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst newPath = pathPrefix ? [...pathPrefix, name] : [name];\n\t\tif (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {\n\t\t\tresult.push({ path: newPath, field });\n\t\t} else if (is(field, Table)) {\n\t\t\tresult.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));\n\t\t} else {\n\t\t\tresult.push(...orderSelectedFields(field as Record<string, unknown>, newPath));\n\t\t}\n\t\treturn result;\n\t}, []) as SelectedFieldsOrdered<TColumn>;\n}\n\nexport function haveSameKeys(left: Record<string, unknown>, right: Record<string, unknown>) {\n\tconst leftKeys = Object.keys(left);\n\tconst rightKeys = Object.keys(right);\n\n\tif (leftKeys.length !== rightKeys.length) {\n\t\treturn false;\n\t}\n\n\tfor (const [index, key] of leftKeys.entries()) {\n\t\tif (key !== rightKeys[index]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/** @internal */\nexport function mapUpdateSet(table: Table, values: Record<string, unknown>): UpdateSet {\n\tconst entries: [string, UpdateSet[string]][] = Object.entries(values)\n\t\t.filter(([, value]) => value !== undefined)\n\t\t.map(([key, value]) => {\n\t\t\t// eslint-disable-next-line unicorn/prefer-ternary\n\t\t\tif (is(value, SQL) || is(value, Column)) {\n\t\t\t\treturn [key, value];\n\t\t\t} else {\n\t\t\t\treturn [key, new Param(value, table[Table.Symbol.Columns][key])];\n\t\t\t}\n\t\t});\n\n\tif (entries.length === 0) {\n\t\tthrow new Error('No values to set');\n\t}\n\n\treturn Object.fromEntries(entries);\n}\n\nexport type UpdateSet = Record<string, SQL | Param | AnyColumn | null | undefined>;\n\nexport type OneOrMany<T> = T | T[];\n\nexport type Update<T, TUpdate> =\n\t& {\n\t\t[K in Exclude<keyof T, keyof TUpdate>]: T[K];\n\t}\n\t& TUpdate;\n\nexport type Simplify<T> =\n\t& {\n\t\t// @ts-ignore - \"Type parameter 'K' has a circular constraint\", not sure why\n\t\t[K in keyof T]: T[K];\n\t}\n\t& {};\n\nexport type SimplifyMappedType<T> = [T] extends [unknown] ? T : never;\n\nexport type ShallowRecord<K extends keyof any, T> = SimplifyMappedType<{ [P in K]: T }>;\n\nexport type Assume<T, U> = T extends U ? T : U;\n\nexport type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2) ? true : false;\n\nexport interface DrizzleTypeError<T extends string> {\n\t$drizzleTypeError: T;\n}\n\nexport type ValueOrArray<T> = T | T[];\n\n/** @internal */\nexport function applyMixins(baseClass: any, extendedClasses: any[]) {\n\tfor (const extendedClass of extendedClasses) {\n\t\tfor (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {\n\t\t\tif (name === 'constructor') continue;\n\n\t\t\tObject.defineProperty(\n\t\t\t\tbaseClass.prototype,\n\t\t\t\tname,\n\t\t\t\tObject.getOwnPropertyDescriptor(extendedClass.prototype, name) || Object.create(null),\n\t\t\t);\n\t\t}\n\t}\n}\n\nexport type Or<T1, T2> = T1 extends true ? true : T2 extends true ? true : false;\n\nexport type IfThenElse<If, Then, Else> = If extends true ? Then : Else;\n\nexport type PromiseOf<T> = T extends Promise<infer U> ? U : T;\n\nexport type Writable<T> = {\n\t-readonly [P in keyof T]: T[P];\n};\n\nexport function getTableColumns<T extends Table>(table: T): T['_']['columns'] {\n\treturn table[Table.Symbol.Columns];\n}\n\nexport function getViewSelectedFields<T extends View>(view: T): T['_']['selectedFields'] {\n\treturn view[ViewBaseConfig].selectedFields;\n}\n\n/** @internal */\nexport function getTableLikeName(table: TableLike): string | undefined {\n\treturn is(table, Subquery)\n\t\t? table._.alias\n\t\t: is(table, View)\n\t\t? table[ViewBaseConfig].name\n\t\t: is(table, SQL)\n\t\t? undefined\n\t\t: table[Table.Symbol.IsAlias]\n\t\t? table[Table.Symbol.Name]\n\t\t: table[Table.Symbol.BaseName];\n}\n\nexport type ColumnsWithTable<\n\tTTableName extends string,\n\tTForeignTableName extends string,\n\tTColumns extends AnyColumn<{ tableName: TTableName }>[],\n> = { [Key in keyof TColumns]: AnyColumn<{ tableName: TForeignTableName }> };\n\nexport type Casing = 'snake_case' | 'camelCase';\n\nexport interface DrizzleConfig<TSchema extends Record<string, unknown> = Record<string, never>> {\n\tlogger?: boolean | Logger;\n\tschema?: TSchema;\n\tcasing?: Casing;\n}\nexport type ValidateShape<T, ValidShape, TResult = T> = T extends ValidShape\n\t? Exclude<keyof T, keyof ValidShape> extends never ? TResult\n\t: DrizzleTypeError<\n\t\t`Invalid key(s): ${Exclude<(keyof T) & (string | number | bigint | boolean | null | undefined), keyof ValidShape>}`\n\t>\n\t: never;\n\nexport type KnownKeysOnly<T, U> = {\n\t[K in keyof T]: K extends keyof U ? T[K] : never;\n};\n\nexport type IsAny<T> = 0 extends (1 & T) ? true : false;\n\n/** @internal */\nexport function getColumnNameAndConfig<\n\tTConfig extends Record<string, any> | undefined,\n>(a: string | TConfig | undefined, b: TConfig | undefined) {\n\treturn {\n\t\tname: typeof a === 'string' && a.length > 0 ? a : '' as string,\n\t\tconfig: typeof a === 'object' ? a : b as TConfig,\n\t};\n}\n\nexport type IfNotImported<T, Y, N> = unknown extends T ? Y : N;\n\nexport type ImportTypeError<TPackageName extends string> =\n\t`Please install \\`${TPackageName}\\` to allow Drizzle ORM to connect to the database`;\n\nexport type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Keys extends any\n\t? Required<Pick<T, Keys>> & Partial<Omit<T, Keys>>\n\t: never;\n\ntype ExpectedConfigShape = {\n\tlogger?: boolean | {\n\t\tlogQuery(query: string, params: unknown[]): void;\n\t};\n\tschema?: Record<string, never>;\n\tcasing?: 'snake_case' | 'camelCase';\n};\n\n// If this errors, you must update config shape checker function with new config specs\nconst _: DrizzleConfig = {} as ExpectedConfigShape;\nconst __: ExpectedConfigShape = {} as DrizzleConfig;\n\nexport function isConfig(data: any): boolean {\n\tif (typeof data !== 'object' || data === null) return false;\n\n\tif (data.constructor.name !== 'Object') return false;\n\n\tif ('logger' in data) {\n\t\tconst type = typeof data['logger'];\n\t\tif (\n\t\t\ttype !== 'boolean' && (type !== 'object' || typeof data['logger']['logQuery'] !== 'function')\n\t\t\t&& type !== 'undefined'\n\t\t) return false;\n\n\t\treturn true;\n\t}\n\n\tif ('schema' in data) {\n\t\tconst type = typeof data['logger'];\n\t\tif (type !== 'object' && type !== 'undefined') return false;\n\n\t\treturn true;\n\t}\n\n\tif ('casing' in data) {\n\t\tconst type = typeof data['logger'];\n\t\tif (type !== 'string' && type !== 'undefined') return false;\n\n\t\treturn true;\n\t}\n\n\tif ('mode' in data) {\n\t\tif (data['mode'] !== 'default' || data['mode'] !== 'planetscale' || data['mode'] !== undefined) return false;\n\n\t\treturn true;\n\t}\n\n\tif ('connection' in data) {\n\t\tconst type = typeof data['connection'];\n\t\tif (type !== 'string' && type !== 'object' && type !== 'undefined') return false;\n\n\t\treturn true;\n\t}\n\n\tif ('client' in data) {\n\t\tconst type = typeof data['client'];\n\t\tif (type !== 'object' && type !== 'function' && type !== 'undefined') return false;\n\n\t\treturn true;\n\t}\n\n\tif (Object.keys(data).length === 0) return true;\n\n\treturn false;\n}\n\nexport type NeonAuthToken = string | (() => string | Promise<string>);\n", "import type { CasingCache } from '~/casing.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport { isPgEnum } from '~/pg-core/columns/enum.ts';\nimport type { SelectResult } from '~/query-builders/select.types.ts';\nimport { Subquery } from '~/subquery.ts';\nimport { tracer } from '~/tracing.ts';\nimport type { Assume, Equal } from '~/utils.ts';\nimport { ViewBaseConfig } from '~/view-common.ts';\nimport type { AnyColumn } from '../column.ts';\nimport { Column } from '../column.ts';\nimport { IsAlias, Table } from '../table.ts';\n\n/**\n * This class is used to indicate a primitive param value that is used in `sql` tag.\n * It is only used on type level and is never instantiated at runtime.\n * If you see a value of this type in the code, its runtime value is actually the primitive param value.\n */\nexport class FakePrimitiveParam {\n\tstatic readonly [entityKind]: string = 'FakePrimitiveParam';\n}\n\nexport type Chunk =\n\t| string\n\t| Table\n\t| View\n\t| AnyColumn\n\t| Name\n\t| Param\n\t| Placeholder\n\t| SQL;\n\nexport interface BuildQueryConfig {\n\tcasing: CasingCache;\n\tescapeName(name: string): string;\n\tescapeParam(num: number, value: unknown): string;\n\tescapeString(str: string): string;\n\tprepareTyping?: (encoder: DriverValueEncoder<unknown, unknown>) => QueryTypingsValue;\n\tparamStartIndex?: { value: number };\n\tinlineParams?: boolean;\n\tinvokeSource?: 'indexes' | undefined;\n}\n\nexport type QueryTypingsValue = 'json' | 'decimal' | 'time' | 'timestamp' | 'uuid' | 'date' | 'none';\n\nexport interface Query {\n\tsql: string;\n\tparams: unknown[];\n}\n\nexport interface QueryWithTypings extends Query {\n\ttypings?: QueryTypingsValue[];\n}\n\n/**\n * Any value that implements the `getSQL` method. The implementations include:\n * - `Table`\n * - `Column`\n * - `View`\n * - `Subquery`\n * - `SQL`\n * - `SQL.Aliased`\n * - `Placeholder`\n * - `Param`\n */\nexport interface SQLWrapper {\n\tgetSQL(): SQL;\n\tshouldOmitSQLParens?(): boolean;\n}\n\nexport function isSQLWrapper(value: unknown): value is SQLWrapper {\n\treturn value !== null && value !== undefined && typeof (value as any).getSQL === 'function';\n}\n\nfunction mergeQueries(queries: QueryWithTypings[]): QueryWithTypings {\n\tconst result: QueryWithTypings = { sql: '', params: [] };\n\tfor (const query of queries) {\n\t\tresult.sql += query.sql;\n\t\tresult.params.push(...query.params);\n\t\tif (query.typings?.length) {\n\t\t\tif (!result.typings) {\n\t\t\t\tresult.typings = [];\n\t\t\t}\n\t\t\tresult.typings.push(...query.typings);\n\t\t}\n\t}\n\treturn result;\n}\n\nexport class StringChunk implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'StringChunk';\n\n\treadonly value: string[];\n\n\tconstructor(value: string | string[]) {\n\t\tthis.value = Array.isArray(value) ? value : [value];\n\t}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\nexport class SQL<T = unknown> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'SQL';\n\n\tdeclare _: {\n\t\tbrand: 'SQL';\n\t\ttype: T;\n\t};\n\n\t/** @internal */\n\tdecoder: DriverValueDecoder<T, any> = noopDecoder;\n\tprivate shouldInlineParams = false;\n\n\tconstructor(readonly queryChunks: SQLChunk[]) {}\n\n\tappend(query: SQL): this {\n\t\tthis.queryChunks.push(...query.queryChunks);\n\t\treturn this;\n\t}\n\n\ttoQuery(config: BuildQueryConfig): QueryWithTypings {\n\t\treturn tracer.startActiveSpan('drizzle.buildSQL', (span) => {\n\t\t\tconst query = this.buildQueryFromSourceParams(this.queryChunks, config);\n\t\t\tspan?.setAttributes({\n\t\t\t\t'drizzle.query.text': query.sql,\n\t\t\t\t'drizzle.query.params': JSON.stringify(query.params),\n\t\t\t});\n\t\t\treturn query;\n\t\t});\n\t}\n\n\tbuildQueryFromSourceParams(chunks: SQLChunk[], _config: BuildQueryConfig): Query {\n\t\tconst config = Object.assign({}, _config, {\n\t\t\tinlineParams: _config.inlineParams || this.shouldInlineParams,\n\t\t\tparamStartIndex: _config.paramStartIndex || { value: 0 },\n\t\t});\n\n\t\tconst {\n\t\t\tcasing,\n\t\t\tescapeName,\n\t\t\tescapeParam,\n\t\t\tprepareTyping,\n\t\t\tinlineParams,\n\t\t\tparamStartIndex,\n\t\t} = config;\n\n\t\treturn mergeQueries(chunks.map((chunk): QueryWithTypings => {\n\t\t\tif (is(chunk, StringChunk)) {\n\t\t\t\treturn { sql: chunk.value.join(''), params: [] };\n\t\t\t}\n\n\t\t\tif (is(chunk, Name)) {\n\t\t\t\treturn { sql: escapeName(chunk.value), params: [] };\n\t\t\t}\n\n\t\t\tif (chunk === undefined) {\n\t\t\t\treturn { sql: '', params: [] };\n\t\t\t}\n\n\t\t\tif (Array.isArray(chunk)) {\n\t\t\t\tconst result: SQLChunk[] = [new StringChunk('(')];\n\t\t\t\tfor (const [i, p] of chunk.entries()) {\n\t\t\t\t\tresult.push(p);\n\t\t\t\t\tif (i < chunk.length - 1) {\n\t\t\t\t\t\tresult.push(new StringChunk(', '));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult.push(new StringChunk(')'));\n\t\t\t\treturn this.buildQueryFromSourceParams(result, config);\n\t\t\t}\n\n\t\t\tif (is(chunk, SQL)) {\n\t\t\t\treturn this.buildQueryFromSourceParams(chunk.queryChunks, {\n\t\t\t\t\t...config,\n\t\t\t\t\tinlineParams: inlineParams || chunk.shouldInlineParams,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (is(chunk, Table)) {\n\t\t\t\tconst schemaName = chunk[Table.Symbol.Schema];\n\t\t\t\tconst tableName = chunk[Table.Symbol.Name];\n\t\t\t\treturn {\n\t\t\t\t\tsql: schemaName === undefined\n\t\t\t\t\t\t? escapeName(tableName)\n\t\t\t\t\t\t: escapeName(schemaName) + '.' + escapeName(tableName),\n\t\t\t\t\tparams: [],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (is(chunk, Column)) {\n\t\t\t\tconst columnName = casing.getColumnCasing(chunk);\n\t\t\t\tif (_config.invokeSource === 'indexes') {\n\t\t\t\t\treturn { sql: escapeName(columnName), params: [] };\n\t\t\t\t}\n\n\t\t\t\tconst schemaName = chunk.table[Table.Symbol.Schema];\n\t\t\t\treturn {\n\t\t\t\t\tsql: chunk.table[IsAlias] || schemaName === undefined\n\t\t\t\t\t\t? escapeName(chunk.table[Table.Symbol.Name]) + '.' + escapeName(columnName)\n\t\t\t\t\t\t: escapeName(schemaName) + '.' + escapeName(chunk.table[Table.Symbol.Name]) + '.'\n\t\t\t\t\t\t\t+ escapeName(columnName),\n\t\t\t\t\tparams: [],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (is(chunk, View)) {\n\t\t\t\tconst schemaName = chunk[ViewBaseConfig].schema;\n\t\t\t\tconst viewName = chunk[ViewBaseConfig].name;\n\t\t\t\treturn {\n\t\t\t\t\tsql: schemaName === undefined\n\t\t\t\t\t\t? escapeName(viewName)\n\t\t\t\t\t\t: escapeName(schemaName) + '.' + escapeName(viewName),\n\t\t\t\t\tparams: [],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (is(chunk, Param)) {\n\t\t\t\tif (is(chunk.value, Placeholder)) {\n\t\t\t\t\treturn { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ['none'] };\n\t\t\t\t}\n\n\t\t\t\tconst mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);\n\n\t\t\t\tif (is(mappedValue, SQL)) {\n\t\t\t\t\treturn this.buildQueryFromSourceParams([mappedValue], config);\n\t\t\t\t}\n\n\t\t\t\tif (inlineParams) {\n\t\t\t\t\treturn { sql: this.mapInlineParam(mappedValue, config), params: [] };\n\t\t\t\t}\n\n\t\t\t\tlet typings: QueryTypingsValue[] = ['none'];\n\t\t\t\tif (prepareTyping) {\n\t\t\t\t\ttypings = [prepareTyping(chunk.encoder)];\n\t\t\t\t}\n\n\t\t\t\treturn { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };\n\t\t\t}\n\n\t\t\tif (is(chunk, Placeholder)) {\n\t\t\t\treturn { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ['none'] };\n\t\t\t}\n\n\t\t\tif (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {\n\t\t\t\treturn { sql: escapeName(chunk.fieldAlias), params: [] };\n\t\t\t}\n\n\t\t\tif (is(chunk, Subquery)) {\n\t\t\t\tif (chunk._.isWith) {\n\t\t\t\t\treturn { sql: escapeName(chunk._.alias), params: [] };\n\t\t\t\t}\n\t\t\t\treturn this.buildQueryFromSourceParams([\n\t\t\t\t\tnew StringChunk('('),\n\t\t\t\t\tchunk._.sql,\n\t\t\t\t\tnew StringChunk(') '),\n\t\t\t\t\tnew Name(chunk._.alias),\n\t\t\t\t], config);\n\t\t\t}\n\n\t\t\tif (isPgEnum(chunk)) {\n\t\t\t\tif (chunk.schema) {\n\t\t\t\t\treturn { sql: escapeName(chunk.schema) + '.' + escapeName(chunk.enumName), params: [] };\n\t\t\t\t}\n\t\t\t\treturn { sql: escapeName(chunk.enumName), params: [] };\n\t\t\t}\n\n\t\t\tif (isSQLWrapper(chunk)) {\n\t\t\t\tif (chunk.shouldOmitSQLParens?.()) {\n\t\t\t\t\treturn this.buildQueryFromSourceParams([chunk.getSQL()], config);\n\t\t\t\t}\n\t\t\t\treturn this.buildQueryFromSourceParams([\n\t\t\t\t\tnew StringChunk('('),\n\t\t\t\t\tchunk.getSQL(),\n\t\t\t\t\tnew StringChunk(')'),\n\t\t\t\t], config);\n\t\t\t}\n\n\t\t\tif (inlineParams) {\n\t\t\t\treturn { sql: this.mapInlineParam(chunk, config), params: [] };\n\t\t\t}\n\n\t\t\treturn { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ['none'] };\n\t\t}));\n\t}\n\n\tprivate mapInlineParam(\n\t\tchunk: unknown,\n\t\t{ escapeString }: BuildQueryConfig,\n\t): string {\n\t\tif (chunk === null) {\n\t\t\treturn 'null';\n\t\t}\n\t\tif (typeof chunk === 'number' || typeof chunk === 'boolean') {\n\t\t\treturn chunk.toString();\n\t\t}\n\t\tif (typeof chunk === 'string') {\n\t\t\treturn escapeString(chunk);\n\t\t}\n\t\tif (typeof chunk === 'object') {\n\t\t\tconst mappedValueAsString = chunk.toString();\n\t\t\tif (mappedValueAsString === '[object Object]') {\n\t\t\t\treturn escapeString(JSON.stringify(chunk));\n\t\t\t}\n\t\t\treturn escapeString(mappedValueAsString);\n\t\t}\n\t\tthrow new Error('Unexpected param value: ' + chunk);\n\t}\n\n\tgetSQL(): SQL {\n\t\treturn this;\n\t}\n\n\tas(alias: string): SQL.Aliased<T>;\n\t/**\n\t * @deprecated\n\t * Use ``sql<DataType>`query`.as(alias)`` instead.\n\t */\n\tas<TData>(): SQL<TData>;\n\t/**\n\t * @deprecated\n\t * Use ``sql<DataType>`query`.as(alias)`` instead.\n\t */\n\tas<TData>(alias: string): SQL.Aliased<TData>;\n\tas(alias?: string): SQL<T> | SQL.Aliased<T> {\n\t\t// TODO: remove with deprecated overloads\n\t\tif (alias === undefined) {\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new SQL.Aliased(this, alias);\n\t}\n\n\tmapWith<\n\t\tTDecoder extends\n\t\t\t| DriverValueDecoder<any, any>\n\t\t\t| DriverValueDecoder<any, any>['mapFromDriverValue'],\n\t>(decoder: TDecoder): SQL<GetDecoderResult<TDecoder>> {\n\t\tthis.decoder = typeof decoder === 'function' ? { mapFromDriverValue: decoder } : decoder;\n\t\treturn this as SQL<GetDecoderResult<TDecoder>>;\n\t}\n\n\tinlineParams(): this {\n\t\tthis.shouldInlineParams = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * This method is used to conditionally include a part of the query.\n\t *\n\t * @param condition - Condition to check\n\t * @returns itself if the condition is `true`, otherwise `undefined`\n\t */\n\tif(condition: any | undefined): this | undefined {\n\t\treturn condition ? this : undefined;\n\t}\n}\n\nexport type GetDecoderResult<T> = T extends Column ? T['_']['data'] : T extends\n\t| DriverValueDecoder<infer TData, any>\n\t| DriverValueDecoder<infer TData, any>['mapFromDriverValue'] ? TData\n: never;\n\n/**\n * Any DB name (table, column, index etc.)\n */\nexport class Name implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Name';\n\n\tprotected brand!: 'Name';\n\n\tconstructor(readonly value: string) {}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\n/**\n * Any DB name (table, column, index etc.)\n * @deprecated Use `sql.identifier` instead.\n */\nexport function name(value: string): Name {\n\treturn new Name(value);\n}\n\nexport interface DriverValueDecoder<TData, TDriverParam> {\n\tmapFromDriverValue(value: TDriverParam): TData;\n}\n\nexport interface DriverValueEncoder<TData, TDriverParam> {\n\tmapToDriverValue(value: TData): TDriverParam | SQL;\n}\n\nexport function isDriverValueEncoder(value: unknown): value is DriverValueEncoder<any, any> {\n\treturn typeof value === 'object' && value !== null && 'mapToDriverValue' in value\n\t\t&& typeof (value as any).mapToDriverValue === 'function';\n}\n\nexport const noopDecoder: DriverValueDecoder<any, any> = {\n\tmapFromDriverValue: (value) => value,\n};\n\nexport const noopEncoder: DriverValueEncoder<any, any> = {\n\tmapToDriverValue: (value) => value,\n};\n\nexport interface DriverValueMapper<TData, TDriverParam>\n\textends DriverValueDecoder<TData, TDriverParam>, DriverValueEncoder<TData, TDriverParam>\n{}\n\nexport const noopMapper: DriverValueMapper<any, any> = {\n\t...noopDecoder,\n\t...noopEncoder,\n};\n\n/** Parameter value that is optionally bound to an encoder (for example, a column). */\nexport class Param<TDataType = unknown, TDriverParamType = TDataType> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Param';\n\n\tprotected brand!: 'BoundParamValue';\n\n\t/**\n\t * @param value - Parameter value\n\t * @param encoder - Encoder to convert the value to a driver parameter\n\t */\n\tconstructor(\n\t\treadonly value: TDataType,\n\t\treadonly encoder: DriverValueEncoder<TDataType, TDriverParamType> = noopEncoder,\n\t) {}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\n/** @deprecated Use `sql.param` instead. */\nexport function param<TData, TDriver>(\n\tvalue: TData,\n\tencoder?: DriverValueEncoder<TData, TDriver>,\n): Param<TData, TDriver> {\n\treturn new Param(value, encoder);\n}\n\n/**\n * Anything that can be passed to the `` sql`...` `` tagged function.\n */\nexport type SQLChunk =\n\t| StringChunk\n\t| SQLChunk[]\n\t| SQLWrapper\n\t| SQL\n\t| Table\n\t| View\n\t| Subquery\n\t| AnyColumn\n\t| Param\n\t| Name\n\t| undefined\n\t| FakePrimitiveParam\n\t| Placeholder;\n\nexport function sql<T>(strings: TemplateStringsArray, ...params: any[]): SQL<T>;\n/*\n\tThe type of `params` is specified as `SQLChunk[]`, but that's slightly incorrect -\n\tin runtime, users won't pass `FakePrimitiveParam` instances as `params` - they will pass primitive values\n\twhich will be wrapped in `Param`. That's why the overload specifies `params` as `any[]` and not as `SQLSourceParam[]`.\n\tThis type is used to make our lives easier and the type checker happy.\n*/\nexport function sql(strings: TemplateStringsArray, ...params: SQLChunk[]): SQL {\n\tconst queryChunks: SQLChunk[] = [];\n\tif (params.length > 0 || (strings.length > 0 && strings[0] !== '')) {\n\t\tqueryChunks.push(new StringChunk(strings[0]!));\n\t}\n\tfor (const [paramIndex, param] of params.entries()) {\n\t\tqueryChunks.push(param, new StringChunk(strings[paramIndex + 1]!));\n\t}\n\n\treturn new SQL(queryChunks);\n}\n\nexport namespace sql {\n\texport function empty(): SQL {\n\t\treturn new SQL([]);\n\t}\n\n\t/** @deprecated - use `sql.join()` */\n\texport function fromList(list: SQLChunk[]): SQL {\n\t\treturn new SQL(list);\n\t}\n\n\t/**\n\t * Convenience function to create an SQL query from a raw string.\n\t * @param str The raw SQL query string.\n\t */\n\texport function raw(str: string): SQL {\n\t\treturn new SQL([new StringChunk(str)]);\n\t}\n\n\t/**\n\t * Join a list of SQL chunks with a separator.\n\t * @example\n\t * ```ts\n\t * const query = sql.join([sql`a`, sql`b`, sql`c`]);\n\t * // sql`abc`\n\t * ```\n\t * @example\n\t * ```ts\n\t * const query = sql.join([sql`a`, sql`b`, sql`c`], sql`, `);\n\t * // sql`a, b, c`\n\t * ```\n\t */\n\texport function join(chunks: SQLChunk[], separator?: SQLChunk): SQL {\n\t\tconst result: SQLChunk[] = [];\n\t\tfor (const [i, chunk] of chunks.entries()) {\n\t\t\tif (i > 0 && separator !== undefined) {\n\t\t\t\tresult.push(separator);\n\t\t\t}\n\t\t\tresult.push(chunk);\n\t\t}\n\t\treturn new SQL(result);\n\t}\n\n\t/**\n\t * Create a SQL chunk that represents a DB identifier (table, column, index etc.).\n\t * When used in a query, the identifier will be escaped based on the DB engine.\n\t * For example, in PostgreSQL, identifiers are escaped with double quotes.\n\t *\n\t * **WARNING: This function does not offer any protection against SQL injections, so you must validate any user input beforehand.**\n\t *\n\t * @example ```ts\n\t * const query = sql`SELECT * FROM ${sql.identifier('my-table')}`;\n\t * // 'SELECT * FROM \"my-table\"'\n\t * ```\n\t */\n\texport function identifier(value: string): Name {\n\t\treturn new Name(value);\n\t}\n\n\texport function placeholder<TName extends string>(name: TName): Placeholder<TName> {\n\t\treturn new Placeholder(name);\n\t}\n\n\texport function param<TData, TDriver>(\n\t\tvalue: TData,\n\t\tencoder?: DriverValueEncoder<TData, TDriver>,\n\t): Param<TData, TDriver> {\n\t\treturn new Param(value, encoder);\n\t}\n}\n\nexport namespace SQL {\n\texport class Aliased<T = unknown> implements SQLWrapper {\n\t\tstatic readonly [entityKind]: string = 'SQL.Aliased';\n\n\t\tdeclare _: {\n\t\t\tbrand: 'SQL.Aliased';\n\t\t\ttype: T;\n\t\t};\n\n\t\t/** @internal */\n\t\tisSelectionField = false;\n\n\t\tconstructor(\n\t\t\treadonly sql: SQL,\n\t\t\treadonly fieldAlias: string,\n\t\t) {}\n\n\t\tgetSQL(): SQL {\n\t\t\treturn this.sql;\n\t\t}\n\n\t\t/** @internal */\n\t\tclone() {\n\t\t\treturn new Aliased(this.sql, this.fieldAlias);\n\t\t}\n\t}\n}\n\nexport class Placeholder<TName extends string = string, TValue = any> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Placeholder';\n\n\tdeclare protected: TValue;\n\n\tconstructor(readonly name: TName) {}\n\n\tgetSQL(): SQL {\n\t\treturn new SQL([this]);\n\t}\n}\n\n/** @deprecated Use `sql.placeholder` instead. */\nexport function placeholder<TName extends string>(name: TName): Placeholder<TName> {\n\treturn new Placeholder(name);\n}\n\nexport function fillPlaceholders(params: unknown[], values: Record<string, unknown>): unknown[] {\n\treturn params.map((p) => {\n\t\tif (is(p, Placeholder)) {\n\t\t\tif (!(p.name in values)) {\n\t\t\t\tthrow new Error(`No value for placeholder \"${p.name}\" was provided`);\n\t\t\t}\n\n\t\t\treturn values[p.name];\n\t\t}\n\n\t\tif (is(p, Param) && is(p.value, Placeholder)) {\n\t\t\tif (!(p.value.name in values)) {\n\t\t\t\tthrow new Error(`No value for placeholder \"${p.value.name}\" was provided`);\n\t\t\t}\n\n\t\t\treturn p.encoder.mapToDriverValue(values[p.value.name]);\n\t\t}\n\n\t\treturn p;\n\t});\n}\n\nexport type ColumnsSelection = Record<string, unknown>;\n\nconst IsDrizzleView = Symbol.for('drizzle:IsDrizzleView');\n\nexport abstract class View<\n\tTName extends string = string,\n\tTExisting extends boolean = boolean,\n\tTSelection extends ColumnsSelection = ColumnsSelection,\n> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'View';\n\n\tdeclare _: {\n\t\tbrand: 'View';\n\t\tviewBrand: string;\n\t\tname: TName;\n\t\texisting: TExisting;\n\t\tselectedFields: TSelection;\n\t};\n\n\t/** @internal */\n\t[ViewBaseConfig]: {\n\t\tname: TName;\n\t\toriginalName: TName;\n\t\tschema: string | undefined;\n\t\tselectedFields: ColumnsSelection;\n\t\tisExisting: TExisting;\n\t\tquery: TExisting extends true ? undefined : SQL;\n\t\tisAlias: boolean;\n\t};\n\n\t/** @internal */\n\t[IsDrizzleView] = true;\n\n\tdeclare readonly $inferSelect: InferSelectViewModel<View<Assume<TName, string>, TExisting, TSelection>>;\n\n\tconstructor(\n\t\t{ name, schema, selectedFields, query }: {\n\t\t\tname: TName;\n\t\t\tschema: string | undefined;\n\t\t\tselectedFields: ColumnsSelection;\n\t\t\tquery: SQL | undefined;\n\t\t},\n\t) {\n\t\tthis[ViewBaseConfig] = {\n\t\t\tname,\n\t\t\toriginalName: name,\n\t\t\tschema,\n\t\t\tselectedFields,\n\t\t\tquery: query as (TExisting extends true ? undefined : SQL),\n\t\t\tisExisting: !query as TExisting,\n\t\t\tisAlias: false,\n\t\t};\n\t}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\nexport function isView(view: unknown): view is View {\n\treturn typeof view === 'object' && view !== null && IsDrizzleView in view;\n}\n\nexport type InferSelectViewModel<TView extends View> =\n\tEqual<TView['_']['selectedFields'], { [x: string]: unknown }> extends true ? { [x: string]: unknown }\n\t\t: SelectResult<\n\t\t\tTView['_']['selectedFields'],\n\t\t\t'single',\n\t\t\tRecord<TView['_']['name'], 'not-null'>\n\t\t>;\n\n// Defined separately from the Column class to resolve circular dependency\nColumn.prototype.getSQL = function() {\n\treturn new SQL([this]);\n};\n\n// Defined separately from the Table class to resolve circular dependency\nTable.prototype.getSQL = function() {\n\treturn new SQL([this]);\n};\n\n// Defined separately from the Column class to resolve circular dependency\nSubquery.prototype.getSQL = function() {\n\treturn new SQL([this]);\n};\n", "import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport type { Writable } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgEnumColumnBuilderInitial<TName extends string, TValues extends [string, ...string[]]> =\n\tPgEnumColumnBuilder<{\n\t\tname: TName;\n\t\tdataType: 'string';\n\t\tcolumnType: 'PgEnumColumn';\n\t\tdata: TValues[number];\n\t\tenumValues: TValues;\n\t\tdriverParam: string;\n\t}>;\n\nconst isPgEnumSym = Symbol.for('drizzle:isPgEnum');\nexport interface PgEnum<TValues extends [string, ...string[]]> {\n\t(): PgEnumColumnBuilderInitial<'', TValues>;\n\t<TName extends string>(name: TName): PgEnumColumnBuilderInitial<TName, TValues>;\n\t<TName extends string>(name?: TName): PgEnumColumnBuilderInitial<TName, TValues>;\n\n\treadonly enumName: string;\n\treadonly enumValues: TValues;\n\treadonly schema: string | undefined;\n\t/** @internal */\n\t[isPgEnumSym]: true;\n}\n\nexport function isPgEnum(obj: unknown): obj is PgEnum<[string, ...string[]]> {\n\treturn !!obj && typeof obj === 'function' && isPgEnumSym in obj && obj[isPgEnumSym] === true;\n}\n\nexport class PgEnumColumnBuilder<\n\tT extends ColumnBuilderBaseConfig<'string', 'PgEnumColumn'> & { enumValues: [string, ...string[]] },\n> extends PgColumnBuilder<T, { enum: PgEnum<T['enumValues']> }> {\n\tstatic override readonly [entityKind]: string = 'PgEnumColumnBuilder';\n\n\tconstructor(name: T['name'], enumInstance: PgEnum<T['enumValues']>) {\n\t\tsuper(name, 'string', 'PgEnumColumn');\n\t\tthis.config.enum = enumInstance;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgEnumColumn<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgEnumColumn<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgEnumColumn<T extends ColumnBaseConfig<'string', 'PgEnumColumn'> & { enumValues: [string, ...string[]] }>\n\textends PgColumn<T, { enum: PgEnum<T['enumValues']> }>\n{\n\tstatic override readonly [entityKind]: string = 'PgEnumColumn';\n\n\treadonly enum = this.config.enum;\n\toverride readonly enumValues = this.config.enum.enumValues;\n\n\tconstructor(\n\t\ttable: AnyPgTable<{ name: T['tableName'] }>,\n\t\tconfig: PgEnumColumnBuilder<T>['config'],\n\t) {\n\t\tsuper(table, config);\n\t\tthis.enum = config.enum;\n\t}\n\n\tgetSQLType(): string {\n\t\treturn this.enum.enumName;\n\t}\n}\n\n// Gratitude to zod for the enum function types\nexport function pgEnum<U extends string, T extends Readonly<[U, ...U[]]>>(\n\tenumName: string,\n\tvalues: T | Writable<T>,\n): PgEnum<Writable<T>> {\n\treturn pgEnumWithSchema(enumName, values, undefined);\n}\n\n/** @internal */\nexport function pgEnumWithSchema<U extends string, T extends Readonly<[U, ...U[]]>>(\n\tenumName: string,\n\tvalues: T | Writable<T>,\n\tschema?: string,\n): PgEnum<Writable<T>> {\n\tconst enumInstance: PgEnum<Writable<T>> = Object.assign(\n\t\t<TName extends string>(name?: TName): PgEnumColumnBuilderInitial<TName, Writable<T>> =>\n\t\t\tnew PgEnumColumnBuilder(name ?? '' as TName, enumInstance),\n\t\t{\n\t\t\tenumName,\n\t\t\tenumValues: values,\n\t\t\tschema,\n\t\t\t[isPgEnumSym]: true,\n\t\t} as const,\n\t);\n\n\treturn enumInstance;\n}\n", "import type {\n\tColumnBuilderBase,\n\tColumnBuilderBaseConfig,\n\tColumnBuilderExtraConfig,\n\tColumnBuilderRuntimeConfig,\n\tColumnDataType,\n\tHasGenerated,\n\tMakeColumnConfig,\n} from '~/column-builder.ts';\nimport { ColumnBuilder } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { Column } from '~/column.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport type { Simplify, Update } from '~/utils.ts';\n\nimport type { ForeignKey, UpdateDeleteAction } from '~/pg-core/foreign-keys.ts';\nimport { ForeignKeyBuilder } from '~/pg-core/foreign-keys.ts';\nimport type { AnyPgTable, PgTable } from '~/pg-core/table.ts';\nimport type { SQL } from '~/sql/sql.ts';\nimport { iife } from '~/tracing-utils.ts';\nimport type { PgIndexOpClass } from '../indexes.ts';\nimport { uniqueKeyName } from '../unique-constraint.ts';\nimport { makePgArray, parsePgArray } from '../utils/array.ts';\n\nexport interface ReferenceConfig {\n\tref: () => PgColumn;\n\tactions: {\n\t\tonUpdate?: UpdateDeleteAction;\n\t\tonDelete?: UpdateDeleteAction;\n\t};\n}\n\nexport interface PgColumnBuilderBase<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTypeConfig extends object = object,\n> extends ColumnBuilderBase<T, TTypeConfig & { dialect: 'pg' }> {}\n\nexport abstract class PgColumnBuilder<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n\tTTypeConfig extends object = object,\n\tTExtraConfig extends ColumnBuilderExtraConfig = ColumnBuilderExtraConfig,\n> extends ColumnBuilder<T, TRuntimeConfig, TTypeConfig & { dialect: 'pg' }, TExtraConfig>\n\timplements PgColumnBuilderBase<T, TTypeConfig>\n{\n\tprivate foreignKeyConfigs: ReferenceConfig[] = [];\n\n\tstatic override readonly [entityKind]: string = 'PgColumnBuilder';\n\n\tarray<TSize extends number | undefined = undefined>(size?: TSize): PgArrayBuilder<\n\t\t& {\n\t\t\tname: T['name'];\n\t\t\tdataType: 'array';\n\t\t\tcolumnType: 'PgArray';\n\t\t\tdata: T['data'][];\n\t\t\tdriverParam: T['driverParam'][] | string;\n\t\t\tenumValues: T['enumValues'];\n\t\t\tsize: TSize;\n\t\t\tbaseBuilder: T;\n\t\t}\n\t\t& (T extends { notNull: true } ? { notNull: true } : {})\n\t\t& (T extends { hasDefault: true } ? { hasDefault: true } : {}),\n\t\tT\n\t> {\n\t\treturn new PgArrayBuilder(this.config.name, this as PgColumnBuilder<any, any>, size as any);\n\t}\n\n\treferences(\n\t\tref: ReferenceConfig['ref'],\n\t\tactions: ReferenceConfig['actions'] = {},\n\t): this {\n\t\tthis.foreignKeyConfigs.push({ ref, actions });\n\t\treturn this;\n\t}\n\n\tunique(\n\t\tname?: string,\n\t\tconfig?: { nulls: 'distinct' | 'not distinct' },\n\t): this {\n\t\tthis.config.isUnique = true;\n\t\tthis.config.uniqueName = name;\n\t\tthis.config.uniqueType = config?.nulls;\n\t\treturn this;\n\t}\n\n\tgeneratedAlwaysAs(as: SQL | T['data'] | (() => SQL)): HasGenerated<this, {\n\t\ttype: 'always';\n\t}> {\n\t\tthis.config.generated = {\n\t\t\tas,\n\t\t\ttype: 'always',\n\t\t\tmode: 'stored',\n\t\t};\n\t\treturn this as HasGenerated<this, {\n\t\t\ttype: 'always';\n\t\t}>;\n\t}\n\n\t/** @internal */\n\tbuildForeignKeys(column: PgColumn, table: PgTable): ForeignKey[] {\n\t\treturn this.foreignKeyConfigs.map(({ ref, actions }) => {\n\t\t\treturn iife(\n\t\t\t\t(ref, actions) => {\n\t\t\t\t\tconst builder = new ForeignKeyBuilder(() => {\n\t\t\t\t\t\tconst foreignColumn = ref();\n\t\t\t\t\t\treturn { columns: [column], foreignColumns: [foreignColumn] };\n\t\t\t\t\t});\n\t\t\t\t\tif (actions.onUpdate) {\n\t\t\t\t\t\tbuilder.onUpdate(actions.onUpdate);\n\t\t\t\t\t}\n\t\t\t\t\tif (actions.onDelete) {\n\t\t\t\t\t\tbuilder.onDelete(actions.onDelete);\n\t\t\t\t\t}\n\t\t\t\t\treturn builder.build(table);\n\t\t\t\t},\n\t\t\t\tref,\n\t\t\t\tactions,\n\t\t\t);\n\t\t});\n\t}\n\n\t/** @internal */\n\tabstract build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgColumn<MakeColumnConfig<T, TTableName>>;\n\n\t/** @internal */\n\tbuildExtraConfigColumn<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): ExtraConfigColumn {\n\t\treturn new ExtraConfigColumn(table, this.config);\n\t}\n}\n\n// To understand how to use `PgColumn` and `PgColumn`, see `Column` and `AnyColumn` documentation.\nexport abstract class PgColumn<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = {},\n\tTTypeConfig extends object = {},\n> extends Column<T, TRuntimeConfig, TTypeConfig & { dialect: 'pg' }> {\n\tstatic override readonly [entityKind]: string = 'PgColumn';\n\n\tconstructor(\n\t\toverride readonly table: PgTable,\n\t\tconfig: ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>,\n\t) {\n\t\tif (!config.uniqueName) {\n\t\t\tconfig.uniqueName = uniqueKeyName(table, [config.name]);\n\t\t}\n\t\tsuper(table, config);\n\t}\n}\n\nexport type IndexedExtraConfigType = { order?: 'asc' | 'desc'; nulls?: 'first' | 'last'; opClass?: string };\n\nexport class ExtraConfigColumn<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n> extends PgColumn<T, IndexedExtraConfigType> {\n\tstatic override readonly [entityKind]: string = 'ExtraConfigColumn';\n\n\toverride getSQLType(): string {\n\t\treturn this.getSQLType();\n\t}\n\n\tindexConfig: IndexedExtraConfigType = {\n\t\torder: this.config.order ?? 'asc',\n\t\tnulls: this.config.nulls ?? 'last',\n\t\topClass: this.config.opClass,\n\t};\n\tdefaultConfig: IndexedExtraConfigType = {\n\t\torder: 'asc',\n\t\tnulls: 'last',\n\t\topClass: undefined,\n\t};\n\n\tasc(): Omit<this, 'asc' | 'desc'> {\n\t\tthis.indexConfig.order = 'asc';\n\t\treturn this;\n\t}\n\n\tdesc(): Omit<this, 'asc' | 'desc'> {\n\t\tthis.indexConfig.order = 'desc';\n\t\treturn this;\n\t}\n\n\tnullsFirst(): Omit<this, 'nullsFirst' | 'nullsLast'> {\n\t\tthis.indexConfig.nulls = 'first';\n\t\treturn this;\n\t}\n\n\tnullsLast(): Omit<this, 'nullsFirst' | 'nullsLast'> {\n\t\tthis.indexConfig.nulls = 'last';\n\t\treturn this;\n\t}\n\n\t/**\n\t * ### PostgreSQL documentation quote\n\t *\n\t * > An operator class with optional parameters can be specified for each column of an index.\n\t * The operator class identifies the operators to be used by the index for that column.\n\t * For example, a B-tree index on four-byte integers would use the int4_ops class;\n\t * this operator class includes comparison functions for four-byte integers.\n\t * In practice the default operator class for the column's data type is usually sufficient.\n\t * The main point of having operator classes is that for some data types, there could be more than one meaningful ordering.\n\t * For example, we might want to sort a complex-number data type either by absolute value or by real part.\n\t * We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index.\n\t * More information about operator classes check:\n\t *\n\t * ### Useful links\n\t * https://www.postgresql.org/docs/current/sql-createindex.html\n\t *\n\t * https://www.postgresql.org/docs/current/indexes-opclass.html\n\t *\n\t * https://www.postgresql.org/docs/current/xindex.html\n\t *\n\t * ### Additional types\n\t * If you have the `pg_vector` extension installed in your database, you can use the\n\t * `vector_l2_ops`, `vector_ip_ops`, `vector_cosine_ops`, `vector_l1_ops`, `bit_hamming_ops`, `bit_jaccard_ops`, `halfvec_l2_ops`, `sparsevec_l2_ops` options, which are predefined types.\n\t *\n\t * **You can always specify any string you want in the operator class, in case Drizzle doesn't have it natively in its types**\n\t *\n\t * @param opClass\n\t * @returns\n\t */\n\top(opClass: PgIndexOpClass): Omit<this, 'op'> {\n\t\tthis.indexConfig.opClass = opClass;\n\t\treturn this;\n\t}\n}\n\nexport class IndexedColumn {\n\tstatic readonly [entityKind]: string = 'IndexedColumn';\n\tconstructor(\n\t\tname: string | undefined,\n\t\tkeyAsName: boolean,\n\t\ttype: string,\n\t\tindexConfig: IndexedExtraConfigType,\n\t) {\n\t\tthis.name = name;\n\t\tthis.keyAsName = keyAsName;\n\t\tthis.type = type;\n\t\tthis.indexConfig = indexConfig;\n\t}\n\n\tname: string | undefined;\n\tkeyAsName: boolean;\n\ttype: string;\n\tindexConfig: IndexedExtraConfigType;\n}\n\nexport type AnyPgColumn<TPartial extends Partial<ColumnBaseConfig<ColumnDataType, string>> = {}> = PgColumn<\n\tRequired<Update<ColumnBaseConfig<ColumnDataType, string>, TPartial>>\n>;\n\nexport type PgArrayColumnBuilderBaseConfig = ColumnBuilderBaseConfig<'array', 'PgArray'> & {\n\tsize: number | undefined;\n\tbaseBuilder: ColumnBuilderBaseConfig<ColumnDataType, string>;\n};\n\nexport class PgArrayBuilder<\n\tT extends PgArrayColumnBuilderBaseConfig,\n\tTBase extends ColumnBuilderBaseConfig<ColumnDataType, string> | PgArrayColumnBuilderBaseConfig,\n> extends PgColumnBuilder<\n\tT,\n\t{\n\t\tbaseBuilder: TBase extends PgArrayColumnBuilderBaseConfig ? PgArrayBuilder<\n\t\t\t\tTBase,\n\t\t\t\tTBase extends { baseBuilder: infer TBaseBuilder extends ColumnBuilderBaseConfig<any, any> } ? TBaseBuilder\n\t\t\t\t\t: never\n\t\t\t>\n\t\t\t: PgColumnBuilder<TBase, {}, Simplify<Omit<TBase, keyof ColumnBuilderBaseConfig<any, any>>>>;\n\t\tsize: T['size'];\n\t},\n\t{\n\t\tbaseBuilder: TBase extends PgArrayColumnBuilderBaseConfig ? PgArrayBuilder<\n\t\t\t\tTBase,\n\t\t\t\tTBase extends { baseBuilder: infer TBaseBuilder extends ColumnBuilderBaseConfig<any, any> } ? TBaseBuilder\n\t\t\t\t\t: never\n\t\t\t>\n\t\t\t: PgColumnBuilder<TBase, {}, Simplify<Omit<TBase, keyof ColumnBuilderBaseConfig<any, any>>>>;\n\t\tsize: T['size'];\n\t}\n> {\n\tstatic override readonly [entityKind] = 'PgArrayBuilder';\n\n\tconstructor(\n\t\tname: string,\n\t\tbaseBuilder: PgArrayBuilder<T, TBase>['config']['baseBuilder'],\n\t\tsize: T['size'],\n\t) {\n\t\tsuper(name, 'array', 'PgArray');\n\t\tthis.config.baseBuilder = baseBuilder;\n\t\tthis.config.size = size;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgArray<MakeColumnConfig<T, TTableName> & { size: T['size']; baseBuilder: T['baseBuilder'] }, TBase> {\n\t\tconst baseColumn = this.config.baseBuilder.build(table);\n\t\treturn new PgArray<MakeColumnConfig<T, TTableName> & { size: T['size']; baseBuilder: T['baseBuilder'] }, TBase>(\n\t\t\ttable as AnyPgTable<{ name: MakeColumnConfig<T, TTableName>['tableName'] }>,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t\tbaseColumn,\n\t\t);\n\t}\n}\n\nexport class PgArray<\n\tT extends ColumnBaseConfig<'array', 'PgArray'> & {\n\t\tsize: number | undefined;\n\t\tbaseBuilder: ColumnBuilderBaseConfig<ColumnDataType, string>;\n\t},\n\tTBase extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n> extends PgColumn<T, {}, { size: T['size']; baseBuilder: T['baseBuilder'] }> {\n\treadonly size: T['size'];\n\n\tstatic override readonly [entityKind]: string = 'PgArray';\n\n\tconstructor(\n\t\ttable: AnyPgTable<{ name: T['tableName'] }>,\n\t\tconfig: PgArrayBuilder<T, TBase>['config'],\n\t\treadonly baseColumn: PgColumn,\n\t\treadonly range?: [number | undefined, number | undefined],\n\t) {\n\t\tsuper(table, config);\n\t\tthis.size = config.size;\n\t}\n\n\tgetSQLType(): string {\n\t\treturn `${this.baseColumn.getSQLType()}[${typeof this.size === 'number' ? this.size : ''}]`;\n\t}\n\n\toverride mapFromDriverValue(value: unknown[] | string): T['data'] {\n\t\tif (typeof value === 'string') {\n\t\t\t// Thank you node-postgres for not parsing enum arrays\n\t\t\tvalue = parsePgArray(value);\n\t\t}\n\t\treturn value.map((v) => this.baseColumn.mapFromDriverValue(v));\n\t}\n\n\toverride mapToDriverValue(value: unknown[], isNestedArray = false): unknown[] | string {\n\t\tconst a = value.map((v) =>\n\t\t\tv === null\n\t\t\t\t? null\n\t\t\t\t: is(this.baseColumn, PgArray)\n\t\t\t\t? this.baseColumn.mapToDriverValue(v as unknown[], true)\n\t\t\t\t: this.baseColumn.mapToDriverValue(v)\n\t\t);\n\t\tif (isNestedArray) return a;\n\t\treturn makePgArray(a);\n\t}\n}\n", "import { entityKind } from '~/entity.ts';\nimport type { Column } from './column.ts';\nimport type { MySqlColumn } from './mysql-core/index.ts';\nimport type { ExtraConfigColumn, PgColumn, PgSequenceOptions } from './pg-core/index.ts';\nimport type { SingleStoreColumn } from './singlestore-core/index.ts';\nimport type { SQL } from './sql/sql.ts';\nimport type { SQLiteColumn } from './sqlite-core/index.ts';\nimport type { Assume, Simplify } from './utils.ts';\n\nexport type ColumnDataType =\n\t| 'string'\n\t| 'number'\n\t| 'boolean'\n\t| 'array'\n\t| 'json'\n\t| 'date'\n\t| 'bigint'\n\t| 'custom'\n\t| 'buffer';\n\nexport type Dialect = 'pg' | 'mysql' | 'sqlite' | 'singlestore' | 'common';\n\nexport type GeneratedStorageMode = 'virtual' | 'stored';\n\nexport type GeneratedType = 'always' | 'byDefault';\n\nexport type GeneratedColumnConfig<TDataType> = {\n\tas: TDataType | SQL | (() => SQL);\n\ttype?: GeneratedType;\n\tmode?: GeneratedStorageMode;\n};\n\nexport type GeneratedIdentityConfig = {\n\tsequenceName?: string;\n\tsequenceOptions?: PgSequenceOptions;\n\ttype: 'always' | 'byDefault';\n};\n\nexport interface ColumnBuilderBaseConfig<TDataType extends ColumnDataType, TColumnType extends string> {\n\tname: string;\n\tdataType: TDataType;\n\tcolumnType: TColumnType;\n\tdata: unknown;\n\tdriverParam: unknown;\n\tenumValues: string[] | undefined;\n}\n\nexport type MakeColumnConfig<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTableName extends string,\n\tTData = T extends { $type: infer U } ? U : T['data'],\n> = {\n\tname: T['name'];\n\ttableName: TTableName;\n\tdataType: T['dataType'];\n\tcolumnType: T['columnType'];\n\tdata: TData;\n\tdriverParam: T['driverParam'];\n\tnotNull: T extends { notNull: true } ? true : false;\n\thasDefault: T extends { hasDefault: true } ? true : false;\n\tisPrimaryKey: T extends { isPrimaryKey: true } ? true : false;\n\tisAutoincrement: T extends { isAutoincrement: true } ? true : false;\n\thasRuntimeDefault: T extends { hasRuntimeDefault: true } ? true : false;\n\tenumValues: T['enumValues'];\n\tbaseColumn: T extends { baseBuilder: infer U extends ColumnBuilderBase } ? BuildColumn<TTableName, U, 'common'>\n\t\t: never;\n\tidentity: T extends { identity: 'always' } ? 'always' : T extends { identity: 'byDefault' } ? 'byDefault' : undefined;\n\tgenerated: T extends { generated: infer G } ? unknown extends G ? undefined\n\t\t: G extends undefined ? undefined\n\t\t: G\n\t\t: undefined;\n} & {};\n\nexport type ColumnBuilderTypeConfig<\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTypeConfig extends object = object,\n> = Simplify<\n\t& {\n\t\tbrand: 'ColumnBuilder';\n\t\tname: T['name'];\n\t\tdataType: T['dataType'];\n\t\tcolumnType: T['columnType'];\n\t\tdata: T['data'];\n\t\tdriverParam: T['driverParam'];\n\t\tnotNull: T extends { notNull: infer U } ? U : boolean;\n\t\thasDefault: T extends { hasDefault: infer U } ? U : boolean;\n\t\tenumValues: T['enumValues'];\n\t\tidentity: T extends { identity: infer U } ? U : unknown;\n\t\tgenerated: T extends { generated: infer G } ? G extends undefined ? unknown : G : unknown;\n\t}\n\t& TTypeConfig\n>;\n\nexport type ColumnBuilderRuntimeConfig<TData, TRuntimeConfig extends object = object> = {\n\tname: string;\n\tkeyAsName: boolean;\n\tnotNull: boolean;\n\tdefault: TData | SQL | undefined;\n\tdefaultFn: (() => TData | SQL) | undefined;\n\tonUpdateFn: (() => TData | SQL) | undefined;\n\thasDefault: boolean;\n\tprimaryKey: boolean;\n\tisUnique: boolean;\n\tuniqueName: string | undefined;\n\tuniqueType: string | undefined;\n\tdataType: string;\n\tcolumnType: string;\n\tgenerated: GeneratedColumnConfig<TData> | undefined;\n\tgeneratedIdentity: GeneratedIdentityConfig | undefined;\n} & TRuntimeConfig;\n\nexport interface ColumnBuilderExtraConfig {\n\tprimaryKeyHasDefault?: boolean;\n}\n\nexport type NotNull<T extends ColumnBuilderBase> = T & {\n\t_: {\n\t\tnotNull: true;\n\t};\n};\n\nexport type HasDefault<T extends ColumnBuilderBase> = T & {\n\t_: {\n\t\thasDefault: true;\n\t};\n};\n\nexport type IsPrimaryKey<T extends ColumnBuilderBase> = T & {\n\t_: {\n\t\tisPrimaryKey: true;\n\t};\n};\n\nexport type IsAutoincrement<T extends ColumnBuilderBase> = T & {\n\t_: {\n\t\tisAutoincrement: true;\n\t};\n};\n\nexport type HasRuntimeDefault<T extends ColumnBuilderBase> = T & {\n\t_: {\n\t\thasRuntimeDefault: true;\n\t};\n};\n\nexport type $Type<T extends ColumnBuilderBase, TType> = T & {\n\t_: {\n\t\t$type: TType;\n\t};\n};\n\nexport type HasGenerated<T extends ColumnBuilderBase, TGenerated extends {} = {}> = T & {\n\t_: {\n\t\thasDefault: true;\n\t\tgenerated: TGenerated;\n\t};\n};\n\nexport type IsIdentity<\n\tT extends ColumnBuilderBase,\n\tTType extends 'always' | 'byDefault',\n> = T & {\n\t_: {\n\t\tnotNull: true;\n\t\thasDefault: true;\n\t\tidentity: TType;\n\t};\n};\nexport interface ColumnBuilderBase<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTypeConfig extends object = object,\n> {\n\t_: ColumnBuilderTypeConfig<T, TTypeConfig>;\n}\n\n// To understand how to use `ColumnBuilder` and `AnyColumnBuilder`, see `Column` and `AnyColumn` documentation.\nexport abstract class ColumnBuilder<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n\tTTypeConfig extends object = object,\n\tTExtraConfig extends ColumnBuilderExtraConfig = ColumnBuilderExtraConfig,\n> implements ColumnBuilderBase<T, TTypeConfig> {\n\tstatic readonly [entityKind]: string = 'ColumnBuilder';\n\n\tdeclare _: ColumnBuilderTypeConfig<T, TTypeConfig>;\n\n\tprotected config: ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>;\n\n\tconstructor(name: T['name'], dataType: T['dataType'], columnType: T['columnType']) {\n\t\tthis.config = {\n\t\t\tname,\n\t\t\tkeyAsName: name === '',\n\t\t\tnotNull: false,\n\t\t\tdefault: undefined,\n\t\t\thasDefault: false,\n\t\t\tprimaryKey: false,\n\t\t\tisUnique: false,\n\t\t\tuniqueName: undefined,\n\t\t\tuniqueType: undefined,\n\t\t\tdataType,\n\t\t\tcolumnType,\n\t\t\tgenerated: undefined,\n\t\t} as ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>;\n\t}\n\n\t/**\n\t * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.\n\t *\n\t * @example\n\t * ```ts\n\t * const users = pgTable('users', {\n\t * \tid: integer('id').$type<UserId>().primaryKey(),\n\t * \tdetails: json('details').$type<UserDetails>().notNull(),\n\t * });\n\t * ```\n\t */\n\t$type<TType>(): $Type<this, TType> {\n\t\treturn this as $Type<this, TType>;\n\t}\n\n\t/**\n\t * Adds a `not null` clause to the column definition.\n\t *\n\t * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.\n\t */\n\tnotNull(): NotNull<this> {\n\t\tthis.config.notNull = true;\n\t\treturn this as NotNull<this>;\n\t}\n\n\t/**\n\t * Adds a `default <value>` clause to the column definition.\n\t *\n\t * Affects the `insert` model of the table - columns *with* `default` are optional on insert.\n\t *\n\t * If you need to set a dynamic default value, use {@link $defaultFn} instead.\n\t */\n\tdefault(value: (this['_'] extends { $type: infer U } ? U : this['_']['data']) | SQL): HasDefault<this> {\n\t\tthis.config.default = value;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as HasDefault<this>;\n\t}\n\n\t/**\n\t * Adds a dynamic default value to the column.\n\t * The function will be called when the row is inserted, and the returned value will be used as the column value.\n\t *\n\t * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.\n\t */\n\t$defaultFn(\n\t\tfn: () => (this['_'] extends { $type: infer U } ? U : this['_']['data']) | SQL,\n\t): HasRuntimeDefault<HasDefault<this>> {\n\t\tthis.config.defaultFn = fn;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as HasRuntimeDefault<HasDefault<this>>;\n\t}\n\n\t/**\n\t * Alias for {@link $defaultFn}.\n\t */\n\t$default = this.$defaultFn;\n\n\t/**\n\t * Adds a dynamic update value to the column.\n\t * The function will be called when the row is updated, and the returned value will be used as the column value if none is provided.\n\t * If no `default` (or `$defaultFn`) value is provided, the function will be called when the row is inserted as well, and the returned value will be used as the column value.\n\t *\n\t * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.\n\t */\n\t$onUpdateFn(\n\t\tfn: () => (this['_'] extends { $type: infer U } ? U : this['_']['data']) | SQL,\n\t): HasDefault<this> {\n\t\tthis.config.onUpdateFn = fn;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as HasDefault<this>;\n\t}\n\n\t/**\n\t * Alias for {@link $onUpdateFn}.\n\t */\n\t$onUpdate = this.$onUpdateFn;\n\n\t/**\n\t * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.\n\t *\n\t * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.\n\t */\n\tprimaryKey(): TExtraConfig['primaryKeyHasDefault'] extends true ? IsPrimaryKey<HasDefault<NotNull<this>>>\n\t\t: IsPrimaryKey<NotNull<this>>\n\t{\n\t\tthis.config.primaryKey = true;\n\t\tthis.config.notNull = true;\n\t\treturn this as TExtraConfig['primaryKeyHasDefault'] extends true ? IsPrimaryKey<HasDefault<NotNull<this>>>\n\t\t\t: IsPrimaryKey<NotNull<this>>;\n\t}\n\n\tabstract generatedAlwaysAs(\n\t\tas: SQL | T['data'] | (() => SQL),\n\t\tconfig?: Partial<GeneratedColumnConfig<unknown>>,\n\t): HasGenerated<this, {\n\t\ttype: 'always';\n\t}>;\n\n\t/** @internal Sets the name of the column to the key within the table definition if a name was not given. */\n\tsetName(name: string) {\n\t\tif (this.config.name !== '') return;\n\t\tthis.config.name = name;\n\t}\n}\n\nexport type BuildColumn<\n\tTTableName extends string,\n\tTBuilder extends ColumnBuilderBase,\n\tTDialect extends Dialect,\n> = TDialect extends 'pg' ? PgColumn<\n\t\tMakeColumnConfig<TBuilder['_'], TTableName>,\n\t\t{},\n\t\tSimplify<Omit<TBuilder['_'], keyof MakeColumnConfig<TBuilder['_'], TTableName> | 'brand' | 'dialect'>>\n\t>\n\t: TDialect extends 'mysql' ? MySqlColumn<\n\t\t\tMakeColumnConfig<TBuilder['_'], TTableName>,\n\t\t\t{},\n\t\t\tSimplify<\n\t\t\t\tOmit<\n\t\t\t\t\tTBuilder['_'],\n\t\t\t\t\t| keyof MakeColumnConfig<TBuilder['_'], TTableName>\n\t\t\t\t\t| 'brand'\n\t\t\t\t\t| 'dialect'\n\t\t\t\t\t| 'primaryKeyHasDefault'\n\t\t\t\t\t| 'mysqlColumnBuilderBrand'\n\t\t\t\t>\n\t\t\t>\n\t\t>\n\t: TDialect extends 'sqlite' ? SQLiteColumn<\n\t\t\tMakeColumnConfig<TBuilder['_'], TTableName>,\n\t\t\t{},\n\t\t\tSimplify<Omit<TBuilder['_'], keyof MakeColumnConfig<TBuilder['_'], TTableName> | 'brand' | 'dialect'>>\n\t\t>\n\t: TDialect extends 'common' ? Column<\n\t\t\tMakeColumnConfig<TBuilder['_'], TTableName>,\n\t\t\t{},\n\t\t\tSimplify<Omit<TBuilder['_'], keyof MakeColumnConfig<TBuilder['_'], TTableName> | 'brand' | 'dialect'>>\n\t\t>\n\t: TDialect extends 'singlestore' ? SingleStoreColumn<\n\t\t\tMakeColumnConfig<TBuilder['_'], TTableName>,\n\t\t\t{},\n\t\t\tSimplify<\n\t\t\t\tOmit<\n\t\t\t\t\tTBuilder['_'],\n\t\t\t\t\t| keyof MakeColumnConfig<TBuilder['_'], TTableName>\n\t\t\t\t\t| 'brand'\n\t\t\t\t\t| 'dialect'\n\t\t\t\t\t| 'primaryKeyHasDefault'\n\t\t\t\t\t| 'singlestoreColumnBuilderBrand'\n\t\t\t\t>\n\t\t\t>\n\t\t>\n\t: never;\n\nexport type BuildIndexColumn<\n\tTDialect extends Dialect,\n> = TDialect extends 'pg' ? ExtraConfigColumn : never;\n\n// TODO\n// try to make sql as well + indexRaw\n\n// optional after everything will be working as expected\n// also try to leave only needed methods for extraConfig\n// make an error if I pass .asc() to fk and so on\n\nexport type BuildColumns<\n\tTTableName extends string,\n\tTConfigMap extends Record<string, ColumnBuilderBase>,\n\tTDialect extends Dialect,\n> =\n\t& {\n\t\t[Key in keyof TConfigMap]: BuildColumn<TTableName, {\n\t\t\t_:\n\t\t\t\t& Omit<TConfigMap[Key]['_'], 'name'>\n\t\t\t\t& { name: TConfigMap[Key]['_']['name'] extends '' ? Assume<Key, string> : TConfigMap[Key]['_']['name'] };\n\t\t}, TDialect>;\n\t}\n\t& {};\n\nexport type BuildExtraConfigColumns<\n\t_TTableName extends string,\n\tTConfigMap extends Record<string, ColumnBuilderBase>,\n\tTDialect extends Dialect,\n> =\n\t& {\n\t\t[Key in keyof TConfigMap]: BuildIndexColumn<TDialect>;\n\t}\n\t& {};\n\nexport type ChangeColumnTableName<TColumn extends Column, TAlias extends string, TDialect extends Dialect> =\n\tTDialect extends 'pg' ? PgColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'mysql' ? MySqlColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'singlestore' ? SingleStoreColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'sqlite' ? SQLiteColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: never;\n", "import { entityKind } from '~/entity.ts';\nimport { TableName } from '~/table.utils.ts';\nimport type { AnyPgColumn, PgColumn } from './columns/index.ts';\nimport type { PgTable } from './table.ts';\n\nexport type UpdateDeleteAction = 'cascade' | 'restrict' | 'no action' | 'set null' | 'set default';\n\nexport type Reference = () => {\n\treadonly name?: string;\n\treadonly columns: PgColumn[];\n\treadonly foreignTable: PgTable;\n\treadonly foreignColumns: PgColumn[];\n};\n\nexport class ForeignKeyBuilder {\n\tstatic readonly [entityKind]: string = 'PgForeignKeyBuilder';\n\n\t/** @internal */\n\treference: Reference;\n\n\t/** @internal */\n\t_onUpdate: UpdateDeleteAction | undefined = 'no action';\n\n\t/** @internal */\n\t_onDelete: UpdateDeleteAction | undefined = 'no action';\n\n\tconstructor(\n\t\tconfig: () => {\n\t\t\tname?: string;\n\t\t\tcolumns: PgColumn[];\n\t\t\tforeignColumns: PgColumn[];\n\t\t},\n\t\tactions?: {\n\t\t\tonUpdate?: UpdateDeleteAction;\n\t\t\tonDelete?: UpdateDeleteAction;\n\t\t} | undefined,\n\t) {\n\t\tthis.reference = () => {\n\t\t\tconst { name, columns, foreignColumns } = config();\n\t\t\treturn { name, columns, foreignTable: foreignColumns[0]!.table as PgTable, foreignColumns };\n\t\t};\n\t\tif (actions) {\n\t\t\tthis._onUpdate = actions.onUpdate;\n\t\t\tthis._onDelete = actions.onDelete;\n\t\t}\n\t}\n\n\tonUpdate(action: UpdateDeleteAction): this {\n\t\tthis._onUpdate = action === undefined ? 'no action' : action;\n\t\treturn this;\n\t}\n\n\tonDelete(action: UpdateDeleteAction): this {\n\t\tthis._onDelete = action === undefined ? 'no action' : action;\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tbuild(table: PgTable): ForeignKey {\n\t\treturn new ForeignKey(table, this);\n\t}\n}\n\nexport type AnyForeignKeyBuilder = ForeignKeyBuilder;\n\nexport class ForeignKey {\n\tstatic readonly [entityKind]: string = 'PgForeignKey';\n\n\treadonly reference: Reference;\n\treadonly onUpdate: UpdateDeleteAction | undefined;\n\treadonly onDelete: UpdateDeleteAction | undefined;\n\n\tconstructor(readonly table: PgTable, builder: ForeignKeyBuilder) {\n\t\tthis.reference = builder.reference;\n\t\tthis.onUpdate = builder._onUpdate;\n\t\tthis.onDelete = builder._onDelete;\n\t}\n\n\tgetName(): string {\n\t\tconst { name, columns, foreignColumns } = this.reference();\n\t\tconst columnNames = columns.map((column) => column.name);\n\t\tconst foreignColumnNames = foreignColumns.map((column) => column.name);\n\t\tconst chunks = [\n\t\t\tthis.table[TableName],\n\t\t\t...columnNames,\n\t\t\tforeignColumns[0]!.table[TableName],\n\t\t\t...foreignColumnNames,\n\t\t];\n\t\treturn name ?? `${chunks.join('_')}_fk`;\n\t}\n}\n\ntype ColumnsWithTable<\n\tTTableName extends string,\n\tTColumns extends PgColumn[],\n> = { [Key in keyof TColumns]: AnyPgColumn<{ tableName: TTableName }> };\n\nexport function foreignKey<\n\tTTableName extends string,\n\tTForeignTableName extends string,\n\tTColumns extends [AnyPgColumn<{ tableName: TTableName }>, ...AnyPgColumn<{ tableName: TTableName }>[]],\n>(\n\tconfig: {\n\t\tname?: string;\n\t\tcolumns: TColumns;\n\t\tforeignColumns: ColumnsWithTable<TForeignTableName, TColumns>;\n\t},\n): ForeignKeyBuilder {\n\tfunction mappedConfig() {\n\t\tconst { name, columns, foreignColumns } = config;\n\t\treturn {\n\t\t\tname,\n\t\t\tcolumns,\n\t\t\tforeignColumns,\n\t\t};\n\t}\n\n\treturn new ForeignKeyBuilder(mappedConfig);\n}\n", "export function iife<T extends unknown[], U>(fn: (...args: T) => U, ...args: T): U {\n\treturn fn(...args);\n}\n", "import { entityKind } from '~/entity.ts';\nimport { TableName } from '~/table.utils.ts';\nimport type { PgColumn } from './columns/index.ts';\nimport type { PgTable } from './table.ts';\n\nexport function unique(name?: string): UniqueOnConstraintBuilder {\n\treturn new UniqueOnConstraintBuilder(name);\n}\n\nexport function uniqueKeyName(table: PgTable, columns: string[]) {\n\treturn `${table[TableName]}_${columns.join('_')}_unique`;\n}\n\nexport class UniqueConstraintBuilder {\n\tstatic readonly [entityKind]: string = 'PgUniqueConstraintBuilder';\n\n\t/** @internal */\n\tcolumns: PgColumn[];\n\t/** @internal */\n\tnullsNotDistinctConfig = false;\n\n\tconstructor(\n\t\tcolumns: PgColumn[],\n\t\tprivate name?: string,\n\t) {\n\t\tthis.columns = columns;\n\t}\n\n\tnullsNotDistinct() {\n\t\tthis.nullsNotDistinctConfig = true;\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tbuild(table: PgTable): UniqueConstraint {\n\t\treturn new UniqueConstraint(table, this.columns, this.nullsNotDistinctConfig, this.name);\n\t}\n}\n\nexport class UniqueOnConstraintBuilder {\n\tstatic readonly [entityKind]: string = 'PgUniqueOnConstraintBuilder';\n\n\t/** @internal */\n\tname?: string;\n\n\tconstructor(\n\t\tname?: string,\n\t) {\n\t\tthis.name = name;\n\t}\n\n\ton(...columns: [PgColumn, ...PgColumn[]]) {\n\t\treturn new UniqueConstraintBuilder(columns, this.name);\n\t}\n}\n\nexport class UniqueConstraint {\n\tstatic readonly [entityKind]: string = 'PgUniqueConstraint';\n\n\treadonly columns: PgColumn[];\n\treadonly name?: string;\n\treadonly nullsNotDistinct: boolean = false;\n\n\tconstructor(readonly table: PgTable, columns: PgColumn[], nullsNotDistinct: boolean, name?: string) {\n\t\tthis.columns = columns;\n\t\tthis.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));\n\t\tthis.nullsNotDistinct = nullsNotDistinct;\n\t}\n\n\tgetName() {\n\t\treturn this.name;\n\t}\n}\n", "function parsePgArrayValue(arrayString: string, startFrom: number, inQuotes: boolean): [string, number] {\n\tfor (let i = startFrom; i < arrayString.length; i++) {\n\t\tconst char = arrayString[i];\n\n\t\tif (char === '\\\\') {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '\"') {\n\t\t\treturn [arrayString.slice(startFrom, i).replace(/\\\\/g, ''), i + 1];\n\t\t}\n\n\t\tif (inQuotes) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === ',' || char === '}') {\n\t\t\treturn [arrayString.slice(startFrom, i).replace(/\\\\/g, ''), i];\n\t\t}\n\t}\n\n\treturn [arrayString.slice(startFrom).replace(/\\\\/g, ''), arrayString.length];\n}\n\nexport function parsePgNestedArray(arrayString: string, startFrom = 0): [any[], number] {\n\tconst result: any[] = [];\n\tlet i = startFrom;\n\tlet lastCharIsComma = false;\n\n\twhile (i < arrayString.length) {\n\t\tconst char = arrayString[i];\n\n\t\tif (char === ',') {\n\t\t\tif (lastCharIsComma || i === startFrom) {\n\t\t\t\tresult.push('');\n\t\t\t}\n\t\t\tlastCharIsComma = true;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlastCharIsComma = false;\n\n\t\tif (char === '\\\\') {\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '\"') {\n\t\t\tconst [value, startFrom] = parsePgArrayValue(arrayString, i + 1, true);\n\t\t\tresult.push(value);\n\t\t\ti = startFrom;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '}') {\n\t\t\treturn [result, i + 1];\n\t\t}\n\n\t\tif (char === '{') {\n\t\t\tconst [value, startFrom] = parsePgNestedArray(arrayString, i + 1);\n\t\t\tresult.push(value);\n\t\t\ti = startFrom;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst [value, newStartFrom] = parsePgArrayValue(arrayString, i, false);\n\t\tresult.push(value);\n\t\ti = newStartFrom;\n\t}\n\n\treturn [result, i];\n}\n\nexport function parsePgArray(arrayString: string): any[] {\n\tconst [result] = parsePgNestedArray(arrayString, 1);\n\treturn result;\n}\n\nexport function makePgArray(array: any[]): string {\n\treturn `{${\n\t\tarray.map((item) => {\n\t\t\tif (Array.isArray(item)) {\n\t\t\t\treturn makePgArray(item);\n\t\t\t}\n\n\t\t\tif (typeof item === 'string') {\n\t\t\t\treturn `\"${item.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"')}\"`;\n\t\t\t}\n\n\t\t\treturn `${item}`;\n\t\t}).join(',')\n\t}}`;\n}\n", "import { entityKind } from './entity.ts';\nimport type { SQL, SQLWrapper } from './sql/sql.ts';\n\nexport interface Subquery<\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTAlias extends string = string,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTSelectedFields extends Record<string, unknown> = Record<string, unknown>,\n> extends SQLWrapper {\n\t// SQLWrapper runtime implementation is defined in 'sql/sql.ts'\n}\nexport class Subquery<\n\tTAlias extends string = string,\n\tTSelectedFields extends Record<string, unknown> = Record<string, unknown>,\n> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Subquery';\n\n\tdeclare _: {\n\t\tbrand: 'Subquery';\n\t\tsql: SQL;\n\t\tselectedFields: TSelectedFields;\n\t\talias: TAlias;\n\t\tisWith: boolean;\n\t};\n\n\tconstructor(sql: SQL, selection: Record<string, unknown>, alias: string, isWith = false) {\n\t\tthis._ = {\n\t\t\tbrand: 'Subquery',\n\t\t\tsql,\n\t\t\tselectedFields: selection as TSelectedFields,\n\t\t\talias: alias as TAlias,\n\t\t\tisWith,\n\t\t};\n\t}\n\n\t// getSQL(): SQL<unknown> {\n\t// \treturn new SQL([this]);\n\t// }\n}\n\nexport class WithSubquery<\n\tTAlias extends string = string,\n\tTSelection extends Record<string, unknown> = Record<string, unknown>,\n> extends Subquery<TAlias, TSelection> {\n\tstatic override readonly [entityKind]: string = 'WithSubquery';\n}\n", "import type { Span, Tracer } from '@opentelemetry/api';\nimport { iife } from '~/tracing-utils.ts';\nimport { npmVersion } from '~/version.ts';\n\nlet otel: typeof import('@opentelemetry/api') | undefined;\nlet rawTracer: Tracer | undefined;\n// try {\n// \totel = await import('@opentelemetry/api');\n// } catch (err: any) {\n// \tif (err.code !== 'MODULE_NOT_FOUND' && err.code !== 'ERR_MODULE_NOT_FOUND') {\n// \t\tthrow err;\n// \t}\n// }\n\ntype SpanName =\n\t| 'drizzle.operation'\n\t| 'drizzle.prepareQuery'\n\t| 'drizzle.buildSQL'\n\t| 'drizzle.execute'\n\t| 'drizzle.driver.execute'\n\t| 'drizzle.mapResponse';\n\n/** @internal */\nexport const tracer = {\n\tstartActiveSpan<F extends (span?: Span) => unknown>(name: SpanName, fn: F): ReturnType<F> {\n\t\tif (!otel) {\n\t\t\treturn fn() as ReturnType<F>;\n\t\t}\n\n\t\tif (!rawTracer) {\n\t\t\trawTracer = otel.trace.getTracer('drizzle-orm', npmVersion);\n\t\t}\n\n\t\treturn iife(\n\t\t\t(otel, rawTracer) =>\n\t\t\t\trawTracer.startActiveSpan(\n\t\t\t\t\tname,\n\t\t\t\t\t((span: Span) => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn fn(span);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tspan.setStatus({\n\t\t\t\t\t\t\t\tcode: otel.SpanStatusCode.ERROR,\n\t\t\t\t\t\t\t\tmessage: e instanceof Error ? e.message : 'Unknown error', // eslint-disable-line no-instanceof/no-instanceof\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tspan.end();\n\t\t\t\t\t\t}\n\t\t\t\t\t}) as F,\n\t\t\t\t),\n\t\t\totel,\n\t\t\trawTracer,\n\t\t);\n\t},\n};\n", "// package.json\nvar version = \"0.38.4\";\n\n// src/version.ts\nvar compatibilityVersion = 10;\nexport {\n  compatibilityVersion,\n  version as npmVersion\n};\n", "export const ViewBaseConfig = Symbol.for('drizzle:ViewBaseConfig');\n", "import { type AnyColumn, Column, type GetColumnData } from '~/column.ts';\nimport { is } from '~/entity.ts';\nimport { Table } from '~/table.ts';\nimport {\n\tisDriverValueEncoder,\n\tisSQLWrapper,\n\tParam,\n\tPlaceholder,\n\tSQL,\n\tsql,\n\ttype SQLChunk,\n\ttype SQLWrapper,\n\tStringChunk,\n\tView,\n} from '../sql.ts';\n\nexport function bindIfParam(value: unknown, column: SQLWrapper): SQLChunk {\n\tif (\n\t\tisDriverValueEncoder(column)\n\t\t&& !isSQLWrapper(value)\n\t\t&& !is(value, Param)\n\t\t&& !is(value, Placeholder)\n\t\t&& !is(value, Column)\n\t\t&& !is(value, Table)\n\t\t&& !is(value, View)\n\t) {\n\t\treturn new Param(value, column);\n\t}\n\treturn value as SQLChunk;\n}\n\nexport interface BinaryOperator {\n\t<TColumn extends Column>(\n\t\tleft: TColumn,\n\t\tright: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n\t): SQL;\n\t<T>(left: SQL.Aliased<T>, right: T | SQLWrapper): SQL;\n\t<T extends SQLWrapper>(\n\t\tleft: Exclude<T, SQL.Aliased | Column>,\n\t\tright: unknown,\n\t): SQL;\n}\n\n/**\n * Test that two values are equal.\n *\n * Remember that the SQL standard dictates that\n * two NULL values are not equal, so if you want to test\n * whether a value is null, you may want to use\n * `isNull` instead.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made by Ford\n * db.select().from(cars)\n *   .where(eq(cars.make, 'Ford'))\n * ```\n *\n * @see isNull for a way to test equality to NULL.\n */\nexport const eq: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} = ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that two values are not equal.\n *\n * Remember that the SQL standard dictates that\n * two NULL values are not equal, so if you want to test\n * whether a value is not null, you may want to use\n * `isNotNull` instead.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars not made by Ford\n * db.select().from(cars)\n *   .where(ne(cars.make, 'Ford'))\n * ```\n *\n * @see isNotNull for a way to test whether a value is not null.\n */\nexport const ne: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} <> ${bindIfParam(right, left)}`;\n};\n\n/**\n * Combine a list of conditions with the `and` operator. Conditions\n * that are equal `undefined` are automatically ignored.\n *\n * ## Examples\n *\n * ```ts\n * db.select().from(cars)\n *   .where(\n *     and(\n *       eq(cars.make, 'Volvo'),\n *       eq(cars.year, 1950),\n *     )\n *   )\n * ```\n */\nexport function and(...conditions: (SQLWrapper | undefined)[]): SQL | undefined;\nexport function and(\n\t...unfilteredConditions: (SQLWrapper | undefined)[]\n): SQL | undefined {\n\tconst conditions = unfilteredConditions.filter(\n\t\t(c): c is Exclude<typeof c, undefined> => c !== undefined,\n\t);\n\n\tif (conditions.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tif (conditions.length === 1) {\n\t\treturn new SQL(conditions);\n\t}\n\n\treturn new SQL([\n\t\tnew StringChunk('('),\n\t\tsql.join(conditions, new StringChunk(' and ')),\n\t\tnew StringChunk(')'),\n\t]);\n}\n\n/**\n * Combine a list of conditions with the `or` operator. Conditions\n * that are equal `undefined` are automatically ignored.\n *\n * ## Examples\n *\n * ```ts\n * db.select().from(cars)\n *   .where(\n *     or(\n *       eq(cars.make, 'GM'),\n *       eq(cars.make, 'Ford'),\n *     )\n *   )\n * ```\n */\nexport function or(...conditions: (SQLWrapper | undefined)[]): SQL | undefined;\nexport function or(\n\t...unfilteredConditions: (SQLWrapper | undefined)[]\n): SQL | undefined {\n\tconst conditions = unfilteredConditions.filter(\n\t\t(c): c is Exclude<typeof c, undefined> => c !== undefined,\n\t);\n\n\tif (conditions.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tif (conditions.length === 1) {\n\t\treturn new SQL(conditions);\n\t}\n\n\treturn new SQL([\n\t\tnew StringChunk('('),\n\t\tsql.join(conditions, new StringChunk(' or ')),\n\t\tnew StringChunk(')'),\n\t]);\n}\n\n/**\n * Negate the meaning of an expression using the `not` keyword.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars _not_ made by GM or Ford.\n * db.select().from(cars)\n *   .where(not(inArray(cars.make, ['GM', 'Ford'])))\n * ```\n */\nexport function not(condition: SQLWrapper): SQL {\n\treturn sql`not ${condition}`;\n}\n\n/**\n * Test that the first expression passed is greater than\n * the second expression.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made after 2000.\n * db.select().from(cars)\n *   .where(gt(cars.year, 2000))\n * ```\n *\n * @see gte for greater-than-or-equal\n */\nexport const gt: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} > ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that the first expression passed is greater than\n * or equal to the second expression. Use `gt` to\n * test whether an expression is strictly greater\n * than another.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made on or after 2000.\n * db.select().from(cars)\n *   .where(gte(cars.year, 2000))\n * ```\n *\n * @see gt for a strictly greater-than condition\n */\nexport const gte: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} >= ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that the first expression passed is less than\n * the second expression.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made before 2000.\n * db.select().from(cars)\n *   .where(lt(cars.year, 2000))\n * ```\n *\n * @see lte for less-than-or-equal\n */\nexport const lt: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} < ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that the first expression passed is less than\n * or equal to the second expression.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made before 2000.\n * db.select().from(cars)\n *   .where(lte(cars.year, 2000))\n * ```\n *\n * @see lt for a strictly less-than condition\n */\nexport const lte: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} <= ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test whether the first parameter, a column or expression,\n * has a value from a list passed as the second argument.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made by Ford or GM.\n * db.select().from(cars)\n *   .where(inArray(cars.make, ['Ford', 'GM']))\n * ```\n *\n * @see notInArray for the inverse of this test\n */\nexport function inArray<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function inArray<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function inArray<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function inArray(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\treturn sql`false`;\n\t\t}\n\t\treturn sql`${column} in ${values.map((v) => bindIfParam(v, column))}`;\n\t}\n\n\treturn sql`${column} in ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test whether the first parameter, a column or expression,\n * has a value that is not present in a list passed as the\n * second argument.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made by any company except Ford or GM.\n * db.select().from(cars)\n *   .where(notInArray(cars.make, ['Ford', 'GM']))\n * ```\n *\n * @see inArray for the inverse of this test\n */\nexport function notInArray<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function notInArray<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function notInArray<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function notInArray(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\treturn sql`true`;\n\t\t}\n\t\treturn sql`${column} not in ${values.map((v) => bindIfParam(v, column))}`;\n\t}\n\n\treturn sql`${column} not in ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test whether an expression is NULL. By the SQL standard,\n * NULL is neither equal nor not equal to itself, so\n * it's recommended to use `isNull` and `notIsNull` for\n * comparisons to NULL.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars that have no discontinuedAt date.\n * db.select().from(cars)\n *   .where(isNull(cars.discontinuedAt))\n * ```\n *\n * @see isNotNull for the inverse of this test\n */\nexport function isNull(value: SQLWrapper): SQL {\n\treturn sql`${value} is null`;\n}\n\n/**\n * Test whether an expression is not NULL. By the SQL standard,\n * NULL is neither equal nor not equal to itself, so\n * it's recommended to use `isNull` and `notIsNull` for\n * comparisons to NULL.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars that have been discontinued.\n * db.select().from(cars)\n *   .where(isNotNull(cars.discontinuedAt))\n * ```\n *\n * @see isNull for the inverse of this test\n */\nexport function isNotNull(value: SQLWrapper): SQL {\n\treturn sql`${value} is not null`;\n}\n\n/**\n * Test whether a subquery evaluates to have any rows.\n *\n * ## Examples\n *\n * ```ts\n * // Users whose `homeCity` column has a match in a cities\n * // table.\n * db\n *   .select()\n *   .from(users)\n *   .where(\n *     exists(db.select()\n *       .from(cities)\n *       .where(eq(users.homeCity, cities.id))),\n *   );\n * ```\n *\n * @see notExists for the inverse of this test\n */\nexport function exists(subquery: SQLWrapper): SQL {\n\treturn sql`exists ${subquery}`;\n}\n\n/**\n * Test whether a subquery doesn't include any result\n * rows.\n *\n * ## Examples\n *\n * ```ts\n * // Users whose `homeCity` column doesn't match\n * // a row in the cities table.\n * db\n *   .select()\n *   .from(users)\n *   .where(\n *     notExists(db.select()\n *       .from(cities)\n *       .where(eq(users.homeCity, cities.id))),\n *   );\n * ```\n *\n * @see exists for the inverse of this test\n */\nexport function notExists(subquery: SQLWrapper): SQL {\n\treturn sql`not exists ${subquery}`;\n}\n\n/**\n * Test whether an expression is between two values. This\n * is an easier way to express range tests, which would be\n * expressed mathematically as `x <= a <= y` but in SQL\n * would have to be like `a >= x AND a <= y`.\n *\n * Between is inclusive of the endpoints: if `column`\n * is equal to `min` or `max`, it will be TRUE.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made between 1990 and 2000\n * db.select().from(cars)\n *   .where(between(cars.year, 1990, 2000))\n * ```\n *\n * @see notBetween for the inverse of this test\n */\nexport function between<T>(\n\tcolumn: SQL.Aliased,\n\tmin: T | SQLWrapper,\n\tmax: T | SQLWrapper,\n): SQL;\nexport function between<TColumn extends AnyColumn>(\n\tcolumn: TColumn,\n\tmin: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n\tmax: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n): SQL;\nexport function between<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tmin: unknown,\n\tmax: unknown,\n): SQL;\nexport function between(column: SQLWrapper, min: unknown, max: unknown): SQL {\n\treturn sql`${column} between ${bindIfParam(min, column)} and ${\n\t\tbindIfParam(\n\t\t\tmax,\n\t\t\tcolumn,\n\t\t)\n\t}`;\n}\n\n/**\n * Test whether an expression is not between two values.\n *\n * This, like `between`, includes its endpoints, so if\n * the `column` is equal to `min` or `max`, in this case\n * it will evaluate to FALSE.\n *\n * ## Examples\n *\n * ```ts\n * // Exclude cars made in the 1970s\n * db.select().from(cars)\n *   .where(notBetween(cars.year, 1970, 1979))\n * ```\n *\n * @see between for the inverse of this test\n */\nexport function notBetween<T>(\n\tcolumn: SQL.Aliased,\n\tmin: T | SQLWrapper,\n\tmax: T | SQLWrapper,\n): SQL;\nexport function notBetween<TColumn extends AnyColumn>(\n\tcolumn: TColumn,\n\tmin: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n\tmax: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n): SQL;\nexport function notBetween<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tmin: unknown,\n\tmax: unknown,\n): SQL;\nexport function notBetween(\n\tcolumn: SQLWrapper,\n\tmin: unknown,\n\tmax: unknown,\n): SQL {\n\treturn sql`${column} not between ${\n\t\tbindIfParam(\n\t\t\tmin,\n\t\t\tcolumn,\n\t\t)\n\t} and ${bindIfParam(max, column)}`;\n}\n\n/**\n * Compare a column to a pattern, which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars with 'Turbo' in their names.\n * db.select().from(cars)\n *   .where(like(cars.name, '%Turbo%'))\n * ```\n *\n * @see ilike for a case-insensitive version of this condition\n */\nexport function like(column: Column | SQL.Aliased | SQL, value: string | SQLWrapper): SQL {\n\treturn sql`${column} like ${value}`;\n}\n\n/**\n * The inverse of like - this tests that a given column\n * does not match a pattern, which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars that don't have \"ROver\" in their name.\n * db.select().from(cars)\n *   .where(notLike(cars.name, '%Rover%'))\n * ```\n *\n * @see like for the inverse condition\n * @see notIlike for a case-insensitive version of this condition\n */\nexport function notLike(column: Column | SQL.Aliased | SQL, value: string | SQLWrapper): SQL {\n\treturn sql`${column} not like ${value}`;\n}\n\n/**\n * Case-insensitively compare a column to a pattern,\n * which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * Unlike like, this performs a case-insensitive comparison.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars with 'Turbo' in their names.\n * db.select().from(cars)\n *   .where(ilike(cars.name, '%Turbo%'))\n * ```\n *\n * @see like for a case-sensitive version of this condition\n */\nexport function ilike(column: Column | SQL.Aliased | SQL, value: string | SQLWrapper): SQL {\n\treturn sql`${column} ilike ${value}`;\n}\n\n/**\n * The inverse of ilike - this case-insensitively tests that a given column\n * does not match a pattern, which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars that don't have \"Rover\" in their name.\n * db.select().from(cars)\n *   .where(notLike(cars.name, '%Rover%'))\n * ```\n *\n * @see ilike for the inverse condition\n * @see notLike for a case-sensitive version of this condition\n */\nexport function notIlike(column: Column | SQL.Aliased | SQL, value: string | SQLWrapper): SQL {\n\treturn sql`${column} not ilike ${value}`;\n}\n\n/**\n * Test that a column or expression contains all elements of\n * the list passed as the second argument.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select posts where its tags contain \"Typescript\" and \"ORM\".\n * db.select().from(posts)\n *   .where(arrayContains(posts.tags, ['Typescript', 'ORM']))\n * ```\n *\n * @see arrayContained to find if an array contains all elements of a column or expression\n * @see arrayOverlaps to find if a column or expression contains any elements of an array\n */\nexport function arrayContains<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContains<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContains<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function arrayContains(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('arrayContains requires at least one value');\n\t\t}\n\t\tconst array = sql`${bindIfParam(values, column)}`;\n\t\treturn sql`${column} @> ${array}`;\n\t}\n\n\treturn sql`${column} @> ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test that the list passed as the second argument contains\n * all elements of a column or expression.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select posts where its tags contain \"Typescript\", \"ORM\" or both,\n * // but filtering posts that have additional tags.\n * db.select().from(posts)\n *   .where(arrayContained(posts.tags, ['Typescript', 'ORM']))\n * ```\n *\n * @see arrayContains to find if a column or expression contains all elements of an array\n * @see arrayOverlaps to find if a column or expression contains any elements of an array\n */\nexport function arrayContained<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContained<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContained<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function arrayContained(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('arrayContained requires at least one value');\n\t\t}\n\t\tconst array = sql`${bindIfParam(values, column)}`;\n\t\treturn sql`${column} <@ ${array}`;\n\t}\n\n\treturn sql`${column} <@ ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test that a column or expression contains any elements of\n * the list passed as the second argument.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select posts where its tags contain \"Typescript\", \"ORM\" or both.\n * db.select().from(posts)\n *   .where(arrayOverlaps(posts.tags, ['Typescript', 'ORM']))\n * ```\n *\n * @see arrayContains to find if a column or expression contains all elements of an array\n * @see arrayContained to find if an array contains all elements of a column or expression\n */\nexport function arrayOverlaps<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayOverlaps<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayOverlaps<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function arrayOverlaps(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('arrayOverlaps requires at least one value');\n\t\t}\n\t\tconst array = sql`${bindIfParam(values, column)}`;\n\t\treturn sql`${column} && ${array}`;\n\t}\n\n\treturn sql`${column} && ${bindIfParam(values, column)}`;\n}\n", "import type { AnyColumn } from '../../column.ts';\nimport type { SQL, SQLWrapper } from '../sql.ts';\nimport { sql } from '../sql.ts';\n\n/**\n * Used in sorting, this specifies that the given\n * column or expression should be sorted in ascending\n * order. By the SQL standard, ascending order is the\n * default, so it is not usually necessary to specify\n * ascending sort order.\n *\n * ## Examples\n *\n * ```ts\n * // Return cars, starting with the oldest models\n * // and going in ascending order to the newest.\n * db.select().from(cars)\n *   .orderBy(asc(cars.year));\n * ```\n *\n * @see desc to sort in descending order\n */\nexport function asc(column: AnyColumn | SQLWrapper): SQL {\n\treturn sql`${column} asc`;\n}\n\n/**\n * Used in sorting, this specifies that the given\n * column or expression should be sorted in descending\n * order.\n *\n * ## Examples\n *\n * ```ts\n * // Select users, with the most recently created\n * // records coming first.\n * db.select().from(users)\n *   .orderBy(desc(users.createdAt));\n * ```\n *\n * @see asc to sort in ascending order\n */\nexport function desc(column: AnyColumn | SQLWrapper): SQL {\n\treturn sql`${column} desc`;\n}\n", "import { entityKind } from '~/entity.ts';\nimport type { TypedQueryBuilder } from '~/query-builders/query-builder.ts';\nimport type { ExtractTablesWithRelations, RelationalSchemaConfig, TablesRelationalConfig } from '~/relations.ts';\nimport { SelectionProxyHandler } from '~/selection-proxy.ts';\nimport { type ColumnsSelection, type SQL, sql, type SQLWrapper } from '~/sql/sql.ts';\nimport type { SQLiteAsyncDialect, SQLiteSyncDialect } from '~/sqlite-core/dialect.ts';\nimport {\n\tQueryBuilder,\n\tSQLiteDeleteBase,\n\tSQLiteInsertBuilder,\n\tSQLiteSelectBuilder,\n\tSQLiteUpdateBuilder,\n} from '~/sqlite-core/query-builders/index.ts';\nimport type {\n\tDBResult,\n\tResult,\n\tSQLiteSession,\n\tSQLiteTransaction,\n\tSQLiteTransactionConfig,\n} from '~/sqlite-core/session.ts';\nimport type { SQLiteTable } from '~/sqlite-core/table.ts';\nimport { WithSubquery } from '~/subquery.ts';\nimport type { DrizzleTypeError } from '~/utils.ts';\nimport { SQLiteCountBuilder } from './query-builders/count.ts';\nimport { RelationalQueryBuilder } from './query-builders/query.ts';\nimport { SQLiteRaw } from './query-builders/raw.ts';\nimport type { SelectedFields } from './query-builders/select.types.ts';\nimport type { WithSubqueryWithSelection } from './subquery.ts';\nimport type { SQLiteViewBase } from './view-base.ts';\n\nexport class BaseSQLiteDatabase<\n\tTResultKind extends 'sync' | 'async',\n\tTRunResult,\n\tTFullSchema extends Record<string, unknown> = Record<string, never>,\n\tTSchema extends TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>,\n> {\n\tstatic readonly [entityKind]: string = 'BaseSQLiteDatabase';\n\n\tdeclare readonly _: {\n\t\treadonly schema: TSchema | undefined;\n\t\treadonly fullSchema: TFullSchema;\n\t\treadonly tableNamesMap: Record<string, string>;\n\t};\n\n\tquery: TFullSchema extends Record<string, never>\n\t\t? DrizzleTypeError<'Seems like the schema generic is missing - did you forget to add it to your DB type?'>\n\t\t: {\n\t\t\t[K in keyof TSchema]: RelationalQueryBuilder<TResultKind, TFullSchema, TSchema, TSchema[K]>;\n\t\t};\n\n\tconstructor(\n\t\tprivate resultKind: TResultKind,\n\t\t/** @internal */\n\t\treadonly dialect: { sync: SQLiteSyncDialect; async: SQLiteAsyncDialect }[TResultKind],\n\t\t/** @internal */\n\t\treadonly session: SQLiteSession<TResultKind, TRunResult, TFullSchema, TSchema>,\n\t\tschema: RelationalSchemaConfig<TSchema> | undefined,\n\t) {\n\t\tthis._ = schema\n\t\t\t? {\n\t\t\t\tschema: schema.schema,\n\t\t\t\tfullSchema: schema.fullSchema as TFullSchema,\n\t\t\t\ttableNamesMap: schema.tableNamesMap,\n\t\t\t}\n\t\t\t: {\n\t\t\t\tschema: undefined,\n\t\t\t\tfullSchema: {} as TFullSchema,\n\t\t\t\ttableNamesMap: {},\n\t\t\t};\n\t\tthis.query = {} as typeof this['query'];\n\t\tconst query = this.query as {\n\t\t\t[K in keyof TSchema]: RelationalQueryBuilder<TResultKind, TFullSchema, TSchema, TSchema[K]>;\n\t\t};\n\t\tif (this._.schema) {\n\t\t\tfor (const [tableName, columns] of Object.entries(this._.schema)) {\n\t\t\t\tquery[tableName as keyof TSchema] = new RelationalQueryBuilder(\n\t\t\t\t\tresultKind,\n\t\t\t\t\tschema!.fullSchema,\n\t\t\t\t\tthis._.schema,\n\t\t\t\t\tthis._.tableNamesMap,\n\t\t\t\t\tschema!.fullSchema[tableName] as SQLiteTable,\n\t\t\t\t\tcolumns,\n\t\t\t\t\tdialect,\n\t\t\t\t\tsession as SQLiteSession<any, any, any, any> as any,\n\t\t\t\t) as typeof query[keyof TSchema];\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates a subquery that defines a temporary named result set as a CTE.\n\t *\n\t * It is useful for breaking down complex queries into simpler parts and for reusing the result set in subsequent parts of the query.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}\n\t *\n\t * @param alias The alias for the subquery.\n\t *\n\t * Failure to provide an alias will result in a DrizzleTypeError, preventing the subquery from being referenced in other queries.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Create a subquery with alias 'sq' and use it in the select query\n\t * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));\n\t *\n\t * const result = await db.with(sq).select().from(sq);\n\t * ```\n\t *\n\t * To select arbitrary SQL values as fields in a CTE and reference them in other CTEs or in the main query, you need to add aliases to them:\n\t *\n\t * ```ts\n\t * // Select an arbitrary SQL value as a field in a CTE and reference it in the main query\n\t * const sq = db.$with('sq').as(db.select({\n\t *   name: sql<string>`upper(${users.name})`.as('name'),\n\t * })\n\t * .from(users));\n\t *\n\t * const result = await db.with(sq).select({ name: sq.name }).from(sq);\n\t * ```\n\t */\n\t$with<TAlias extends string>(alias: TAlias) {\n\t\tconst self = this;\n\t\treturn {\n\t\t\tas<TSelection extends ColumnsSelection>(\n\t\t\t\tqb: TypedQueryBuilder<TSelection> | ((qb: QueryBuilder) => TypedQueryBuilder<TSelection>),\n\t\t\t): WithSubqueryWithSelection<TSelection, TAlias> {\n\t\t\t\tif (typeof qb === 'function') {\n\t\t\t\t\tqb = qb(new QueryBuilder(self.dialect));\n\t\t\t\t}\n\n\t\t\t\treturn new Proxy(\n\t\t\t\t\tnew WithSubquery(qb.getSQL(), qb.getSelectedFields() as SelectedFields, alias, true),\n\t\t\t\t\tnew SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }),\n\t\t\t\t) as WithSubqueryWithSelection<TSelection, TAlias>;\n\t\t\t},\n\t\t};\n\t}\n\n\t$count(\n\t\tsource: SQLiteTable | SQLiteViewBase | SQL | SQLWrapper,\n\t\tfilters?: SQL<unknown>,\n\t) {\n\t\treturn new SQLiteCountBuilder({ source, filters, session: this.session });\n\t}\n\n\t/**\n\t * Incorporates a previously defined CTE (using `$with`) into the main query.\n\t *\n\t * This method allows the main query to reference a temporary named result set.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}\n\t *\n\t * @param queries The CTEs to incorporate into the main query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Define a subquery 'sq' as a CTE using $with\n\t * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));\n\t *\n\t * // Incorporate the CTE 'sq' into the main query and select from it\n\t * const result = await db.with(sq).select().from(sq);\n\t * ```\n\t */\n\twith(...queries: WithSubquery[]) {\n\t\tconst self = this;\n\n\t\t/**\n\t\t * Creates a select query.\n\t\t *\n\t\t * Calling this method with no arguments will select all columns from the table. Pass a selection object to specify the columns you want to select.\n\t\t *\n\t\t * Use `.from()` method to specify which table to select from.\n\t\t *\n\t\t * See docs: {@link https://orm.drizzle.team/docs/select}\n\t\t *\n\t\t * @param fields The selection object.\n\t\t *\n\t\t * @example\n\t\t *\n\t\t * ```ts\n\t\t * // Select all columns and all rows from the 'cars' table\n\t\t * const allCars: Car[] = await db.select().from(cars);\n\t\t *\n\t\t * // Select specific columns and all rows from the 'cars' table\n\t\t * const carsIdsAndBrands: { id: number; brand: string }[] = await db.select({\n\t\t *   id: cars.id,\n\t\t *   brand: cars.brand\n\t\t * })\n\t\t *   .from(cars);\n\t\t * ```\n\t\t *\n\t\t * Like in SQL, you can use arbitrary expressions as selection fields, not just table columns:\n\t\t *\n\t\t * ```ts\n\t\t * // Select specific columns along with expression and all rows from the 'cars' table\n\t\t * const carsIdsAndLowerNames: { id: number; lowerBrand: string }[] = await db.select({\n\t\t *   id: cars.id,\n\t\t *   lowerBrand: sql<string>`lower(${cars.brand})`,\n\t\t * })\n\t\t *   .from(cars);\n\t\t * ```\n\t\t */\n\t\tfunction select(): SQLiteSelectBuilder<undefined, TResultKind, TRunResult>;\n\t\tfunction select<TSelection extends SelectedFields>(\n\t\t\tfields: TSelection,\n\t\t): SQLiteSelectBuilder<TSelection, TResultKind, TRunResult>;\n\t\tfunction select(\n\t\t\tfields?: SelectedFields,\n\t\t): SQLiteSelectBuilder<SelectedFields | undefined, TResultKind, TRunResult> {\n\t\t\treturn new SQLiteSelectBuilder({\n\t\t\t\tfields: fields ?? undefined,\n\t\t\t\tsession: self.session,\n\t\t\t\tdialect: self.dialect,\n\t\t\t\twithList: queries,\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Adds `distinct` expression to the select query.\n\t\t *\n\t\t * Calling this method will return only unique values. When multiple columns are selected, it returns rows with unique combinations of values in these columns.\n\t\t *\n\t\t * Use `.from()` method to specify which table to select from.\n\t\t *\n\t\t * See docs: {@link https://orm.drizzle.team/docs/select#distinct}\n\t\t *\n\t\t * @param fields The selection object.\n\t\t *\n\t\t * @example\n\t\t *\n\t\t * ```ts\n\t\t * // Select all unique rows from the 'cars' table\n\t\t * await db.selectDistinct()\n\t\t *   .from(cars)\n\t\t *   .orderBy(cars.id, cars.brand, cars.color);\n\t\t *\n\t\t * // Select all unique brands from the 'cars' table\n\t\t * await db.selectDistinct({ brand: cars.brand })\n\t\t *   .from(cars)\n\t\t *   .orderBy(cars.brand);\n\t\t * ```\n\t\t */\n\t\tfunction selectDistinct(): SQLiteSelectBuilder<undefined, TResultKind, TRunResult>;\n\t\tfunction selectDistinct<TSelection extends SelectedFields>(\n\t\t\tfields: TSelection,\n\t\t): SQLiteSelectBuilder<TSelection, TResultKind, TRunResult>;\n\t\tfunction selectDistinct(\n\t\t\tfields?: SelectedFields,\n\t\t): SQLiteSelectBuilder<SelectedFields | undefined, TResultKind, TRunResult> {\n\t\t\treturn new SQLiteSelectBuilder({\n\t\t\t\tfields: fields ?? undefined,\n\t\t\t\tsession: self.session,\n\t\t\t\tdialect: self.dialect,\n\t\t\t\twithList: queries,\n\t\t\t\tdistinct: true,\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Creates an update query.\n\t\t *\n\t\t * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.\n\t\t *\n\t\t * Use `.set()` method to specify which values to update.\n\t\t *\n\t\t * See docs: {@link https://orm.drizzle.team/docs/update}\n\t\t *\n\t\t * @param table The table to update.\n\t\t *\n\t\t * @example\n\t\t *\n\t\t * ```ts\n\t\t * // Update all rows in the 'cars' table\n\t\t * await db.update(cars).set({ color: 'red' });\n\t\t *\n\t\t * // Update rows with filters and conditions\n\t\t * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));\n\t\t *\n\t\t * // Update with returning clause\n\t\t * const updatedCar: Car[] = await db.update(cars)\n\t\t *   .set({ color: 'red' })\n\t\t *   .where(eq(cars.id, 1))\n\t\t *   .returning();\n\t\t * ```\n\t\t */\n\t\tfunction update<TTable extends SQLiteTable>(table: TTable): SQLiteUpdateBuilder<TTable, TResultKind, TRunResult> {\n\t\t\treturn new SQLiteUpdateBuilder(table, self.session, self.dialect, queries);\n\t\t}\n\n\t\t/**\n\t\t * Creates an insert query.\n\t\t *\n\t\t * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.\n\t\t *\n\t\t * See docs: {@link https://orm.drizzle.team/docs/insert}\n\t\t *\n\t\t * @param table The table to insert into.\n\t\t *\n\t\t * @example\n\t\t *\n\t\t * ```ts\n\t\t * // Insert one row\n\t\t * await db.insert(cars).values({ brand: 'BMW' });\n\t\t *\n\t\t * // Insert multiple rows\n\t\t * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);\n\t\t *\n\t\t * // Insert with returning clause\n\t\t * const insertedCar: Car[] = await db.insert(cars)\n\t\t *   .values({ brand: 'BMW' })\n\t\t *   .returning();\n\t\t * ```\n\t\t */\n\t\tfunction insert<TTable extends SQLiteTable>(into: TTable): SQLiteInsertBuilder<TTable, TResultKind, TRunResult> {\n\t\t\treturn new SQLiteInsertBuilder(into, self.session, self.dialect, queries);\n\t\t}\n\n\t\t/**\n\t\t * Creates a delete query.\n\t\t *\n\t\t * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.\n\t\t *\n\t\t * See docs: {@link https://orm.drizzle.team/docs/delete}\n\t\t *\n\t\t * @param table The table to delete from.\n\t\t *\n\t\t * @example\n\t\t *\n\t\t * ```ts\n\t\t * // Delete all rows in the 'cars' table\n\t\t * await db.delete(cars);\n\t\t *\n\t\t * // Delete rows with filters and conditions\n\t\t * await db.delete(cars).where(eq(cars.color, 'green'));\n\t\t *\n\t\t * // Delete with returning clause\n\t\t * const deletedCar: Car[] = await db.delete(cars)\n\t\t *   .where(eq(cars.id, 1))\n\t\t *   .returning();\n\t\t * ```\n\t\t */\n\t\tfunction delete_<TTable extends SQLiteTable>(from: TTable): SQLiteDeleteBase<TTable, TResultKind, TRunResult> {\n\t\t\treturn new SQLiteDeleteBase(from, self.session, self.dialect, queries);\n\t\t}\n\n\t\treturn { select, selectDistinct, update, insert, delete: delete_ };\n\t}\n\n\t/**\n\t * Creates a select query.\n\t *\n\t * Calling this method with no arguments will select all columns from the table. Pass a selection object to specify the columns you want to select.\n\t *\n\t * Use `.from()` method to specify which table to select from.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select}\n\t *\n\t * @param fields The selection object.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all columns and all rows from the 'cars' table\n\t * const allCars: Car[] = await db.select().from(cars);\n\t *\n\t * // Select specific columns and all rows from the 'cars' table\n\t * const carsIdsAndBrands: { id: number; brand: string }[] = await db.select({\n\t *   id: cars.id,\n\t *   brand: cars.brand\n\t * })\n\t *   .from(cars);\n\t * ```\n\t *\n\t * Like in SQL, you can use arbitrary expressions as selection fields, not just table columns:\n\t *\n\t * ```ts\n\t * // Select specific columns along with expression and all rows from the 'cars' table\n\t * const carsIdsAndLowerNames: { id: number; lowerBrand: string }[] = await db.select({\n\t *   id: cars.id,\n\t *   lowerBrand: sql<string>`lower(${cars.brand})`,\n\t * })\n\t *   .from(cars);\n\t * ```\n\t */\n\tselect(): SQLiteSelectBuilder<undefined, TResultKind, TRunResult>;\n\tselect<TSelection extends SelectedFields>(\n\t\tfields: TSelection,\n\t): SQLiteSelectBuilder<TSelection, TResultKind, TRunResult>;\n\tselect(fields?: SelectedFields): SQLiteSelectBuilder<SelectedFields | undefined, TResultKind, TRunResult> {\n\t\treturn new SQLiteSelectBuilder({ fields: fields ?? undefined, session: this.session, dialect: this.dialect });\n\t}\n\n\t/**\n\t * Adds `distinct` expression to the select query.\n\t *\n\t * Calling this method will return only unique values. When multiple columns are selected, it returns rows with unique combinations of values in these columns.\n\t *\n\t * Use `.from()` method to specify which table to select from.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#distinct}\n\t *\n\t * @param fields The selection object.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all unique rows from the 'cars' table\n\t * await db.selectDistinct()\n\t *   .from(cars)\n\t *   .orderBy(cars.id, cars.brand, cars.color);\n\t *\n\t * // Select all unique brands from the 'cars' table\n\t * await db.selectDistinct({ brand: cars.brand })\n\t *   .from(cars)\n\t *   .orderBy(cars.brand);\n\t * ```\n\t */\n\tselectDistinct(): SQLiteSelectBuilder<undefined, TResultKind, TRunResult>;\n\tselectDistinct<TSelection extends SelectedFields>(\n\t\tfields: TSelection,\n\t): SQLiteSelectBuilder<TSelection, TResultKind, TRunResult>;\n\tselectDistinct(\n\t\tfields?: SelectedFields,\n\t): SQLiteSelectBuilder<SelectedFields | undefined, TResultKind, TRunResult> {\n\t\treturn new SQLiteSelectBuilder({\n\t\t\tfields: fields ?? undefined,\n\t\t\tsession: this.session,\n\t\t\tdialect: this.dialect,\n\t\t\tdistinct: true,\n\t\t});\n\t}\n\n\t/**\n\t * Creates an update query.\n\t *\n\t * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.\n\t *\n\t * Use `.set()` method to specify which values to update.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/update}\n\t *\n\t * @param table The table to update.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Update all rows in the 'cars' table\n\t * await db.update(cars).set({ color: 'red' });\n\t *\n\t * // Update rows with filters and conditions\n\t * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));\n\t *\n\t * // Update with returning clause\n\t * const updatedCar: Car[] = await db.update(cars)\n\t *   .set({ color: 'red' })\n\t *   .where(eq(cars.id, 1))\n\t *   .returning();\n\t * ```\n\t */\n\tupdate<TTable extends SQLiteTable>(table: TTable): SQLiteUpdateBuilder<TTable, TResultKind, TRunResult> {\n\t\treturn new SQLiteUpdateBuilder(table, this.session, this.dialect);\n\t}\n\n\t/**\n\t * Creates an insert query.\n\t *\n\t * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/insert}\n\t *\n\t * @param table The table to insert into.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Insert one row\n\t * await db.insert(cars).values({ brand: 'BMW' });\n\t *\n\t * // Insert multiple rows\n\t * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);\n\t *\n\t * // Insert with returning clause\n\t * const insertedCar: Car[] = await db.insert(cars)\n\t *   .values({ brand: 'BMW' })\n\t *   .returning();\n\t * ```\n\t */\n\tinsert<TTable extends SQLiteTable>(into: TTable): SQLiteInsertBuilder<TTable, TResultKind, TRunResult> {\n\t\treturn new SQLiteInsertBuilder(into, this.session, this.dialect);\n\t}\n\n\t/**\n\t * Creates a delete query.\n\t *\n\t * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/delete}\n\t *\n\t * @param table The table to delete from.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Delete all rows in the 'cars' table\n\t * await db.delete(cars);\n\t *\n\t * // Delete rows with filters and conditions\n\t * await db.delete(cars).where(eq(cars.color, 'green'));\n\t *\n\t * // Delete with returning clause\n\t * const deletedCar: Car[] = await db.delete(cars)\n\t *   .where(eq(cars.id, 1))\n\t *   .returning();\n\t * ```\n\t */\n\tdelete<TTable extends SQLiteTable>(from: TTable): SQLiteDeleteBase<TTable, TResultKind, TRunResult> {\n\t\treturn new SQLiteDeleteBase(from, this.session, this.dialect);\n\t}\n\n\trun(query: SQLWrapper | string): DBResult<TResultKind, TRunResult> {\n\t\tconst sequel = typeof query === 'string' ? sql.raw(query) : query.getSQL();\n\t\tif (this.resultKind === 'async') {\n\t\t\treturn new SQLiteRaw(\n\t\t\t\tasync () => this.session.run(sequel),\n\t\t\t\t() => sequel,\n\t\t\t\t'run',\n\t\t\t\tthis.dialect as SQLiteAsyncDialect,\n\t\t\t\tthis.session.extractRawRunValueFromBatchResult.bind(this.session),\n\t\t\t) as DBResult<TResultKind, TRunResult>;\n\t\t}\n\t\treturn this.session.run(sequel) as DBResult<TResultKind, TRunResult>;\n\t}\n\n\tall<T = unknown>(query: SQLWrapper | string): DBResult<TResultKind, T[]> {\n\t\tconst sequel = typeof query === 'string' ? sql.raw(query) : query.getSQL();\n\t\tif (this.resultKind === 'async') {\n\t\t\treturn new SQLiteRaw(\n\t\t\t\tasync () => this.session.all(sequel),\n\t\t\t\t() => sequel,\n\t\t\t\t'all',\n\t\t\t\tthis.dialect as SQLiteAsyncDialect,\n\t\t\t\tthis.session.extractRawAllValueFromBatchResult.bind(this.session),\n\t\t\t) as any;\n\t\t}\n\t\treturn this.session.all(sequel) as DBResult<TResultKind, T[]>;\n\t}\n\n\tget<T = unknown>(query: SQLWrapper | string): DBResult<TResultKind, T> {\n\t\tconst sequel = typeof query === 'string' ? sql.raw(query) : query.getSQL();\n\t\tif (this.resultKind === 'async') {\n\t\t\treturn new SQLiteRaw(\n\t\t\t\tasync () => this.session.get(sequel),\n\t\t\t\t() => sequel,\n\t\t\t\t'get',\n\t\t\t\tthis.dialect as SQLiteAsyncDialect,\n\t\t\t\tthis.session.extractRawGetValueFromBatchResult.bind(this.session),\n\t\t\t) as DBResult<TResultKind, T>;\n\t\t}\n\t\treturn this.session.get(sequel) as DBResult<TResultKind, T>;\n\t}\n\n\tvalues<T extends unknown[] = unknown[]>(query: SQLWrapper | string): DBResult<TResultKind, T[]> {\n\t\tconst sequel = typeof query === 'string' ? sql.raw(query) : query.getSQL();\n\t\tif (this.resultKind === 'async') {\n\t\t\treturn new SQLiteRaw(\n\t\t\t\tasync () => this.session.values(sequel),\n\t\t\t\t() => sequel,\n\t\t\t\t'values',\n\t\t\t\tthis.dialect as SQLiteAsyncDialect,\n\t\t\t\tthis.session.extractRawValuesValueFromBatchResult.bind(this.session),\n\t\t\t) as any;\n\t\t}\n\t\treturn this.session.values(sequel) as DBResult<TResultKind, T[]>;\n\t}\n\n\ttransaction<T>(\n\t\ttransaction: (tx: SQLiteTransaction<TResultKind, TRunResult, TFullSchema, TSchema>) => Result<TResultKind, T>,\n\t\tconfig?: SQLiteTransactionConfig,\n\t): Result<TResultKind, T> {\n\t\treturn this.session.transaction(transaction, config);\n\t}\n}\n\nexport type SQLiteWithReplicas<Q> = Q & { $primary: Q };\n\nexport const withReplicas = <\n\tTResultKind extends 'sync' | 'async',\n\tTRunResult,\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n\tQ extends BaseSQLiteDatabase<\n\t\tTResultKind,\n\t\tTRunResult,\n\t\tTFullSchema,\n\t\tTSchema extends Record<string, unknown> ? ExtractTablesWithRelations<TFullSchema> : TSchema\n\t>,\n>(\n\tprimary: Q,\n\treplicas: [Q, ...Q[]],\n\tgetReplica: (replicas: Q[]) => Q = () => replicas[Math.floor(Math.random() * replicas.length)]!,\n): SQLiteWithReplicas<Q> => {\n\tconst select: Q['select'] = (...args: []) => getReplica(replicas).select(...args);\n\tconst selectDistinct: Q['selectDistinct'] = (...args: []) => getReplica(replicas).selectDistinct(...args);\n\tconst $with: Q['with'] = (...args: []) => getReplica(replicas).with(...args);\n\n\tconst update: Q['update'] = (...args: [any]) => primary.update(...args);\n\tconst insert: Q['insert'] = (...args: [any]) => primary.insert(...args);\n\tconst $delete: Q['delete'] = (...args: [any]) => primary.delete(...args);\n\tconst run: Q['run'] = (...args: [any]) => primary.run(...args);\n\tconst all: Q['all'] = (...args: [any]) => primary.all(...args);\n\tconst get: Q['get'] = (...args: [any]) => primary.get(...args);\n\tconst values: Q['values'] = (...args: [any]) => primary.values(...args);\n\tconst transaction: Q['transaction'] = (...args: [any]) => primary.transaction(...args);\n\n\treturn {\n\t\t...primary,\n\t\tupdate,\n\t\tinsert,\n\t\tdelete: $delete,\n\t\trun,\n\t\tall,\n\t\tget,\n\t\tvalues,\n\t\ttransaction,\n\t\t$primary: primary,\n\t\tselect,\n\t\tselectDistinct,\n\t\twith: $with,\n\t\tget query() {\n\t\t\treturn getReplica(replicas).query;\n\t\t},\n\t};\n};\n", "import { ColumnAliasProxyHandler, TableAliasProxyHandler } from './alias.ts';\nimport { Column } from './column.ts';\nimport { entityKind, is } from './entity.ts';\nimport { SQL, View } from './sql/sql.ts';\nimport { Subquery } from './subquery.ts';\nimport { ViewBaseConfig } from './view-common.ts';\n\nexport class SelectionProxyHandler<T extends Subquery | Record<string, unknown> | View>\n\timplements ProxyHandler<Subquery | Record<string, unknown> | View>\n{\n\tstatic readonly [entityKind]: string = 'SelectionProxyHandler';\n\n\tprivate config: {\n\t\t/**\n\t\t * Table alias for the columns\n\t\t */\n\t\talias?: string;\n\t\t/**\n\t\t * What to do when a field is an instance of `SQL.Aliased` and it's not a selection field (from a subquery)\n\t\t *\n\t\t * `sql` - return the underlying SQL expression\n\t\t *\n\t\t * `alias` - return the field alias\n\t\t */\n\t\tsqlAliasedBehavior: 'sql' | 'alias';\n\t\t/**\n\t\t * What to do when a field is an instance of `SQL` and it doesn't have an alias declared\n\t\t *\n\t\t * `sql` - return the underlying SQL expression\n\t\t *\n\t\t * `error` - return a DrizzleTypeError on type level and throw an error on runtime\n\t\t */\n\t\tsqlBehavior: 'sql' | 'error';\n\n\t\t/**\n\t\t * Whether to replace the original name of the column with the alias\n\t\t * Should be set to `true` for views creation\n\t\t * @default false\n\t\t */\n\t\treplaceOriginalName?: boolean;\n\t};\n\n\tconstructor(config: SelectionProxyHandler<T>['config']) {\n\t\tthis.config = { ...config };\n\t}\n\n\tget(subquery: T, prop: string | symbol): any {\n\t\tif (prop === '_') {\n\t\t\treturn {\n\t\t\t\t...subquery['_' as keyof typeof subquery],\n\t\t\t\tselectedFields: new Proxy(\n\t\t\t\t\t(subquery as Subquery)._.selectedFields,\n\t\t\t\t\tthis as ProxyHandler<Record<string, unknown>>,\n\t\t\t\t),\n\t\t\t};\n\t\t}\n\n\t\tif (prop === ViewBaseConfig) {\n\t\t\treturn {\n\t\t\t\t...subquery[ViewBaseConfig as keyof typeof subquery],\n\t\t\t\tselectedFields: new Proxy(\n\t\t\t\t\t(subquery as View)[ViewBaseConfig].selectedFields,\n\t\t\t\t\tthis as ProxyHandler<Record<string, unknown>>,\n\t\t\t\t),\n\t\t\t};\n\t\t}\n\n\t\tif (typeof prop === 'symbol') {\n\t\t\treturn subquery[prop as keyof typeof subquery];\n\t\t}\n\n\t\tconst columns = is(subquery, Subquery)\n\t\t\t? subquery._.selectedFields\n\t\t\t: is(subquery, View)\n\t\t\t? subquery[ViewBaseConfig].selectedFields\n\t\t\t: subquery;\n\t\tconst value: unknown = columns[prop as keyof typeof columns];\n\n\t\tif (is(value, SQL.Aliased)) {\n\t\t\t// Never return the underlying SQL expression for a field previously selected in a subquery\n\t\t\tif (this.config.sqlAliasedBehavior === 'sql' && !value.isSelectionField) {\n\t\t\t\treturn value.sql;\n\t\t\t}\n\n\t\t\tconst newValue = value.clone();\n\t\t\tnewValue.isSelectionField = true;\n\t\t\treturn newValue;\n\t\t}\n\n\t\tif (is(value, SQL)) {\n\t\t\tif (this.config.sqlBehavior === 'sql') {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tthrow new Error(\n\t\t\t\t`You tried to reference \"${prop}\" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using \".as('alias')\" method.`,\n\t\t\t);\n\t\t}\n\n\t\tif (is(value, Column)) {\n\t\t\tif (this.config.alias) {\n\t\t\t\treturn new Proxy(\n\t\t\t\t\tvalue,\n\t\t\t\t\tnew ColumnAliasProxyHandler(\n\t\t\t\t\t\tnew Proxy(\n\t\t\t\t\t\t\tvalue.table,\n\t\t\t\t\t\t\tnew TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tif (typeof value !== 'object' || value === null) {\n\t\t\treturn value;\n\t\t}\n\n\t\treturn new Proxy(value, new SelectionProxyHandler(this.config));\n\t}\n}\n", "import type { AnyColumn } from './column.ts';\nimport { Column } from './column.ts';\nimport { entityKind, is } from './entity.ts';\nimport type { Relation } from './relations.ts';\nimport type { View } from './sql/sql.ts';\nimport { SQL, sql } from './sql/sql.ts';\nimport { Table } from './table.ts';\nimport { ViewBaseConfig } from './view-common.ts';\n\nexport class ColumnAliasProxyHandler<TColumn extends Column> implements ProxyHandler<TColumn> {\n\tstatic readonly [entityKind]: string = 'ColumnAliasProxyHandler';\n\n\tconstructor(private table: Table | View) {}\n\n\tget(columnObj: TColumn, prop: string | symbol): any {\n\t\tif (prop === 'table') {\n\t\t\treturn this.table;\n\t\t}\n\n\t\treturn columnObj[prop as keyof TColumn];\n\t}\n}\n\nexport class TableAliasProxyHandler<T extends Table | View> implements ProxyHandler<T> {\n\tstatic readonly [entityKind]: string = 'TableAliasProxyHandler';\n\n\tconstructor(private alias: string, private replaceOriginalName: boolean) {}\n\n\tget(target: T, prop: string | symbol): any {\n\t\tif (prop === Table.Symbol.IsAlias) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (prop === Table.Symbol.Name) {\n\t\t\treturn this.alias;\n\t\t}\n\n\t\tif (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {\n\t\t\treturn this.alias;\n\t\t}\n\n\t\tif (prop === ViewBaseConfig) {\n\t\t\treturn {\n\t\t\t\t...target[ViewBaseConfig as keyof typeof target],\n\t\t\t\tname: this.alias,\n\t\t\t\tisAlias: true,\n\t\t\t};\n\t\t}\n\n\t\tif (prop === Table.Symbol.Columns) {\n\t\t\tconst columns = (target as Table)[Table.Symbol.Columns];\n\t\t\tif (!columns) {\n\t\t\t\treturn columns;\n\t\t\t}\n\n\t\t\tconst proxiedColumns: { [key: string]: any } = {};\n\n\t\t\tObject.keys(columns).map((key) => {\n\t\t\t\tproxiedColumns[key] = new Proxy(\n\t\t\t\t\tcolumns[key]!,\n\t\t\t\t\tnew ColumnAliasProxyHandler(new Proxy(target, this)),\n\t\t\t\t);\n\t\t\t});\n\n\t\t\treturn proxiedColumns;\n\t\t}\n\n\t\tconst value = target[prop as keyof typeof target];\n\t\tif (is(value, Column)) {\n\t\t\treturn new Proxy(value as AnyColumn, new ColumnAliasProxyHandler(new Proxy(target, this)));\n\t\t}\n\n\t\treturn value;\n\t}\n}\n\nexport class RelationTableAliasProxyHandler<T extends Relation> implements ProxyHandler<T> {\n\tstatic readonly [entityKind]: string = 'RelationTableAliasProxyHandler';\n\n\tconstructor(private alias: string) {}\n\n\tget(target: T, prop: string | symbol): any {\n\t\tif (prop === 'sourceTable') {\n\t\t\treturn aliasedTable(target.sourceTable, this.alias);\n\t\t}\n\n\t\treturn target[prop as keyof typeof target];\n\t}\n}\n\nexport function aliasedTable<T extends Table>(table: T, tableAlias: string): T {\n\treturn new Proxy(table, new TableAliasProxyHandler(tableAlias, false));\n}\n\nexport function aliasedRelation<T extends Relation>(relation: T, tableAlias: string): T {\n\treturn new Proxy(relation, new RelationTableAliasProxyHandler(tableAlias));\n}\n\nexport function aliasedTableColumn<T extends AnyColumn>(column: T, tableAlias: string): T {\n\treturn new Proxy(\n\t\tcolumn,\n\t\tnew ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false))),\n\t);\n}\n\nexport function mapColumnsInAliasedSQLToAlias(query: SQL.Aliased, alias: string): SQL.Aliased {\n\treturn new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);\n}\n\nexport function mapColumnsInSQLToAlias(query: SQL, alias: string): SQL {\n\treturn sql.join(query.queryChunks.map((c) => {\n\t\tif (is(c, Column)) {\n\t\t\treturn aliasedTableColumn(c, alias);\n\t\t}\n\t\tif (is(c, SQL)) {\n\t\t\treturn mapColumnsInSQLToAlias(c, alias);\n\t\t}\n\t\tif (is(c, SQL.Aliased)) {\n\t\t\treturn mapColumnsInAliasedSQLToAlias(c, alias);\n\t\t}\n\t\treturn c;\n\t}));\n}\n", "import { entityKind } from '~/entity.ts';\nimport type { SelectResultFields } from '~/query-builders/select.types.ts';\nimport { QueryPromise } from '~/query-promise.ts';\nimport type { RunnableQuery } from '~/runnable-query.ts';\nimport { SelectionProxyHandler } from '~/selection-proxy.ts';\nimport type { Placeholder, Query, SQL, SQLWrapper } from '~/sql/sql.ts';\nimport type { SQLiteDialect } from '~/sqlite-core/dialect.ts';\nimport type { SQLitePreparedQuery, SQLiteSession } from '~/sqlite-core/session.ts';\nimport { SQLiteTable } from '~/sqlite-core/table.ts';\nimport type { Subquery } from '~/subquery.ts';\nimport { Table } from '~/table.ts';\nimport { type DrizzleTypeError, orderSelectedFields, type ValueOrArray } from '~/utils.ts';\nimport type { SQLiteColumn } from '../columns/common.ts';\nimport type { SelectedFieldsFlat, SelectedFieldsOrdered } from './select.types.ts';\n\nexport type SQLiteDeleteWithout<\n\tT extends AnySQLiteDeleteBase,\n\tTDynamic extends boolean,\n\tK extends keyof T & string,\n> = TDynamic extends true ? T\n\t: Omit<\n\t\tSQLiteDeleteBase<\n\t\t\tT['_']['table'],\n\t\t\tT['_']['resultType'],\n\t\t\tT['_']['runResult'],\n\t\t\tT['_']['returning'],\n\t\t\tTDynamic,\n\t\t\tT['_']['excludedMethods'] | K\n\t\t>,\n\t\tT['_']['excludedMethods'] | K\n\t>;\n\nexport type SQLiteDelete<\n\tTTable extends SQLiteTable = SQLiteTable,\n\tTResultType extends 'sync' | 'async' = 'sync' | 'async',\n\tTRunResult = unknown,\n\tTReturning extends Record<string, unknown> | undefined = undefined,\n> = SQLiteDeleteBase<TTable, TResultType, TRunResult, TReturning, true, never>;\n\nexport interface SQLiteDeleteConfig {\n\twhere?: SQL | undefined;\n\tlimit?: number | Placeholder;\n\torderBy?: (SQLiteColumn | SQL | SQL.Aliased)[];\n\ttable: SQLiteTable;\n\treturning?: SelectedFieldsOrdered;\n\twithList?: Subquery[];\n}\n\nexport type SQLiteDeleteReturningAll<\n\tT extends AnySQLiteDeleteBase,\n\tTDynamic extends boolean,\n> = SQLiteDeleteWithout<\n\tSQLiteDeleteBase<\n\t\tT['_']['table'],\n\t\tT['_']['resultType'],\n\t\tT['_']['runResult'],\n\t\tT['_']['table']['$inferSelect'],\n\t\tT['_']['dynamic'],\n\t\tT['_']['excludedMethods']\n\t>,\n\tTDynamic,\n\t'returning'\n>;\n\nexport type SQLiteDeleteReturning<\n\tT extends AnySQLiteDeleteBase,\n\tTDynamic extends boolean,\n\tTSelectedFields extends SelectedFieldsFlat,\n> = SQLiteDeleteWithout<\n\tSQLiteDeleteBase<\n\t\tT['_']['table'],\n\t\tT['_']['resultType'],\n\t\tT['_']['runResult'],\n\t\tSelectResultFields<TSelectedFields>,\n\t\tT['_']['dynamic'],\n\t\tT['_']['excludedMethods']\n\t>,\n\tTDynamic,\n\t'returning'\n>;\n\nexport type SQLiteDeleteExecute<T extends AnySQLiteDeleteBase> = T['_']['returning'] extends undefined\n\t? T['_']['runResult']\n\t: T['_']['returning'][];\n\nexport type SQLiteDeletePrepare<T extends AnySQLiteDeleteBase> = SQLitePreparedQuery<{\n\ttype: T['_']['resultType'];\n\trun: T['_']['runResult'];\n\tall: T['_']['returning'] extends undefined ? DrizzleTypeError<'.all() cannot be used without .returning()'>\n\t\t: T['_']['returning'][];\n\tget: T['_']['returning'] extends undefined ? DrizzleTypeError<'.get() cannot be used without .returning()'>\n\t\t: T['_']['returning'] | undefined;\n\tvalues: T['_']['returning'] extends undefined ? DrizzleTypeError<'.values() cannot be used without .returning()'>\n\t\t: any[][];\n\texecute: SQLiteDeleteExecute<T>;\n}>;\n\nexport type SQLiteDeleteDynamic<T extends AnySQLiteDeleteBase> = SQLiteDelete<\n\tT['_']['table'],\n\tT['_']['resultType'],\n\tT['_']['runResult'],\n\tT['_']['returning']\n>;\n\nexport type AnySQLiteDeleteBase = SQLiteDeleteBase<any, any, any, any, any, any>;\n\nexport interface SQLiteDeleteBase<\n\tTTable extends SQLiteTable,\n\tTResultType extends 'sync' | 'async',\n\tTRunResult,\n\tTReturning extends Record<string, unknown> | undefined = undefined,\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n> extends\n\tQueryPromise<TReturning extends undefined ? TRunResult : TReturning[]>,\n\tRunnableQuery<TReturning extends undefined ? TRunResult : TReturning[], 'sqlite'>,\n\tSQLWrapper\n{\n\treadonly _: {\n\t\tdialect: 'sqlite';\n\t\treadonly table: TTable;\n\t\treadonly resultType: TResultType;\n\t\treadonly runResult: TRunResult;\n\t\treadonly returning: TReturning;\n\t\treadonly dynamic: TDynamic;\n\t\treadonly excludedMethods: TExcludedMethods;\n\t\treadonly result: TReturning extends undefined ? TRunResult : TReturning[];\n\t};\n}\n\nexport class SQLiteDeleteBase<\n\tTTable extends SQLiteTable,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTResultType extends 'sync' | 'async',\n\tTRunResult,\n\tTReturning extends Record<string, unknown> | undefined = undefined,\n\tTDynamic extends boolean = false,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTExcludedMethods extends string = never,\n> extends QueryPromise<TReturning extends undefined ? TRunResult : TReturning[]>\n\timplements RunnableQuery<TReturning extends undefined ? TRunResult : TReturning[], 'sqlite'>, SQLWrapper\n{\n\tstatic override readonly [entityKind]: string = 'SQLiteDelete';\n\n\t/** @internal */\n\tconfig: SQLiteDeleteConfig;\n\n\tconstructor(\n\t\tprivate table: TTable,\n\t\tprivate session: SQLiteSession<any, any, any, any>,\n\t\tprivate dialect: SQLiteDialect,\n\t\twithList?: Subquery[],\n\t) {\n\t\tsuper();\n\t\tthis.config = { table, withList };\n\t}\n\n\t/**\n\t * Adds a `where` clause to the query.\n\t *\n\t * Calling this method will delete only those rows that fulfill a specified condition.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/delete}\n\t *\n\t * @param where the `where` clause.\n\t *\n\t * @example\n\t * You can use conditional operators and `sql function` to filter the rows to be deleted.\n\t *\n\t * ```ts\n\t * // Delete all cars with green color\n\t * db.delete(cars).where(eq(cars.color, 'green'));\n\t * // or\n\t * db.delete(cars).where(sql`${cars.color} = 'green'`)\n\t * ```\n\t *\n\t * You can logically combine conditional operators with `and()` and `or()` operators:\n\t *\n\t * ```ts\n\t * // Delete all BMW cars with a green color\n\t * db.delete(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));\n\t *\n\t * // Delete all cars with the green or blue color\n\t * db.delete(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));\n\t * ```\n\t */\n\twhere(where: SQL | undefined): SQLiteDeleteWithout<this, TDynamic, 'where'> {\n\t\tthis.config.where = where;\n\t\treturn this as any;\n\t}\n\n\torderBy(\n\t\tbuilder: (deleteTable: TTable) => ValueOrArray<SQLiteColumn | SQL | SQL.Aliased>,\n\t): SQLiteDeleteWithout<this, TDynamic, 'orderBy'>;\n\torderBy(...columns: (SQLiteColumn | SQL | SQL.Aliased)[]): SQLiteDeleteWithout<this, TDynamic, 'orderBy'>;\n\torderBy(\n\t\t...columns:\n\t\t\t| [(deleteTable: TTable) => ValueOrArray<SQLiteColumn | SQL | SQL.Aliased>]\n\t\t\t| (SQLiteColumn | SQL | SQL.Aliased)[]\n\t): SQLiteDeleteWithout<this, TDynamic, 'orderBy'> {\n\t\tif (typeof columns[0] === 'function') {\n\t\t\tconst orderBy = columns[0](\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.table[Table.Symbol.Columns],\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' }),\n\t\t\t\t) as any,\n\t\t\t);\n\n\t\t\tconst orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];\n\t\t\tthis.config.orderBy = orderByArray;\n\t\t} else {\n\t\t\tconst orderByArray = columns as (SQLiteColumn | SQL | SQL.Aliased)[];\n\t\t\tthis.config.orderBy = orderByArray;\n\t\t}\n\t\treturn this as any;\n\t}\n\n\tlimit(limit: number | Placeholder): SQLiteDeleteWithout<this, TDynamic, 'limit'> {\n\t\tthis.config.limit = limit;\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `returning` clause to the query.\n\t *\n\t * Calling this method will return the specified fields of the deleted rows. If no fields are specified, all fields will be returned.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/delete#delete-with-return}\n\t *\n\t * @example\n\t * ```ts\n\t * // Delete all cars with the green color and return all fields\n\t * const deletedCars: Car[] = await db.delete(cars)\n\t *   .where(eq(cars.color, 'green'))\n\t *   .returning();\n\t *\n\t * // Delete all cars with the green color and return only their id and brand fields\n\t * const deletedCarsIdsAndBrands: { id: number, brand: string }[] = await db.delete(cars)\n\t *   .where(eq(cars.color, 'green'))\n\t *   .returning({ id: cars.id, brand: cars.brand });\n\t * ```\n\t */\n\treturning(): SQLiteDeleteReturningAll<this, TDynamic>;\n\treturning<TSelectedFields extends SelectedFieldsFlat>(\n\t\tfields: TSelectedFields,\n\t): SQLiteDeleteReturning<this, TDynamic, TSelectedFields>;\n\treturning(\n\t\tfields: SelectedFieldsFlat = this.table[SQLiteTable.Symbol.Columns],\n\t): SQLiteDeleteReturning<this, TDynamic, any> {\n\t\tthis.config.returning = orderSelectedFields<SQLiteColumn>(fields);\n\t\treturn this as any;\n\t}\n\n\t/** @internal */\n\tgetSQL(): SQL {\n\t\treturn this.dialect.buildDeleteQuery(this.config);\n\t}\n\n\ttoSQL(): Query {\n\t\tconst { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n\t\treturn rest;\n\t}\n\n\t/** @internal */\n\t_prepare(isOneTimeQuery = true): SQLiteDeletePrepare<this> {\n\t\treturn this.session[isOneTimeQuery ? 'prepareOneTimeQuery' : 'prepareQuery'](\n\t\t\tthis.dialect.sqlToQuery(this.getSQL()),\n\t\t\tthis.config.returning,\n\t\t\tthis.config.returning ? 'all' : 'run',\n\t\t\ttrue,\n\t\t) as SQLiteDeletePrepare<this>;\n\t}\n\n\tprepare(): SQLiteDeletePrepare<this> {\n\t\treturn this._prepare(false);\n\t}\n\n\trun: ReturnType<this['prepare']>['run'] = (placeholderValues) => {\n\t\treturn this._prepare().run(placeholderValues);\n\t};\n\n\tall: ReturnType<this['prepare']>['all'] = (placeholderValues) => {\n\t\treturn this._prepare().all(placeholderValues);\n\t};\n\n\tget: ReturnType<this['prepare']>['get'] = (placeholderValues) => {\n\t\treturn this._prepare().get(placeholderValues);\n\t};\n\n\tvalues: ReturnType<this['prepare']>['values'] = (placeholderValues) => {\n\t\treturn this._prepare().values(placeholderValues);\n\t};\n\n\toverride async execute(placeholderValues?: Record<string, unknown>): Promise<SQLiteDeleteExecute<this>> {\n\t\treturn this._prepare().execute(placeholderValues) as SQLiteDeleteExecute<this>;\n\t}\n\n\t$dynamic(): SQLiteDeleteDynamic<this> {\n\t\treturn this as any;\n\t}\n}\n", "import { entityKind } from '~/entity.ts';\n\nexport abstract class QueryPromise<T> implements Promise<T> {\n\tstatic readonly [entityKind]: string = 'QueryPromise';\n\n\t[Symbol.toStringTag] = 'QueryPromise';\n\n\tcatch<TResult = never>(\n\t\tonRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined,\n\t): Promise<T | TResult> {\n\t\treturn this.then(undefined, onRejected);\n\t}\n\n\tfinally(onFinally?: (() => void) | null | undefined): Promise<T> {\n\t\treturn this.then(\n\t\t\t(value) => {\n\t\t\t\tonFinally?.();\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\t(reason) => {\n\t\t\t\tonFinally?.();\n\t\t\t\tthrow reason;\n\t\t\t},\n\t\t);\n\t}\n\n\tthen<TResult1 = T, TResult2 = never>(\n\t\tonFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n\t\tonRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n\t): Promise<TResult1 | TResult2> {\n\t\treturn this.execute().then(onFulfilled, onRejected);\n\t}\n\n\tabstract execute(): Promise<T>;\n}\n", "import type { BuildColumns, BuildExtraConfigColumns } from '~/column-builder.ts';\nimport { entityKind } from '~/entity.ts';\nimport { Table, type TableConfig as TableConfigBase, type UpdateTableConfig } from '~/table.ts';\nimport type { CheckBuilder } from './checks.ts';\nimport { getSQLiteColumnBuilders, type SQLiteColumnBuilders } from './columns/all.ts';\nimport type { SQLiteColumn, SQLiteColumnBuilder, SQLiteColumnBuilderBase } from './columns/common.ts';\nimport type { ForeignKey, ForeignKeyBuilder } from './foreign-keys.ts';\nimport type { IndexBuilder } from './indexes.ts';\nimport type { PrimaryKeyBuilder } from './primary-keys.ts';\nimport type { UniqueConstraintBuilder } from './unique-constraint.ts';\n\nexport type SQLiteTableExtraConfigValue =\n\t| IndexBuilder\n\t| CheckBuilder\n\t| ForeignKeyBuilder\n\t| PrimaryKeyBuilder\n\t| UniqueConstraintBuilder;\n\nexport type SQLiteTableExtraConfig = Record<\n\tstring,\n\tSQLiteTableExtraConfigValue\n>;\n\nexport type TableConfig = TableConfigBase<SQLiteColumn<any>>;\n\n/** @internal */\nexport const InlineForeignKeys = Symbol.for('drizzle:SQLiteInlineForeignKeys');\n\nexport class SQLiteTable<T extends TableConfig = TableConfig> extends Table<T> {\n\tstatic override readonly [entityKind]: string = 'SQLiteTable';\n\n\t/** @internal */\n\tstatic override readonly Symbol = Object.assign({}, Table.Symbol, {\n\t\tInlineForeignKeys: InlineForeignKeys as typeof InlineForeignKeys,\n\t});\n\n\t/** @internal */\n\toverride [Table.Symbol.Columns]!: NonNullable<T['columns']>;\n\n\t/** @internal */\n\t[InlineForeignKeys]: ForeignKey[] = [];\n\n\t/** @internal */\n\toverride [Table.Symbol.ExtraConfigBuilder]:\n\t\t| ((self: Record<string, SQLiteColumn>) => SQLiteTableExtraConfig)\n\t\t| undefined = undefined;\n}\n\nexport type AnySQLiteTable<TPartial extends Partial<TableConfig> = {}> = SQLiteTable<\n\tUpdateTableConfig<TableConfig, TPartial>\n>;\n\nexport type SQLiteTableWithColumns<T extends TableConfig> =\n\t& SQLiteTable<T>\n\t& {\n\t\t[Key in keyof T['columns']]: T['columns'][Key];\n\t};\n\nexport interface SQLiteTableFn<TSchema extends string | undefined = undefined> {\n\t<\n\t\tTTableName extends string,\n\t\tTColumnsMap extends Record<string, SQLiteColumnBuilderBase>,\n\t>(\n\t\tname: TTableName,\n\t\tcolumns: TColumnsMap,\n\t\textraConfig?: (\n\t\t\tself: BuildColumns<TTableName, TColumnsMap, 'sqlite'>,\n\t\t) => SQLiteTableExtraConfigValue[],\n\t): SQLiteTableWithColumns<{\n\t\tname: TTableName;\n\t\tschema: TSchema;\n\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'sqlite'>;\n\t\tdialect: 'sqlite';\n\t}>;\n\n\t<\n\t\tTTableName extends string,\n\t\tTColumnsMap extends Record<string, SQLiteColumnBuilderBase>,\n\t>(\n\t\tname: TTableName,\n\t\tcolumns: (columnTypes: SQLiteColumnBuilders) => TColumnsMap,\n\t\textraConfig?: (self: BuildColumns<TTableName, TColumnsMap, 'sqlite'>) => SQLiteTableExtraConfigValue[],\n\t): SQLiteTableWithColumns<{\n\t\tname: TTableName;\n\t\tschema: TSchema;\n\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'sqlite'>;\n\t\tdialect: 'sqlite';\n\t}>;\n\t/**\n\t * @deprecated The third parameter of sqliteTable is changing and will only accept an array instead of an object\n\t *\n\t * @example\n\t * Deprecated version:\n\t * ```ts\n\t * export const users = sqliteTable(\"users\", {\n\t * \tid: int(),\n\t * }, (t) => ({\n\t * \tidx: index('custom_name').on(t.id)\n\t * }));\n\t * ```\n\t *\n\t * New API:\n\t * ```ts\n\t * export const users = sqliteTable(\"users\", {\n\t * \tid: int(),\n\t * }, (t) => [\n\t * \tindex('custom_name').on(t.id)\n\t * ]);\n\t * ```\n\t */\n\t<\n\t\tTTableName extends string,\n\t\tTColumnsMap extends Record<string, SQLiteColumnBuilderBase>,\n\t>(\n\t\tname: TTableName,\n\t\tcolumns: TColumnsMap,\n\t\textraConfig?: (self: BuildColumns<TTableName, TColumnsMap, 'sqlite'>) => SQLiteTableExtraConfig,\n\t): SQLiteTableWithColumns<{\n\t\tname: TTableName;\n\t\tschema: TSchema;\n\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'sqlite'>;\n\t\tdialect: 'sqlite';\n\t}>;\n\n\t/**\n\t * @deprecated The third parameter of sqliteTable is changing and will only accept an array instead of an object\n\t *\n\t * @example\n\t * Deprecated version:\n\t * ```ts\n\t * export const users = sqliteTable(\"users\", {\n\t * \tid: int(),\n\t * }, (t) => ({\n\t * \tidx: index('custom_name').on(t.id)\n\t * }));\n\t * ```\n\t *\n\t * New API:\n\t * ```ts\n\t * export const users = sqliteTable(\"users\", {\n\t * \tid: int(),\n\t * }, (t) => [\n\t * \tindex('custom_name').on(t.id)\n\t * ]);\n\t * ```\n\t */\n\t<\n\t\tTTableName extends string,\n\t\tTColumnsMap extends Record<string, SQLiteColumnBuilderBase>,\n\t>(\n\t\tname: TTableName,\n\t\tcolumns: (columnTypes: SQLiteColumnBuilders) => TColumnsMap,\n\t\textraConfig?: (self: BuildColumns<TTableName, TColumnsMap, 'sqlite'>) => SQLiteTableExtraConfig,\n\t): SQLiteTableWithColumns<{\n\t\tname: TTableName;\n\t\tschema: TSchema;\n\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'sqlite'>;\n\t\tdialect: 'sqlite';\n\t}>;\n}\n\nfunction sqliteTableBase<\n\tTTableName extends string,\n\tTColumnsMap extends Record<string, SQLiteColumnBuilderBase>,\n\tTSchema extends string | undefined,\n>(\n\tname: TTableName,\n\tcolumns: TColumnsMap | ((columnTypes: SQLiteColumnBuilders) => TColumnsMap),\n\textraConfig:\n\t\t| ((\n\t\t\tself: BuildColumns<TTableName, TColumnsMap, 'sqlite'>,\n\t\t) => SQLiteTableExtraConfig | SQLiteTableExtraConfigValue[])\n\t\t| undefined,\n\tschema?: TSchema,\n\tbaseName = name,\n): SQLiteTableWithColumns<{\n\tname: TTableName;\n\tschema: TSchema;\n\tcolumns: BuildColumns<TTableName, TColumnsMap, 'sqlite'>;\n\tdialect: 'sqlite';\n}> {\n\tconst rawTable = new SQLiteTable<{\n\t\tname: TTableName;\n\t\tschema: TSchema;\n\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'sqlite'>;\n\t\tdialect: 'sqlite';\n\t}>(name, schema, baseName);\n\n\tconst parsedColumns: TColumnsMap = typeof columns === 'function' ? columns(getSQLiteColumnBuilders()) : columns;\n\n\tconst builtColumns = Object.fromEntries(\n\t\tObject.entries(parsedColumns).map(([name, colBuilderBase]) => {\n\t\t\tconst colBuilder = colBuilderBase as SQLiteColumnBuilder;\n\t\t\tcolBuilder.setName(name);\n\t\t\tconst column = colBuilder.build(rawTable);\n\t\t\trawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));\n\t\t\treturn [name, column];\n\t\t}),\n\t) as unknown as BuildColumns<TTableName, TColumnsMap, 'sqlite'>;\n\n\tconst table = Object.assign(rawTable, builtColumns);\n\n\ttable[Table.Symbol.Columns] = builtColumns;\n\ttable[Table.Symbol.ExtraConfigColumns] = builtColumns as unknown as BuildExtraConfigColumns<\n\t\tTTableName,\n\t\tTColumnsMap,\n\t\t'sqlite'\n\t>;\n\n\tif (extraConfig) {\n\t\ttable[SQLiteTable.Symbol.ExtraConfigBuilder] = extraConfig as (\n\t\t\tself: Record<string, SQLiteColumn>,\n\t\t) => SQLiteTableExtraConfig;\n\t}\n\n\treturn table;\n}\n\nexport const sqliteTable: SQLiteTableFn = (name, columns, extraConfig) => {\n\treturn sqliteTableBase(name, columns, extraConfig);\n};\n\nexport function sqliteTableCreator(customizeTableName: (name: string) => string): SQLiteTableFn {\n\treturn (name, columns, extraConfig) => {\n\t\treturn sqliteTableBase(customizeTableName(name) as typeof name, columns, extraConfig, undefined, name);\n\t};\n}\n", "import { blob } from './blob.ts';\nimport { customType } from './custom.ts';\nimport { integer } from './integer.ts';\nimport { numeric } from './numeric.ts';\nimport { real } from './real.ts';\nimport { text } from './text.ts';\n\nexport function getSQLiteColumnBuilders() {\n\treturn {\n\t\tblob,\n\t\tcustomType,\n\t\tinteger,\n\t\tnumeric,\n\t\treal,\n\t\ttext,\n\t};\n}\n\nexport type SQLiteColumnBuilders = ReturnType<typeof getSQLiteColumnBuilders>;\n", "import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnySQLiteTable } from '~/sqlite-core/table.ts';\nimport { type Equal, getColumnNameAndConfig } from '~/utils.ts';\nimport { SQLiteColumn, SQLiteColumnBuilder } from './common.ts';\n\ntype BlobMode = 'buffer' | 'json' | 'bigint';\n\nexport type SQLiteBigIntBuilderInitial<TName extends string> = SQLiteBigIntBuilder<{\n\tname: TName;\n\tdataType: 'bigint';\n\tcolumnType: 'SQLiteBigInt';\n\tdata: bigint;\n\tdriverParam: Buffer;\n\tenumValues: undefined;\n}>;\n\nexport class SQLiteBigIntBuilder<T extends ColumnBuilderBaseConfig<'bigint', 'SQLiteBigInt'>>\n\textends SQLiteColumnBuilder<T>\n{\n\tstatic override readonly [entityKind]: string = 'SQLiteBigIntBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'bigint', 'SQLiteBigInt');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnySQLiteTable<{ name: TTableName }>,\n\t): SQLiteBigInt<MakeColumnConfig<T, TTableName>> {\n\t\treturn new SQLiteBigInt<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any>);\n\t}\n}\n\nexport class SQLiteBigInt<T extends ColumnBaseConfig<'bigint', 'SQLiteBigInt'>> extends SQLiteColumn<T> {\n\tstatic override readonly [entityKind]: string = 'SQLiteBigInt';\n\n\tgetSQLType(): string {\n\t\treturn 'blob';\n\t}\n\n\toverride mapFromDriverValue(value: Buffer | Uint8Array | ArrayBuffer): bigint {\n\t\tif (Buffer.isBuffer(value)) {\n\t\t\treturn BigInt(value.toString());\n\t\t}\n\n\t\t// for sqlite durable objects\n\t\t// eslint-disable-next-line no-instanceof/no-instanceof\n\t\tif (value instanceof ArrayBuffer) {\n\t\t\tconst decoder = new TextDecoder();\n\t\t\treturn BigInt(decoder.decode(value));\n\t\t}\n\n\t\treturn BigInt(String.fromCodePoint(...value));\n\t}\n\n\toverride mapToDriverValue(value: bigint): Buffer {\n\t\treturn Buffer.from(value.toString());\n\t}\n}\n\nexport type SQLiteBlobJsonBuilderInitial<TName extends string> = SQLiteBlobJsonBuilder<{\n\tname: TName;\n\tdataType: 'json';\n\tcolumnType: 'SQLiteBlobJson';\n\tdata: unknown;\n\tdriverParam: Buffer;\n\tenumValues: undefined;\n}>;\n\nexport class SQLiteBlobJsonBuilder<T extends ColumnBuilderBaseConfig<'json', 'SQLiteBlobJson'>>\n\textends SQLiteColumnBuilder<T>\n{\n\tstatic override readonly [entityKind]: string = 'SQLiteBlobJsonBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'json', 'SQLiteBlobJson');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnySQLiteTable<{ name: TTableName }>,\n\t): SQLiteBlobJson<MakeColumnConfig<T, TTableName>> {\n\t\treturn new SQLiteBlobJson<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any>,\n\t\t);\n\t}\n}\n\nexport class SQLiteBlobJson<T extends ColumnBaseConfig<'json', 'SQLiteBlobJson'>> extends SQLiteColumn<T> {\n\tstatic override readonly [entityKind]: string = 'SQLiteBlobJson';\n\n\tgetSQLType(): string {\n\t\treturn 'blob';\n\t}\n\n\toverride mapFromDriverValue(value: Buffer | Uint8Array | ArrayBuffer): T['data'] {\n\t\tif (Buffer.isBuffer(value)) {\n\t\t\treturn JSON.parse(value.toString());\n\t\t}\n\n\t\t// for sqlite durable objects\n\t\t// eslint-disable-next-line no-instanceof/no-instanceof\n\t\tif (value instanceof ArrayBuffer) {\n\t\t\tconst decoder = new TextDecoder();\n\t\t\treturn JSON.parse(decoder.decode(value));\n\t\t}\n\n\t\treturn JSON.parse(String.fromCodePoint(...value));\n\t}\n\n\toverride mapToDriverValue(value: T['data']): Buffer {\n\t\treturn Buffer.from(JSON.stringify(value));\n\t}\n}\n\nexport type SQLiteBlobBufferBuilderInitial<TName extends string> = SQLiteBlobBufferBuilder<{\n\tname: TName;\n\tdataType: 'buffer';\n\tcolumnType: 'SQLiteBlobBuffer';\n\tdata: Buffer;\n\tdriverParam: Buffer;\n\tenumValues: undefined;\n}>;\n\nexport class SQLiteBlobBufferBuilder<T extends ColumnBuilderBaseConfig<'buffer', 'SQLiteBlobBuffer'>>\n\textends SQLiteColumnBuilder<T>\n{\n\tstatic override readonly [entityKind]: string = 'SQLiteBlobBufferBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'buffer', 'SQLiteBlobBuffer');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnySQLiteTable<{ name: TTableName }>,\n\t): SQLiteBlobBuffer<MakeColumnConfig<T, TTableName>> {\n\t\treturn new SQLiteBlobBuffer<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any>);\n\t}\n}\n\nexport class SQLiteBlobBuffer<T extends ColumnBaseConfig<'buffer', 'SQLiteBlobBuffer'>> extends SQLiteColumn<T> {\n\tstatic override readonly [entityKind]: string = 'SQLiteBlobBuffer';\n\n\tgetSQLType(): string {\n\t\treturn 'blob';\n\t}\n}\n\nexport interface BlobConfig<TMode extends BlobMode = BlobMode> {\n\tmode: TMode;\n}\n\n/**\n *  It's recommended to use `text('...', { mode: 'json' })` instead of `blob` in JSON mode, because it supports JSON functions:\n * >All JSON functions currently throw an error if any of their arguments are BLOBs because BLOBs are reserved for a future enhancement in which BLOBs will store the binary encoding for JSON.\n *\n * https://www.sqlite.org/json1.html\n */\nexport function blob(): SQLiteBlobJsonBuilderInitial<''>;\nexport function blob<TMode extends BlobMode = BlobMode>(\n\tconfig?: BlobConfig<TMode>,\n): Equal<TMode, 'bigint'> extends true ? SQLiteBigIntBuilderInitial<''>\n\t: Equal<TMode, 'buffer'> extends true ? SQLiteBlobBufferBuilderInitial<''>\n\t: SQLiteBlobJsonBuilderInitial<''>;\nexport function blob<TName extends string, TMode extends BlobMode = BlobMode>(\n\tname: TName,\n\tconfig?: BlobConfig<TMode>,\n): Equal<TMode, 'bigint'> extends true ? SQLiteBigIntBuilderInitial<TName>\n\t: Equal<TMode, 'buffer'> extends true ? SQLiteBlobBufferBuilderInitial<TName>\n\t: SQLiteBlobJsonBuilderInitial<TName>;\nexport function blob(a?: string | BlobConfig, b?: BlobConfig) {\n\tconst { name, config } = getColumnNameAndConfig<BlobConfig | undefined>(a, b);\n\tif (config?.mode === 'json') {\n\t\treturn new SQLiteBlobJsonBuilder(name);\n\t}\n\tif (config?.mode === 'bigint') {\n\t\treturn new SQLiteBigIntBuilder(name);\n\t}\n\treturn new SQLiteBlobBufferBuilder(name);\n}\n", "import type {\n\tColumnBuilderBase,\n\tColumnBuilderBaseConfig,\n\tColumnBuilderExtraConfig,\n\tColumnBuilderRuntimeConfig,\n\tColumnDataType,\n\tHasGenerated,\n\tMakeColumnConfig,\n} from '~/column-builder.ts';\nimport { ColumnBuilder } from '~/column-builder.ts';\nimport { Column } from '~/column.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { SQL } from '~/sql/sql.ts';\nimport type { ForeignKey, UpdateDeleteAction } from '~/sqlite-core/foreign-keys.ts';\nimport { ForeignKeyBuilder } from '~/sqlite-core/foreign-keys.ts';\nimport type { AnySQLiteTable, SQLiteTable } from '~/sqlite-core/table.ts';\nimport type { Update } from '~/utils.ts';\nimport { uniqueKeyName } from '../unique-constraint.ts';\n\nexport interface ReferenceConfig {\n\tref: () => SQLiteColumn;\n\tactions: {\n\t\tonUpdate?: UpdateDeleteAction;\n\t\tonDelete?: UpdateDeleteAction;\n\t};\n}\n\nexport interface SQLiteColumnBuilderBase<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTypeConfig extends object = object,\n> extends ColumnBuilderBase<T, TTypeConfig & { dialect: 'sqlite' }> {}\n\nexport interface SQLiteGeneratedColumnConfig {\n\tmode?: 'virtual' | 'stored';\n}\n\nexport abstract class SQLiteColumnBuilder<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n\tTTypeConfig extends object = object,\n\tTExtraConfig extends ColumnBuilderExtraConfig = object,\n> extends ColumnBuilder<T, TRuntimeConfig, TTypeConfig & { dialect: 'sqlite' }, TExtraConfig>\n\timplements SQLiteColumnBuilderBase<T, TTypeConfig>\n{\n\tstatic override readonly [entityKind]: string = 'SQLiteColumnBuilder';\n\n\tprivate foreignKeyConfigs: ReferenceConfig[] = [];\n\n\treferences(\n\t\tref: ReferenceConfig['ref'],\n\t\tactions: ReferenceConfig['actions'] = {},\n\t): this {\n\t\tthis.foreignKeyConfigs.push({ ref, actions });\n\t\treturn this;\n\t}\n\n\tunique(\n\t\tname?: string,\n\t): this {\n\t\tthis.config.isUnique = true;\n\t\tthis.config.uniqueName = name;\n\t\treturn this;\n\t}\n\n\tgeneratedAlwaysAs(as: SQL | T['data'] | (() => SQL), config?: SQLiteGeneratedColumnConfig): HasGenerated<this, {\n\t\ttype: 'always';\n\t}> {\n\t\tthis.config.generated = {\n\t\t\tas,\n\t\t\ttype: 'always',\n\t\t\tmode: config?.mode ?? 'virtual',\n\t\t};\n\t\treturn this as any;\n\t}\n\n\t/** @internal */\n\tbuildForeignKeys(column: SQLiteColumn, table: SQLiteTable): ForeignKey[] {\n\t\treturn this.foreignKeyConfigs.map(({ ref, actions }) => {\n\t\t\treturn ((ref, actions) => {\n\t\t\t\tconst builder = new ForeignKeyBuilder(() => {\n\t\t\t\t\tconst foreignColumn = ref();\n\t\t\t\t\treturn { columns: [column], foreignColumns: [foreignColumn] };\n\t\t\t\t});\n\t\t\t\tif (actions.onUpdate) {\n\t\t\t\t\tbuilder.onUpdate(actions.onUpdate);\n\t\t\t\t}\n\t\t\t\tif (actions.onDelete) {\n\t\t\t\t\tbuilder.onDelete(actions.onDelete);\n\t\t\t\t}\n\t\t\t\treturn builder.build(table);\n\t\t\t})(ref, actions);\n\t\t});\n\t}\n\n\t/** @internal */\n\tabstract build<TTableName extends string>(\n\t\ttable: AnySQLiteTable<{ name: TTableName }>,\n\t): SQLiteColumn<MakeColumnConfig<T, TTableName>>;\n}\n\n// To understand how to use `SQLiteColumn` and `AnySQLiteColumn`, see `Column` and `AnyColumn` documentation.\nexport abstract class SQLiteColumn<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = {},\n\tTTypeConfig extends object = {},\n> extends Column<T, TRuntimeConfig, TTypeConfig & { dialect: 'sqlite' }> {\n\tstatic override readonly [entityKind]: string = 'SQLiteColumn';\n\n\tconstructor(\n\t\toverride readonly table: SQLiteTable,\n\t\tconfig: ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>,\n\t) {\n\t\tif (!config.uniqueName) {\n\t\t\tconfig.uniqueName = uniqueKeyName(table, [config.name]);\n\t\t}\n\t\tsuper(table, config);\n\t}\n}\n\nexport type AnySQLiteColumn<TPartial extends Partial<ColumnBaseConfig<ColumnDataType, string>> = {}> = SQLiteColumn<\n\tRequired<Update<ColumnBaseConfig<ColumnDataType, string>, TPartial>>\n>;\n", "import { entityKind } from '~/entity.ts';\nimport { TableName } from '~/table.utils.ts';\nimport type { AnySQLiteColumn, SQLiteColumn } from './columns/index.ts';\nimport type { SQLiteTable } from './table.ts';\n\nexport type UpdateDeleteAction = 'cascade' | 'restrict' | 'no action' | 'set null' | 'set default';\n\nexport type Reference = () => {\n\treadonly name?: string;\n\treadonly columns: SQLiteColumn[];\n\treadonly foreignTable: SQLiteTable;\n\treadonly foreignColumns: SQLiteColumn[];\n};\n\nexport class ForeignKeyBuilder {\n\tstatic readonly [entityKind]: string = 'SQLiteForeignKeyBuilder';\n\n\tdeclare _: {\n\t\tbrand: 'SQLiteForeignKeyBuilder';\n\t\tforeignTableName: 'TForeignTableName';\n\t};\n\n\t/** @internal */\n\treference: Reference;\n\n\t/** @internal */\n\t_onUpdate: UpdateDeleteAction | undefined;\n\n\t/** @internal */\n\t_onDelete: UpdateDeleteAction | undefined;\n\n\tconstructor(\n\t\tconfig: () => {\n\t\t\tname?: string;\n\t\t\tcolumns: SQLiteColumn[];\n\t\t\tforeignColumns: SQLiteColumn[];\n\t\t},\n\t\tactions?: {\n\t\t\tonUpdate?: UpdateDeleteAction;\n\t\t\tonDelete?: UpdateDeleteAction;\n\t\t} | undefined,\n\t) {\n\t\tthis.reference = () => {\n\t\t\tconst { name, columns, foreignColumns } = config();\n\t\t\treturn { name, columns, foreignTable: foreignColumns[0]!.table as SQLiteTable, foreignColumns };\n\t\t};\n\t\tif (actions) {\n\t\t\tthis._onUpdate = actions.onUpdate;\n\t\t\tthis._onDelete = actions.onDelete;\n\t\t}\n\t}\n\n\tonUpdate(action: UpdateDeleteAction): this {\n\t\tthis._onUpdate = action;\n\t\treturn this;\n\t}\n\n\tonDelete(action: UpdateDeleteAction): this {\n\t\tthis._onDelete = action;\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tbuild(table: SQLiteTable): ForeignKey {\n\t\treturn new ForeignKey(table, this);\n\t}\n}\n\nexport class ForeignKey {\n\tstatic readonly [entityKind]: string = 'SQLiteForeignKey';\n\n\treadonly reference: Reference;\n\treadonly onUpdate: UpdateDeleteAction | undefined;\n\treadonly onDelete: UpdateDeleteAction | undefined;\n\n\tconstructor(readonly table: SQLiteTable, builder: ForeignKeyBuilder) {\n\t\tthis.reference = builder.reference;\n\t\tthis.onUpdate = builder._onUpdate;\n\t\tthis.onDelete = builder._onDelete;\n\t}\n\n\tgetName(): string {\n\t\tconst { name, columns, foreignColumns } = this.reference();\n\t\tconst columnNames = columns.map((column) => column.name);\n\t\tconst foreignColumnNames = foreignColumns.map((column) => column.name);\n\t\tconst chunks = [\n\t\t\tthis.table[TableName],\n\t\t\t...columnNames,\n\t\t\tforeignColumns[0]!.table[TableName],\n\t\t\t...foreignColumnNames,\n\t\t];\n\t\treturn name ?? `${chunks.join('_')}_fk`;\n\t}\n}\n\ntype ColumnsWithTable<\n\tTTableName extends string,\n\tTColumns extends SQLiteColumn[],\n> = { [Key in keyof TColumns]: AnySQLiteColumn<{ tableName: TTableName }> };\n\n/**\n * @deprecated please use `foreignKey({ columns: [], foreignColumns: [] })` syntax without callback\n * @param config\n * @returns\n */\nexport function foreignKey<\n\tTTableName extends string,\n\tTForeignTableName extends string,\n\tTColumns extends [AnySQLiteColumn<{ tableName: TTableName }>, ...AnySQLiteColumn<{ tableName: TTableName }>[]],\n>(\n\tconfig: () => {\n\t\tname?: string;\n\t\tcolumns: TColumns;\n\t\tforeignColumns: ColumnsWithTable<TForeignTableName, TColumns>;\n\t},\n): ForeignKeyBuilder;\nexport function foreignKey<\n\tTTableName extends string,\n\tTForeignTableName extends string,\n\tTColumns extends [AnySQLiteColumn<{ tableName: TTableName }>, ...AnySQLiteColumn<{ tableName: TTableName }>[]],\n>(\n\tconfig: {\n\t\tname?: string;\n\t\tcolumns: TColumns;\n\t\tforeignColumns: ColumnsWithTable<TForeignTableName, TColumns>;\n\t},\n): ForeignKeyBuilder;\nexport function foreignKey(\n\tconfig: any,\n): ForeignKeyBuilder {\n\tfunction mappedConfig() {\n\t\tif (typeof config === 'function') {\n\t\t\tconst { name, columns, foreignColumns } = config();\n\t\t\treturn {\n\t\t\t\tname,\n\t\t\t\tcolumns,\n\t\t\t\tforeignColumns,\n\t\t\t};\n\t\t}\n\t\treturn config;\n\t}\n\n\treturn new ForeignKeyBuilder(mappedConfig);\n}\n", "import { entityKind } from '~/entity.ts';\nimport { TableName } from '~/table.utils.ts';\nimport type { SQLiteColumn } from './columns/common.ts';\nimport type { SQLiteTable } from './table.ts';\n\nexport function uniqueKeyName(table: SQLiteTable, columns: string[]) {\n\treturn `${table[TableName]}_${columns.join('_')}_unique`;\n}\n\nexport function unique(name?: string): UniqueOnConstraintBuilder {\n\treturn new UniqueOnConstraintBuilder(name);\n}\n\nexport class UniqueConstraintBuilder {\n\tstatic readonly [entityKind]: string = 'SQLiteUniqueConstraintBuilder';\n\n\t/** @internal */\n\tcolumns: SQLiteColumn[];\n\n\tconstructor(\n\t\tcolumns: SQLiteColumn[],\n\t\tprivate name?: string,\n\t) {\n\t\tthis.columns = columns;\n\t}\n\n\t/** @internal */\n\tbuild(table: SQLiteTable): UniqueConstraint {\n\t\treturn new UniqueConstraint(table, this.columns, this.name);\n\t}\n}\n\nexport class UniqueOnConstraintBuilder {\n\tstatic readonly [entityKind]: string = 'SQLiteUniqueOnConstraintBuilder';\n\n\t/** @internal */\n\tname?: string;\n\n\tconstructor(\n\t\tname?: string,\n\t) {\n\t\tthis.name = name;\n\t}\n\n\ton(...columns: [SQLiteColumn, ...SQLiteColumn[]]) {\n\t\treturn new UniqueConstraintBuilder(columns, this.name);\n\t}\n}\n\nexport class UniqueConstraint {\n\tstatic readonly [entityKind]: string = 'SQLiteUniqueConstraint';\n\n\treadonly columns: SQLiteColumn[];\n\treadonly name?: string;\n\n\tconstructor(readonly table: SQLiteTable, columns: SQLiteColumn[], name?: string) {\n\t\tthis.columns = columns;\n\t\tthis.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));\n\t}\n\n\tgetName() {\n\t\treturn this.name;\n\t}\n}\n", "import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { SQL } from '~/sql/sql.ts';\nimport type { AnySQLiteTable } from '~/sqlite-core/table.ts';\nimport { type Equal, getColumnNameAndConfig } from '~/utils.ts';\nimport { SQLiteColumn, SQLiteColumnBuilder } from './common.ts';\n\nexport type ConvertCustomConfig<TName extends string, T extends Partial<CustomTypeValues>> =\n\t& {\n\t\tname: TName;\n\t\tdataType: 'custom';\n\t\tcolumnType: 'SQLiteCustomColumn';\n\t\tdata: T['data'];\n\t\tdriverParam: T['driverData'];\n\t\tenumValues: undefined;\n\t}\n\t& (T['notNull'] extends true ? { notNull: true } : {})\n\t& (T['default'] extends true ? { hasDefault: true } : {});\n\nexport interface SQLiteCustomColumnInnerConfig {\n\tcustomTypeValues: CustomTypeValues;\n}\n\nexport class SQLiteCustomColumnBuilder<T extends ColumnBuilderBaseConfig<'custom', 'SQLiteCustomColumn'>>\n\textends SQLiteColumnBuilder<\n\t\tT,\n\t\t{\n\t\t\tfieldConfig: CustomTypeValues['config'];\n\t\t\tcustomTypeParams: CustomTypeParams<any>;\n\t\t},\n\t\t{\n\t\t\tsqliteColumnBuilderBrand: 'SQLiteCustomColumnBuilderBrand';\n\t\t}\n\t>\n{\n\tstatic override readonly [entityKind]: string = 'SQLiteCustomColumnBuilder';\n\n\tconstructor(\n\t\tname: T['name'],\n\t\tfieldConfig: CustomTypeValues['config'],\n\t\tcustomTypeParams: CustomTypeParams<any>,\n\t) {\n\t\tsuper(name, 'custom', 'SQLiteCustomColumn');\n\t\tthis.config.fieldConfig = fieldConfig;\n\t\tthis.config.customTypeParams = customTypeParams;\n\t}\n\n\t/** @internal */\n\tbuild<TTableName extends string>(\n\t\ttable: AnySQLiteTable<{ name: TTableName }>,\n\t): SQLiteCustomColumn<MakeColumnConfig<T, TTableName>> {\n\t\treturn new SQLiteCustomColumn<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class SQLiteCustomColumn<T extends ColumnBaseConfig<'custom', 'SQLiteCustomColumn'>> extends SQLiteColumn<T> {\n\tstatic override readonly [entityKind]: string = 'SQLiteCustomColumn';\n\n\tprivate sqlName: string;\n\tprivate mapTo?: (value: T['data']) => T['driverParam'];\n\tprivate mapFrom?: (value: T['driverParam']) => T['data'];\n\n\tconstructor(\n\t\ttable: AnySQLiteTable<{ name: T['tableName'] }>,\n\t\tconfig: SQLiteCustomColumnBuilder<T>['config'],\n\t) {\n\t\tsuper(table, config);\n\t\tthis.sqlName = config.customTypeParams.dataType(config.fieldConfig);\n\t\tthis.mapTo = config.customTypeParams.toDriver;\n\t\tthis.mapFrom = config.customTypeParams.fromDriver;\n\t}\n\n\tgetSQLType(): string {\n\t\treturn this.sqlName;\n\t}\n\n\toverride mapFromDriverValue(value: T['driverParam']): T['data'] {\n\t\treturn typeof this.mapFrom === 'function' ? this.mapFrom(value) : value as T['data'];\n\t}\n\n\toverride mapToDriverValue(value: T['data']): T['driverParam'] {\n\t\treturn typeof this.mapTo === 'function' ? this.mapTo(value) : value as T['data'];\n\t}\n}\n\nexport type CustomTypeValues = {\n\t/**\n\t * Required type for custom column, that will infer proper type model\n\t *\n\t * Examples:\n\t *\n\t * If you want your column to be `string` type after selecting/or on inserting - use `data: string`. Like `text`, `varchar`\n\t *\n\t * If you want your column to be `number` type after selecting/or on inserting - use `data: number`. Like `integer`\n\t */\n\tdata: unknown;\n\n\t/**\n\t * Type helper, that represents what type database driver is accepting for specific database data type\n\t */\n\tdriverData?: unknown;\n\n\t/**\n\t * What config type should be used for {@link CustomTypeParams} `dataType` generation\n\t */\n\tconfig?: Record<string, any>;\n\n\t/**\n\t * Whether the config argument should be required or not\n\t * @default false\n\t */\n\tconfigRequired?: boolean;\n\n\t/**\n\t * If your custom data type should be notNull by default you can use `notNull: true`\n\t *\n\t * @example\n\t * const customSerial = customType<{ data: number, notNull: true, default: true }>({\n\t * \t  dataType() {\n\t * \t    return 'serial';\n\t *    },\n\t * });\n\t */\n\tnotNull?: boolean;\n\n\t/**\n\t * If your custom data type has default you can use `default: true`\n\t *\n\t * @example\n\t * const customSerial = customType<{ data: number, notNull: true, default: true }>({\n\t * \t  dataType() {\n\t * \t    return 'serial';\n\t *    },\n\t * });\n\t */\n\tdefault?: boolean;\n};\n\nexport interface CustomTypeParams<T extends CustomTypeValues> {\n\t/**\n\t * Database data type string representation, that is used for migrations\n\t * @example\n\t * ```\n\t * `jsonb`, `text`\n\t * ```\n\t *\n\t * If database data type needs additional params you can use them from `config` param\n\t * @example\n\t * ```\n\t * `varchar(256)`, `numeric(2,3)`\n\t * ```\n\t *\n\t * To make `config` be of specific type please use config generic in {@link CustomTypeValues}\n\t *\n\t * @example\n\t * Usage example\n\t * ```\n\t *   dataType() {\n\t *     return 'boolean';\n\t *   },\n\t * ```\n\t * Or\n\t * ```\n\t *   dataType(config) {\n\t * \t   return typeof config.length !== 'undefined' ? `varchar(${config.length})` : `varchar`;\n\t * \t }\n\t * ```\n\t */\n\tdataType: (config: T['config'] | (Equal<T['configRequired'], true> extends true ? never : undefined)) => string;\n\n\t/**\n\t * Optional mapping function, between user input and driver\n\t * @example\n\t * For example, when using jsonb we need to map JS/TS object to string before writing to database\n\t * ```\n\t * toDriver(value: TData): string {\n\t * \t return JSON.stringify(value);\n\t * }\n\t * ```\n\t */\n\ttoDriver?: (value: T['data']) => T['driverData'] | SQL;\n\n\t/**\n\t * Optional mapping function, that is responsible for data mapping from database to JS/TS code\n\t * @example\n\t * For example, when using timestamp we need to map string Date representation to JS Date\n\t * ```\n\t * fromDriver(value: string): Date {\n\t * \treturn new Date(value);\n\t * },\n\t * ```\n\t */\n\tfromDriver?: (value: T['driverData']) => T['data'];\n}\n\n/**\n * Custom sqlite database data type generator\n */\nexport function customType<T extends CustomTypeValues = CustomTypeValues>(\n\tcustomTypeParams: CustomTypeParams<T>,\n): Equal<T['configRequired'], true> extends true ? {\n\t\t<TConfig extends Record<string, any> & T['config']>(\n\t\t\tfieldConfig: TConfig,\n\t\t): SQLiteCustomColumnBuilder<ConvertCustomConfig<'', T>>;\n\t\t<TName extends string>(\n\t\t\tdbName: TName,\n\t\t\tfieldConfig: T['config'],\n\t\t): SQLiteCustomColumnBuilder<ConvertCustomConfig<TName, T>>;\n\t}\n\t: {\n\t\t(): SQLiteCustomColumnBuilder<ConvertCustomConfig<'', T>>;\n\t\t<TConfig extends Record<string, any> & T['config']>(\n\t\t\tfieldConfig?: TConfig,\n\t\t): SQLiteCustomColumnBuilder<ConvertCustomConfig<'', T>>;\n\t\t<TName extends string>(\n\t\t\tdbName: TName,\n\t\t\tfieldConfig?: T['config'],\n\t\t): SQLiteCustomColumnBuilder<ConvertCustomConfig<TName, T>>;\n\t}\n{\n\treturn <TName extends string>(\n\t\ta?: TName | T['config'],\n\t\tb?: T['config'],\n\t): SQLiteCustomColumnBuilder<ConvertCustomConfig<TName, T>> => {\n\t\tconst { name, config } = getColumnNameAndConfig<T['config']>(a, b);\n\t\treturn new SQLiteCustomColumnBuilder(\n\t\t\tname as ConvertCustomConfig<TName, T>['name'],\n\t\t\tconfig,\n\t\t\tcustomTypeParams,\n\t\t);\n\t};\n}\n", "import type {\n\tColumnBuilderBaseConfig,\n\tColumnBuilderRuntimeConfig,\n\tColumnDataType,\n\tHasDefault,\n\tIsPrimaryKey,\n\tMakeColumnConfig,\n\tNotNull,\n} from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport { sql } from '~/sql/sql.ts';\nimport type { OnConflict } from '~/sqlite-core/utils.ts';\nimport { type Equal, getColumnNameAndConfig, type Or } from '~/utils.ts';\nimport type { AnySQLiteTable } from '../table.ts';\nimport { SQLiteColumn, SQLiteColumnBuilder } from './common.ts';\n\nexport interface PrimaryKeyConfig {\n\tautoIncrement?: boolean;\n\tonConflict?: OnConflict;\n}\n\nexport abstract class SQLiteBaseIntegerBuilder<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n> extends SQLiteColumnBuilder<\n\tT,\n\tTRuntimeConfig & { autoIncrement: boolean },\n\t{},\n\t{ primaryKeyHasDefault: true }\n> {\n\tstatic override readonly [entityKind]: string = 'SQLiteBaseIntegerBuilder';\n\n\tconstructor(name: T['name'], dataType: T['dataType'], columnType: T['columnType']) {\n\t\tsuper(name, dataType, columnType);\n\t\tthis.config.autoIncrement = false;\n\t}\n\n\toverride primaryKey(config?: PrimaryKeyConfig): IsPrimaryKey<HasDefault<NotNull<this>>> {\n\t\tif (config?.autoIncrement) {\n\t\t\tthis.config.autoIncrement = true;\n\t\t}\n\t\tthis.config.hasDefault = true;\n\t\treturn super.primaryKey() as IsPrimaryKey<HasDefault<NotNull<this>>>;\n\t}\n\n\t/** @internal */\n\tabstract override build<TTableName extends string>(\n\t\ttable: AnySQLiteTable<{ name: TTableName }>,\n\t): SQLiteBaseInteger<MakeColumnConfig<T, TTableName>>;\n}\n\nexport abstract class SQLiteBaseInteger<\n\tT extends ColumnBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n> extends SQLiteColumn<T, TRuntimeConfig & { autoIncrement: boolean }> {\n\tstatic override readonly [entityKind]: string = 'SQLiteBaseInteger';\n\n\treadonly autoIncrement: boolean = this.config.autoIncrement;\n\n\tgetSQLType(): string {\n\t\treturn 'integer';\n\t}\n}\n\nexport type SQLiteIntegerBuilderInitial<TName extends string> = SQLiteIntegerBuilder<{\n\tname: TName;\n\tdataType: 'number';\n\tcolumnType: 'SQLiteInteger';\n\tdata: number;\n\tdriverParam: number;\n\tenumValues: undefined;\n}>;\n\nexport class SQLiteIntegerBuilder<T extends ColumnBuilderBaseConfig<'number', 'SQLiteInteger'>>\n\textends SQLiteBaseIntegerBuilder<T>\n{\n\tstatic override readonly [entityKind]: string = 'SQLiteIntegerBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'number', 'SQLiteInteger');\n\t}\n\n\tbuild<TTableName extends string>(\n\t\ttable: AnySQLiteTable<{ name: TTableName }>,\n\t): SQLiteInteger<MakeColumnConfig<T, TTableName>> {\n\t\treturn new SQLiteInteger<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class SQLiteInteger<T extends ColumnBaseConfig<'number', 'SQLiteInteger'>> extends SQLiteBaseInteger<T> {\n\tstatic override readonly [entityKind]: string = 'SQLiteInteger';\n}\n\nexport type SQLiteTimestampBuilderInitial<TName extends string> = SQLiteTimestampBuilder<{\n\tname: TName;\n\tdataType: 'date';\n\tcolumnType: 'SQLiteTimestamp';\n\tdata: Date;\n\tdriverParam: number;\n\tenumValues: undefined;\n}>;\n\nexport class SQLiteTimestampBuilder<T extends ColumnBuilderBaseConfig<'date', 'SQLiteTimestamp'>>\n\textends SQLiteBaseIntegerBuilder<T, { mode: 'timestamp' | 'timestamp_ms' }>\n{\n\tstatic override readonly [entityKind]: string = 'SQLiteTimestampBuilder';\n\n\tconstructor(name: T['name'], mode: 'timestamp' | 'timestamp_ms') {\n\t\tsuper(name, 'date', 'SQLiteTimestamp');\n\t\tthis.config.mode = mode;\n\t}\n\n\t/**\n\t * @deprecated Use `default()` with your own expression instead.\n\t *\n\t * Adds `DEFAULT (cast((julianday('now') - 2440587.5)*86400000 as integer))` to the column, which is the current epoch timestamp in milliseconds.\n\t */\n\tdefaultNow(): HasDefault<this> {\n\t\treturn this.default(sql`(cast((julianday('now') - 2440587.5)*86400000 as integer))`) as any;\n\t}\n\n\tbuild<TTableName extends string>(\n\t\ttable: AnySQLiteTable<{ name: TTableName }>,\n\t): SQLiteTimestamp<MakeColumnConfig<T, TTableName>> {\n\t\treturn new SQLiteTimestamp<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class SQLiteTimestamp<T extends ColumnBaseConfig<'date', 'SQLiteTimestamp'>>\n\textends SQLiteBaseInteger<T, { mode: 'timestamp' | 'timestamp_ms' }>\n{\n\tstatic override readonly [entityKind]: string = 'SQLiteTimestamp';\n\n\treadonly mode: 'timestamp' | 'timestamp_ms' = this.config.mode;\n\n\toverride mapFromDriverValue(value: number): Date {\n\t\tif (this.config.mode === 'timestamp') {\n\t\t\treturn new Date(value * 1000);\n\t\t}\n\t\treturn new Date(value);\n\t}\n\n\toverride mapToDriverValue(value: Date): number {\n\t\tconst unix = value.getTime();\n\t\tif (this.config.mode === 'timestamp') {\n\t\t\treturn Math.floor(unix / 1000);\n\t\t}\n\t\treturn unix;\n\t}\n}\n\nexport type SQLiteBooleanBuilderInitial<TName extends string> = SQLiteBooleanBuilder<{\n\tname: TName;\n\tdataType: 'boolean';\n\tcolumnType: 'SQLiteBoolean';\n\tdata: boolean;\n\tdriverParam: number;\n\tenumValues: undefined;\n}>;\n\nexport class SQLiteBooleanBuilder<T extends ColumnBuilderBaseConfig<'boolean', 'SQLiteBoolean'>>\n\textends SQLiteBaseIntegerBuilder<T, { mode: 'boolean' }>\n{\n\tstatic override readonly [entityKind]: string = 'SQLiteBooleanBuilder';\n\n\tconstructor(name: T['name'], mode: 'boolean') {\n\t\tsuper(name, 'boolean', 'SQLiteBoolean');\n\t\tthis.config.mode = mode;\n\t}\n\n\tbuild<TTableName extends string>(\n\t\ttable: AnySQLiteTable<{ name: TTableName }>,\n\t): SQLiteBoolean<MakeColumnConfig<T, TTableName>> {\n\t\treturn new SQLiteBoolean<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class SQLiteBoolean<T extends ColumnBaseConfig<'boolean', 'SQLiteBoolean'>>\n\textends SQLiteBaseInteger<T, { mode: 'boolean' }>\n{\n\tstatic override readonly [entityKind]: string = 'SQLiteBoolean';\n\n\treadonly mode: 'boolean' = this.config.mode;\n\n\toverride mapFromDriverValue(value: number): boolean {\n\t\treturn Number(value) === 1;\n\t}\n\n\toverride mapToDriverValue(value: boolean): number {\n\t\treturn value ? 1 : 0;\n\t}\n}\n\nexport interface IntegerConfig<\n\tTMode extends 'number' | 'timestamp' | 'timestamp_ms' | 'boolean' =\n\t\t| 'number'\n\t\t| 'timestamp'\n\t\t| 'timestamp_ms'\n\t\t| 'boolean',\n> {\n\tmode: TMode;\n}\n\nexport function integer(): SQLiteIntegerBuilderInitial<''>;\nexport function integer<TMode extends IntegerConfig['mode']>(\n\tconfig?: IntegerConfig<TMode>,\n): Or<Equal<TMode, 'timestamp'>, Equal<TMode, 'timestamp_ms'>> extends true ? SQLiteTimestampBuilderInitial<''>\n\t: Equal<TMode, 'boolean'> extends true ? SQLiteBooleanBuilderInitial<''>\n\t: SQLiteIntegerBuilderInitial<''>;\nexport function integer<TName extends string, TMode extends IntegerConfig['mode']>(\n\tname: TName,\n\tconfig?: IntegerConfig<TMode>,\n): Or<Equal<TMode, 'timestamp'>, Equal<TMode, 'timestamp_ms'>> extends true ? SQLiteTimestampBuilderInitial<TName>\n\t: Equal<TMode, 'boolean'> extends true ? SQLiteBooleanBuilderInitial<TName>\n\t: SQLiteIntegerBuilderInitial<TName>;\nexport function integer(a?: string | IntegerConfig, b?: IntegerConfig) {\n\tconst { name, config } = getColumnNameAndConfig<IntegerConfig | undefined>(a, b);\n\tif (config?.mode === 'timestamp' || config?.mode === 'timestamp_ms') {\n\t\treturn new SQLiteTimestampBuilder(name, config.mode);\n\t}\n\tif (config?.mode === 'boolean') {\n\t\treturn new SQLiteBooleanBuilder(name, config.mode);\n\t}\n\treturn new SQLiteIntegerBuilder(name);\n}\n\nexport const int = integer;\n", "import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnySQLiteTable } from '~/sqlite-core/table.ts';\nimport { SQLiteColumn, SQLiteColumnBuilder } from './common.ts';\n\nexport type SQLiteNumericBuilderInitial<TName extends string> = SQLiteNumericBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'SQLiteNumeric';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class SQLiteNumericBuilder<T extends ColumnBuilderBaseConfig<'string', 'SQLiteNumeric'>>\n\textends SQLiteColumnBuilder<T>\n{\n\tstatic override readonly [entityKind]: string = 'SQLiteNumericBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'string', 'SQLiteNumeric');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnySQLiteTable<{ name: TTableName }>,\n\t): SQLiteNumeric<MakeColumnConfig<T, TTableName>> {\n\t\treturn new SQLiteNumeric<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class SQLiteNumeric<T extends ColumnBaseConfig<'string', 'SQLiteNumeric'>> extends SQLiteColumn<T> {\n\tstatic override readonly [entityKind]: string = 'SQLiteNumeric';\n\n\tgetSQLType(): string {\n\t\treturn 'numeric';\n\t}\n}\n\nexport function numeric(): SQLiteNumericBuilderInitial<''>;\nexport function numeric<TName extends string>(name: TName): SQLiteNumericBuilderInitial<TName>;\nexport function numeric(name?: string) {\n\treturn new SQLiteNumericBuilder(name ?? '');\n}\n", "import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnySQLiteTable } from '../table.ts';\nimport { SQLiteColumn, SQLiteColumnBuilder } from './common.ts';\n\nexport type SQLiteRealBuilderInitial<TName extends string> = SQLiteRealBuilder<{\n\tname: TName;\n\tdataType: 'number';\n\tcolumnType: 'SQLiteReal';\n\tdata: number;\n\tdriverParam: number;\n\tenumValues: undefined;\n}>;\n\nexport class SQLiteRealBuilder<T extends ColumnBuilderBaseConfig<'number', 'SQLiteReal'>>\n\textends SQLiteColumnBuilder<T>\n{\n\tstatic override readonly [entityKind]: string = 'SQLiteRealBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'number', 'SQLiteReal');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnySQLiteTable<{ name: TTableName }>,\n\t): SQLiteReal<MakeColumnConfig<T, TTableName>> {\n\t\treturn new SQLiteReal<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class SQLiteReal<T extends ColumnBaseConfig<'number', 'SQLiteReal'>> extends SQLiteColumn<T> {\n\tstatic override readonly [entityKind]: string = 'SQLiteReal';\n\n\tgetSQLType(): string {\n\t\treturn 'real';\n\t}\n}\n\nexport function real(): SQLiteRealBuilderInitial<''>;\nexport function real<TName extends string>(name: TName): SQLiteRealBuilderInitial<TName>;\nexport function real(name?: string) {\n\treturn new SQLiteRealBuilder(name ?? '');\n}\n", "import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnySQLiteTable } from '~/sqlite-core/table.ts';\nimport { type Equal, getColumnNameAndConfig, type Writable } from '~/utils.ts';\nimport { SQLiteColumn, SQLiteColumnBuilder } from './common.ts';\n\nexport type SQLiteTextBuilderInitial<\n\tTName extends string,\n\tTEnum extends [string, ...string[]],\n\tTLength extends number | undefined,\n> = SQLiteTextBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'SQLiteText';\n\tdata: TEnum[number];\n\tdriverParam: string;\n\tenumValues: TEnum;\n\tlength: TLength;\n}>;\n\nexport class SQLiteTextBuilder<\n\tT extends ColumnBuilderBaseConfig<'string', 'SQLiteText'> & { length?: number | undefined },\n> extends SQLiteColumnBuilder<\n\tT,\n\t{ length: T['length']; enumValues: T['enumValues'] },\n\t{ length: T['length'] }\n> {\n\tstatic override readonly [entityKind]: string = 'SQLiteTextBuilder';\n\n\tconstructor(name: T['name'], config: SQLiteTextConfig<'text', T['enumValues'], T['length']>) {\n\t\tsuper(name, 'string', 'SQLiteText');\n\t\tthis.config.enumValues = config.enum;\n\t\tthis.config.length = config.length;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnySQLiteTable<{ name: TTableName }>,\n\t): SQLiteText<MakeColumnConfig<T, TTableName> & { length: T['length'] }> {\n\t\treturn new SQLiteText<MakeColumnConfig<T, TTableName> & { length: T['length'] }>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class SQLiteText<T extends ColumnBaseConfig<'string', 'SQLiteText'> & { length?: number | undefined }>\n\textends SQLiteColumn<T, { length: T['length']; enumValues: T['enumValues'] }>\n{\n\tstatic override readonly [entityKind]: string = 'SQLiteText';\n\n\toverride readonly enumValues = this.config.enumValues;\n\n\treadonly length: T['length'] = this.config.length;\n\n\tconstructor(\n\t\ttable: AnySQLiteTable<{ name: T['tableName'] }>,\n\t\tconfig: SQLiteTextBuilder<T>['config'],\n\t) {\n\t\tsuper(table, config);\n\t}\n\n\tgetSQLType(): string {\n\t\treturn `text${this.config.length ? `(${this.config.length})` : ''}`;\n\t}\n}\n\nexport type SQLiteTextJsonBuilderInitial<TName extends string> = SQLiteTextJsonBuilder<{\n\tname: TName;\n\tdataType: 'json';\n\tcolumnType: 'SQLiteTextJson';\n\tdata: unknown;\n\tdriverParam: string;\n\tenumValues: undefined;\n\tgenerated: undefined;\n}>;\n\nexport class SQLiteTextJsonBuilder<T extends ColumnBuilderBaseConfig<'json', 'SQLiteTextJson'>>\n\textends SQLiteColumnBuilder<T>\n{\n\tstatic override readonly [entityKind]: string = 'SQLiteTextJsonBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'json', 'SQLiteTextJson');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnySQLiteTable<{ name: TTableName }>,\n\t): SQLiteTextJson<MakeColumnConfig<T, TTableName>> {\n\t\treturn new SQLiteTextJson<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class SQLiteTextJson<T extends ColumnBaseConfig<'json', 'SQLiteTextJson'>>\n\textends SQLiteColumn<T, { length: number | undefined; enumValues: T['enumValues'] }>\n{\n\tstatic override readonly [entityKind]: string = 'SQLiteTextJson';\n\n\tgetSQLType(): string {\n\t\treturn 'text';\n\t}\n\n\toverride mapFromDriverValue(value: string): T['data'] {\n\t\treturn JSON.parse(value);\n\t}\n\n\toverride mapToDriverValue(value: T['data']): string {\n\t\treturn JSON.stringify(value);\n\t}\n}\n\nexport type SQLiteTextConfig<\n\tTMode extends 'text' | 'json' = 'text' | 'json',\n\tTEnum extends readonly string[] | string[] | undefined = readonly string[] | string[] | undefined,\n\tTLength extends number | undefined = number | undefined,\n> = TMode extends 'text' ? {\n\t\tmode?: TMode;\n\t\tlength?: TLength;\n\t\tenum?: TEnum;\n\t}\n\t: {\n\t\tmode?: TMode;\n\t};\n\nexport function text(): SQLiteTextBuilderInitial<'', [string, ...string[]], undefined>;\nexport function text<\n\tU extends string,\n\tT extends Readonly<[U, ...U[]]>,\n\tL extends number | undefined,\n\tTMode extends 'text' | 'json' = 'text' | 'json',\n>(\n\tconfig?: SQLiteTextConfig<TMode, T | Writable<T>, L>,\n): Equal<TMode, 'json'> extends true ? SQLiteTextJsonBuilderInitial<''>\n\t: SQLiteTextBuilderInitial<'', Writable<T>, L>;\nexport function text<\n\tTName extends string,\n\tU extends string,\n\tT extends Readonly<[U, ...U[]]>,\n\tL extends number | undefined,\n\tTMode extends 'text' | 'json' = 'text' | 'json',\n>(\n\tname: TName,\n\tconfig?: SQLiteTextConfig<TMode, T | Writable<T>, L>,\n): Equal<TMode, 'json'> extends true ? SQLiteTextJsonBuilderInitial<TName>\n\t: SQLiteTextBuilderInitial<TName, Writable<T>, L>;\nexport function text(a?: string | SQLiteTextConfig, b: SQLiteTextConfig = {}): any {\n\tconst { name, config } = getColumnNameAndConfig<SQLiteTextConfig>(a, b);\n\tif (config.mode === 'json') {\n\t\treturn new SQLiteTextJsonBuilder(name);\n\t}\n\treturn new SQLiteTextBuilder(name, config as any);\n}\n", "import { entityKind, is } from '~/entity.ts';\nimport type { TypedQueryBuilder } from '~/query-builders/query-builder.ts';\nimport type { SelectResultFields } from '~/query-builders/select.types.ts';\nimport { QueryPromise } from '~/query-promise.ts';\nimport type { RunnableQuery } from '~/runnable-query.ts';\nimport type { Placeholder, Query, SQLWrapper } from '~/sql/sql.ts';\nimport { Param, SQL, sql } from '~/sql/sql.ts';\nimport type { SQLiteDialect } from '~/sqlite-core/dialect.ts';\nimport type { IndexColumn } from '~/sqlite-core/indexes.ts';\nimport type { SQLitePreparedQuery, SQLiteSession } from '~/sqlite-core/session.ts';\nimport { SQLiteTable } from '~/sqlite-core/table.ts';\nimport type { Subquery } from '~/subquery.ts';\nimport { Columns, Table } from '~/table.ts';\nimport { type DrizzleTypeError, haveSameKeys, mapUpdateSet, orderSelectedFields, type Simplify } from '~/utils.ts';\nimport type { AnySQLiteColumn, SQLiteColumn } from '../columns/common.ts';\nimport { QueryBuilder } from './query-builder.ts';\nimport type { SelectedFieldsFlat, SelectedFieldsOrdered } from './select.types.ts';\nimport type { SQLiteUpdateSetSource } from './update.ts';\n\nexport interface SQLiteInsertConfig<TTable extends SQLiteTable = SQLiteTable> {\n\ttable: TTable;\n\tvalues: Record<string, Param | SQL>[] | SQLiteInsertSelectQueryBuilder<TTable> | SQL;\n\twithList?: Subquery[];\n\tonConflict?: SQL;\n\treturning?: SelectedFieldsOrdered;\n\tselect?: boolean;\n}\n\nexport type SQLiteInsertValue<TTable extends SQLiteTable> = Simplify<\n\t{\n\t\t[Key in keyof TTable['$inferInsert']]: TTable['$inferInsert'][Key] | SQL | Placeholder;\n\t}\n>;\n\nexport type SQLiteInsertSelectQueryBuilder<TTable extends SQLiteTable> = TypedQueryBuilder<\n\t{ [K in keyof TTable['$inferInsert']]: AnySQLiteColumn | SQL | SQL.Aliased | TTable['$inferInsert'][K] }\n>;\n\nexport class SQLiteInsertBuilder<\n\tTTable extends SQLiteTable,\n\tTResultType extends 'sync' | 'async',\n\tTRunResult,\n> {\n\tstatic readonly [entityKind]: string = 'SQLiteInsertBuilder';\n\n\tconstructor(\n\t\tprotected table: TTable,\n\t\tprotected session: SQLiteSession<any, any, any, any>,\n\t\tprotected dialect: SQLiteDialect,\n\t\tprivate withList?: Subquery[],\n\t) {}\n\n\tvalues(value: SQLiteInsertValue<TTable>): SQLiteInsertBase<TTable, TResultType, TRunResult>;\n\tvalues(values: SQLiteInsertValue<TTable>[]): SQLiteInsertBase<TTable, TResultType, TRunResult>;\n\tvalues(\n\t\tvalues: SQLiteInsertValue<TTable> | SQLiteInsertValue<TTable>[],\n\t): SQLiteInsertBase<TTable, TResultType, TRunResult> {\n\t\tvalues = Array.isArray(values) ? values : [values];\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('values() must be called with at least one value');\n\t\t}\n\t\tconst mappedValues = values.map((entry) => {\n\t\t\tconst result: Record<string, Param | SQL> = {};\n\t\t\tconst cols = this.table[Table.Symbol.Columns];\n\t\t\tfor (const colKey of Object.keys(entry)) {\n\t\t\t\tconst colValue = entry[colKey as keyof typeof entry];\n\t\t\t\tresult[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\n\t\t// if (mappedValues.length > 1 && mappedValues.some((t) => Object.keys(t).length === 0)) {\n\t\t// \tthrow new Error(\n\t\t// \t\t`One of the values you want to insert is empty. In SQLite you can insert only one empty object per statement. For this case Drizzle with use \"INSERT INTO ... DEFAULT VALUES\" syntax`,\n\t\t// \t);\n\t\t// }\n\n\t\treturn new SQLiteInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList);\n\t}\n\n\tselect(\n\t\tselectQuery: (qb: QueryBuilder) => SQLiteInsertSelectQueryBuilder<TTable>,\n\t): SQLiteInsertBase<TTable, TResultType, TRunResult>;\n\tselect(selectQuery: (qb: QueryBuilder) => SQL): SQLiteInsertBase<TTable, TResultType, TRunResult>;\n\tselect(selectQuery: SQL): SQLiteInsertBase<TTable, TResultType, TRunResult>;\n\tselect(selectQuery: SQLiteInsertSelectQueryBuilder<TTable>): SQLiteInsertBase<TTable, TResultType, TRunResult>;\n\tselect(\n\t\tselectQuery:\n\t\t\t| SQL\n\t\t\t| SQLiteInsertSelectQueryBuilder<TTable>\n\t\t\t| ((qb: QueryBuilder) => SQLiteInsertSelectQueryBuilder<TTable> | SQL),\n\t): SQLiteInsertBase<TTable, TResultType, TRunResult> {\n\t\tconst select = typeof selectQuery === 'function' ? selectQuery(new QueryBuilder()) : selectQuery;\n\n\t\tif (\n\t\t\t!is(select, SQL)\n\t\t\t&& !haveSameKeys(this.table[Columns], select._.selectedFields)\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t'Insert select error: selected fields are not the same or are in a different order compared to the table definition',\n\t\t\t);\n\t\t}\n\n\t\treturn new SQLiteInsertBase(this.table, select, this.session, this.dialect, this.withList, true);\n\t}\n}\n\nexport type SQLiteInsertWithout<T extends AnySQLiteInsert, TDynamic extends boolean, K extends keyof T & string> =\n\tTDynamic extends true ? T\n\t\t: Omit<\n\t\t\tSQLiteInsertBase<\n\t\t\t\tT['_']['table'],\n\t\t\t\tT['_']['resultType'],\n\t\t\t\tT['_']['runResult'],\n\t\t\t\tT['_']['returning'],\n\t\t\t\tTDynamic,\n\t\t\t\tT['_']['excludedMethods'] | K\n\t\t\t>,\n\t\t\tT['_']['excludedMethods'] | K\n\t\t>;\n\nexport type SQLiteInsertReturning<\n\tT extends AnySQLiteInsert,\n\tTDynamic extends boolean,\n\tTSelectedFields extends SelectedFieldsFlat,\n> = SQLiteInsertWithout<\n\tSQLiteInsertBase<\n\t\tT['_']['table'],\n\t\tT['_']['resultType'],\n\t\tT['_']['runResult'],\n\t\tSelectResultFields<TSelectedFields>,\n\t\tTDynamic,\n\t\tT['_']['excludedMethods']\n\t>,\n\tTDynamic,\n\t'returning'\n>;\n\nexport type SQLiteInsertReturningAll<\n\tT extends AnySQLiteInsert,\n\tTDynamic extends boolean,\n> = SQLiteInsertWithout<\n\tSQLiteInsertBase<\n\t\tT['_']['table'],\n\t\tT['_']['resultType'],\n\t\tT['_']['runResult'],\n\t\tT['_']['table']['$inferSelect'],\n\t\tTDynamic,\n\t\tT['_']['excludedMethods']\n\t>,\n\tTDynamic,\n\t'returning'\n>;\n\nexport type SQLiteInsertOnConflictDoUpdateConfig<T extends AnySQLiteInsert> = {\n\ttarget: IndexColumn | IndexColumn[];\n\t/** @deprecated - use either `targetWhere` or `setWhere` */\n\twhere?: SQL;\n\t// TODO: add tests for targetWhere and setWhere\n\ttargetWhere?: SQL;\n\tsetWhere?: SQL;\n\tset: SQLiteUpdateSetSource<T['_']['table']>;\n};\n\nexport type SQLiteInsertDynamic<T extends AnySQLiteInsert> = SQLiteInsert<\n\tT['_']['table'],\n\tT['_']['resultType'],\n\tT['_']['runResult'],\n\tT['_']['returning']\n>;\n\nexport type SQLiteInsertExecute<T extends AnySQLiteInsert> = T['_']['returning'] extends undefined ? T['_']['runResult']\n\t: T['_']['returning'][];\n\nexport type SQLiteInsertPrepare<T extends AnySQLiteInsert> = SQLitePreparedQuery<\n\t{\n\t\ttype: T['_']['resultType'];\n\t\trun: T['_']['runResult'];\n\t\tall: T['_']['returning'] extends undefined ? DrizzleTypeError<'.all() cannot be used without .returning()'>\n\t\t\t: T['_']['returning'][];\n\t\tget: T['_']['returning'] extends undefined ? DrizzleTypeError<'.get() cannot be used without .returning()'>\n\t\t\t: T['_']['returning'];\n\t\tvalues: T['_']['returning'] extends undefined ? DrizzleTypeError<'.values() cannot be used without .returning()'>\n\t\t\t: any[][];\n\t\texecute: SQLiteInsertExecute<T>;\n\t}\n>;\n\nexport type AnySQLiteInsert = SQLiteInsertBase<any, any, any, any, any, any>;\n\nexport type SQLiteInsert<\n\tTTable extends SQLiteTable = SQLiteTable,\n\tTResultType extends 'sync' | 'async' = 'sync' | 'async',\n\tTRunResult = unknown,\n\tTReturning = any,\n> = SQLiteInsertBase<TTable, TResultType, TRunResult, TReturning, true, never>;\n\nexport interface SQLiteInsertBase<\n\tTTable extends SQLiteTable,\n\tTResultType extends 'sync' | 'async',\n\tTRunResult,\n\tTReturning = undefined,\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n> extends\n\tSQLWrapper,\n\tQueryPromise<TReturning extends undefined ? TRunResult : TReturning[]>,\n\tRunnableQuery<TReturning extends undefined ? TRunResult : TReturning[], 'sqlite'>\n{\n\treadonly _: {\n\t\treadonly dialect: 'sqlite';\n\t\treadonly table: TTable;\n\t\treadonly resultType: TResultType;\n\t\treadonly runResult: TRunResult;\n\t\treadonly returning: TReturning;\n\t\treadonly dynamic: TDynamic;\n\t\treadonly excludedMethods: TExcludedMethods;\n\t\treadonly result: TReturning extends undefined ? TRunResult : TReturning[];\n\t};\n}\n\nexport class SQLiteInsertBase<\n\tTTable extends SQLiteTable,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTResultType extends 'sync' | 'async',\n\tTRunResult,\n\tTReturning = undefined,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTDynamic extends boolean = false,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTExcludedMethods extends string = never,\n> extends QueryPromise<TReturning extends undefined ? TRunResult : TReturning[]>\n\timplements RunnableQuery<TReturning extends undefined ? TRunResult : TReturning[], 'sqlite'>, SQLWrapper\n{\n\tstatic override readonly [entityKind]: string = 'SQLiteInsert';\n\n\t/** @internal */\n\tconfig: SQLiteInsertConfig<TTable>;\n\n\tconstructor(\n\t\ttable: TTable,\n\t\tvalues: SQLiteInsertConfig['values'],\n\t\tprivate session: SQLiteSession<any, any, any, any>,\n\t\tprivate dialect: SQLiteDialect,\n\t\twithList?: Subquery[],\n\t\tselect?: boolean,\n\t) {\n\t\tsuper();\n\t\tthis.config = { table, values: values as any, withList, select };\n\t}\n\n\t/**\n\t * Adds a `returning` clause to the query.\n\t *\n\t * Calling this method will return the specified fields of the inserted rows. If no fields are specified, all fields will be returned.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/insert#insert-returning}\n\t *\n\t * @example\n\t * ```ts\n\t * // Insert one row and return all fields\n\t * const insertedCar: Car[] = await db.insert(cars)\n\t *   .values({ brand: 'BMW' })\n\t *   .returning();\n\t *\n\t * // Insert one row and return only the id\n\t * const insertedCarId: { id: number }[] = await db.insert(cars)\n\t *   .values({ brand: 'BMW' })\n\t *   .returning({ id: cars.id });\n\t * ```\n\t */\n\treturning(): SQLiteInsertReturningAll<this, TDynamic>;\n\treturning<TSelectedFields extends SelectedFieldsFlat>(\n\t\tfields: TSelectedFields,\n\t): SQLiteInsertReturning<this, TDynamic, TSelectedFields>;\n\treturning(\n\t\tfields: SelectedFieldsFlat = this.config.table[SQLiteTable.Symbol.Columns],\n\t): SQLiteInsertWithout<AnySQLiteInsert, TDynamic, 'returning'> {\n\t\tthis.config.returning = orderSelectedFields<SQLiteColumn>(fields);\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds an `on conflict do nothing` clause to the query.\n\t *\n\t * Calling this method simply avoids inserting a row as its alternative action.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/insert#on-conflict-do-nothing}\n\t *\n\t * @param config The `target` and `where` clauses.\n\t *\n\t * @example\n\t * ```ts\n\t * // Insert one row and cancel the insert if there's a conflict\n\t * await db.insert(cars)\n\t *   .values({ id: 1, brand: 'BMW' })\n\t *   .onConflictDoNothing();\n\t *\n\t * // Explicitly specify conflict target\n\t * await db.insert(cars)\n\t *   .values({ id: 1, brand: 'BMW' })\n\t *   .onConflictDoNothing({ target: cars.id });\n\t * ```\n\t */\n\tonConflictDoNothing(config: { target?: IndexColumn | IndexColumn[]; where?: SQL } = {}): this {\n\t\tif (config.target === undefined) {\n\t\t\tthis.config.onConflict = sql`do nothing`;\n\t\t} else {\n\t\t\tconst targetSql = Array.isArray(config.target) ? sql`${config.target}` : sql`${[config.target]}`;\n\t\t\tconst whereSql = config.where ? sql` where ${config.where}` : sql``;\n\t\t\tthis.config.onConflict = sql`${targetSql} do nothing${whereSql}`;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds an `on conflict do update` clause to the query.\n\t *\n\t * Calling this method will update the existing row that conflicts with the row proposed for insertion as its alternative action.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/insert#upserts-and-conflicts}\n\t *\n\t * @param config The `target`, `set` and `where` clauses.\n\t *\n\t * @example\n\t * ```ts\n\t * // Update the row if there's a conflict\n\t * await db.insert(cars)\n\t *   .values({ id: 1, brand: 'BMW' })\n\t *   .onConflictDoUpdate({\n\t *     target: cars.id,\n\t *     set: { brand: 'Porsche' }\n\t *   });\n\t *\n\t * // Upsert with 'where' clause\n\t * await db.insert(cars)\n\t *   .values({ id: 1, brand: 'BMW' })\n\t *   .onConflictDoUpdate({\n\t *     target: cars.id,\n\t *     set: { brand: 'newBMW' },\n\t *     where: sql`${cars.createdAt} > '2023-01-01'::date`,\n\t *   });\n\t * ```\n\t */\n\tonConflictDoUpdate(config: SQLiteInsertOnConflictDoUpdateConfig<this>): this {\n\t\tif (config.where && (config.targetWhere || config.setWhere)) {\n\t\t\tthrow new Error(\n\t\t\t\t'You cannot use both \"where\" and \"targetWhere\"/\"setWhere\" at the same time - \"where\" is deprecated, use \"targetWhere\" or \"setWhere\" instead.',\n\t\t\t);\n\t\t}\n\t\tconst whereSql = config.where ? sql` where ${config.where}` : undefined;\n\t\tconst targetWhereSql = config.targetWhere ? sql` where ${config.targetWhere}` : undefined;\n\t\tconst setWhereSql = config.setWhere ? sql` where ${config.setWhere}` : undefined;\n\t\tconst targetSql = Array.isArray(config.target) ? sql`${config.target}` : sql`${[config.target]}`;\n\t\tconst setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));\n\t\tthis.config.onConflict = sql`${targetSql}${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`;\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tgetSQL(): SQL {\n\t\treturn this.dialect.buildInsertQuery(this.config);\n\t}\n\n\ttoSQL(): Query {\n\t\tconst { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n\t\treturn rest;\n\t}\n\n\t/** @internal */\n\t_prepare(isOneTimeQuery = true): SQLiteInsertPrepare<this> {\n\t\treturn this.session[isOneTimeQuery ? 'prepareOneTimeQuery' : 'prepareQuery'](\n\t\t\tthis.dialect.sqlToQuery(this.getSQL()),\n\t\t\tthis.config.returning,\n\t\t\tthis.config.returning ? 'all' : 'run',\n\t\t\ttrue,\n\t\t) as SQLiteInsertPrepare<this>;\n\t}\n\n\tprepare(): SQLiteInsertPrepare<this> {\n\t\treturn this._prepare(false);\n\t}\n\n\trun: ReturnType<this['prepare']>['run'] = (placeholderValues) => {\n\t\treturn this._prepare().run(placeholderValues);\n\t};\n\n\tall: ReturnType<this['prepare']>['all'] = (placeholderValues) => {\n\t\treturn this._prepare().all(placeholderValues);\n\t};\n\n\tget: ReturnType<this['prepare']>['get'] = (placeholderValues) => {\n\t\treturn this._prepare().get(placeholderValues);\n\t};\n\n\tvalues: ReturnType<this['prepare']>['values'] = (placeholderValues) => {\n\t\treturn this._prepare().values(placeholderValues);\n\t};\n\n\toverride async execute(): Promise<SQLiteInsertExecute<this>> {\n\t\treturn (this.config.returning ? this.all() : this.run()) as SQLiteInsertExecute<this>;\n\t}\n\n\t$dynamic(): SQLiteInsertDynamic<this> {\n\t\treturn this as any;\n\t}\n}\n", "import { entityKind, is } from '~/entity.ts';\nimport type { TypedQueryBuilder } from '~/query-builders/query-builder.ts';\nimport { SelectionProxyHandler } from '~/selection-proxy.ts';\nimport type { ColumnsSelection } from '~/sql/sql.ts';\nimport type { SQLiteDialectConfig } from '~/sqlite-core/dialect.ts';\nimport { SQLiteDialect, SQLiteSyncDialect } from '~/sqlite-core/dialect.ts';\nimport type { WithSubqueryWithSelection } from '~/sqlite-core/subquery.ts';\nimport { WithSubquery } from '~/subquery.ts';\nimport { SQLiteSelectBuilder } from './select.ts';\nimport type { SelectedFields } from './select.types.ts';\n\nexport class QueryBuilder {\n\tstatic readonly [entityKind]: string = 'SQLiteQueryBuilder';\n\n\tprivate dialect: SQLiteDialect | undefined;\n\tprivate dialectConfig: SQLiteDialectConfig | undefined;\n\n\tconstructor(dialect?: SQLiteDialect | SQLiteDialectConfig) {\n\t\tthis.dialect = is(dialect, SQLiteDialect) ? dialect : undefined;\n\t\tthis.dialectConfig = is(dialect, SQLiteDialect) ? undefined : dialect;\n\t}\n\n\t$with<TAlias extends string>(alias: TAlias) {\n\t\tconst queryBuilder = this;\n\n\t\treturn {\n\t\t\tas<TSelection extends ColumnsSelection>(\n\t\t\t\tqb: TypedQueryBuilder<TSelection> | ((qb: QueryBuilder) => TypedQueryBuilder<TSelection>),\n\t\t\t): WithSubqueryWithSelection<TSelection, TAlias> {\n\t\t\t\tif (typeof qb === 'function') {\n\t\t\t\t\tqb = qb(queryBuilder);\n\t\t\t\t}\n\n\t\t\t\treturn new Proxy(\n\t\t\t\t\tnew WithSubquery(qb.getSQL(), qb.getSelectedFields() as SelectedFields, alias, true),\n\t\t\t\t\tnew SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }),\n\t\t\t\t) as WithSubqueryWithSelection<TSelection, TAlias>;\n\t\t\t},\n\t\t};\n\t}\n\n\twith(...queries: WithSubquery[]) {\n\t\tconst self = this;\n\n\t\tfunction select(): SQLiteSelectBuilder<undefined, 'sync', void, 'qb'>;\n\t\tfunction select<TSelection extends SelectedFields>(\n\t\t\tfields: TSelection,\n\t\t): SQLiteSelectBuilder<TSelection, 'sync', void, 'qb'>;\n\t\tfunction select<TSelection extends SelectedFields>(\n\t\t\tfields?: TSelection,\n\t\t): SQLiteSelectBuilder<TSelection | undefined, 'sync', void, 'qb'> {\n\t\t\treturn new SQLiteSelectBuilder({\n\t\t\t\tfields: fields ?? undefined,\n\t\t\t\tsession: undefined,\n\t\t\t\tdialect: self.getDialect(),\n\t\t\t\twithList: queries,\n\t\t\t});\n\t\t}\n\n\t\tfunction selectDistinct(): SQLiteSelectBuilder<undefined, 'sync', void, 'qb'>;\n\t\tfunction selectDistinct<TSelection extends SelectedFields>(\n\t\t\tfields: TSelection,\n\t\t): SQLiteSelectBuilder<TSelection, 'sync', void, 'qb'>;\n\t\tfunction selectDistinct<TSelection extends SelectedFields>(\n\t\t\tfields?: TSelection,\n\t\t): SQLiteSelectBuilder<TSelection | undefined, 'sync', void, 'qb'> {\n\t\t\treturn new SQLiteSelectBuilder({\n\t\t\t\tfields: fields ?? undefined,\n\t\t\t\tsession: undefined,\n\t\t\t\tdialect: self.getDialect(),\n\t\t\t\twithList: queries,\n\t\t\t\tdistinct: true,\n\t\t\t});\n\t\t}\n\n\t\treturn { select, selectDistinct };\n\t}\n\n\tselect(): SQLiteSelectBuilder<undefined, 'sync', void, 'qb'>;\n\tselect<TSelection extends SelectedFields>(\n\t\tfields: TSelection,\n\t): SQLiteSelectBuilder<TSelection, 'sync', void, 'qb'>;\n\tselect<TSelection extends SelectedFields>(\n\t\tfields?: TSelection,\n\t): SQLiteSelectBuilder<TSelection | undefined, 'sync', void, 'qb'> {\n\t\treturn new SQLiteSelectBuilder({ fields: fields ?? undefined, session: undefined, dialect: this.getDialect() });\n\t}\n\n\tselectDistinct(): SQLiteSelectBuilder<undefined, 'sync', void, 'qb'>;\n\tselectDistinct<TSelection extends SelectedFields>(\n\t\tfields: TSelection,\n\t): SQLiteSelectBuilder<TSelection, 'sync', void, 'qb'>;\n\tselectDistinct<TSelection extends SelectedFields>(\n\t\tfields?: TSelection,\n\t): SQLiteSelectBuilder<TSelection | undefined, 'sync', void, 'qb'> {\n\t\treturn new SQLiteSelectBuilder({\n\t\t\tfields: fields ?? undefined,\n\t\t\tsession: undefined,\n\t\t\tdialect: this.getDialect(),\n\t\t\tdistinct: true,\n\t\t});\n\t}\n\n\t// Lazy load dialect to avoid circular dependency\n\tprivate getDialect() {\n\t\tif (!this.dialect) {\n\t\t\tthis.dialect = new SQLiteSyncDialect(this.dialectConfig);\n\t\t}\n\n\t\treturn this.dialect;\n\t}\n}\n", "import { aliasedTable, aliasedTableColumn, mapColumnsInAliasedSQLToAlias, mapColumnsInSQLToAlias } from '~/alias.ts';\nimport { CasingCache } from '~/casing.ts';\nimport type { AnyColumn } from '~/column.ts';\nimport { Column } from '~/column.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport { DrizzleError } from '~/errors.ts';\nimport type { MigrationConfig, MigrationMeta } from '~/migrator.ts';\nimport {\n\ttype BuildRelationalQueryResult,\n\ttype DBQueryConfig,\n\tgetOperators,\n\tgetOrderByOperators,\n\tMany,\n\tnormalizeRelation,\n\tOne,\n\ttype Relation,\n\ttype TableRelationalConfig,\n\ttype TablesRelationalConfig,\n} from '~/relations.ts';\nimport type { Name, Placeholder } from '~/sql/index.ts';\nimport { and, eq } from '~/sql/index.ts';\nimport { Param, type QueryWithTypings, SQL, sql, type SQLChunk } from '~/sql/sql.ts';\nimport { SQLiteColumn } from '~/sqlite-core/columns/index.ts';\nimport type {\n\tAnySQLiteSelectQueryBuilder,\n\tSQLiteDeleteConfig,\n\tSQLiteInsertConfig,\n\tSQLiteUpdateConfig,\n} from '~/sqlite-core/query-builders/index.ts';\nimport { SQLiteTable } from '~/sqlite-core/table.ts';\nimport { Subquery } from '~/subquery.ts';\nimport { getTableName, getTableUniqueName, Table } from '~/table.ts';\nimport { type Casing, orderSelectedFields, type UpdateSet } from '~/utils.ts';\nimport { ViewBaseConfig } from '~/view-common.ts';\nimport type {\n\tSelectedFieldsOrdered,\n\tSQLiteSelectConfig,\n\tSQLiteSelectJoinConfig,\n} from './query-builders/select.types.ts';\nimport type { SQLiteSession } from './session.ts';\nimport { SQLiteViewBase } from './view-base.ts';\n\nexport interface SQLiteDialectConfig {\n\tcasing?: Casing;\n}\n\nexport abstract class SQLiteDialect {\n\tstatic readonly [entityKind]: string = 'SQLiteDialect';\n\n\t/** @internal */\n\treadonly casing: CasingCache;\n\n\tconstructor(config?: SQLiteDialectConfig) {\n\t\tthis.casing = new CasingCache(config?.casing);\n\t}\n\n\tescapeName(name: string): string {\n\t\treturn `\"${name}\"`;\n\t}\n\n\tescapeParam(_num: number): string {\n\t\treturn '?';\n\t}\n\n\tescapeString(str: string): string {\n\t\treturn `'${str.replace(/'/g, \"''\")}'`;\n\t}\n\n\tprivate buildWithCTE(queries: Subquery[] | undefined): SQL | undefined {\n\t\tif (!queries?.length) return undefined;\n\n\t\tconst withSqlChunks = [sql`with `];\n\t\tfor (const [i, w] of queries.entries()) {\n\t\t\twithSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);\n\t\t\tif (i < queries.length - 1) {\n\t\t\t\twithSqlChunks.push(sql`, `);\n\t\t\t}\n\t\t}\n\t\twithSqlChunks.push(sql` `);\n\t\treturn sql.join(withSqlChunks);\n\t}\n\n\tbuildDeleteQuery({ table, where, returning, withList, limit, orderBy }: SQLiteDeleteConfig): SQL {\n\t\tconst withSql = this.buildWithCTE(withList);\n\n\t\tconst returningSql = returning\n\t\t\t? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}`\n\t\t\t: undefined;\n\n\t\tconst whereSql = where ? sql` where ${where}` : undefined;\n\n\t\tconst orderBySql = this.buildOrderBy(orderBy);\n\n\t\tconst limitSql = this.buildLimit(limit);\n\n\t\treturn sql`${withSql}delete from ${table}${whereSql}${returningSql}${orderBySql}${limitSql}`;\n\t}\n\n\tbuildUpdateSet(table: SQLiteTable, set: UpdateSet): SQL {\n\t\tconst tableColumns = table[Table.Symbol.Columns];\n\n\t\tconst columnNames = Object.keys(tableColumns).filter((colName) =>\n\t\t\tset[colName] !== undefined || tableColumns[colName]?.onUpdateFn !== undefined\n\t\t);\n\n\t\tconst setSize = columnNames.length;\n\t\treturn sql.join(columnNames.flatMap((colName, i) => {\n\t\t\tconst col = tableColumns[colName]!;\n\n\t\t\tconst value = set[colName] ?? sql.param(col.onUpdateFn!(), col);\n\t\t\tconst res = sql`${sql.identifier(this.casing.getColumnCasing(col))} = ${value}`;\n\n\t\t\tif (i < setSize - 1) {\n\t\t\t\treturn [res, sql.raw(', ')];\n\t\t\t}\n\t\t\treturn [res];\n\t\t}));\n\t}\n\n\tbuildUpdateQuery({ table, set, where, returning, withList, joins, from, limit, orderBy }: SQLiteUpdateConfig): SQL {\n\t\tconst withSql = this.buildWithCTE(withList);\n\n\t\tconst setSql = this.buildUpdateSet(table, set);\n\n\t\tconst fromSql = from && sql.join([sql.raw(' from '), this.buildFromTable(from)]);\n\n\t\tconst joinsSql = this.buildJoins(joins);\n\n\t\tconst returningSql = returning\n\t\t\t? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}`\n\t\t\t: undefined;\n\n\t\tconst whereSql = where ? sql` where ${where}` : undefined;\n\n\t\tconst orderBySql = this.buildOrderBy(orderBy);\n\n\t\tconst limitSql = this.buildLimit(limit);\n\n\t\treturn sql`${withSql}update ${table} set ${setSql}${fromSql}${joinsSql}${whereSql}${returningSql}${orderBySql}${limitSql}`;\n\t}\n\n\t/**\n\t * Builds selection SQL with provided fields/expressions\n\t *\n\t * Examples:\n\t *\n\t * `select <selection> from`\n\t *\n\t * `insert ... returning <selection>`\n\t *\n\t * If `isSingleTable` is true, then columns won't be prefixed with table name\n\t */\n\tprivate buildSelection(\n\t\tfields: SelectedFieldsOrdered,\n\t\t{ isSingleTable = false }: { isSingleTable?: boolean } = {},\n\t): SQL {\n\t\tconst columnsLen = fields.length;\n\n\t\tconst chunks = fields\n\t\t\t.flatMap(({ field }, i) => {\n\t\t\t\tconst chunk: SQLChunk[] = [];\n\n\t\t\t\tif (is(field, SQL.Aliased) && field.isSelectionField) {\n\t\t\t\t\tchunk.push(sql.identifier(field.fieldAlias));\n\t\t\t\t} else if (is(field, SQL.Aliased) || is(field, SQL)) {\n\t\t\t\t\tconst query = is(field, SQL.Aliased) ? field.sql : field;\n\n\t\t\t\t\tif (isSingleTable) {\n\t\t\t\t\t\tchunk.push(\n\t\t\t\t\t\t\tnew SQL(\n\t\t\t\t\t\t\t\tquery.queryChunks.map((c) => {\n\t\t\t\t\t\t\t\t\tif (is(c, Column)) {\n\t\t\t\t\t\t\t\t\t\treturn sql.identifier(this.casing.getColumnCasing(c));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn c;\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchunk.push(query);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is(field, SQL.Aliased)) {\n\t\t\t\t\t\tchunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);\n\t\t\t\t\t}\n\t\t\t\t} else if (is(field, Column)) {\n\t\t\t\t\tconst tableName = field.table[Table.Symbol.Name];\n\t\t\t\t\tif (isSingleTable) {\n\t\t\t\t\t\tchunk.push(sql.identifier(this.casing.getColumnCasing(field)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchunk.push(sql`${sql.identifier(tableName)}.${sql.identifier(this.casing.getColumnCasing(field))}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (i < columnsLen - 1) {\n\t\t\t\t\tchunk.push(sql`, `);\n\t\t\t\t}\n\n\t\t\t\treturn chunk;\n\t\t\t});\n\n\t\treturn sql.join(chunks);\n\t}\n\n\tprivate buildJoins(joins: SQLiteSelectJoinConfig[] | undefined): SQL | undefined {\n\t\tif (!joins || joins.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst joinsArray: SQL[] = [];\n\n\t\tif (joins) {\n\t\t\tfor (const [index, joinMeta] of joins.entries()) {\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tjoinsArray.push(sql` `);\n\t\t\t\t}\n\t\t\t\tconst table = joinMeta.table;\n\n\t\t\t\tif (is(table, SQLiteTable)) {\n\t\t\t\t\tconst tableName = table[SQLiteTable.Symbol.Name];\n\t\t\t\t\tconst tableSchema = table[SQLiteTable.Symbol.Schema];\n\t\t\t\t\tconst origTableName = table[SQLiteTable.Symbol.OriginalName];\n\t\t\t\t\tconst alias = tableName === origTableName ? undefined : joinMeta.alias;\n\t\t\t\t\tjoinsArray.push(\n\t\t\t\t\t\tsql`${sql.raw(joinMeta.joinType)} join ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined}${\n\t\t\t\t\t\t\tsql.identifier(origTableName)\n\t\t\t\t\t\t}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tjoinsArray.push(\n\t\t\t\t\t\tsql`${sql.raw(joinMeta.joinType)} join ${table} on ${joinMeta.on}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (index < joins.length - 1) {\n\t\t\t\t\tjoinsArray.push(sql` `);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn sql.join(joinsArray);\n\t}\n\n\tprivate buildLimit(limit: number | Placeholder | undefined): SQL | undefined {\n\t\treturn typeof limit === 'object' || (typeof limit === 'number' && limit >= 0)\n\t\t\t? sql` limit ${limit}`\n\t\t\t: undefined;\n\t}\n\n\tprivate buildOrderBy(orderBy: (SQLiteColumn | SQL | SQL.Aliased)[] | undefined): SQL | undefined {\n\t\tconst orderByList: (SQLiteColumn | SQL | SQL.Aliased)[] = [];\n\n\t\tif (orderBy) {\n\t\t\tfor (const [index, orderByValue] of orderBy.entries()) {\n\t\t\t\torderByList.push(orderByValue);\n\n\t\t\t\tif (index < orderBy.length - 1) {\n\t\t\t\t\torderByList.push(sql`, `);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn orderByList.length > 0 ? sql` order by ${sql.join(orderByList)}` : undefined;\n\t}\n\n\tprivate buildFromTable(\n\t\ttable: SQL | Subquery | SQLiteViewBase | SQLiteTable | undefined,\n\t): SQL | Subquery | SQLiteViewBase | SQLiteTable | undefined {\n\t\tif (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {\n\t\t\treturn sql`${sql.identifier(table[Table.Symbol.OriginalName])} ${sql.identifier(table[Table.Symbol.Name])}`;\n\t\t}\n\n\t\treturn table;\n\t}\n\n\tbuildSelectQuery(\n\t\t{\n\t\t\twithList,\n\t\t\tfields,\n\t\t\tfieldsFlat,\n\t\t\twhere,\n\t\t\thaving,\n\t\t\ttable,\n\t\t\tjoins,\n\t\t\torderBy,\n\t\t\tgroupBy,\n\t\t\tlimit,\n\t\t\toffset,\n\t\t\tdistinct,\n\t\t\tsetOperators,\n\t\t}: SQLiteSelectConfig,\n\t): SQL {\n\t\tconst fieldsList = fieldsFlat ?? orderSelectedFields<SQLiteColumn>(fields);\n\t\tfor (const f of fieldsList) {\n\t\t\tif (\n\t\t\t\tis(f.field, Column)\n\t\t\t\t&& getTableName(f.field.table)\n\t\t\t\t\t!== (is(table, Subquery)\n\t\t\t\t\t\t? table._.alias\n\t\t\t\t\t\t: is(table, SQLiteViewBase)\n\t\t\t\t\t\t? table[ViewBaseConfig].name\n\t\t\t\t\t\t: is(table, SQL)\n\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t: getTableName(table))\n\t\t\t\t&& !((table) =>\n\t\t\t\t\tjoins?.some(({ alias }) =>\n\t\t\t\t\t\talias === (table[Table.Symbol.IsAlias] ? getTableName(table) : table[Table.Symbol.BaseName])\n\t\t\t\t\t))(f.field.table)\n\t\t\t) {\n\t\t\t\tconst tableName = getTableName(f.field.table);\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Your \"${\n\t\t\t\t\t\tf.path.join('->')\n\t\t\t\t\t}\" field references a column \"${tableName}\".\"${f.field.name}\", but the table \"${tableName}\" is not part of the query! Did you forget to join it?`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst isSingleTable = !joins || joins.length === 0;\n\n\t\tconst withSql = this.buildWithCTE(withList);\n\n\t\tconst distinctSql = distinct ? sql` distinct` : undefined;\n\n\t\tconst selection = this.buildSelection(fieldsList, { isSingleTable });\n\n\t\tconst tableSql = this.buildFromTable(table);\n\n\t\tconst joinsSql = this.buildJoins(joins);\n\n\t\tconst whereSql = where ? sql` where ${where}` : undefined;\n\n\t\tconst havingSql = having ? sql` having ${having}` : undefined;\n\n\t\tconst groupByList: (SQL | AnyColumn | SQL.Aliased)[] = [];\n\t\tif (groupBy) {\n\t\t\tfor (const [index, groupByValue] of groupBy.entries()) {\n\t\t\t\tgroupByList.push(groupByValue);\n\n\t\t\t\tif (index < groupBy.length - 1) {\n\t\t\t\t\tgroupByList.push(sql`, `);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst groupBySql = groupByList.length > 0 ? sql` group by ${sql.join(groupByList)}` : undefined;\n\n\t\tconst orderBySql = this.buildOrderBy(orderBy);\n\n\t\tconst limitSql = this.buildLimit(limit);\n\n\t\tconst offsetSql = offset ? sql` offset ${offset}` : undefined;\n\n\t\tconst finalQuery =\n\t\t\tsql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}`;\n\n\t\tif (setOperators.length > 0) {\n\t\t\treturn this.buildSetOperations(finalQuery, setOperators);\n\t\t}\n\n\t\treturn finalQuery;\n\t}\n\n\tbuildSetOperations(leftSelect: SQL, setOperators: SQLiteSelectConfig['setOperators']): SQL {\n\t\tconst [setOperator, ...rest] = setOperators;\n\n\t\tif (!setOperator) {\n\t\t\tthrow new Error('Cannot pass undefined values to any set operator');\n\t\t}\n\n\t\tif (rest.length === 0) {\n\t\t\treturn this.buildSetOperationQuery({ leftSelect, setOperator });\n\t\t}\n\n\t\t// Some recursive magic here\n\t\treturn this.buildSetOperations(\n\t\t\tthis.buildSetOperationQuery({ leftSelect, setOperator }),\n\t\t\trest,\n\t\t);\n\t}\n\n\tbuildSetOperationQuery({\n\t\tleftSelect,\n\t\tsetOperator: { type, isAll, rightSelect, limit, orderBy, offset },\n\t}: { leftSelect: SQL; setOperator: SQLiteSelectConfig['setOperators'][number] }): SQL {\n\t\t// SQLite doesn't support parenthesis in set operations\n\t\tconst leftChunk = sql`${leftSelect.getSQL()} `;\n\t\tconst rightChunk = sql`${rightSelect.getSQL()}`;\n\n\t\tlet orderBySql;\n\t\tif (orderBy && orderBy.length > 0) {\n\t\t\tconst orderByValues: (SQL<unknown> | Name)[] = [];\n\n\t\t\t// The next bit is necessary because the sql operator replaces ${table.column} with `table`.`column`\n\t\t\t// which is invalid Sql syntax, Table from one of the SELECTs cannot be used in global ORDER clause\n\t\t\tfor (const singleOrderBy of orderBy) {\n\t\t\t\tif (is(singleOrderBy, SQLiteColumn)) {\n\t\t\t\t\torderByValues.push(sql.identifier(singleOrderBy.name));\n\t\t\t\t} else if (is(singleOrderBy, SQL)) {\n\t\t\t\t\tfor (let i = 0; i < singleOrderBy.queryChunks.length; i++) {\n\t\t\t\t\t\tconst chunk = singleOrderBy.queryChunks[i];\n\n\t\t\t\t\t\tif (is(chunk, SQLiteColumn)) {\n\t\t\t\t\t\t\tsingleOrderBy.queryChunks[i] = sql.identifier(this.casing.getColumnCasing(chunk));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\torderByValues.push(sql`${singleOrderBy}`);\n\t\t\t\t} else {\n\t\t\t\t\torderByValues.push(sql`${singleOrderBy}`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\torderBySql = sql` order by ${sql.join(orderByValues, sql`, `)}`;\n\t\t}\n\n\t\tconst limitSql = typeof limit === 'object' || (typeof limit === 'number' && limit >= 0)\n\t\t\t? sql` limit ${limit}`\n\t\t\t: undefined;\n\n\t\tconst operatorChunk = sql.raw(`${type} ${isAll ? 'all ' : ''}`);\n\n\t\tconst offsetSql = offset ? sql` offset ${offset}` : undefined;\n\n\t\treturn sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;\n\t}\n\n\tbuildInsertQuery(\n\t\t{ table, values: valuesOrSelect, onConflict, returning, withList, select }: SQLiteInsertConfig,\n\t): SQL {\n\t\t// const isSingleValue = values.length === 1;\n\t\tconst valuesSqlList: ((SQLChunk | SQL)[] | SQL)[] = [];\n\t\tconst columns: Record<string, SQLiteColumn> = table[Table.Symbol.Columns];\n\n\t\tconst colEntries: [string, SQLiteColumn][] = Object.entries(columns).filter(([_, col]) =>\n\t\t\t!col.shouldDisableInsert()\n\t\t);\n\t\tconst insertOrder = colEntries.map(([, column]) => sql.identifier(this.casing.getColumnCasing(column)));\n\n\t\tif (select) {\n\t\t\tconst select = valuesOrSelect as AnySQLiteSelectQueryBuilder | SQL;\n\n\t\t\tif (is(select, SQL)) {\n\t\t\t\tvaluesSqlList.push(select);\n\t\t\t} else {\n\t\t\t\tvaluesSqlList.push(select.getSQL());\n\t\t\t}\n\t\t} else {\n\t\t\tconst values = valuesOrSelect as Record<string, Param | SQL>[];\n\t\t\tvaluesSqlList.push(sql.raw('values '));\n\n\t\t\tfor (const [valueIndex, value] of values.entries()) {\n\t\t\t\tconst valueList: (SQLChunk | SQL)[] = [];\n\t\t\t\tfor (const [fieldName, col] of colEntries) {\n\t\t\t\t\tconst colValue = value[fieldName];\n\t\t\t\t\tif (colValue === undefined || (is(colValue, Param) && colValue.value === undefined)) {\n\t\t\t\t\t\tlet defaultValue;\n\t\t\t\t\t\tif (col.default !== null && col.default !== undefined) {\n\t\t\t\t\t\t\tdefaultValue = is(col.default, SQL) ? col.default : sql.param(col.default, col);\n\t\t\t\t\t\t\t// eslint-disable-next-line unicorn/no-negated-condition\n\t\t\t\t\t\t} else if (col.defaultFn !== undefined) {\n\t\t\t\t\t\t\tconst defaultFnResult = col.defaultFn();\n\t\t\t\t\t\t\tdefaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);\n\t\t\t\t\t\t\t// eslint-disable-next-line unicorn/no-negated-condition\n\t\t\t\t\t\t} else if (!col.default && col.onUpdateFn !== undefined) {\n\t\t\t\t\t\t\tconst onUpdateFnResult = col.onUpdateFn();\n\t\t\t\t\t\t\tdefaultValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdefaultValue = sql`null`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueList.push(defaultValue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalueList.push(colValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvaluesSqlList.push(valueList);\n\t\t\t\tif (valueIndex < values.length - 1) {\n\t\t\t\t\tvaluesSqlList.push(sql`, `);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst withSql = this.buildWithCTE(withList);\n\n\t\tconst valuesSql = sql.join(valuesSqlList);\n\n\t\tconst returningSql = returning\n\t\t\t? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}`\n\t\t\t: undefined;\n\n\t\tconst onConflictSql = onConflict ? sql` on conflict ${onConflict}` : undefined;\n\n\t\t// if (isSingleValue && valuesSqlList.length === 0){\n\t\t// \treturn sql`insert into ${table} default values ${onConflictSql}${returningSql}`;\n\t\t// }\n\n\t\treturn sql`${withSql}insert into ${table} ${insertOrder} ${valuesSql}${onConflictSql}${returningSql}`;\n\t}\n\n\tsqlToQuery(sql: SQL, invokeSource?: 'indexes' | undefined): QueryWithTypings {\n\t\treturn sql.toQuery({\n\t\t\tcasing: this.casing,\n\t\t\tescapeName: this.escapeName,\n\t\t\tescapeParam: this.escapeParam,\n\t\t\tescapeString: this.escapeString,\n\t\t\tinvokeSource,\n\t\t});\n\t}\n\n\tbuildRelationalQuery({\n\t\tfullSchema,\n\t\tschema,\n\t\ttableNamesMap,\n\t\ttable,\n\t\ttableConfig,\n\t\tqueryConfig: config,\n\t\ttableAlias,\n\t\tnestedQueryRelation,\n\t\tjoinOn,\n\t}: {\n\t\tfullSchema: Record<string, unknown>;\n\t\tschema: TablesRelationalConfig;\n\t\ttableNamesMap: Record<string, string>;\n\t\ttable: SQLiteTable;\n\t\ttableConfig: TableRelationalConfig;\n\t\tqueryConfig: true | DBQueryConfig<'many', true>;\n\t\ttableAlias: string;\n\t\tnestedQueryRelation?: Relation;\n\t\tjoinOn?: SQL;\n\t}): BuildRelationalQueryResult<SQLiteTable, SQLiteColumn> {\n\t\tlet selection: BuildRelationalQueryResult<SQLiteTable, SQLiteColumn>['selection'] = [];\n\t\tlet limit, offset, orderBy: SQLiteSelectConfig['orderBy'] = [], where;\n\t\tconst joins: SQLiteSelectJoinConfig[] = [];\n\n\t\tif (config === true) {\n\t\t\tconst selectionEntries = Object.entries(tableConfig.columns);\n\t\t\tselection = selectionEntries.map((\n\t\t\t\t[key, value],\n\t\t\t) => ({\n\t\t\t\tdbKey: value.name,\n\t\t\t\ttsKey: key,\n\t\t\t\tfield: aliasedTableColumn(value as SQLiteColumn, tableAlias),\n\t\t\t\trelationTableTsKey: undefined,\n\t\t\t\tisJson: false,\n\t\t\t\tselection: [],\n\t\t\t}));\n\t\t} else {\n\t\t\tconst aliasedColumns = Object.fromEntries(\n\t\t\t\tObject.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]),\n\t\t\t);\n\n\t\t\tif (config.where) {\n\t\t\t\tconst whereSql = typeof config.where === 'function'\n\t\t\t\t\t? config.where(aliasedColumns, getOperators())\n\t\t\t\t\t: config.where;\n\t\t\t\twhere = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);\n\t\t\t}\n\n\t\t\tconst fieldsSelection: { tsKey: string; value: SQLiteColumn | SQL.Aliased }[] = [];\n\t\t\tlet selectedColumns: string[] = [];\n\n\t\t\t// Figure out which columns to select\n\t\t\tif (config.columns) {\n\t\t\t\tlet isIncludeMode = false;\n\n\t\t\t\tfor (const [field, value] of Object.entries(config.columns)) {\n\t\t\t\t\tif (value === undefined) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (field in tableConfig.columns) {\n\t\t\t\t\t\tif (!isIncludeMode && value === true) {\n\t\t\t\t\t\t\tisIncludeMode = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tselectedColumns.push(field);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (selectedColumns.length > 0) {\n\t\t\t\t\tselectedColumns = isIncludeMode\n\t\t\t\t\t\t? selectedColumns.filter((c) => config.columns?.[c] === true)\n\t\t\t\t\t\t: Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Select all columns if selection is not specified\n\t\t\t\tselectedColumns = Object.keys(tableConfig.columns);\n\t\t\t}\n\n\t\t\tfor (const field of selectedColumns) {\n\t\t\t\tconst column = tableConfig.columns[field]! as SQLiteColumn;\n\t\t\t\tfieldsSelection.push({ tsKey: field, value: column });\n\t\t\t}\n\n\t\t\tlet selectedRelations: {\n\t\t\t\ttsKey: string;\n\t\t\t\tqueryConfig: true | DBQueryConfig<'many', false>;\n\t\t\t\trelation: Relation;\n\t\t\t}[] = [];\n\n\t\t\t// Figure out which relations to select\n\t\t\tif (config.with) {\n\t\t\t\tselectedRelations = Object.entries(config.with)\n\t\t\t\t\t.filter((entry): entry is [typeof entry[0], NonNullable<typeof entry[1]>] => !!entry[1])\n\t\t\t\t\t.map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey]! }));\n\t\t\t}\n\n\t\t\tlet extras;\n\n\t\t\t// Figure out which extras to select\n\t\t\tif (config.extras) {\n\t\t\t\textras = typeof config.extras === 'function'\n\t\t\t\t\t? config.extras(aliasedColumns, { sql })\n\t\t\t\t\t: config.extras;\n\t\t\t\tfor (const [tsKey, value] of Object.entries(extras)) {\n\t\t\t\t\tfieldsSelection.push({\n\t\t\t\t\t\ttsKey,\n\t\t\t\t\t\tvalue: mapColumnsInAliasedSQLToAlias(value, tableAlias),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Transform `fieldsSelection` into `selection`\n\t\t\t// `fieldsSelection` shouldn't be used after this point\n\t\t\tfor (const { tsKey, value } of fieldsSelection) {\n\t\t\t\tselection.push({\n\t\t\t\t\tdbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey]!.name,\n\t\t\t\t\ttsKey,\n\t\t\t\t\tfield: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,\n\t\t\t\t\trelationTableTsKey: undefined,\n\t\t\t\t\tisJson: false,\n\t\t\t\t\tselection: [],\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlet orderByOrig = typeof config.orderBy === 'function'\n\t\t\t\t? config.orderBy(aliasedColumns, getOrderByOperators())\n\t\t\t\t: config.orderBy ?? [];\n\t\t\tif (!Array.isArray(orderByOrig)) {\n\t\t\t\torderByOrig = [orderByOrig];\n\t\t\t}\n\t\t\torderBy = orderByOrig.map((orderByValue) => {\n\t\t\t\tif (is(orderByValue, Column)) {\n\t\t\t\t\treturn aliasedTableColumn(orderByValue, tableAlias) as SQLiteColumn;\n\t\t\t\t}\n\t\t\t\treturn mapColumnsInSQLToAlias(orderByValue, tableAlias);\n\t\t\t});\n\n\t\t\tlimit = config.limit;\n\t\t\toffset = config.offset;\n\n\t\t\t// Process all relations\n\t\t\tfor (\n\t\t\t\tconst {\n\t\t\t\t\ttsKey: selectedRelationTsKey,\n\t\t\t\t\tqueryConfig: selectedRelationConfigValue,\n\t\t\t\t\trelation,\n\t\t\t\t} of selectedRelations\n\t\t\t) {\n\t\t\t\tconst normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);\n\t\t\t\tconst relationTableName = getTableUniqueName(relation.referencedTable);\n\t\t\t\tconst relationTableTsName = tableNamesMap[relationTableName]!;\n\t\t\t\tconst relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;\n\t\t\t\t// const relationTable = schema[relationTableTsName]!;\n\t\t\t\tconst joinOn = and(\n\t\t\t\t\t...normalizedRelation.fields.map((field, i) =>\n\t\t\t\t\t\teq(\n\t\t\t\t\t\t\taliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),\n\t\t\t\t\t\t\taliasedTableColumn(field, tableAlias),\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t\tconst builtRelation = this.buildRelationalQuery({\n\t\t\t\t\tfullSchema,\n\t\t\t\t\tschema,\n\t\t\t\t\ttableNamesMap,\n\t\t\t\t\ttable: fullSchema[relationTableTsName] as SQLiteTable,\n\t\t\t\t\ttableConfig: schema[relationTableTsName]!,\n\t\t\t\t\tqueryConfig: is(relation, One)\n\t\t\t\t\t\t? (selectedRelationConfigValue === true\n\t\t\t\t\t\t\t? { limit: 1 }\n\t\t\t\t\t\t\t: { ...selectedRelationConfigValue, limit: 1 })\n\t\t\t\t\t\t: selectedRelationConfigValue,\n\t\t\t\t\ttableAlias: relationTableAlias,\n\t\t\t\t\tjoinOn,\n\t\t\t\t\tnestedQueryRelation: relation,\n\t\t\t\t});\n\t\t\t\tconst field = (sql`(${builtRelation.sql})`).as(selectedRelationTsKey);\n\t\t\t\tselection.push({\n\t\t\t\t\tdbKey: selectedRelationTsKey,\n\t\t\t\t\ttsKey: selectedRelationTsKey,\n\t\t\t\t\tfield,\n\t\t\t\t\trelationTableTsKey: relationTableTsName,\n\t\t\t\t\tisJson: true,\n\t\t\t\t\tselection: builtRelation.selection,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (selection.length === 0) {\n\t\t\tthrow new DrizzleError({\n\t\t\t\tmessage:\n\t\t\t\t\t`No fields selected for table \"${tableConfig.tsName}\" (\"${tableAlias}\"). You need to have at least one item in \"columns\", \"with\" or \"extras\". If you need to select all columns, omit the \"columns\" key or set it to undefined.`,\n\t\t\t});\n\t\t}\n\n\t\tlet result;\n\n\t\twhere = and(joinOn, where);\n\n\t\tif (nestedQueryRelation) {\n\t\t\tlet field = sql`json_array(${\n\t\t\t\tsql.join(\n\t\t\t\t\tselection.map(({ field }) =>\n\t\t\t\t\t\tis(field, SQLiteColumn)\n\t\t\t\t\t\t\t? sql.identifier(this.casing.getColumnCasing(field))\n\t\t\t\t\t\t\t: is(field, SQL.Aliased)\n\t\t\t\t\t\t\t? field.sql\n\t\t\t\t\t\t\t: field\n\t\t\t\t\t),\n\t\t\t\t\tsql`, `,\n\t\t\t\t)\n\t\t\t})`;\n\t\t\tif (is(nestedQueryRelation, Many)) {\n\t\t\t\tfield = sql`coalesce(json_group_array(${field}), json_array())`;\n\t\t\t}\n\t\t\tconst nestedSelection = [{\n\t\t\t\tdbKey: 'data',\n\t\t\t\ttsKey: 'data',\n\t\t\t\tfield: field.as('data'),\n\t\t\t\tisJson: true,\n\t\t\t\trelationTableTsKey: tableConfig.tsName,\n\t\t\t\tselection,\n\t\t\t}];\n\n\t\t\tconst needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;\n\n\t\t\tif (needsSubquery) {\n\t\t\t\tresult = this.buildSelectQuery({\n\t\t\t\t\ttable: aliasedTable(table, tableAlias),\n\t\t\t\t\tfields: {},\n\t\t\t\t\tfieldsFlat: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpath: [],\n\t\t\t\t\t\t\tfield: sql.raw('*'),\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\twhere,\n\t\t\t\t\tlimit,\n\t\t\t\t\toffset,\n\t\t\t\t\torderBy,\n\t\t\t\t\tsetOperators: [],\n\t\t\t\t});\n\n\t\t\t\twhere = undefined;\n\t\t\t\tlimit = undefined;\n\t\t\t\toffset = undefined;\n\t\t\t\torderBy = undefined;\n\t\t\t} else {\n\t\t\t\tresult = aliasedTable(table, tableAlias);\n\t\t\t}\n\n\t\t\tresult = this.buildSelectQuery({\n\t\t\t\ttable: is(result, SQLiteTable) ? result : new Subquery(result, {}, tableAlias),\n\t\t\t\tfields: {},\n\t\t\t\tfieldsFlat: nestedSelection.map(({ field }) => ({\n\t\t\t\t\tpath: [],\n\t\t\t\t\tfield: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,\n\t\t\t\t})),\n\t\t\t\tjoins,\n\t\t\t\twhere,\n\t\t\t\tlimit,\n\t\t\t\toffset,\n\t\t\t\torderBy,\n\t\t\t\tsetOperators: [],\n\t\t\t});\n\t\t} else {\n\t\t\tresult = this.buildSelectQuery({\n\t\t\t\ttable: aliasedTable(table, tableAlias),\n\t\t\t\tfields: {},\n\t\t\t\tfieldsFlat: selection.map(({ field }) => ({\n\t\t\t\t\tpath: [],\n\t\t\t\t\tfield: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,\n\t\t\t\t})),\n\t\t\t\tjoins,\n\t\t\t\twhere,\n\t\t\t\tlimit,\n\t\t\t\toffset,\n\t\t\t\torderBy,\n\t\t\t\tsetOperators: [],\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\ttableTsKey: tableConfig.tsName,\n\t\t\tsql: result,\n\t\t\tselection,\n\t\t};\n\t}\n}\n\nexport class SQLiteSyncDialect extends SQLiteDialect {\n\tstatic override readonly [entityKind]: string = 'SQLiteSyncDialect';\n\n\tmigrate(\n\t\tmigrations: MigrationMeta[],\n\t\tsession: SQLiteSession<'sync', unknown, Record<string, unknown>, TablesRelationalConfig>,\n\t\tconfig?: string | MigrationConfig,\n\t): void {\n\t\tconst migrationsTable = config === undefined\n\t\t\t? '__drizzle_migrations'\n\t\t\t: typeof config === 'string'\n\t\t\t? '__drizzle_migrations'\n\t\t\t: config.migrationsTable ?? '__drizzle_migrations';\n\n\t\tconst migrationTableCreate = sql`\n\t\t\tCREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (\n\t\t\t\tid SERIAL PRIMARY KEY,\n\t\t\t\thash text NOT NULL,\n\t\t\t\tcreated_at numeric\n\t\t\t)\n\t\t`;\n\t\tsession.run(migrationTableCreate);\n\n\t\tconst dbMigrations = session.values<[number, string, string]>(\n\t\t\tsql`SELECT id, hash, created_at FROM ${sql.identifier(migrationsTable)} ORDER BY created_at DESC LIMIT 1`,\n\t\t);\n\n\t\tconst lastDbMigration = dbMigrations[0] ?? undefined;\n\t\tsession.run(sql`BEGIN`);\n\n\t\ttry {\n\t\t\tfor (const migration of migrations) {\n\t\t\t\tif (!lastDbMigration || Number(lastDbMigration[2])! < migration.folderMillis) {\n\t\t\t\t\tfor (const stmt of migration.sql) {\n\t\t\t\t\t\tsession.run(sql.raw(stmt));\n\t\t\t\t\t}\n\t\t\t\t\tsession.run(\n\t\t\t\t\t\tsql`INSERT INTO ${\n\t\t\t\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t\t\t\t} (\"hash\", \"created_at\") VALUES(${migration.hash}, ${migration.folderMillis})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsession.run(sql`COMMIT`);\n\t\t} catch (e) {\n\t\t\tsession.run(sql`ROLLBACK`);\n\t\t\tthrow e;\n\t\t}\n\t}\n}\n\nexport class SQLiteAsyncDialect extends SQLiteDialect {\n\tstatic override readonly [entityKind]: string = 'SQLiteAsyncDialect';\n\n\tasync migrate(\n\t\tmigrations: MigrationMeta[],\n\t\tsession: SQLiteSession<'async', any, any, any>,\n\t\tconfig?: string | MigrationConfig,\n\t): Promise<void> {\n\t\tconst migrationsTable = config === undefined\n\t\t\t? '__drizzle_migrations'\n\t\t\t: typeof config === 'string'\n\t\t\t? '__drizzle_migrations'\n\t\t\t: config.migrationsTable ?? '__drizzle_migrations';\n\n\t\tconst migrationTableCreate = sql`\n\t\t\tCREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (\n\t\t\t\tid SERIAL PRIMARY KEY,\n\t\t\t\thash text NOT NULL,\n\t\t\t\tcreated_at numeric\n\t\t\t)\n\t\t`;\n\t\tawait session.run(migrationTableCreate);\n\n\t\tconst dbMigrations = await session.values<[number, string, string]>(\n\t\t\tsql`SELECT id, hash, created_at FROM ${sql.identifier(migrationsTable)} ORDER BY created_at DESC LIMIT 1`,\n\t\t);\n\n\t\tconst lastDbMigration = dbMigrations[0] ?? undefined;\n\n\t\tawait session.transaction(async (tx) => {\n\t\t\tfor (const migration of migrations) {\n\t\t\t\tif (!lastDbMigration || Number(lastDbMigration[2])! < migration.folderMillis) {\n\t\t\t\t\tfor (const stmt of migration.sql) {\n\t\t\t\t\t\tawait tx.run(sql.raw(stmt));\n\t\t\t\t\t}\n\t\t\t\t\tawait tx.run(\n\t\t\t\t\t\tsql`INSERT INTO ${\n\t\t\t\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t\t\t\t} (\"hash\", \"created_at\") VALUES(${migration.hash}, ${migration.folderMillis})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n", "import type { Column } from '~/column.ts';\nimport { entityKind } from './entity.ts';\nimport { Table } from './table.ts';\nimport type { Casing } from './utils.ts';\n\nexport function toSnakeCase(input: string) {\n\tconst words = input\n\t\t.replace(/['\\u2019]/g, '')\n\t\t.match(/[\\da-z]+|[A-Z]+(?![a-z])|[A-Z][\\da-z]+/g) ?? [];\n\n\treturn words.map((word) => word.toLowerCase()).join('_');\n}\n\nexport function toCamelCase(input: string) {\n\tconst words = input\n\t\t.replace(/['\\u2019]/g, '')\n\t\t.match(/[\\da-z]+|[A-Z]+(?![a-z])|[A-Z][\\da-z]+/g) ?? [];\n\n\treturn words.reduce((acc, word, i) => {\n\t\tconst formattedWord = i === 0 ? word.toLowerCase() : `${word[0]!.toUpperCase()}${word.slice(1)}`;\n\t\treturn acc + formattedWord;\n\t}, '');\n}\n\nfunction noopCase(input: string) {\n\treturn input;\n}\n\nexport class CasingCache {\n\tstatic readonly [entityKind]: string = 'CasingCache';\n\n\t/** @internal */\n\tcache: Record<string, string> = {};\n\tprivate cachedTables: Record<string, true> = {};\n\tprivate convert: (input: string) => string;\n\n\tconstructor(casing?: Casing) {\n\t\tthis.convert = casing === 'snake_case'\n\t\t\t? toSnakeCase\n\t\t\t: casing === 'camelCase'\n\t\t\t? toCamelCase\n\t\t\t: noopCase;\n\t}\n\n\tgetColumnCasing(column: Column): string {\n\t\tif (!column.keyAsName) return column.name;\n\n\t\tconst schema = column.table[Table.Symbol.Schema] ?? 'public';\n\t\tconst tableName = column.table[Table.Symbol.OriginalName];\n\t\tconst key = `${schema}.${tableName}.${column.name}`;\n\n\t\tif (!this.cache[key]) {\n\t\t\tthis.cacheTable(column.table);\n\t\t}\n\t\treturn this.cache[key]!;\n\t}\n\n\tprivate cacheTable(table: Table) {\n\t\tconst schema = table[Table.Symbol.Schema] ?? 'public';\n\t\tconst tableName = table[Table.Symbol.OriginalName];\n\t\tconst tableKey = `${schema}.${tableName}`;\n\n\t\tif (!this.cachedTables[tableKey]) {\n\t\t\tfor (const column of Object.values(table[Table.Symbol.Columns])) {\n\t\t\t\tconst columnKey = `${tableKey}.${column.name}`;\n\t\t\t\tthis.cache[columnKey] = this.convert(column.name);\n\t\t\t}\n\t\t\tthis.cachedTables[tableKey] = true;\n\t\t}\n\t}\n\n\tclearCache() {\n\t\tthis.cache = {};\n\t\tthis.cachedTables = {};\n\t}\n}\n", "import { entityKind } from '~/entity.ts';\n\nexport class DrizzleError extends Error {\n\tstatic readonly [entityKind]: string = 'DrizzleError';\n\n\tconstructor({ message, cause }: { message?: string; cause?: unknown }) {\n\t\tsuper(message);\n\t\tthis.name = 'DrizzleError';\n\t\tthis.cause = cause;\n\t}\n}\n\nexport class TransactionRollbackError extends DrizzleError {\n\tstatic override readonly [entityKind]: string = 'TransactionRollbackError';\n\n\tconstructor() {\n\t\tsuper({ message: 'Rollback' });\n\t}\n}\n", "import { entityKind } from '~/entity.ts';\nimport type { ColumnsSelection } from '~/sql/sql.ts';\nimport { View } from '~/sql/sql.ts';\n\nexport abstract class SQLiteViewBase<\n\tTName extends string = string,\n\tTExisting extends boolean = boolean,\n\tTSelection extends ColumnsSelection = ColumnsSelection,\n> extends View<TName, TExisting, TSelection> {\n\tstatic override readonly [entityKind]: string = 'SQLiteViewBase';\n\n\tdeclare _: View<TName, TExisting, TSelection>['_'] & {\n\t\tviewBrand: 'SQLiteView';\n\t};\n}\n", "import { entityKind, is } from '~/entity.ts';\nimport { TypedQueryBuilder } from '~/query-builders/query-builder.ts';\nimport type {\n\tBuildSubquerySelection,\n\tGetSelectTableName,\n\tGetSelectTableSelection,\n\tJoinNullability,\n\tJoinType,\n\tSelectMode,\n\tSelectResult,\n\tSetOperator,\n} from '~/query-builders/select.types.ts';\nimport { QueryPromise } from '~/query-promise.ts';\nimport type { RunnableQuery } from '~/runnable-query.ts';\nimport { SelectionProxyHandler } from '~/selection-proxy.ts';\nimport { SQL, View } from '~/sql/sql.ts';\nimport type { ColumnsSelection, Placeholder, Query, SQLWrapper } from '~/sql/sql.ts';\nimport type { SQLiteColumn } from '~/sqlite-core/columns/index.ts';\nimport type { SQLiteDialect } from '~/sqlite-core/dialect.ts';\nimport type { SQLiteSession } from '~/sqlite-core/session.ts';\nimport type { SubqueryWithSelection } from '~/sqlite-core/subquery.ts';\nimport type { SQLiteTable } from '~/sqlite-core/table.ts';\nimport { Subquery } from '~/subquery.ts';\nimport { Table } from '~/table.ts';\nimport {\n\tapplyMixins,\n\tgetTableColumns,\n\tgetTableLikeName,\n\thaveSameKeys,\n\torderSelectedFields,\n\ttype ValueOrArray,\n} from '~/utils.ts';\nimport { ViewBaseConfig } from '~/view-common.ts';\nimport { SQLiteViewBase } from '../view-base.ts';\nimport type {\n\tAnySQLiteSelect,\n\tCreateSQLiteSelectFromBuilderMode,\n\tGetSQLiteSetOperators,\n\tSelectedFields,\n\tSetOperatorRightSelect,\n\tSQLiteCreateSetOperatorFn,\n\tSQLiteSelectConfig,\n\tSQLiteSelectDynamic,\n\tSQLiteSelectExecute,\n\tSQLiteSelectHKT,\n\tSQLiteSelectHKTBase,\n\tSQLiteSelectJoinFn,\n\tSQLiteSelectPrepare,\n\tSQLiteSelectWithout,\n\tSQLiteSetOperatorExcludedMethods,\n\tSQLiteSetOperatorWithResult,\n} from './select.types.ts';\n\nexport class SQLiteSelectBuilder<\n\tTSelection extends SelectedFields | undefined,\n\tTResultType extends 'sync' | 'async',\n\tTRunResult,\n\tTBuilderMode extends 'db' | 'qb' = 'db',\n> {\n\tstatic readonly [entityKind]: string = 'SQLiteSelectBuilder';\n\n\tprivate fields: TSelection;\n\tprivate session: SQLiteSession<any, any, any, any> | undefined;\n\tprivate dialect: SQLiteDialect;\n\tprivate withList: Subquery[] | undefined;\n\tprivate distinct: boolean | undefined;\n\n\tconstructor(\n\t\tconfig: {\n\t\t\tfields: TSelection;\n\t\t\tsession: SQLiteSession<any, any, any, any> | undefined;\n\t\t\tdialect: SQLiteDialect;\n\t\t\twithList?: Subquery[];\n\t\t\tdistinct?: boolean;\n\t\t},\n\t) {\n\t\tthis.fields = config.fields;\n\t\tthis.session = config.session;\n\t\tthis.dialect = config.dialect;\n\t\tthis.withList = config.withList;\n\t\tthis.distinct = config.distinct;\n\t}\n\n\tfrom<TFrom extends SQLiteTable | Subquery | SQLiteViewBase | SQL>(\n\t\tsource: TFrom,\n\t): CreateSQLiteSelectFromBuilderMode<\n\t\tTBuilderMode,\n\t\tGetSelectTableName<TFrom>,\n\t\tTResultType,\n\t\tTRunResult,\n\t\tTSelection extends undefined ? GetSelectTableSelection<TFrom> : TSelection,\n\t\tTSelection extends undefined ? 'single' : 'partial'\n\t> {\n\t\tconst isPartialSelect = !!this.fields;\n\n\t\tlet fields: SelectedFields;\n\t\tif (this.fields) {\n\t\t\tfields = this.fields;\n\t\t} else if (is(source, Subquery)) {\n\t\t\t// This is required to use the proxy handler to get the correct field values from the subquery\n\t\t\tfields = Object.fromEntries(\n\t\t\t\tObject.keys(source._.selectedFields).map((\n\t\t\t\t\tkey,\n\t\t\t\t) => [key, source[key as unknown as keyof typeof source] as unknown as SelectedFields[string]]),\n\t\t\t);\n\t\t} else if (is(source, SQLiteViewBase)) {\n\t\t\tfields = source[ViewBaseConfig].selectedFields as SelectedFields;\n\t\t} else if (is(source, SQL)) {\n\t\t\tfields = {};\n\t\t} else {\n\t\t\tfields = getTableColumns<SQLiteTable>(source);\n\t\t}\n\n\t\treturn new SQLiteSelectBase({\n\t\t\ttable: source,\n\t\t\tfields,\n\t\t\tisPartialSelect,\n\t\t\tsession: this.session,\n\t\t\tdialect: this.dialect,\n\t\t\twithList: this.withList,\n\t\t\tdistinct: this.distinct,\n\t\t}) as any;\n\t}\n}\n\nexport abstract class SQLiteSelectQueryBuilderBase<\n\tTHKT extends SQLiteSelectHKTBase,\n\tTTableName extends string | undefined,\n\tTResultType extends 'sync' | 'async',\n\tTRunResult,\n\tTSelection extends ColumnsSelection,\n\tTSelectMode extends SelectMode,\n\tTNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'>\n\t\t: {},\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n\tTResult extends any[] = SelectResult<TSelection, TSelectMode, TNullabilityMap>[],\n\tTSelectedFields extends ColumnsSelection = BuildSubquerySelection<TSelection, TNullabilityMap>,\n> extends TypedQueryBuilder<TSelectedFields, TResult> {\n\tstatic override readonly [entityKind]: string = 'SQLiteSelectQueryBuilder';\n\n\toverride readonly _: {\n\t\treadonly dialect: 'sqlite';\n\t\treadonly hkt: THKT;\n\t\treadonly tableName: TTableName;\n\t\treadonly resultType: TResultType;\n\t\treadonly runResult: TRunResult;\n\t\treadonly selection: TSelection;\n\t\treadonly selectMode: TSelectMode;\n\t\treadonly nullabilityMap: TNullabilityMap;\n\t\treadonly dynamic: TDynamic;\n\t\treadonly excludedMethods: TExcludedMethods;\n\t\treadonly result: TResult;\n\t\treadonly selectedFields: TSelectedFields;\n\t};\n\n\t/** @internal */\n\tconfig: SQLiteSelectConfig;\n\tprotected joinsNotNullableMap: Record<string, boolean>;\n\tprivate tableName: string | undefined;\n\tprivate isPartialSelect: boolean;\n\tprotected session: SQLiteSession<any, any, any, any> | undefined;\n\tprotected dialect: SQLiteDialect;\n\n\tconstructor(\n\t\t{ table, fields, isPartialSelect, session, dialect, withList, distinct }: {\n\t\t\ttable: SQLiteSelectConfig['table'];\n\t\t\tfields: SQLiteSelectConfig['fields'];\n\t\t\tisPartialSelect: boolean;\n\t\t\tsession: SQLiteSession<any, any, any, any> | undefined;\n\t\t\tdialect: SQLiteDialect;\n\t\t\twithList: Subquery[] | undefined;\n\t\t\tdistinct: boolean | undefined;\n\t\t},\n\t) {\n\t\tsuper();\n\t\tthis.config = {\n\t\t\twithList,\n\t\t\ttable,\n\t\t\tfields: { ...fields },\n\t\t\tdistinct,\n\t\t\tsetOperators: [],\n\t\t};\n\t\tthis.isPartialSelect = isPartialSelect;\n\t\tthis.session = session;\n\t\tthis.dialect = dialect;\n\t\tthis._ = {\n\t\t\tselectedFields: fields as TSelectedFields,\n\t\t} as this['_'];\n\t\tthis.tableName = getTableLikeName(table);\n\t\tthis.joinsNotNullableMap = typeof this.tableName === 'string' ? { [this.tableName]: true } : {};\n\t}\n\n\tprivate createJoin<TJoinType extends JoinType>(\n\t\tjoinType: TJoinType,\n\t): SQLiteSelectJoinFn<this, TDynamic, TJoinType> {\n\t\treturn (\n\t\t\ttable: SQLiteTable | Subquery | SQLiteViewBase | SQL,\n\t\t\ton: ((aliases: TSelection) => SQL | undefined) | SQL | undefined,\n\t\t) => {\n\t\t\tconst baseTableName = this.tableName;\n\t\t\tconst tableName = getTableLikeName(table);\n\n\t\t\tif (typeof tableName === 'string' && this.config.joins?.some((join) => join.alias === tableName)) {\n\t\t\t\tthrow new Error(`Alias \"${tableName}\" is already used in this query`);\n\t\t\t}\n\n\t\t\tif (!this.isPartialSelect) {\n\t\t\t\t// If this is the first join and this is not a partial select and we're not selecting from raw SQL, \"move\" the fields from the main table to the nested object\n\t\t\t\tif (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === 'string') {\n\t\t\t\t\tthis.config.fields = {\n\t\t\t\t\t\t[baseTableName]: this.config.fields,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (typeof tableName === 'string' && !is(table, SQL)) {\n\t\t\t\t\tconst selection = is(table, Subquery)\n\t\t\t\t\t\t? table._.selectedFields\n\t\t\t\t\t\t: is(table, View)\n\t\t\t\t\t\t? table[ViewBaseConfig].selectedFields\n\t\t\t\t\t\t: table[Table.Symbol.Columns];\n\t\t\t\t\tthis.config.fields[tableName] = selection;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (typeof on === 'function') {\n\t\t\t\ton = on(\n\t\t\t\t\tnew Proxy(\n\t\t\t\t\t\tthis.config.fields,\n\t\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' }),\n\t\t\t\t\t) as TSelection,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (!this.config.joins) {\n\t\t\t\tthis.config.joins = [];\n\t\t\t}\n\t\t\tthis.config.joins.push({ on, table, joinType, alias: tableName });\n\n\t\t\tif (typeof tableName === 'string') {\n\t\t\t\tswitch (joinType) {\n\t\t\t\t\tcase 'left': {\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'right': {\n\t\t\t\t\t\tthis.joinsNotNullableMap = Object.fromEntries(\n\t\t\t\t\t\t\tObject.entries(this.joinsNotNullableMap).map(([key]) => [key, false]),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'inner': {\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'full': {\n\t\t\t\t\t\tthis.joinsNotNullableMap = Object.fromEntries(\n\t\t\t\t\t\t\tObject.entries(this.joinsNotNullableMap).map(([key]) => [key, false]),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this as any;\n\t\t};\n\t}\n\n\t/**\n\t * Executes a `left join` operation by adding another table to the current query.\n\t *\n\t * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#left-join}\n\t *\n\t * @param table the table to join.\n\t * @param on the `on` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all users and their pets\n\t * const usersWithPets: { user: User; pets: Pet | null }[] = await db.select()\n\t *   .from(users)\n\t *   .leftJoin(pets, eq(users.id, pets.ownerId))\n\t *\n\t * // Select userId and petId\n\t * const usersIdsAndPetIds: { userId: number; petId: number | null }[] = await db.select({\n\t *   userId: users.id,\n\t *   petId: pets.id,\n\t * })\n\t *   .from(users)\n\t *   .leftJoin(pets, eq(users.id, pets.ownerId))\n\t * ```\n\t */\n\tleftJoin = this.createJoin('left');\n\n\t/**\n\t * Executes a `right join` operation by adding another table to the current query.\n\t *\n\t * Calling this method associates each row of the joined table with the corresponding row from the main table, if a match is found. If no matching row exists, it sets all columns of the main table to null.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#right-join}\n\t *\n\t * @param table the table to join.\n\t * @param on the `on` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all users and their pets\n\t * const usersWithPets: { user: User | null; pets: Pet }[] = await db.select()\n\t *   .from(users)\n\t *   .rightJoin(pets, eq(users.id, pets.ownerId))\n\t *\n\t * // Select userId and petId\n\t * const usersIdsAndPetIds: { userId: number | null; petId: number }[] = await db.select({\n\t *   userId: users.id,\n\t *   petId: pets.id,\n\t * })\n\t *   .from(users)\n\t *   .rightJoin(pets, eq(users.id, pets.ownerId))\n\t * ```\n\t */\n\trightJoin = this.createJoin('right');\n\n\t/**\n\t * Executes an `inner join` operation, creating a new table by combining rows from two tables that have matching values.\n\t *\n\t * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join}\n\t *\n\t * @param table the table to join.\n\t * @param on the `on` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all users and their pets\n\t * const usersWithPets: { user: User; pets: Pet }[] = await db.select()\n\t *   .from(users)\n\t *   .innerJoin(pets, eq(users.id, pets.ownerId))\n\t *\n\t * // Select userId and petId\n\t * const usersIdsAndPetIds: { userId: number; petId: number }[] = await db.select({\n\t *   userId: users.id,\n\t *   petId: pets.id,\n\t * })\n\t *   .from(users)\n\t *   .innerJoin(pets, eq(users.id, pets.ownerId))\n\t * ```\n\t */\n\tinnerJoin = this.createJoin('inner');\n\n\t/**\n\t * Executes a `full join` operation by combining rows from two tables into a new table.\n\t *\n\t * Calling this method retrieves all rows from both main and joined tables, merging rows with matching values and filling in `null` for non-matching columns.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#full-join}\n\t *\n\t * @param table the table to join.\n\t * @param on the `on` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all users and their pets\n\t * const usersWithPets: { user: User | null; pets: Pet | null }[] = await db.select()\n\t *   .from(users)\n\t *   .fullJoin(pets, eq(users.id, pets.ownerId))\n\t *\n\t * // Select userId and petId\n\t * const usersIdsAndPetIds: { userId: number | null; petId: number | null }[] = await db.select({\n\t *   userId: users.id,\n\t *   petId: pets.id,\n\t * })\n\t *   .from(users)\n\t *   .fullJoin(pets, eq(users.id, pets.ownerId))\n\t * ```\n\t */\n\tfullJoin = this.createJoin('full');\n\n\tprivate createSetOperator(\n\t\ttype: SetOperator,\n\t\tisAll: boolean,\n\t): <TValue extends SQLiteSetOperatorWithResult<TResult>>(\n\t\trightSelection:\n\t\t\t| ((setOperators: GetSQLiteSetOperators) => SetOperatorRightSelect<TValue, TResult>)\n\t\t\t| SetOperatorRightSelect<TValue, TResult>,\n\t) => SQLiteSelectWithout<\n\t\tthis,\n\t\tTDynamic,\n\t\tSQLiteSetOperatorExcludedMethods,\n\t\ttrue\n\t> {\n\t\treturn (rightSelection) => {\n\t\t\tconst rightSelect = (typeof rightSelection === 'function'\n\t\t\t\t? rightSelection(getSQLiteSetOperators())\n\t\t\t\t: rightSelection) as TypedQueryBuilder<\n\t\t\t\t\tany,\n\t\t\t\t\tTResult\n\t\t\t\t>;\n\n\t\t\tif (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Set operator error (union / intersect / except): selected fields are not the same or are in a different order',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.config.setOperators.push({ type, isAll, rightSelect });\n\t\t\treturn this as any;\n\t\t};\n\t}\n\n\t/**\n\t * Adds `union` set operator to the query.\n\t *\n\t * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all unique names from customers and users tables\n\t * await db.select({ name: users.name })\n\t *   .from(users)\n\t *   .union(\n\t *     db.select({ name: customers.name }).from(customers)\n\t *   );\n\t * // or\n\t * import { union } from 'drizzle-orm/sqlite-core'\n\t *\n\t * await union(\n\t *   db.select({ name: users.name }).from(users),\n\t *   db.select({ name: customers.name }).from(customers)\n\t * );\n\t * ```\n\t */\n\tunion = this.createSetOperator('union', false);\n\n\t/**\n\t * Adds `union all` set operator to the query.\n\t *\n\t * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all transaction ids from both online and in-store sales\n\t * await db.select({ transaction: onlineSales.transactionId })\n\t *   .from(onlineSales)\n\t *   .unionAll(\n\t *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n\t *   );\n\t * // or\n\t * import { unionAll } from 'drizzle-orm/sqlite-core'\n\t *\n\t * await unionAll(\n\t *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),\n\t *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n\t * );\n\t * ```\n\t */\n\tunionAll = this.createSetOperator('union', true);\n\n\t/**\n\t * Adds `intersect` set operator to the query.\n\t *\n\t * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select course names that are offered in both departments A and B\n\t * await db.select({ courseName: depA.courseName })\n\t *   .from(depA)\n\t *   .intersect(\n\t *     db.select({ courseName: depB.courseName }).from(depB)\n\t *   );\n\t * // or\n\t * import { intersect } from 'drizzle-orm/sqlite-core'\n\t *\n\t * await intersect(\n\t *   db.select({ courseName: depA.courseName }).from(depA),\n\t *   db.select({ courseName: depB.courseName }).from(depB)\n\t * );\n\t * ```\n\t */\n\tintersect = this.createSetOperator('intersect', false);\n\n\t/**\n\t * Adds `except` set operator to the query.\n\t *\n\t * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all courses offered in department A but not in department B\n\t * await db.select({ courseName: depA.courseName })\n\t *   .from(depA)\n\t *   .except(\n\t *     db.select({ courseName: depB.courseName }).from(depB)\n\t *   );\n\t * // or\n\t * import { except } from 'drizzle-orm/sqlite-core'\n\t *\n\t * await except(\n\t *   db.select({ courseName: depA.courseName }).from(depA),\n\t *   db.select({ courseName: depB.courseName }).from(depB)\n\t * );\n\t * ```\n\t */\n\texcept = this.createSetOperator('except', false);\n\n\t/** @internal */\n\taddSetOperators(setOperators: SQLiteSelectConfig['setOperators']): SQLiteSelectWithout<\n\t\tthis,\n\t\tTDynamic,\n\t\tSQLiteSetOperatorExcludedMethods,\n\t\ttrue\n\t> {\n\t\tthis.config.setOperators.push(...setOperators);\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `where` clause to the query.\n\t *\n\t * Calling this method will select only those rows that fulfill a specified condition.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#filtering}\n\t *\n\t * @param where the `where` clause.\n\t *\n\t * @example\n\t * You can use conditional operators and `sql function` to filter the rows to be selected.\n\t *\n\t * ```ts\n\t * // Select all cars with green color\n\t * await db.select().from(cars).where(eq(cars.color, 'green'));\n\t * // or\n\t * await db.select().from(cars).where(sql`${cars.color} = 'green'`)\n\t * ```\n\t *\n\t * You can logically combine conditional operators with `and()` and `or()` operators:\n\t *\n\t * ```ts\n\t * // Select all BMW cars with a green color\n\t * await db.select().from(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));\n\t *\n\t * // Select all cars with the green or blue color\n\t * await db.select().from(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));\n\t * ```\n\t */\n\twhere(\n\t\twhere: ((aliases: TSelection) => SQL | undefined) | SQL | undefined,\n\t): SQLiteSelectWithout<this, TDynamic, 'where'> {\n\t\tif (typeof where === 'function') {\n\t\t\twhere = where(\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.fields,\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' }),\n\t\t\t\t) as TSelection,\n\t\t\t);\n\t\t}\n\t\tthis.config.where = where;\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `having` clause to the query.\n\t *\n\t * Calling this method will select only those rows that fulfill a specified condition. It is typically used with aggregate functions to filter the aggregated data based on a specified condition.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}\n\t *\n\t * @param having the `having` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all brands with more than one car\n\t * await db.select({\n\t * \tbrand: cars.brand,\n\t * \tcount: sql<number>`cast(count(${cars.id}) as int)`,\n\t * })\n\t *   .from(cars)\n\t *   .groupBy(cars.brand)\n\t *   .having(({ count }) => gt(count, 1));\n\t * ```\n\t */\n\thaving(\n\t\thaving: ((aliases: this['_']['selection']) => SQL | undefined) | SQL | undefined,\n\t): SQLiteSelectWithout<this, TDynamic, 'having'> {\n\t\tif (typeof having === 'function') {\n\t\t\thaving = having(\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.fields,\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' }),\n\t\t\t\t) as TSelection,\n\t\t\t);\n\t\t}\n\t\tthis.config.having = having;\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `group by` clause to the query.\n\t *\n\t * Calling this method will group rows that have the same values into summary rows, often used for aggregation purposes.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Group and count people by their last names\n\t * await db.select({\n\t *    lastName: people.lastName,\n\t *    count: sql<number>`cast(count(*) as int)`\n\t * })\n\t *   .from(people)\n\t *   .groupBy(people.lastName);\n\t * ```\n\t */\n\tgroupBy(\n\t\tbuilder: (aliases: this['_']['selection']) => ValueOrArray<SQLiteColumn | SQL | SQL.Aliased>,\n\t): SQLiteSelectWithout<this, TDynamic, 'groupBy'>;\n\tgroupBy(...columns: (SQLiteColumn | SQL)[]): SQLiteSelectWithout<this, TDynamic, 'groupBy'>;\n\tgroupBy(\n\t\t...columns:\n\t\t\t| [(aliases: this['_']['selection']) => ValueOrArray<SQLiteColumn | SQL | SQL.Aliased>]\n\t\t\t| (SQLiteColumn | SQL | SQL.Aliased)[]\n\t): SQLiteSelectWithout<this, TDynamic, 'groupBy'> {\n\t\tif (typeof columns[0] === 'function') {\n\t\t\tconst groupBy = columns[0](\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.fields,\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' }),\n\t\t\t\t) as TSelection,\n\t\t\t);\n\t\t\tthis.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];\n\t\t} else {\n\t\t\tthis.config.groupBy = columns as (SQLiteColumn | SQL | SQL.Aliased)[];\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds an `order by` clause to the query.\n\t *\n\t * Calling this method will sort the result-set in ascending or descending order. By default, the sort order is ascending.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#order-by}\n\t *\n\t * @example\n\t *\n\t * ```\n\t * // Select cars ordered by year\n\t * await db.select().from(cars).orderBy(cars.year);\n\t * ```\n\t *\n\t * You can specify whether results are in ascending or descending order with the `asc()` and `desc()` operators.\n\t *\n\t * ```ts\n\t * // Select cars ordered by year in descending order\n\t * await db.select().from(cars).orderBy(desc(cars.year));\n\t *\n\t * // Select cars ordered by year and price\n\t * await db.select().from(cars).orderBy(asc(cars.year), desc(cars.price));\n\t * ```\n\t */\n\torderBy(\n\t\tbuilder: (aliases: this['_']['selection']) => ValueOrArray<SQLiteColumn | SQL | SQL.Aliased>,\n\t): SQLiteSelectWithout<this, TDynamic, 'orderBy'>;\n\torderBy(...columns: (SQLiteColumn | SQL)[]): SQLiteSelectWithout<this, TDynamic, 'orderBy'>;\n\torderBy(\n\t\t...columns:\n\t\t\t| [(aliases: this['_']['selection']) => ValueOrArray<SQLiteColumn | SQL | SQL.Aliased>]\n\t\t\t| (SQLiteColumn | SQL | SQL.Aliased)[]\n\t): SQLiteSelectWithout<this, TDynamic, 'orderBy'> {\n\t\tif (typeof columns[0] === 'function') {\n\t\t\tconst orderBy = columns[0](\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.fields,\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' }),\n\t\t\t\t) as TSelection,\n\t\t\t);\n\n\t\t\tconst orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];\n\n\t\t\tif (this.config.setOperators.length > 0) {\n\t\t\t\tthis.config.setOperators.at(-1)!.orderBy = orderByArray;\n\t\t\t} else {\n\t\t\t\tthis.config.orderBy = orderByArray;\n\t\t\t}\n\t\t} else {\n\t\t\tconst orderByArray = columns as (SQLiteColumn | SQL | SQL.Aliased)[];\n\n\t\t\tif (this.config.setOperators.length > 0) {\n\t\t\t\tthis.config.setOperators.at(-1)!.orderBy = orderByArray;\n\t\t\t} else {\n\t\t\t\tthis.config.orderBy = orderByArray;\n\t\t\t}\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `limit` clause to the query.\n\t *\n\t * Calling this method will set the maximum number of rows that will be returned by this query.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}\n\t *\n\t * @param limit the `limit` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Get the first 10 people from this query.\n\t * await db.select().from(people).limit(10);\n\t * ```\n\t */\n\tlimit(limit: number | Placeholder): SQLiteSelectWithout<this, TDynamic, 'limit'> {\n\t\tif (this.config.setOperators.length > 0) {\n\t\t\tthis.config.setOperators.at(-1)!.limit = limit;\n\t\t} else {\n\t\t\tthis.config.limit = limit;\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds an `offset` clause to the query.\n\t *\n\t * Calling this method will skip a number of rows when returning results from this query.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}\n\t *\n\t * @param offset the `offset` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Get the 10th-20th people from this query.\n\t * await db.select().from(people).offset(10).limit(10);\n\t * ```\n\t */\n\toffset(offset: number | Placeholder): SQLiteSelectWithout<this, TDynamic, 'offset'> {\n\t\tif (this.config.setOperators.length > 0) {\n\t\t\tthis.config.setOperators.at(-1)!.offset = offset;\n\t\t} else {\n\t\t\tthis.config.offset = offset;\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/** @internal */\n\tgetSQL(): SQL {\n\t\treturn this.dialect.buildSelectQuery(this.config);\n\t}\n\n\ttoSQL(): Query {\n\t\tconst { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n\t\treturn rest;\n\t}\n\n\tas<TAlias extends string>(\n\t\talias: TAlias,\n\t): SubqueryWithSelection<this['_']['selectedFields'], TAlias> {\n\t\treturn new Proxy(\n\t\t\tnew Subquery(this.getSQL(), this.config.fields, alias),\n\t\t\tnew SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }),\n\t\t) as SubqueryWithSelection<this['_']['selectedFields'], TAlias>;\n\t}\n\n\t/** @internal */\n\toverride getSelectedFields(): this['_']['selectedFields'] {\n\t\treturn new Proxy(\n\t\t\tthis.config.fields,\n\t\t\tnew SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }),\n\t\t) as this['_']['selectedFields'];\n\t}\n\n\t$dynamic(): SQLiteSelectDynamic<this> {\n\t\treturn this;\n\t}\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface SQLiteSelectBase<\n\tTTableName extends string | undefined,\n\tTResultType extends 'sync' | 'async',\n\tTRunResult,\n\tTSelection extends ColumnsSelection,\n\tTSelectMode extends SelectMode = 'single',\n\tTNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'>\n\t\t: {},\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n\tTResult extends any[] = SelectResult<TSelection, TSelectMode, TNullabilityMap>[],\n\tTSelectedFields extends ColumnsSelection = BuildSubquerySelection<TSelection, TNullabilityMap>,\n> extends\n\tSQLiteSelectQueryBuilderBase<\n\t\tSQLiteSelectHKT,\n\t\tTTableName,\n\t\tTResultType,\n\t\tTRunResult,\n\t\tTSelection,\n\t\tTSelectMode,\n\t\tTNullabilityMap,\n\t\tTDynamic,\n\t\tTExcludedMethods,\n\t\tTResult,\n\t\tTSelectedFields\n\t>,\n\tQueryPromise<TResult>\n{}\n\nexport class SQLiteSelectBase<\n\tTTableName extends string | undefined,\n\tTResultType extends 'sync' | 'async',\n\tTRunResult,\n\tTSelection,\n\tTSelectMode extends SelectMode = 'single',\n\tTNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'>\n\t\t: {},\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n\tTResult = SelectResult<TSelection, TSelectMode, TNullabilityMap>[],\n\tTSelectedFields extends ColumnsSelection = BuildSubquerySelection<TSelection, TNullabilityMap>,\n> extends SQLiteSelectQueryBuilderBase<\n\tSQLiteSelectHKT,\n\tTTableName,\n\tTResultType,\n\tTRunResult,\n\tTSelection,\n\tTSelectMode,\n\tTNullabilityMap,\n\tTDynamic,\n\tTExcludedMethods,\n\tTResult,\n\tTSelectedFields\n> implements RunnableQuery<TResult, 'sqlite'>, SQLWrapper {\n\tstatic override readonly [entityKind]: string = 'SQLiteSelect';\n\n\t/** @internal */\n\t_prepare(isOneTimeQuery = true): SQLiteSelectPrepare<this> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Cannot execute a query on a query builder. Please use a database instance instead.');\n\t\t}\n\t\tconst fieldsList = orderSelectedFields<SQLiteColumn>(this.config.fields);\n\t\tconst query = this.session[isOneTimeQuery ? 'prepareOneTimeQuery' : 'prepareQuery'](\n\t\t\tthis.dialect.sqlToQuery(this.getSQL()),\n\t\t\tfieldsList,\n\t\t\t'all',\n\t\t\ttrue,\n\t\t);\n\t\tquery.joinsNotNullableMap = this.joinsNotNullableMap;\n\t\treturn query as ReturnType<this['prepare']>;\n\t}\n\n\tprepare(): SQLiteSelectPrepare<this> {\n\t\treturn this._prepare(false);\n\t}\n\n\trun: ReturnType<this['prepare']>['run'] = (placeholderValues) => {\n\t\treturn this._prepare().run(placeholderValues);\n\t};\n\n\tall: ReturnType<this['prepare']>['all'] = (placeholderValues) => {\n\t\treturn this._prepare().all(placeholderValues);\n\t};\n\n\tget: ReturnType<this['prepare']>['get'] = (placeholderValues) => {\n\t\treturn this._prepare().get(placeholderValues);\n\t};\n\n\tvalues: ReturnType<this['prepare']>['values'] = (placeholderValues) => {\n\t\treturn this._prepare().values(placeholderValues);\n\t};\n\n\tasync execute(): Promise<SQLiteSelectExecute<this>> {\n\t\treturn this.all() as SQLiteSelectExecute<this>;\n\t}\n}\n\napplyMixins(SQLiteSelectBase, [QueryPromise]);\n\nfunction createSetOperator(type: SetOperator, isAll: boolean): SQLiteCreateSetOperatorFn {\n\treturn (leftSelect, rightSelect, ...restSelects) => {\n\t\tconst setOperators = [rightSelect, ...restSelects].map((select) => ({\n\t\t\ttype,\n\t\t\tisAll,\n\t\t\trightSelect: select as AnySQLiteSelect,\n\t\t}));\n\n\t\tfor (const setOperator of setOperators) {\n\t\t\tif (!haveSameKeys((leftSelect as any).getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Set operator error (union / intersect / except): selected fields are not the same or are in a different order',\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn (leftSelect as AnySQLiteSelect).addSetOperators(setOperators) as any;\n\t};\n}\n\nconst getSQLiteSetOperators = () => ({\n\tunion,\n\tunionAll,\n\tintersect,\n\texcept,\n});\n\n/**\n * Adds `union` set operator to the query.\n *\n * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}\n *\n * @example\n *\n * ```ts\n * // Select all unique names from customers and users tables\n * import { union } from 'drizzle-orm/sqlite-core'\n *\n * await union(\n *   db.select({ name: users.name }).from(users),\n *   db.select({ name: customers.name }).from(customers)\n * );\n * // or\n * await db.select({ name: users.name })\n *   .from(users)\n *   .union(\n *     db.select({ name: customers.name }).from(customers)\n *   );\n * ```\n */\nexport const union = createSetOperator('union', false);\n\n/**\n * Adds `union all` set operator to the query.\n *\n * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}\n *\n * @example\n *\n * ```ts\n * // Select all transaction ids from both online and in-store sales\n * import { unionAll } from 'drizzle-orm/sqlite-core'\n *\n * await unionAll(\n *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),\n *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n * );\n * // or\n * await db.select({ transaction: onlineSales.transactionId })\n *   .from(onlineSales)\n *   .unionAll(\n *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n *   );\n * ```\n */\nexport const unionAll = createSetOperator('union', true);\n\n/**\n * Adds `intersect` set operator to the query.\n *\n * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}\n *\n * @example\n *\n * ```ts\n * // Select course names that are offered in both departments A and B\n * import { intersect } from 'drizzle-orm/sqlite-core'\n *\n * await intersect(\n *   db.select({ courseName: depA.courseName }).from(depA),\n *   db.select({ courseName: depB.courseName }).from(depB)\n * );\n * // or\n * await db.select({ courseName: depA.courseName })\n *   .from(depA)\n *   .intersect(\n *     db.select({ courseName: depB.courseName }).from(depB)\n *   );\n * ```\n */\nexport const intersect = createSetOperator('intersect', false);\n\n/**\n * Adds `except` set operator to the query.\n *\n * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}\n *\n * @example\n *\n * ```ts\n * // Select all courses offered in department A but not in department B\n * import { except } from 'drizzle-orm/sqlite-core'\n *\n * await except(\n *   db.select({ courseName: depA.courseName }).from(depA),\n *   db.select({ courseName: depB.courseName }).from(depB)\n * );\n * // or\n * await db.select({ courseName: depA.courseName })\n *   .from(depA)\n *   .except(\n *     db.select({ courseName: depB.courseName }).from(depB)\n *   );\n * ```\n */\nexport const except = createSetOperator('except', false);\n", "import { entityKind } from '~/entity.ts';\nimport type { SQL, SQLWrapper } from '~/sql/index.ts';\n\nexport abstract class TypedQueryBuilder<TSelection, TResult = unknown> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'TypedQueryBuilder';\n\n\tdeclare _: {\n\t\tselectedFields: TSelection;\n\t\tresult: TResult;\n\t};\n\n\t/** @internal */\n\tgetSelectedFields(): TSelection {\n\t\treturn this._.selectedFields;\n\t}\n\n\tabstract getSQL(): SQL;\n}\n", "import type { GetColumnData } from '~/column.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport type { JoinType, SelectResultFields } from '~/query-builders/select.types.ts';\nimport { QueryPromise } from '~/query-promise.ts';\nimport type { RunnableQuery } from '~/runnable-query.ts';\nimport { SelectionProxyHandler } from '~/selection-proxy.ts';\nimport type { Placeholder, Query, SQL, SQLWrapper } from '~/sql/sql.ts';\nimport type { SQLiteDialect } from '~/sqlite-core/dialect.ts';\nimport type { SQLitePreparedQuery, SQLiteSession } from '~/sqlite-core/session.ts';\nimport { SQLiteTable } from '~/sqlite-core/table.ts';\nimport { Subquery } from '~/subquery.ts';\nimport { Table } from '~/table.ts';\nimport {\n\ttype DrizzleTypeError,\n\tgetTableLikeName,\n\tmapUpdateSet,\n\torderSelectedFields,\n\ttype UpdateSet,\n\ttype ValueOrArray,\n} from '~/utils.ts';\nimport { ViewBaseConfig } from '~/view-common.ts';\nimport type { SQLiteColumn } from '../columns/common.ts';\nimport { SQLiteViewBase } from '../view-base.ts';\nimport type { SelectedFields, SelectedFieldsOrdered, SQLiteSelectJoinConfig } from './select.types.ts';\n\nexport interface SQLiteUpdateConfig {\n\twhere?: SQL | undefined;\n\tlimit?: number | Placeholder;\n\torderBy?: (SQLiteColumn | SQL | SQL.Aliased)[];\n\tset: UpdateSet;\n\ttable: SQLiteTable;\n\tfrom?: SQLiteTable | Subquery | SQLiteViewBase | SQL;\n\tjoins: SQLiteSelectJoinConfig[];\n\treturning?: SelectedFieldsOrdered;\n\twithList?: Subquery[];\n}\n\nexport type SQLiteUpdateSetSource<TTable extends SQLiteTable> =\n\t& {\n\t\t[Key in keyof TTable['$inferInsert']]?:\n\t\t\t| GetColumnData<TTable['_']['columns'][Key], 'query'>\n\t\t\t| SQL\n\t\t\t| SQLiteColumn\n\t\t\t| undefined;\n\t}\n\t& {};\n\nexport class SQLiteUpdateBuilder<\n\tTTable extends SQLiteTable,\n\tTResultType extends 'sync' | 'async',\n\tTRunResult,\n> {\n\tstatic readonly [entityKind]: string = 'SQLiteUpdateBuilder';\n\n\tdeclare readonly _: {\n\t\treadonly table: TTable;\n\t};\n\n\tconstructor(\n\t\tprotected table: TTable,\n\t\tprotected session: SQLiteSession<any, any, any, any>,\n\t\tprotected dialect: SQLiteDialect,\n\t\tprivate withList?: Subquery[],\n\t) {}\n\n\tset(\n\t\tvalues: SQLiteUpdateSetSource<TTable>,\n\t): SQLiteUpdateWithout<\n\t\tSQLiteUpdateBase<TTable, TResultType, TRunResult>,\n\t\tfalse,\n\t\t'leftJoin' | 'rightJoin' | 'innerJoin' | 'fullJoin'\n\t> {\n\t\treturn new SQLiteUpdateBase(\n\t\t\tthis.table,\n\t\t\tmapUpdateSet(this.table, values),\n\t\t\tthis.session,\n\t\t\tthis.dialect,\n\t\t\tthis.withList,\n\t\t) as any;\n\t}\n}\n\nexport type SQLiteUpdateWithout<\n\tT extends AnySQLiteUpdate,\n\tTDynamic extends boolean,\n\tK extends keyof T & string,\n> = TDynamic extends true ? T : Omit<\n\tSQLiteUpdateBase<\n\t\tT['_']['table'],\n\t\tT['_']['resultType'],\n\t\tT['_']['runResult'],\n\t\tT['_']['from'],\n\t\tT['_']['returning'],\n\t\tTDynamic,\n\t\tT['_']['excludedMethods'] | K\n\t>,\n\tT['_']['excludedMethods'] | K\n>;\n\nexport type SQLiteUpdateWithJoins<\n\tT extends AnySQLiteUpdate,\n\tTDynamic extends boolean,\n\tTFrom extends SQLiteTable | Subquery | SQLiteViewBase | SQL,\n> = TDynamic extends true ? T : Omit<\n\tSQLiteUpdateBase<\n\t\tT['_']['table'],\n\t\tT['_']['resultType'],\n\t\tT['_']['runResult'],\n\t\tTFrom,\n\t\tT['_']['returning'],\n\t\tTDynamic,\n\t\tExclude<T['_']['excludedMethods'] | 'from', 'leftJoin' | 'rightJoin' | 'innerJoin' | 'fullJoin'>\n\t>,\n\tExclude<T['_']['excludedMethods'] | 'from', 'leftJoin' | 'rightJoin' | 'innerJoin' | 'fullJoin'>\n>;\n\nexport type SQLiteUpdateReturningAll<T extends AnySQLiteUpdate, TDynamic extends boolean> = SQLiteUpdateWithout<\n\tSQLiteUpdateBase<\n\t\tT['_']['table'],\n\t\tT['_']['resultType'],\n\t\tT['_']['runResult'],\n\t\tT['_']['from'],\n\t\tT['_']['table']['$inferSelect'],\n\t\tTDynamic,\n\t\tT['_']['excludedMethods']\n\t>,\n\tTDynamic,\n\t'returning'\n>;\n\nexport type SQLiteUpdateReturning<\n\tT extends AnySQLiteUpdate,\n\tTDynamic extends boolean,\n\tTSelectedFields extends SelectedFields,\n> = SQLiteUpdateWithout<\n\tSQLiteUpdateBase<\n\t\tT['_']['table'],\n\t\tT['_']['resultType'],\n\t\tT['_']['runResult'],\n\t\tT['_']['from'],\n\t\tSelectResultFields<TSelectedFields>,\n\t\tTDynamic,\n\t\tT['_']['excludedMethods']\n\t>,\n\tTDynamic,\n\t'returning'\n>;\n\nexport type SQLiteUpdateExecute<T extends AnySQLiteUpdate> = T['_']['returning'] extends undefined ? T['_']['runResult']\n\t: T['_']['returning'][];\n\nexport type SQLiteUpdatePrepare<T extends AnySQLiteUpdate> = SQLitePreparedQuery<\n\t{\n\t\ttype: T['_']['resultType'];\n\t\trun: T['_']['runResult'];\n\t\tall: T['_']['returning'] extends undefined ? DrizzleTypeError<'.all() cannot be used without .returning()'>\n\t\t\t: T['_']['returning'][];\n\t\tget: T['_']['returning'] extends undefined ? DrizzleTypeError<'.get() cannot be used without .returning()'>\n\t\t\t: T['_']['returning'];\n\t\tvalues: T['_']['returning'] extends undefined ? DrizzleTypeError<'.values() cannot be used without .returning()'>\n\t\t\t: any[][];\n\t\texecute: SQLiteUpdateExecute<T>;\n\t}\n>;\n\nexport type SQLiteUpdateJoinFn<\n\tT extends AnySQLiteUpdate,\n> = <\n\tTJoinedTable extends SQLiteTable | Subquery | SQLiteViewBase | SQL,\n>(\n\ttable: TJoinedTable,\n\ton:\n\t\t| (\n\t\t\t(\n\t\t\t\tupdateTable: T['_']['table']['_']['columns'],\n\t\t\t\tfrom: T['_']['from'] extends SQLiteTable ? T['_']['from']['_']['columns']\n\t\t\t\t\t: T['_']['from'] extends Subquery | SQLiteViewBase ? T['_']['from']['_']['selectedFields']\n\t\t\t\t\t: never,\n\t\t\t) => SQL | undefined\n\t\t)\n\t\t| SQL\n\t\t| undefined,\n) => T;\n\nexport type SQLiteUpdateDynamic<T extends AnySQLiteUpdate> = SQLiteUpdate<\n\tT['_']['table'],\n\tT['_']['resultType'],\n\tT['_']['runResult'],\n\tT['_']['returning']\n>;\n\nexport type SQLiteUpdate<\n\tTTable extends SQLiteTable = SQLiteTable,\n\tTResultType extends 'sync' | 'async' = 'sync' | 'async',\n\tTRunResult = any,\n\tTFrom extends SQLiteTable | Subquery | SQLiteViewBase | SQL | undefined = undefined,\n\tTReturning extends Record<string, unknown> | undefined = Record<string, unknown> | undefined,\n> = SQLiteUpdateBase<TTable, TResultType, TRunResult, TFrom, TReturning, true, never>;\n\nexport type AnySQLiteUpdate = SQLiteUpdateBase<any, any, any, any, any, any, any>;\n\nexport interface SQLiteUpdateBase<\n\tTTable extends SQLiteTable = SQLiteTable,\n\tTResultType extends 'sync' | 'async' = 'sync' | 'async',\n\tTRunResult = unknown,\n\tTFrom extends SQLiteTable | Subquery | SQLiteViewBase | SQL | undefined = undefined,\n\tTReturning = undefined,\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n> extends SQLWrapper, QueryPromise<TReturning extends undefined ? TRunResult : TReturning[]> {\n\treadonly _: {\n\t\treadonly dialect: 'sqlite';\n\t\treadonly table: TTable;\n\t\treadonly resultType: TResultType;\n\t\treadonly runResult: TRunResult;\n\t\treadonly from: TFrom;\n\t\treadonly returning: TReturning;\n\t\treadonly dynamic: TDynamic;\n\t\treadonly excludedMethods: TExcludedMethods;\n\t\treadonly result: TReturning extends undefined ? TRunResult : TReturning[];\n\t};\n}\n\nexport class SQLiteUpdateBase<\n\tTTable extends SQLiteTable = SQLiteTable,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTResultType extends 'sync' | 'async' = 'sync' | 'async',\n\tTRunResult = unknown,\n\tTFrom extends SQLiteTable | Subquery | SQLiteViewBase | SQL | undefined = undefined,\n\tTReturning = undefined,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTDynamic extends boolean = false,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTExcludedMethods extends string = never,\n> extends QueryPromise<TReturning extends undefined ? TRunResult : TReturning[]>\n\timplements RunnableQuery<TReturning extends undefined ? TRunResult : TReturning[], 'sqlite'>, SQLWrapper\n{\n\tstatic override readonly [entityKind]: string = 'SQLiteUpdate';\n\n\t/** @internal */\n\tconfig: SQLiteUpdateConfig;\n\n\tconstructor(\n\t\ttable: TTable,\n\t\tset: UpdateSet,\n\t\tprivate session: SQLiteSession<any, any, any, any>,\n\t\tprivate dialect: SQLiteDialect,\n\t\twithList?: Subquery[],\n\t) {\n\t\tsuper();\n\t\tthis.config = { set, table, withList, joins: [] };\n\t}\n\n\tfrom<TFrom extends SQLiteTable | Subquery | SQLiteViewBase | SQL>(\n\t\tsource: TFrom,\n\t): SQLiteUpdateWithJoins<this, TDynamic, TFrom> {\n\t\tthis.config.from = source;\n\t\treturn this as any;\n\t}\n\n\tprivate createJoin<TJoinType extends JoinType>(\n\t\tjoinType: TJoinType,\n\t): SQLiteUpdateJoinFn<this> {\n\t\treturn ((\n\t\t\ttable: SQLiteTable | Subquery | SQLiteViewBase | SQL,\n\t\t\ton: ((updateTable: TTable, from: TFrom) => SQL | undefined) | SQL | undefined,\n\t\t) => {\n\t\t\tconst tableName = getTableLikeName(table);\n\n\t\t\tif (typeof tableName === 'string' && this.config.joins.some((join) => join.alias === tableName)) {\n\t\t\t\tthrow new Error(`Alias \"${tableName}\" is already used in this query`);\n\t\t\t}\n\n\t\t\tif (typeof on === 'function') {\n\t\t\t\tconst from = this.config.from\n\t\t\t\t\t? is(table, SQLiteTable)\n\t\t\t\t\t\t? table[Table.Symbol.Columns]\n\t\t\t\t\t\t: is(table, Subquery)\n\t\t\t\t\t\t? table._.selectedFields\n\t\t\t\t\t\t: is(table, SQLiteViewBase)\n\t\t\t\t\t\t? table[ViewBaseConfig].selectedFields\n\t\t\t\t\t\t: undefined\n\t\t\t\t\t: undefined;\n\t\t\t\ton = on(\n\t\t\t\t\tnew Proxy(\n\t\t\t\t\t\tthis.config.table[Table.Symbol.Columns],\n\t\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' }),\n\t\t\t\t\t) as any,\n\t\t\t\t\tfrom && new Proxy(\n\t\t\t\t\t\tfrom,\n\t\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' }),\n\t\t\t\t\t) as any,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.config.joins.push({ on, table, joinType, alias: tableName });\n\n\t\t\treturn this as any;\n\t\t}) as any;\n\t}\n\n\tleftJoin = this.createJoin('left');\n\n\trightJoin = this.createJoin('right');\n\n\tinnerJoin = this.createJoin('inner');\n\n\tfullJoin = this.createJoin('full');\n\n\t/**\n\t * Adds a 'where' clause to the query.\n\t *\n\t * Calling this method will update only those rows that fulfill a specified condition.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/update}\n\t *\n\t * @param where the 'where' clause.\n\t *\n\t * @example\n\t * You can use conditional operators and `sql function` to filter the rows to be updated.\n\t *\n\t * ```ts\n\t * // Update all cars with green color\n\t * db.update(cars).set({ color: 'red' })\n\t *   .where(eq(cars.color, 'green'));\n\t * // or\n\t * db.update(cars).set({ color: 'red' })\n\t *   .where(sql`${cars.color} = 'green'`)\n\t * ```\n\t *\n\t * You can logically combine conditional operators with `and()` and `or()` operators:\n\t *\n\t * ```ts\n\t * // Update all BMW cars with a green color\n\t * db.update(cars).set({ color: 'red' })\n\t *   .where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));\n\t *\n\t * // Update all cars with the green or blue color\n\t * db.update(cars).set({ color: 'red' })\n\t *   .where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));\n\t * ```\n\t */\n\twhere(where: SQL | undefined): SQLiteUpdateWithout<this, TDynamic, 'where'> {\n\t\tthis.config.where = where;\n\t\treturn this as any;\n\t}\n\n\torderBy(\n\t\tbuilder: (updateTable: TTable) => ValueOrArray<SQLiteColumn | SQL | SQL.Aliased>,\n\t): SQLiteUpdateWithout<this, TDynamic, 'orderBy'>;\n\torderBy(...columns: (SQLiteColumn | SQL | SQL.Aliased)[]): SQLiteUpdateWithout<this, TDynamic, 'orderBy'>;\n\torderBy(\n\t\t...columns:\n\t\t\t| [(updateTable: TTable) => ValueOrArray<SQLiteColumn | SQL | SQL.Aliased>]\n\t\t\t| (SQLiteColumn | SQL | SQL.Aliased)[]\n\t): SQLiteUpdateWithout<this, TDynamic, 'orderBy'> {\n\t\tif (typeof columns[0] === 'function') {\n\t\t\tconst orderBy = columns[0](\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.table[Table.Symbol.Columns],\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' }),\n\t\t\t\t) as any,\n\t\t\t);\n\n\t\t\tconst orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];\n\t\t\tthis.config.orderBy = orderByArray;\n\t\t} else {\n\t\t\tconst orderByArray = columns as (SQLiteColumn | SQL | SQL.Aliased)[];\n\t\t\tthis.config.orderBy = orderByArray;\n\t\t}\n\t\treturn this as any;\n\t}\n\n\tlimit(limit: number | Placeholder): SQLiteUpdateWithout<this, TDynamic, 'limit'> {\n\t\tthis.config.limit = limit;\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `returning` clause to the query.\n\t *\n\t * Calling this method will return the specified fields of the updated rows. If no fields are specified, all fields will be returned.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/update#update-with-returning}\n\t *\n\t * @example\n\t * ```ts\n\t * // Update all cars with the green color and return all fields\n\t * const updatedCars: Car[] = await db.update(cars)\n\t *   .set({ color: 'red' })\n\t *   .where(eq(cars.color, 'green'))\n\t *   .returning();\n\t *\n\t * // Update all cars with the green color and return only their id and brand fields\n\t * const updatedCarsIdsAndBrands: { id: number, brand: string }[] = await db.update(cars)\n\t *   .set({ color: 'red' })\n\t *   .where(eq(cars.color, 'green'))\n\t *   .returning({ id: cars.id, brand: cars.brand });\n\t * ```\n\t */\n\treturning(): SQLiteUpdateReturningAll<this, TDynamic>;\n\treturning<TSelectedFields extends SelectedFields>(\n\t\tfields: TSelectedFields,\n\t): SQLiteUpdateReturning<this, TDynamic, TSelectedFields>;\n\treturning(\n\t\tfields: SelectedFields = this.config.table[SQLiteTable.Symbol.Columns],\n\t): SQLiteUpdateWithout<AnySQLiteUpdate, TDynamic, 'returning'> {\n\t\tthis.config.returning = orderSelectedFields<SQLiteColumn>(fields);\n\t\treturn this as any;\n\t}\n\n\t/** @internal */\n\tgetSQL(): SQL {\n\t\treturn this.dialect.buildUpdateQuery(this.config);\n\t}\n\n\ttoSQL(): Query {\n\t\tconst { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n\t\treturn rest;\n\t}\n\n\t/** @internal */\n\t_prepare(isOneTimeQuery = true): SQLiteUpdatePrepare<this> {\n\t\treturn this.session[isOneTimeQuery ? 'prepareOneTimeQuery' : 'prepareQuery'](\n\t\t\tthis.dialect.sqlToQuery(this.getSQL()),\n\t\t\tthis.config.returning,\n\t\t\tthis.config.returning ? 'all' : 'run',\n\t\t\ttrue,\n\t\t) as SQLiteUpdatePrepare<this>;\n\t}\n\n\tprepare(): SQLiteUpdatePrepare<this> {\n\t\treturn this._prepare(false);\n\t}\n\n\trun: ReturnType<this['prepare']>['run'] = (placeholderValues) => {\n\t\treturn this._prepare().run(placeholderValues);\n\t};\n\n\tall: ReturnType<this['prepare']>['all'] = (placeholderValues) => {\n\t\treturn this._prepare().all(placeholderValues);\n\t};\n\n\tget: ReturnType<this['prepare']>['get'] = (placeholderValues) => {\n\t\treturn this._prepare().get(placeholderValues);\n\t};\n\n\tvalues: ReturnType<this['prepare']>['values'] = (placeholderValues) => {\n\t\treturn this._prepare().values(placeholderValues);\n\t};\n\n\toverride async execute(): Promise<SQLiteUpdateExecute<this>> {\n\t\treturn (this.config.returning ? this.all() : this.run()) as SQLiteUpdateExecute<this>;\n\t}\n\n\t$dynamic(): SQLiteUpdateDynamic<this> {\n\t\treturn this as any;\n\t}\n}\n", "import { entityKind } from '~/entity.ts';\nimport { SQL, sql, type SQLWrapper } from '~/sql/sql.ts';\nimport type { SQLiteSession } from '../session.ts';\nimport type { SQLiteTable } from '../table.ts';\nimport type { SQLiteView } from '../view.ts';\n\nexport class SQLiteCountBuilder<\n\tTSession extends SQLiteSession<any, any, any, any>,\n> extends SQL<number> implements Promise<number>, SQLWrapper {\n\tprivate sql: SQL<number>;\n\n\tstatic override readonly [entityKind] = 'SQLiteCountBuilderAsync';\n\t[Symbol.toStringTag] = 'SQLiteCountBuilderAsync';\n\n\tprivate session: TSession;\n\n\tprivate static buildEmbeddedCount(\n\t\tsource: SQLiteTable | SQLiteView | SQL | SQLWrapper,\n\t\tfilters?: SQL<unknown>,\n\t): SQL<number> {\n\t\treturn sql<number>`(select count(*) from ${source}${sql.raw(' where ').if(filters)}${filters})`;\n\t}\n\n\tprivate static buildCount(\n\t\tsource: SQLiteTable | SQLiteView | SQL | SQLWrapper,\n\t\tfilters?: SQL<unknown>,\n\t): SQL<number> {\n\t\treturn sql<number>`select count(*) from ${source}${sql.raw(' where ').if(filters)}${filters}`;\n\t}\n\n\tconstructor(\n\t\treadonly params: {\n\t\t\tsource: SQLiteTable | SQLiteView | SQL | SQLWrapper;\n\t\t\tfilters?: SQL<unknown>;\n\t\t\tsession: TSession;\n\t\t},\n\t) {\n\t\tsuper(SQLiteCountBuilder.buildEmbeddedCount(params.source, params.filters).queryChunks);\n\n\t\tthis.session = params.session;\n\n\t\tthis.sql = SQLiteCountBuilder.buildCount(\n\t\t\tparams.source,\n\t\t\tparams.filters,\n\t\t);\n\t}\n\n\tthen<TResult1 = number, TResult2 = never>(\n\t\tonfulfilled?: ((value: number) => TResult1 | PromiseLike<TResult1>) | null | undefined,\n\t\tonrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined,\n\t): Promise<TResult1 | TResult2> {\n\t\treturn Promise.resolve(this.session.count(this.sql)).then(\n\t\t\tonfulfilled,\n\t\t\tonrejected,\n\t\t);\n\t}\n\n\tcatch(\n\t\tonRejected?: ((reason: any) => never | PromiseLike<never>) | null | undefined,\n\t): Promise<number> {\n\t\treturn this.then(undefined, onRejected);\n\t}\n\n\tfinally(onFinally?: (() => void) | null | undefined): Promise<number> {\n\t\treturn this.then(\n\t\t\t(value) => {\n\t\t\t\tonFinally?.();\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\t(reason) => {\n\t\t\t\tonFinally?.();\n\t\t\t\tthrow reason;\n\t\t\t},\n\t\t);\n\t}\n}\n", "import { entityKind } from '~/entity.ts';\nimport { QueryPromise } from '~/query-promise.ts';\nimport {\n\ttype BuildQueryResult,\n\ttype BuildRelationalQueryResult,\n\ttype DBQueryConfig,\n\tmapRelationalRow,\n\ttype TableRelationalConfig,\n\ttype TablesRelationalConfig,\n} from '~/relations.ts';\nimport type { RunnableQuery } from '~/runnable-query.ts';\nimport type { Query, QueryWithTypings, SQL, SQLWrapper } from '~/sql/sql.ts';\nimport type { KnownKeysOnly } from '~/utils.ts';\nimport type { SQLiteDialect } from '../dialect.ts';\nimport type { PreparedQueryConfig, SQLitePreparedQuery, SQLiteSession } from '../session.ts';\nimport type { SQLiteTable } from '../table.ts';\n\nexport type SQLiteRelationalQueryKind<TMode extends 'sync' | 'async', TResult> = TMode extends 'async'\n\t? SQLiteRelationalQuery<TMode, TResult>\n\t: SQLiteSyncRelationalQuery<TResult>;\n\nexport class RelationalQueryBuilder<\n\tTMode extends 'sync' | 'async',\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n\tTFields extends TableRelationalConfig,\n> {\n\tstatic readonly [entityKind]: string = 'SQLiteAsyncRelationalQueryBuilder';\n\n\tconstructor(\n\t\tprotected mode: TMode,\n\t\tprotected fullSchema: Record<string, unknown>,\n\t\tprotected schema: TSchema,\n\t\tprotected tableNamesMap: Record<string, string>,\n\t\tprotected table: SQLiteTable,\n\t\tprotected tableConfig: TableRelationalConfig,\n\t\tprotected dialect: SQLiteDialect,\n\t\tprotected session: SQLiteSession<'async', unknown, TFullSchema, TSchema>,\n\t) {}\n\n\tfindMany<TConfig extends DBQueryConfig<'many', true, TSchema, TFields>>(\n\t\tconfig?: KnownKeysOnly<TConfig, DBQueryConfig<'many', true, TSchema, TFields>>,\n\t): SQLiteRelationalQueryKind<TMode, BuildQueryResult<TSchema, TFields, TConfig>[]> {\n\t\treturn (this.mode === 'sync'\n\t\t\t? new SQLiteSyncRelationalQuery(\n\t\t\t\tthis.fullSchema,\n\t\t\t\tthis.schema,\n\t\t\t\tthis.tableNamesMap,\n\t\t\t\tthis.table,\n\t\t\t\tthis.tableConfig,\n\t\t\t\tthis.dialect,\n\t\t\t\tthis.session,\n\t\t\t\tconfig ? (config as DBQueryConfig<'many', true>) : {},\n\t\t\t\t'many',\n\t\t\t)\n\t\t\t: new SQLiteRelationalQuery(\n\t\t\t\tthis.fullSchema,\n\t\t\t\tthis.schema,\n\t\t\t\tthis.tableNamesMap,\n\t\t\t\tthis.table,\n\t\t\t\tthis.tableConfig,\n\t\t\t\tthis.dialect,\n\t\t\t\tthis.session,\n\t\t\t\tconfig ? (config as DBQueryConfig<'many', true>) : {},\n\t\t\t\t'many',\n\t\t\t)) as SQLiteRelationalQueryKind<TMode, BuildQueryResult<TSchema, TFields, TConfig>[]>;\n\t}\n\n\tfindFirst<TSelection extends Omit<DBQueryConfig<'many', true, TSchema, TFields>, 'limit'>>(\n\t\tconfig?: KnownKeysOnly<TSelection, Omit<DBQueryConfig<'many', true, TSchema, TFields>, 'limit'>>,\n\t): SQLiteRelationalQueryKind<TMode, BuildQueryResult<TSchema, TFields, TSelection> | undefined> {\n\t\treturn (this.mode === 'sync'\n\t\t\t? new SQLiteSyncRelationalQuery(\n\t\t\t\tthis.fullSchema,\n\t\t\t\tthis.schema,\n\t\t\t\tthis.tableNamesMap,\n\t\t\t\tthis.table,\n\t\t\t\tthis.tableConfig,\n\t\t\t\tthis.dialect,\n\t\t\t\tthis.session,\n\t\t\t\tconfig ? { ...(config as DBQueryConfig<'many', true> | undefined), limit: 1 } : { limit: 1 },\n\t\t\t\t'first',\n\t\t\t)\n\t\t\t: new SQLiteRelationalQuery(\n\t\t\t\tthis.fullSchema,\n\t\t\t\tthis.schema,\n\t\t\t\tthis.tableNamesMap,\n\t\t\t\tthis.table,\n\t\t\t\tthis.tableConfig,\n\t\t\t\tthis.dialect,\n\t\t\t\tthis.session,\n\t\t\t\tconfig ? { ...(config as DBQueryConfig<'many', true> | undefined), limit: 1 } : { limit: 1 },\n\t\t\t\t'first',\n\t\t\t)) as SQLiteRelationalQueryKind<TMode, BuildQueryResult<TSchema, TFields, TSelection> | undefined>;\n\t}\n}\n\nexport class SQLiteRelationalQuery<TType extends 'sync' | 'async', TResult> extends QueryPromise<TResult>\n\timplements RunnableQuery<TResult, 'sqlite'>, SQLWrapper\n{\n\tstatic override readonly [entityKind]: string = 'SQLiteAsyncRelationalQuery';\n\n\tdeclare readonly _: {\n\t\treadonly dialect: 'sqlite';\n\t\treadonly type: TType;\n\t\treadonly result: TResult;\n\t};\n\n\t/** @internal */\n\tmode: 'many' | 'first';\n\n\tconstructor(\n\t\tprivate fullSchema: Record<string, unknown>,\n\t\tprivate schema: TablesRelationalConfig,\n\t\tprivate tableNamesMap: Record<string, string>,\n\t\t/** @internal */\n\t\tpublic table: SQLiteTable,\n\t\tprivate tableConfig: TableRelationalConfig,\n\t\tprivate dialect: SQLiteDialect,\n\t\tprivate session: SQLiteSession<'sync' | 'async', unknown, Record<string, unknown>, TablesRelationalConfig>,\n\t\tprivate config: DBQueryConfig<'many', true> | true,\n\t\tmode: 'many' | 'first',\n\t) {\n\t\tsuper();\n\t\tthis.mode = mode;\n\t}\n\n\t/** @internal */\n\tgetSQL(): SQL {\n\t\treturn this.dialect.buildRelationalQuery({\n\t\t\tfullSchema: this.fullSchema,\n\t\t\tschema: this.schema,\n\t\t\ttableNamesMap: this.tableNamesMap,\n\t\t\ttable: this.table,\n\t\t\ttableConfig: this.tableConfig,\n\t\t\tqueryConfig: this.config,\n\t\t\ttableAlias: this.tableConfig.tsName,\n\t\t}).sql as SQL;\n\t}\n\n\t/** @internal */\n\t_prepare(\n\t\tisOneTimeQuery = false,\n\t): SQLitePreparedQuery<PreparedQueryConfig & { type: TType; all: TResult; get: TResult; execute: TResult }> {\n\t\tconst { query, builtQuery } = this._toSQL();\n\n\t\treturn this.session[isOneTimeQuery ? 'prepareOneTimeQuery' : 'prepareQuery'](\n\t\t\tbuiltQuery,\n\t\t\tundefined,\n\t\t\tthis.mode === 'first' ? 'get' : 'all',\n\t\t\ttrue,\n\t\t\t(rawRows, mapColumnValue) => {\n\t\t\t\tconst rows = rawRows.map((row) =>\n\t\t\t\t\tmapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue)\n\t\t\t\t);\n\t\t\t\tif (this.mode === 'first') {\n\t\t\t\t\treturn rows[0] as TResult;\n\t\t\t\t}\n\t\t\t\treturn rows as TResult;\n\t\t\t},\n\t\t) as SQLitePreparedQuery<PreparedQueryConfig & { type: TType; all: TResult; get: TResult; execute: TResult }>;\n\t}\n\n\tprepare(): SQLitePreparedQuery<PreparedQueryConfig & { type: TType; all: TResult; get: TResult; execute: TResult }> {\n\t\treturn this._prepare(false);\n\t}\n\n\tprivate _toSQL(): { query: BuildRelationalQueryResult; builtQuery: QueryWithTypings } {\n\t\tconst query = this.dialect.buildRelationalQuery({\n\t\t\tfullSchema: this.fullSchema,\n\t\t\tschema: this.schema,\n\t\t\ttableNamesMap: this.tableNamesMap,\n\t\t\ttable: this.table,\n\t\t\ttableConfig: this.tableConfig,\n\t\t\tqueryConfig: this.config,\n\t\t\ttableAlias: this.tableConfig.tsName,\n\t\t});\n\n\t\tconst builtQuery = this.dialect.sqlToQuery(query.sql as SQL);\n\n\t\treturn { query, builtQuery };\n\t}\n\n\ttoSQL(): Query {\n\t\treturn this._toSQL().builtQuery;\n\t}\n\n\t/** @internal */\n\texecuteRaw(): TResult {\n\t\tif (this.mode === 'first') {\n\t\t\treturn this._prepare(false).get() as TResult;\n\t\t}\n\t\treturn this._prepare(false).all() as TResult;\n\t}\n\n\toverride async execute(): Promise<TResult> {\n\t\treturn this.executeRaw();\n\t}\n}\n\nexport class SQLiteSyncRelationalQuery<TResult> extends SQLiteRelationalQuery<'sync', TResult> {\n\tstatic override readonly [entityKind]: string = 'SQLiteSyncRelationalQuery';\n\n\tsync(): TResult {\n\t\treturn this.executeRaw();\n\t}\n}\n", "import { entityKind } from '~/entity.ts';\nimport { QueryPromise } from '~/query-promise.ts';\nimport type { RunnableQuery } from '~/runnable-query.ts';\nimport type { PreparedQuery } from '~/session.ts';\nimport type { SQL, SQLWrapper } from '~/sql/sql.ts';\nimport type { SQLiteAsyncDialect } from '../dialect.ts';\n\ntype SQLiteRawAction = 'all' | 'get' | 'values' | 'run';\nexport interface SQLiteRawConfig {\n\taction: SQLiteRawAction;\n}\n\nexport interface SQLiteRaw<TResult> extends QueryPromise<TResult>, RunnableQuery<TResult, 'sqlite'>, SQLWrapper {}\n\nexport class SQLiteRaw<TResult> extends QueryPromise<TResult>\n\timplements RunnableQuery<TResult, 'sqlite'>, SQLWrapper, PreparedQuery\n{\n\tstatic override readonly [entityKind]: string = 'SQLiteRaw';\n\n\tdeclare readonly _: {\n\t\treadonly dialect: 'sqlite';\n\t\treadonly result: TResult;\n\t};\n\n\t/** @internal */\n\tconfig: SQLiteRawConfig;\n\n\tconstructor(\n\t\tpublic execute: () => Promise<TResult>,\n\t\t/** @internal */\n\t\tpublic getSQL: () => SQL,\n\t\taction: SQLiteRawAction,\n\t\tprivate dialect: SQLiteAsyncDialect,\n\t\tprivate mapBatchResult: (result: unknown) => unknown,\n\t) {\n\t\tsuper();\n\t\tthis.config = { action };\n\t}\n\n\tgetQuery() {\n\t\treturn { ...this.dialect.sqlToQuery(this.getSQL()), method: this.config.action };\n\t}\n\n\tmapResult(result: unknown, isFromBatch?: boolean) {\n\t\treturn isFromBatch ? this.mapBatchResult(result) : result;\n\t}\n\n\t_prepare(): PreparedQuery {\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tisResponseInArrayMode(): boolean {\n\t\treturn false;\n\t}\n}\n", "/// <reference types=\"@cloudflare/workers-types\" />\n\nimport type { BatchItem } from '~/batch.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { Logger } from '~/logger.ts';\nimport { NoopLogger } from '~/logger.ts';\nimport type { RelationalSchemaConfig, TablesRelationalConfig } from '~/relations.ts';\nimport type { PreparedQuery } from '~/session.ts';\nimport { fillPlaceholders, type Query, sql } from '~/sql/sql.ts';\nimport type { SQLiteAsyncDialect } from '~/sqlite-core/dialect.ts';\nimport { SQLiteTransaction } from '~/sqlite-core/index.ts';\nimport type { SelectedFieldsOrdered } from '~/sqlite-core/query-builders/select.types.ts';\nimport type {\n\tPreparedQueryConfig as PreparedQueryConfigBase,\n\tSQLiteExecuteMethod,\n\tSQLiteTransactionConfig,\n} from '~/sqlite-core/session.ts';\nimport { SQLitePreparedQuery, SQLiteSession } from '~/sqlite-core/session.ts';\nimport { mapResultRow } from '~/utils.ts';\n\nexport interface SQLiteD1SessionOptions {\n\tlogger?: Logger;\n}\n\ntype PreparedQueryConfig = Omit<PreparedQueryConfigBase, 'statement' | 'run'>;\n\nexport class SQLiteD1Session<\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> extends SQLiteSession<'async', D1Result, TFullSchema, TSchema> {\n\tstatic override readonly [entityKind]: string = 'SQLiteD1Session';\n\n\tprivate logger: Logger;\n\n\tconstructor(\n\t\tprivate client: D1Database,\n\t\tdialect: SQLiteAsyncDialect,\n\t\tprivate schema: RelationalSchemaConfig<TSchema> | undefined,\n\t\tprivate options: SQLiteD1SessionOptions = {},\n\t) {\n\t\tsuper(dialect);\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t}\n\n\tprepareQuery(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][]) => unknown,\n\t): D1PreparedQuery {\n\t\tconst stmt = this.client.prepare(query.sql);\n\t\treturn new D1PreparedQuery(\n\t\t\tstmt,\n\t\t\tquery,\n\t\t\tthis.logger,\n\t\t\tfields,\n\t\t\texecuteMethod,\n\t\t\tisResponseInArrayMode,\n\t\t\tcustomResultMapper,\n\t\t);\n\t}\n\n\tasync batch<T extends BatchItem<'sqlite'>[] | readonly BatchItem<'sqlite'>[]>(queries: T) {\n\t\tconst preparedQueries: PreparedQuery[] = [];\n\t\tconst builtQueries: D1PreparedStatement[] = [];\n\n\t\tfor (const query of queries) {\n\t\t\tconst preparedQuery = query._prepare();\n\t\t\tconst builtQuery = preparedQuery.getQuery();\n\t\t\tpreparedQueries.push(preparedQuery);\n\t\t\tif (builtQuery.params.length > 0) {\n\t\t\t\tbuiltQueries.push((preparedQuery as D1PreparedQuery).stmt.bind(...builtQuery.params));\n\t\t\t} else {\n\t\t\t\tconst builtQuery = preparedQuery.getQuery();\n\t\t\t\tbuiltQueries.push(\n\t\t\t\t\tthis.client.prepare(builtQuery.sql).bind(...builtQuery.params),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst batchResults = await this.client.batch<any>(builtQueries);\n\t\treturn batchResults.map((result, i) => preparedQueries[i]!.mapResult(result, true));\n\t}\n\n\toverride extractRawAllValueFromBatchResult(result: unknown): unknown {\n\t\treturn (result as D1Result).results;\n\t}\n\n\toverride extractRawGetValueFromBatchResult(result: unknown): unknown {\n\t\treturn (result as D1Result).results[0];\n\t}\n\n\toverride extractRawValuesValueFromBatchResult(result: unknown): unknown {\n\t\treturn d1ToRawMapping((result as D1Result).results);\n\t}\n\n\toverride async transaction<T>(\n\t\ttransaction: (tx: D1Transaction<TFullSchema, TSchema>) => T | Promise<T>,\n\t\tconfig?: SQLiteTransactionConfig,\n\t): Promise<T> {\n\t\tconst tx = new D1Transaction('async', this.dialect, this, this.schema);\n\t\tawait this.run(sql.raw(`begin${config?.behavior ? ' ' + config.behavior : ''}`));\n\t\ttry {\n\t\t\tconst result = await transaction(tx);\n\t\t\tawait this.run(sql`commit`);\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tawait this.run(sql`rollback`);\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\nexport class D1Transaction<\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> extends SQLiteTransaction<'async', D1Result, TFullSchema, TSchema> {\n\tstatic override readonly [entityKind]: string = 'D1Transaction';\n\n\toverride async transaction<T>(transaction: (tx: D1Transaction<TFullSchema, TSchema>) => Promise<T>): Promise<T> {\n\t\tconst savepointName = `sp${this.nestedIndex}`;\n\t\tconst tx = new D1Transaction('async', this.dialect, this.session, this.schema, this.nestedIndex + 1);\n\t\tawait this.session.run(sql.raw(`savepoint ${savepointName}`));\n\t\ttry {\n\t\t\tconst result = await transaction(tx);\n\t\t\tawait this.session.run(sql.raw(`release savepoint ${savepointName}`));\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tawait this.session.run(sql.raw(`rollback to savepoint ${savepointName}`));\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\n/**\n * This function was taken from the D1 implementation: https://github.com/cloudflare/workerd/blob/4aae9f4c7ae30a59a88ca868c4aff88bda85c956/src/cloudflare/internal/d1-api.ts#L287\n * It may cause issues with duplicated column names in join queries, which should be fixed on the D1 side.\n * @param results\n * @returns\n */\nfunction d1ToRawMapping(results: any) {\n\tconst rows: unknown[][] = [];\n\tfor (const row of results) {\n\t\tconst entry = Object.keys(row).map((k) => row[k]);\n\t\trows.push(entry);\n\t}\n\treturn rows;\n}\n\nexport class D1PreparedQuery<T extends PreparedQueryConfig = PreparedQueryConfig> extends SQLitePreparedQuery<\n\t{ type: 'async'; run: D1Response; all: T['all']; get: T['get']; values: T['values']; execute: T['execute'] }\n> {\n\tstatic override readonly [entityKind]: string = 'D1PreparedQuery';\n\n\t/** @internal */\n\tcustomResultMapper?: (rows: unknown[][], mapColumnValue?: (value: unknown) => unknown) => unknown;\n\n\t/** @internal */\n\tfields?: SelectedFieldsOrdered;\n\n\t/** @internal */\n\tstmt: D1PreparedStatement;\n\n\tconstructor(\n\t\tstmt: D1PreparedStatement,\n\t\tquery: Query,\n\t\tprivate logger: Logger,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tprivate _isResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][]) => unknown,\n\t) {\n\t\tsuper('async', executeMethod, query);\n\t\tthis.customResultMapper = customResultMapper;\n\t\tthis.fields = fields;\n\t\tthis.stmt = stmt;\n\t}\n\n\trun(placeholderValues?: Record<string, unknown>): Promise<D1Response> {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\treturn this.stmt.bind(...params).run();\n\t}\n\n\tasync all(placeholderValues?: Record<string, unknown>): Promise<T['all']> {\n\t\tconst { fields, query, logger, stmt, customResultMapper } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\t\tlogger.logQuery(query.sql, params);\n\t\t\treturn stmt.bind(...params).all().then(({ results }) => this.mapAllResult(results!));\n\t\t}\n\n\t\tconst rows = await this.values(placeholderValues);\n\n\t\treturn this.mapAllResult(rows);\n\t}\n\n\toverride mapAllResult(rows: unknown, isFromBatch?: boolean): unknown {\n\t\tif (isFromBatch) {\n\t\t\trows = d1ToRawMapping((rows as D1Result).results);\n\t\t}\n\n\t\tif (!this.fields && !this.customResultMapper) {\n\t\t\treturn rows;\n\t\t}\n\n\t\tif (this.customResultMapper) {\n\t\t\treturn this.customResultMapper(rows as unknown[][]);\n\t\t}\n\n\t\treturn (rows as unknown[][]).map((row) => mapResultRow(this.fields!, row, this.joinsNotNullableMap));\n\t}\n\n\tasync get(placeholderValues?: Record<string, unknown>): Promise<T['get']> {\n\t\tconst { fields, joinsNotNullableMap, query, logger, stmt, customResultMapper } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\t\tlogger.logQuery(query.sql, params);\n\t\t\treturn stmt.bind(...params).all().then(({ results }) => results![0]);\n\t\t}\n\n\t\tconst rows = await this.values(placeholderValues);\n\n\t\tif (!rows[0]) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (customResultMapper) {\n\t\t\treturn customResultMapper(rows) as T['all'];\n\t\t}\n\n\t\treturn mapResultRow(fields!, rows[0], joinsNotNullableMap);\n\t}\n\n\toverride mapGetResult(result: unknown, isFromBatch?: boolean): unknown {\n\t\tif (isFromBatch) {\n\t\t\tresult = d1ToRawMapping((result as D1Result).results)[0];\n\t\t}\n\n\t\tif (!this.fields && !this.customResultMapper) {\n\t\t\treturn result;\n\t\t}\n\n\t\tif (this.customResultMapper) {\n\t\t\treturn this.customResultMapper([result as unknown[]]) as T['all'];\n\t\t}\n\n\t\treturn mapResultRow(this.fields!, result as unknown[], this.joinsNotNullableMap);\n\t}\n\n\tvalues<T extends any[] = unknown[]>(placeholderValues?: Record<string, unknown>): Promise<T[]> {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\treturn this.stmt.bind(...params).raw();\n\t}\n\n\t/** @internal */\n\tisResponseInArrayMode(): boolean {\n\t\treturn this._isResponseInArrayMode;\n\t}\n}\n", "import { entityKind } from '~/entity.ts';\nimport { DrizzleError, TransactionRollbackError } from '~/errors.ts';\nimport type { TablesRelationalConfig } from '~/relations.ts';\nimport type { PreparedQuery } from '~/session.ts';\nimport type { Query, SQL } from '~/sql/sql.ts';\nimport type { SQLiteAsyncDialect, SQLiteSyncDialect } from '~/sqlite-core/dialect.ts';\n// import { QueryPromise } from '../index.ts';\nimport { QueryPromise } from '~/query-promise.ts';\nimport { BaseSQLiteDatabase } from './db.ts';\nimport type { SQLiteRaw } from './query-builders/raw.ts';\nimport type { SelectedFieldsOrdered } from './query-builders/select.types.ts';\n\nexport interface PreparedQueryConfig {\n\ttype: 'sync' | 'async';\n\trun: unknown;\n\tall: unknown;\n\tget: unknown;\n\tvalues: unknown;\n\texecute: unknown;\n}\n\nexport class ExecuteResultSync<T> extends QueryPromise<T> {\n\tstatic override readonly [entityKind]: string = 'ExecuteResultSync';\n\n\tconstructor(private resultCb: () => T) {\n\t\tsuper();\n\t}\n\n\toverride async execute(): Promise<T> {\n\t\treturn this.resultCb();\n\t}\n\n\tsync(): T {\n\t\treturn this.resultCb();\n\t}\n}\n\nexport type ExecuteResult<TType extends 'sync' | 'async', TResult> = TType extends 'async' ? Promise<TResult>\n\t: ExecuteResultSync<TResult>;\n\nexport abstract class SQLitePreparedQuery<T extends PreparedQueryConfig> implements PreparedQuery {\n\tstatic readonly [entityKind]: string = 'PreparedQuery';\n\n\t/** @internal */\n\tjoinsNotNullableMap?: Record<string, boolean>;\n\n\tconstructor(\n\t\tprivate mode: 'sync' | 'async',\n\t\tprivate executeMethod: SQLiteExecuteMethod,\n\t\tprotected query: Query,\n\t) {}\n\n\tgetQuery(): Query {\n\t\treturn this.query;\n\t}\n\n\tabstract run(placeholderValues?: Record<string, unknown>): Result<T['type'], T['run']>;\n\n\tmapRunResult(result: unknown, _isFromBatch?: boolean): unknown {\n\t\treturn result;\n\t}\n\n\tabstract all(placeholderValues?: Record<string, unknown>): Result<T['type'], T['all']>;\n\n\tmapAllResult(_result: unknown, _isFromBatch?: boolean): unknown {\n\t\tthrow new Error('Not implemented');\n\t}\n\n\tabstract get(placeholderValues?: Record<string, unknown>): Result<T['type'], T['get']>;\n\n\tmapGetResult(_result: unknown, _isFromBatch?: boolean): unknown {\n\t\tthrow new Error('Not implemented');\n\t}\n\n\tabstract values(placeholderValues?: Record<string, unknown>): Result<T['type'], T['values']>;\n\n\texecute(placeholderValues?: Record<string, unknown>): ExecuteResult<T['type'], T['execute']> {\n\t\tif (this.mode === 'async') {\n\t\t\treturn this[this.executeMethod](placeholderValues) as ExecuteResult<T['type'], T['execute']>;\n\t\t}\n\t\treturn new ExecuteResultSync(() => this[this.executeMethod](placeholderValues));\n\t}\n\n\tmapResult(response: unknown, isFromBatch?: boolean) {\n\t\tswitch (this.executeMethod) {\n\t\t\tcase 'run': {\n\t\t\t\treturn this.mapRunResult(response, isFromBatch);\n\t\t\t}\n\t\t\tcase 'all': {\n\t\t\t\treturn this.mapAllResult(response, isFromBatch);\n\t\t\t}\n\t\t\tcase 'get': {\n\t\t\t\treturn this.mapGetResult(response, isFromBatch);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tabstract isResponseInArrayMode(): boolean;\n}\n\nexport interface SQLiteTransactionConfig {\n\tbehavior?: 'deferred' | 'immediate' | 'exclusive';\n}\n\nexport type SQLiteExecuteMethod = 'run' | 'all' | 'get';\n\nexport abstract class SQLiteSession<\n\tTResultKind extends 'sync' | 'async',\n\tTRunResult,\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> {\n\tstatic readonly [entityKind]: string = 'SQLiteSession';\n\n\tconstructor(\n\t\t/** @internal */\n\t\treadonly dialect: { sync: SQLiteSyncDialect; async: SQLiteAsyncDialect }[TResultKind],\n\t) {}\n\n\tabstract prepareQuery(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][], mapColumnValue?: (value: unknown) => unknown) => unknown,\n\t): SQLitePreparedQuery<PreparedQueryConfig & { type: TResultKind }>;\n\n\tprepareOneTimeQuery(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tisResponseInArrayMode: boolean,\n\t): SQLitePreparedQuery<PreparedQueryConfig & { type: TResultKind }> {\n\t\treturn this.prepareQuery(query, fields, executeMethod, isResponseInArrayMode);\n\t}\n\n\tabstract transaction<T>(\n\t\ttransaction: (tx: SQLiteTransaction<TResultKind, TRunResult, TFullSchema, TSchema>) => Result<TResultKind, T>,\n\t\tconfig?: SQLiteTransactionConfig,\n\t): Result<TResultKind, T>;\n\n\trun(query: SQL): Result<TResultKind, TRunResult> {\n\t\tconst staticQuery = this.dialect.sqlToQuery(query);\n\t\ttry {\n\t\t\treturn this.prepareOneTimeQuery(staticQuery, undefined, 'run', false).run() as Result<TResultKind, TRunResult>;\n\t\t} catch (err) {\n\t\t\tthrow new DrizzleError({ cause: err, message: `Failed to run the query '${staticQuery.sql}'` });\n\t\t}\n\t}\n\n\t/** @internal */\n\textractRawRunValueFromBatchResult(result: unknown) {\n\t\treturn result;\n\t}\n\n\tall<T = unknown>(query: SQL): Result<TResultKind, T[]> {\n\t\treturn this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), undefined, 'run', false).all() as Result<\n\t\t\tTResultKind,\n\t\t\tT[]\n\t\t>;\n\t}\n\n\t/** @internal */\n\textractRawAllValueFromBatchResult(_result: unknown): unknown {\n\t\tthrow new Error('Not implemented');\n\t}\n\n\tget<T = unknown>(query: SQL): Result<TResultKind, T> {\n\t\treturn this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), undefined, 'run', false).get() as Result<\n\t\t\tTResultKind,\n\t\t\tT\n\t\t>;\n\t}\n\n\t/** @internal */\n\textractRawGetValueFromBatchResult(_result: unknown): unknown {\n\t\tthrow new Error('Not implemented');\n\t}\n\n\tvalues<T extends any[] = unknown[]>(\n\t\tquery: SQL,\n\t): Result<TResultKind, T[]> {\n\t\treturn this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), undefined, 'run', false).values() as Result<\n\t\t\tTResultKind,\n\t\t\tT[]\n\t\t>;\n\t}\n\n\tasync count(sql: SQL) {\n\t\tconst result = await this.values(sql) as [[number]];\n\n\t\treturn result[0][0];\n\t}\n\n\t/** @internal */\n\textractRawValuesValueFromBatchResult(_result: unknown): unknown {\n\t\tthrow new Error('Not implemented');\n\t}\n}\n\nexport type Result<TKind extends 'sync' | 'async', TResult> = { sync: TResult; async: Promise<TResult> }[TKind];\n\nexport type DBResult<TKind extends 'sync' | 'async', TResult> = { sync: TResult; async: SQLiteRaw<TResult> }[TKind];\n\nexport abstract class SQLiteTransaction<\n\tTResultType extends 'sync' | 'async',\n\tTRunResult,\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> extends BaseSQLiteDatabase<TResultType, TRunResult, TFullSchema, TSchema> {\n\tstatic override readonly [entityKind]: string = 'SQLiteTransaction';\n\n\tconstructor(\n\t\tresultType: TResultType,\n\t\tdialect: { sync: SQLiteSyncDialect; async: SQLiteAsyncDialect }[TResultType],\n\t\tsession: SQLiteSession<TResultType, TRunResult, TFullSchema, TSchema>,\n\t\tprotected schema: {\n\t\t\tfullSchema: Record<string, unknown>;\n\t\t\tschema: TSchema;\n\t\t\ttableNamesMap: Record<string, string>;\n\t\t} | undefined,\n\t\tprotected readonly nestedIndex = 0,\n\t) {\n\t\tsuper(resultType, dialect, session, schema);\n\t}\n\n\trollback(): never {\n\t\tthrow new TransactionRollbackError();\n\t}\n}\n", "import { sqliteTable, text } from \"drizzle-orm/sqlite-core\";\n\nexport const schedules = sqliteTable(\"schedules\", {\n  id: text(\"id\").primaryKey(),\n  title: text(\"title\").notNull(),\n  startAt: text(\"start_at\").notNull(),\n  endAt: text(\"end_at\"),\n  createdAt: text(\"created_at\").notNull(),\n  updatedAt: text(\"updated_at\").notNull(),\n});\n\nexport const scheduleSupplements = sqliteTable(\"schedule_supplements\", {\n  id: text(\"id\").primaryKey(),\n  scheduleId: text(\"schedule_id\")\n    .notNull()\n    .references(() => schedules.id, { onDelete: \"cascade\" }),\n  keywords: text(\"keywords\"), // JSON array\n  aiResult: text(\"ai_result\"),\n  userMemo: text(\"user_memo\"),\n  createdAt: text(\"created_at\").notNull(),\n  updatedAt: text(\"updated_at\").notNull(),\n});\n\n// \u578B\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\nexport type ScheduleRow = typeof schedules.$inferSelect;\nexport type ScheduleInsert = typeof schedules.$inferInsert;\nexport type SupplementRow = typeof scheduleSupplements.$inferSelect;\nexport type SupplementInsert = typeof scheduleSupplements.$inferInsert;\n", "import { eq, and, gte, lt } from \"drizzle-orm\";\nimport type { Database } from \"./client\";\nimport { schedules, type ScheduleRow } from \"./schema\";\nimport type { ScheduleRepo } from \"../../domain/infra/scheduleRepo\";\nimport type { Schedule } from \"../../domain/model/schedule\";\n\nexport const createScheduleRepo = (db: Database): ScheduleRepo => ({\n  findAll: async () => {\n    const rows = await db.select().from(schedules).orderBy(schedules.startAt);\n    return rows.map(toSchedule);\n  },\n\n  findByMonth: async (year: number, month: number) => {\n    const startDate = new Date(year, month - 1, 1).toISOString();\n    const endDate = new Date(year, month, 1).toISOString();\n\n    const rows = await db\n      .select()\n      .from(schedules)\n      .where(and(gte(schedules.startAt, startDate), lt(schedules.startAt, endDate)))\n      .orderBy(schedules.startAt);\n\n    return rows.map(toSchedule);\n  },\n\n  findById: async (id) => {\n    const rows = await db.select().from(schedules).where(eq(schedules.id, id));\n    return rows[0] ? toSchedule(rows[0]) : null;\n  },\n\n  save: async (schedule) => {\n    await db.insert(schedules).values(toRow(schedule));\n  },\n\n  update: async (schedule) => {\n    await db\n      .update(schedules)\n      .set(toRow(schedule))\n      .where(eq(schedules.id, schedule.id));\n  },\n\n  delete: async (id) => {\n    await db.delete(schedules).where(eq(schedules.id, id));\n  },\n});\n\n// Row \u2192 Entity \u5909\u63DB\nconst toSchedule = (row: ScheduleRow): Schedule => ({\n  id: row.id,\n  title: row.title,\n  startAt: row.startAt,\n  endAt: row.endAt,\n  createdAt: row.createdAt,\n  updatedAt: row.updatedAt,\n});\n\n// Entity \u2192 Row \u5909\u63DB\nconst toRow = (schedule: Schedule): ScheduleRow => ({\n  id: schedule.id,\n  title: schedule.title,\n  startAt: schedule.startAt,\n  endAt: schedule.endAt,\n  createdAt: schedule.createdAt,\n  updatedAt: schedule.updatedAt,\n});\n", "import { eq } from \"drizzle-orm\";\nimport type { Database } from \"./client\";\nimport { scheduleSupplements, type SupplementRow } from \"./schema\";\nimport type { SupplementRepo } from \"../../domain/infra/supplementRepo\";\nimport type { Supplement } from \"../../domain/model/supplement\";\n\nexport const createSupplementRepo = (db: Database): SupplementRepo => ({\n  findByScheduleId: async (scheduleId) => {\n    const rows = await db\n      .select()\n      .from(scheduleSupplements)\n      .where(eq(scheduleSupplements.scheduleId, scheduleId));\n    return rows[0] ? toSupplement(rows[0]) : null;\n  },\n\n  save: async (supplement) => {\n    await db.insert(scheduleSupplements).values(toRow(supplement));\n  },\n\n  update: async (supplement) => {\n    await db\n      .update(scheduleSupplements)\n      .set(toRow(supplement))\n      .where(eq(scheduleSupplements.id, supplement.id));\n  },\n\n  delete: async (scheduleId) => {\n    await db\n      .delete(scheduleSupplements)\n      .where(eq(scheduleSupplements.scheduleId, scheduleId));\n  },\n});\n\n// Row \u2192 Entity \u5909\u63DB\nconst toSupplement = (row: SupplementRow): Supplement => ({\n  id: row.id,\n  scheduleId: row.scheduleId,\n  keywords: row.keywords ? JSON.parse(row.keywords) : [],\n  aiResult: row.aiResult,\n  userMemo: row.userMemo,\n  createdAt: row.createdAt,\n  updatedAt: row.updatedAt,\n});\n\n// Entity \u2192 Row \u5909\u63DB\nconst toRow = (supplement: Supplement): SupplementRow => ({\n  id: supplement.id,\n  scheduleId: supplement.scheduleId,\n  keywords: JSON.stringify(supplement.keywords),\n  aiResult: supplement.aiResult,\n  userMemo: supplement.userMemo,\n  createdAt: supplement.createdAt,\n  updatedAt: supplement.updatedAt,\n});\n", "import type { ScheduleRepo } from \"../../../domain/infra/scheduleRepo\";\nimport {\n  createSchedule as createScheduleEntity,\n  type Schedule,\n  type CreateScheduleInput,\n} from \"../../../domain/model/schedule\";\nimport { type Result, ok } from \"../../../shared/result\";\n\nexport const createCreateScheduleUseCase = (repo: ScheduleRepo) => {\n  return async (input: CreateScheduleInput): Promise<Result<Schedule>> => {\n    const schedule = createScheduleEntity(input);\n    await repo.save(schedule);\n    return ok(schedule);\n  };\n};\n\nexport type CreateScheduleUseCase = ReturnType<typeof createCreateScheduleUseCase>;\n", "import {\n  type Schedule,\n  type CreateScheduleInput,\n  type UpdateScheduleInput,\n} from \"@ai-scheduler/shared\";\nimport { generateId } from \"../../shared/id\";\n\n// Re-export types from shared\nexport type { Schedule, CreateScheduleInput, UpdateScheduleInput };\n\n// \u30D5\u30A1\u30AF\u30C8\u30EA\u95A2\u6570\nexport const createSchedule = (input: CreateScheduleInput): Schedule => {\n  const now = new Date().toISOString();\n  return {\n    id: generateId(),\n    title: input.title,\n    startAt: input.startAt,\n    endAt: input.endAt ?? null,\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\n// \u66F4\u65B0\u95A2\u6570\nexport const updateSchedule = (\n  schedule: Schedule,\n  input: UpdateScheduleInput\n): Schedule => {\n  return {\n    ...schedule,\n    title: input.title ?? schedule.title,\n    startAt: input.startAt ?? schedule.startAt,\n    endAt: input.endAt !== undefined ? input.endAt : schedule.endAt,\n    updatedAt: new Date().toISOString(),\n  };\n};\n", "import { nanoid } from \"nanoid\";\n\nexport const generateId = (): string => nanoid();\n", "/* @ts-self-types=\"./index.d.ts\" */\nimport { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step | 0\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size | 0, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n", "export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n", "import type { AppError } from \"./errors\";\n\n// Result\u578B\u3067\u30A8\u30E9\u30FC\u30CF\u30F3\u30C9\u30EA\u30F3\u30B0\uFF08\u4F8B\u5916\u3092\u6295\u3052\u306A\u3044\uFF09\nexport type Result<T, E = AppError> =\n  | { ok: true; value: T }\n  | { ok: false; error: E };\n\nexport const ok = <T>(value: T): Result<T, never> => ({ ok: true, value });\nexport const err = <E>(error: E): Result<never, E> => ({ ok: false, error });\n\n// Result\u578B\u306E\u30E6\u30FC\u30C6\u30A3\u30EA\u30C6\u30A3\nexport const isOk = <T, E>(result: Result<T, E>): result is { ok: true; value: T } =>\n  result.ok;\n\nexport const isErr = <T, E>(result: Result<T, E>): result is { ok: false; error: E } =>\n  !result.ok;\n\nexport const unwrap = <T, E>(result: Result<T, E>): T => {\n  if (result.ok) {\n    return result.value;\n  }\n  throw new Error(\"Cannot unwrap Err value\");\n};\n\nexport const unwrapOr = <T, E>(result: Result<T, E>, defaultValue: T): T => {\n  if (result.ok) {\n    return result.value;\n  }\n  return defaultValue;\n};\n", "import type { ScheduleRepo } from \"../../../domain/infra/scheduleRepo\";\nimport type { Schedule } from \"../../../domain/model/schedule\";\nimport { type Result, ok } from \"../../../shared/result\";\n\nexport const createGetSchedulesUseCase = (repo: ScheduleRepo) => {\n  return async (year?: number, month?: number): Promise<Result<Schedule[]>> => {\n    if (year !== undefined && month !== undefined) {\n      const schedules = await repo.findByMonth(year, month);\n      return ok(schedules);\n    }\n    const schedules = await repo.findAll();\n    return ok(schedules);\n  };\n};\n\nexport type GetSchedulesUseCase = ReturnType<typeof createGetSchedulesUseCase>;\n", "import type { ScheduleRepo } from \"../../../domain/infra/scheduleRepo\";\nimport type { SupplementRepo } from \"../../../domain/infra/supplementRepo\";\nimport type { Schedule } from \"../../../domain/model/schedule\";\nimport type { Supplement } from \"../../../domain/model/supplement\";\nimport { type Result, ok, err } from \"../../../shared/result\";\nimport { createNotFoundError } from \"../../../shared/errors\";\n\nexport type ScheduleWithSupplement = Schedule & {\n  supplement: Supplement | null;\n};\n\nexport const createGetScheduleByIdUseCase = (\n  scheduleRepo: ScheduleRepo,\n  supplementRepo: SupplementRepo\n) => {\n  return async (id: string): Promise<Result<ScheduleWithSupplement>> => {\n    const schedule = await scheduleRepo.findById(id);\n    if (!schedule) {\n      return err(createNotFoundError(\"\u30B9\u30B1\u30B8\u30E5\u30FC\u30EB\"));\n    }\n\n    const supplement = await supplementRepo.findByScheduleId(id);\n\n    return ok({\n      ...schedule,\n      supplement,\n    });\n  };\n};\n\nexport type GetScheduleByIdUseCase = ReturnType<typeof createGetScheduleByIdUseCase>;\n", "import type { ZodError } from \"zod\";\nimport type { ErrorCode, ApiError } from \"@ai-scheduler/shared\";\n\n// Re-export types from shared\nexport type { ErrorCode, ApiError };\n\n// \u30A2\u30D7\u30EA\u30B1\u30FC\u30B7\u30E7\u30F3\u30A8\u30E9\u30FC\u578B\nexport type AppError = ApiError;\n\n// \u30A8\u30E9\u30FC\u30D5\u30A1\u30AF\u30C8\u30EA\nexport const createValidationError = (error: ZodError): AppError => ({\n  code: \"VALIDATION_ERROR\",\n  message: \"\u5165\u529B\u5024\u304C\u4E0D\u6B63\u3067\u3059\",\n  details: error.errors.map((e) => ({\n    path: e.path.join(\".\"),\n    message: e.message,\n  })),\n});\n\nexport const createNotFoundError = (resource: string): AppError => ({\n  code: \"NOT_FOUND\",\n  message: `${resource}\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093`,\n});\n\nexport const createAiError = (message: string): AppError => ({\n  code: \"AI_ERROR\",\n  message: `AI\u51E6\u7406\u30A8\u30E9\u30FC: ${message}`,\n});\n\nexport const createDatabaseError = (message: string): AppError => ({\n  code: \"DATABASE_ERROR\",\n  message: `\u30C7\u30FC\u30BF\u30D9\u30FC\u30B9\u30A8\u30E9\u30FC: ${message}`,\n});\n\nexport const createInternalError = (message: string): AppError => ({\n  code: \"INTERNAL_ERROR\",\n  message: `\u5185\u90E8\u30A8\u30E9\u30FC: ${message}`,\n});\n", "import type { ScheduleRepo } from \"../../../domain/infra/scheduleRepo\";\nimport {\n  updateSchedule as updateScheduleEntity,\n  type Schedule,\n  type UpdateScheduleInput,\n} from \"../../../domain/model/schedule\";\nimport { type Result, ok, err } from \"../../../shared/result\";\nimport { createNotFoundError } from \"../../../shared/errors\";\n\nexport const createUpdateScheduleUseCase = (repo: ScheduleRepo) => {\n  return async (\n    id: string,\n    input: UpdateScheduleInput\n  ): Promise<Result<Schedule>> => {\n    const existing = await repo.findById(id);\n    if (!existing) {\n      return err(createNotFoundError(\"\u30B9\u30B1\u30B8\u30E5\u30FC\u30EB\"));\n    }\n\n    const updated = updateScheduleEntity(existing, input);\n    await repo.update(updated);\n    return ok(updated);\n  };\n};\n\nexport type UpdateScheduleUseCase = ReturnType<typeof createUpdateScheduleUseCase>;\n", "import type { ScheduleRepo } from \"../../../domain/infra/scheduleRepo\";\nimport { type Result, ok, err } from \"../../../shared/result\";\nimport { createNotFoundError } from \"../../../shared/errors\";\n\nexport const createDeleteScheduleUseCase = (repo: ScheduleRepo) => {\n  return async (id: string): Promise<Result<void>> => {\n    const existing = await repo.findById(id);\n    if (!existing) {\n      return err(createNotFoundError(\"\u30B9\u30B1\u30B8\u30E5\u30FC\u30EB\"));\n    }\n\n    await repo.delete(id);\n    return ok(undefined);\n  };\n};\n\nexport type DeleteScheduleUseCase = ReturnType<typeof createDeleteScheduleUseCase>;\n", "import type { Context } from \"hono\";\nimport { createScheduleInputSchema } from \"@ai-scheduler/shared\";\nimport type { CreateScheduleUseCase } from \"../usecase/createSchedule\";\nimport { createValidationError } from \"../../../shared/errors\";\nimport { getStatusCode } from \"../../../shared/http\";\n\nexport const createCreateScheduleHandler = (\n  createSchedule: CreateScheduleUseCase\n) => {\n  return async (c: Context) => {\n    const body = await c.req.json();\n\n    const parsed = createScheduleInputSchema.safeParse(body);\n    if (!parsed.success) {\n      return c.json(createValidationError(parsed.error), 400);\n    }\n\n    const result = await createSchedule(parsed.data);\n\n    if (!result.ok) {\n      return c.json(result.error, getStatusCode(result.error.code));\n    }\n\n    return c.json(result.value, 201);\n  };\n};\n", "// Schemas\nexport * from \"./schemas/schedule\";\nexport * from \"./schemas/supplement\";\nexport * from \"./schemas/ai\";\nexport * from \"./schemas/errors\";\n", "import { z } from \"zod\";\n\n// \u5165\u529B\u30B9\u30AD\u30FC\u30DE\nexport const createScheduleInputSchema = z.object({\n  title: z.string().min(1, \"\u30BF\u30A4\u30C8\u30EB\u306F\u5FC5\u9808\u3067\u3059\").max(100, \"\u30BF\u30A4\u30C8\u30EB\u306F100\u6587\u5B57\u4EE5\u5185\u3067\u3059\"),\n  startAt: z.string().datetime({ offset: true, message: \"\u6709\u52B9\u306A\u65E5\u6642\u5F62\u5F0F\u3067\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\" }),\n  endAt: z.string().datetime({ offset: true }).optional(),\n});\n\nexport type CreateScheduleInput = z.infer<typeof createScheduleInputSchema>;\n\nexport const updateScheduleInputSchema = z.object({\n  title: z.string().min(1).max(100).optional(),\n  startAt: z.string().datetime({ offset: true }).optional(),\n  endAt: z.string().datetime({ offset: true }).nullable().optional(),\n});\n\nexport type UpdateScheduleInput = z.infer<typeof updateScheduleInputSchema>;\n\n// \u30A8\u30F3\u30C6\u30A3\u30C6\u30A3\u30B9\u30AD\u30FC\u30DE\nexport const scheduleSchema = z.object({\n  id: z.string(),\n  title: z.string(),\n  startAt: z.string(),\n  endAt: z.string().nullable(),\n  createdAt: z.string(),\n  updatedAt: z.string(),\n});\n\nexport type Schedule = z.infer<typeof scheduleSchema>;\n\n// \u88DC\u8DB3\u60C5\u5831\u4ED8\u304D\u30B9\u30B1\u30B8\u30E5\u30FC\u30EB\nexport const scheduleWithSupplementSchema = scheduleSchema.extend({\n  supplement: z\n    .object({\n      id: z.string(),\n      keywords: z.array(z.string()),\n      aiResult: z.string().nullable(),\n      userMemo: z.string().nullable(),\n    })\n    .nullable(),\n});\n\nexport type ScheduleWithSupplement = z.infer<typeof scheduleWithSupplementSchema>;\n", "import * as z from \"./v3/external.js\";\nexport * from \"./v3/external.js\";\nexport { z };\nexport default z;\n", "export * from \"./errors.js\";\nexport * from \"./helpers/parseUtil.js\";\nexport * from \"./helpers/typeAliases.js\";\nexport * from \"./helpers/util.js\";\nexport * from \"./types.js\";\nexport * from \"./ZodError.js\";\n", "import defaultErrorMap from \"./locales/en.js\";\nlet overrideErrorMap = defaultErrorMap;\nexport { defaultErrorMap };\nexport function setErrorMap(map) {\n    overrideErrorMap = map;\n}\nexport function getErrorMap() {\n    return overrideErrorMap;\n}\n", "import { ZodIssueCode } from \"../ZodError.js\";\nimport { util, ZodParsedType } from \"../helpers/util.js\";\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"bigint\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return { message };\n};\nexport default errorMap;\n", "import { util } from \"./helpers/util.js\";\nexport const ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nexport const quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nexport class ZodError extends Error {\n    get errors() {\n        return this.issues;\n    }\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    static assert(value) {\n        if (!(value instanceof ZodError)) {\n            throw new Error(`Not a ZodError: ${value}`);\n        }\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                const firstEl = sub.path[0];\n                fieldErrors[firstEl] = fieldErrors[firstEl] || [];\n                fieldErrors[firstEl].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n", "export var util;\n(function (util) {\n    util.assertEqual = (_) => { };\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && Number.isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array.map((val) => (typeof val === \"string\" ? `'${val}'` : val)).join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nexport var objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nexport const ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nexport const getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\n", "import { getErrorMap } from \"../errors.js\";\nimport defaultErrorMap from \"../locales/en.js\";\nexport const makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    if (issueData.message !== undefined) {\n        return {\n            ...issueData,\n            path: fullPath,\n            message: issueData.message,\n        };\n    }\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage,\n    };\n};\nexport const EMPTY_PATH = [];\nexport function addIssueToContext(ctx, issueData) {\n    const overrideMap = getErrorMap();\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap, // contextual error map is first priority\n            ctx.schemaErrorMap, // then schema-bound map if available\n            overrideMap, // then global override map\n            overrideMap === defaultErrorMap ? undefined : defaultErrorMap, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nexport class ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n                key,\n                value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return INVALID;\n            if (value.status === \"aborted\")\n                return INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nexport const INVALID = Object.freeze({\n    status: \"aborted\",\n});\nexport const DIRTY = (value) => ({ status: \"dirty\", value });\nexport const OK = (value) => ({ status: \"valid\", value });\nexport const isAborted = (x) => x.status === \"aborted\";\nexport const isDirty = (x) => x.status === \"dirty\";\nexport const isValid = (x) => x.status === \"valid\";\nexport const isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n", "import { ZodError, ZodIssueCode, } from \"./ZodError.js\";\nimport { defaultErrorMap, getErrorMap } from \"./errors.js\";\nimport { errorUtil } from \"./helpers/errorUtil.js\";\nimport { DIRTY, INVALID, OK, ParseStatus, addIssueToContext, isAborted, isAsync, isDirty, isValid, makeIssue, } from \"./helpers/parseUtil.js\";\nimport { util, ZodParsedType, getParsedType } from \"./helpers/util.js\";\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (Array.isArray(this._key)) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if (isValid(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        const { message } = params;\n        if (iss.code === \"invalid_enum_value\") {\n            return { message: message ?? ctx.defaultError };\n        }\n        if (typeof ctx.data === \"undefined\") {\n            return { message: message ?? required_error ?? ctx.defaultError };\n        }\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        return { message: message ?? invalid_type_error ?? ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nexport class ZodType {\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: params?.async ?? false,\n                contextualErrorMap: params?.errorMap,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    \"~validate\"(data) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: !!this[\"~standard\"].async,\n            },\n            path: [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        if (!this[\"~standard\"].async) {\n            try {\n                const result = this._parseSync({ data, path: [], parent: ctx });\n                return isValid(result)\n                    ? {\n                        value: result.value,\n                    }\n                    : {\n                        issues: ctx.common.issues,\n                    };\n            }\n            catch (err) {\n                if (err?.message?.toLowerCase()?.includes(\"encountered\")) {\n                    this[\"~standard\"].async = true;\n                }\n                ctx.common = {\n                    issues: [],\n                    async: true,\n                };\n            }\n        }\n        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result)\n            ? {\n                value: result.value,\n            }\n            : {\n                issues: ctx.common.issues,\n            });\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params?.errorMap,\n                async: true,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n        this[\"~standard\"] = {\n            version: 1,\n            vendor: \"zod\",\n            validate: (data) => this[\"~validate\"](data),\n        };\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[0-9a-z]+$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\nconst jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nconst durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&\u2019*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\n// faster, simpler, safer\nconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nconst ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\n// const ipv6Regex =\n// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nconst ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nconst ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n// https://base64.guru/standards/base64url\nconst base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\n// simple\n// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\n// no leap year validation\n// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\n// with leap year validation\nconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n    let secondsRegexSource = `[0-5]\\\\d`;\n    if (args.precision) {\n        secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n    }\n    else if (args.precision == null) {\n        secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n    }\n    const secondsQuantifier = args.precision ? \"+\" : \"?\"; // require seconds if precision is nonzero\n    return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n    return new RegExp(`^${timeRegexSource(args)}$`);\n}\n// Adapted from https://stackoverflow.com/a/3143231\nexport function datetimeRegex(args) {\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n    const opts = [];\n    opts.push(args.local ? `Z?` : `Z`);\n    if (args.offset)\n        opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n    regex = `${regex}(${opts.join(\"|\")})`;\n    return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nfunction isValidJWT(jwt, alg) {\n    if (!jwtRegex.test(jwt))\n        return false;\n    try {\n        const [header] = jwt.split(\".\");\n        if (!header)\n            return false;\n        // Convert base64url to base64\n        const base64 = header\n            .replace(/-/g, \"+\")\n            .replace(/_/g, \"/\")\n            .padEnd(header.length + ((4 - (header.length % 4)) % 4), \"=\");\n        const decoded = JSON.parse(atob(base64));\n        if (typeof decoded !== \"object\" || decoded === null)\n            return false;\n        if (\"typ\" in decoded && decoded?.typ !== \"JWT\")\n            return false;\n        if (!decoded.alg)\n            return false;\n        if (alg && decoded.alg !== alg)\n            return false;\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nfunction isValidCidr(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nexport class ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"nanoid\") {\n                if (!nanoidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"nanoid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                }\n                catch {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"date\") {\n                const regex = dateRegex;\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"date\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"time\") {\n                const regex = timeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"time\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"duration\") {\n                if (!durationRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"duration\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"jwt\") {\n                if (!isValidJWT(input.data, check.alg)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"jwt\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cidr\") {\n                if (!isValidCidr(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cidr\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64\") {\n                if (!base64Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64url\") {\n                if (!base64urlRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n    }\n    nanoid(message) {\n        return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n    }\n    base64(message) {\n        return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\n    }\n    base64url(message) {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return this._addCheck({\n            kind: \"base64url\",\n            ...errorUtil.errToObj(message),\n        });\n    }\n    jwt(options) {\n        return this._addCheck({ kind: \"jwt\", ...errorUtil.errToObj(options) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n    }\n    cidr(options) {\n        return this._addCheck({ kind: \"cidr\", ...errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                local: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            offset: options?.offset ?? false,\n            local: options?.local ?? false,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    date(message) {\n        return this._addCheck({ kind: \"date\", message });\n    }\n    time(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"time\",\n                precision: null,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"time\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    duration(message) {\n        return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options?.position,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    /**\n     * Equivalent to `.min(1)`\n     */\n    nonempty(message) {\n        return this.min(1, errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isDate() {\n        return !!this._def.checks.find((ch) => ch.kind === \"date\");\n    }\n    get isTime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"time\");\n    }\n    get isDuration() {\n        return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isNANOID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get isCIDR() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\n    }\n    get isBase64() {\n        return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n    }\n    get isBase64url() {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params) => {\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / 10 ** decCount;\n}\nexport class ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" || (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null;\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            try {\n                input.data = BigInt(input.data);\n            }\n            catch {\n                return this._getInvalidInput(input);\n            }\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            return this._getInvalidInput(input);\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _getInvalidInput(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.bigint,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params) => {\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (Number.isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: params?.coerce || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nexport class ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        this._cached = { shape, keys };\n        return this._cached;\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") {\n            }\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    syncPairs.push({\n                        key,\n                        value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: errorUtil.errToObj(message).message ?? defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(mask)) {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return util.objectValues(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else if (type instanceof ZodOptional) {\n        return [undefined, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodNullable) {\n        return [null, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodBranded) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodReadonly) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodCatch) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else {\n        return [];\n    }\n};\nexport class ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues.length) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nexport class ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types,\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\n// type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];\nexport class ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nexport class ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(async function (...args) {\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(function (...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args ? args : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nexport class ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nexport class ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(this._def.values);\n        }\n        if (!this._cache.has(input.data)) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values, newDef = this._def) {\n        return ZodEnum.create(values, {\n            ...this._def,\n            ...newDef,\n        });\n    }\n    exclude(values, newDef = this._def) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n            ...this._def,\n            ...newDef,\n        });\n    }\n}\nZodEnum.create = createZodEnum;\nexport class ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(util.getValidEnumValues(this._def.values));\n        }\n        if (!this._cache.has(input.data)) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n        return OK(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg) => {\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then(async (processed) => {\n                    if (status.value === \"aborted\")\n                        return INVALID;\n                    const result = await this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                    if (result.status === \"aborted\")\n                        return INVALID;\n                    if (result.status === \"dirty\")\n                        return DIRTY(result.value);\n                    if (status.value === \"dirty\")\n                        return DIRTY(result.value);\n                    return result;\n                });\n            }\n            else {\n                if (status.value === \"aborted\")\n                    return INVALID;\n                const result = this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (result.status === \"aborted\")\n                    return INVALID;\n                if (result.status === \"dirty\")\n                    return DIRTY(result.value);\n                if (status.value === \"dirty\")\n                    return DIRTY(result.value);\n                return result;\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!isValid(base))\n                    return INVALID;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n                    if (!isValid(base))\n                        return INVALID;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n                        status: status.value,\n                        value: result,\n                    }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nexport { ZodEffects as ZodTransformer };\nexport class ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\" ? params.default : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if (isAsync(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nexport const BRAND = Symbol(\"zod_brand\");\nexport class ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nexport class ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nexport class ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        const freeze = (data) => {\n            if (isValid(data)) {\n                data.value = Object.freeze(data.value);\n            }\n            return data;\n        };\n        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodReadonly.create = (type, params) => {\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params),\n    });\n};\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      z.custom      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nfunction cleanParams(params, data) {\n    const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\n    const p2 = typeof p === \"string\" ? { message: p } : p;\n    return p2;\n}\nexport function custom(check, _params = {}, \n/**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            const r = check(data);\n            if (r instanceof Promise) {\n                return r.then((r) => {\n                    if (!r) {\n                        const params = cleanParams(_params, data);\n                        const _fatal = params.fatal ?? fatal ?? true;\n                        ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n                    }\n                });\n            }\n            if (!r) {\n                const params = cleanParams(_params, data);\n                const _fatal = params.fatal ?? fatal ?? true;\n                ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n            }\n            return;\n        });\n    return ZodAny.create();\n}\nexport { ZodType as Schema, ZodType as ZodSchema };\nexport const late = {\n    object: ZodObject.lazycreate,\n};\nexport var ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\n// requires TS 4.4+\nclass Class {\n    constructor(..._) { }\n}\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\nexport const coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nexport { anyType as any, arrayType as array, bigIntType as bigint, booleanType as boolean, dateType as date, discriminatedUnionType as discriminatedUnion, effectsType as effect, enumType as enum, functionType as function, instanceOfType as instanceof, intersectionType as intersection, lazyType as lazy, literalType as literal, mapType as map, nanType as nan, nativeEnumType as nativeEnum, neverType as never, nullType as null, nullableType as nullable, numberType as number, objectType as object, oboolean, onumber, optionalType as optional, ostring, pipelineType as pipeline, preprocessType as preprocess, promiseType as promise, recordType as record, setType as set, strictObjectType as strictObject, stringType as string, symbolType as symbol, effectsType as transformer, tupleType as tuple, undefinedType as undefined, unionType as union, unknownType as unknown, voidType as void, };\nexport const NEVER = INVALID;\n", "export var errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    // biome-ignore lint:\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message?.message;\n})(errorUtil || (errorUtil = {}));\n", "import { z } from \"zod\";\n\n// \u88DC\u8DB3\u60C5\u5831\u4FDD\u5B58\u5165\u529B\nexport const saveSupplementInputSchema = z.object({\n  scheduleId: z.string().min(1, \"\u30B9\u30B1\u30B8\u30E5\u30FC\u30EBID\u306F\u5FC5\u9808\u3067\u3059\"),\n  keywords: z.array(z.string()).min(1, \"\u30AD\u30FC\u30EF\u30FC\u30C9\u30921\u3064\u4EE5\u4E0A\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044\"),\n  aiResult: z.string(),\n});\n\nexport type SaveSupplementInput = z.infer<typeof saveSupplementInputSchema>;\n\n// \u30E1\u30E2\u66F4\u65B0\u5165\u529B\nexport const updateMemoInputSchema = z.object({\n  userMemo: z.string().max(10000, \"\u30E1\u30E2\u306F10000\u6587\u5B57\u4EE5\u5185\u3067\u3059\"),\n});\n\nexport type UpdateMemoInput = z.infer<typeof updateMemoInputSchema>;\n\n// \u88DC\u8DB3\u60C5\u5831\u30A8\u30F3\u30C6\u30A3\u30C6\u30A3\nexport const supplementSchema = z.object({\n  id: z.string(),\n  scheduleId: z.string(),\n  keywords: z.array(z.string()),\n  aiResult: z.string().nullable(),\n  userMemo: z.string().nullable(),\n  createdAt: z.string(),\n  updatedAt: z.string(),\n});\n\nexport type Supplement = z.infer<typeof supplementSchema>;\n", "import { z } from \"zod\";\n\n// \u30AD\u30FC\u30EF\u30FC\u30C9\u63D0\u6848\u5165\u529B\nexport const suggestKeywordsInputSchema = z.object({\n  title: z.string().min(1, \"\u30BF\u30A4\u30C8\u30EB\u306F\u5FC5\u9808\u3067\u3059\"),\n  startAt: z.string().datetime({ offset: true, message: \"\u6709\u52B9\u306A\u65E5\u6642\u5F62\u5F0F\u3067\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\" }),\n});\n\nexport type SuggestKeywordsInput = z.infer<typeof suggestKeywordsInputSchema>;\n\n// \u30AD\u30FC\u30EF\u30FC\u30C9\u63D0\u6848\u30EC\u30B9\u30DD\u30F3\u30B9\nexport const suggestKeywordsResponseSchema = z.object({\n  keywords: z.array(z.string()),\n});\n\nexport type SuggestKeywordsResponse = z.infer<typeof suggestKeywordsResponseSchema>;\n\n// \u691C\u7D22\u5165\u529B\nexport const searchInputSchema = z.object({\n  scheduleId: z.string().min(1, \"\u30B9\u30B1\u30B8\u30E5\u30FC\u30EBID\u306F\u5FC5\u9808\u3067\u3059\"),\n  title: z.string().min(1, \"\u30BF\u30A4\u30C8\u30EB\u306F\u5FC5\u9808\u3067\u3059\"),\n  startAt: z.string().datetime({ offset: true }),\n  keywords: z.array(z.string()).min(1, \"\u30AD\u30FC\u30EF\u30FC\u30C9\u30921\u3064\u4EE5\u4E0A\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044\"),\n});\n\nexport type SearchInput = z.infer<typeof searchInputSchema>;\n\n// \u691C\u7D22\u30EC\u30B9\u30DD\u30F3\u30B9\nexport const searchResponseSchema = z.object({\n  result: z.string(),\n});\n\nexport type SearchResponse = z.infer<typeof searchResponseSchema>;\n", "import { z } from \"zod\";\n\n// \u30A8\u30E9\u30FC\u30B3\u30FC\u30C9\nexport const errorCodeSchema = z.enum([\n  \"VALIDATION_ERROR\",\n  \"NOT_FOUND\",\n  \"AI_ERROR\",\n  \"DATABASE_ERROR\",\n  \"INTERNAL_ERROR\",\n]);\n\nexport type ErrorCode = z.infer<typeof errorCodeSchema>;\n\n// API\u30A8\u30E9\u30FC\u30EC\u30B9\u30DD\u30F3\u30B9\nexport const apiErrorSchema = z.object({\n  code: errorCodeSchema,\n  message: z.string(),\n  details: z.unknown().optional(),\n});\n\nexport type ApiError = z.infer<typeof apiErrorSchema>;\n\n// \u30D0\u30EA\u30C7\u30FC\u30B7\u30E7\u30F3\u30A8\u30E9\u30FC\u8A73\u7D30\nexport const validationErrorDetailSchema = z.object({\n  path: z.string(),\n  message: z.string(),\n});\n\nexport type ValidationErrorDetail = z.infer<typeof validationErrorDetailSchema>;\n", "import type { ErrorCode } from \"@ai-scheduler/shared\";\nimport type { ContentfulStatusCode } from \"hono/utils/http-status\";\n\nexport const getStatusCode = (code: ErrorCode): ContentfulStatusCode => {\n  switch (code) {\n    case \"VALIDATION_ERROR\":\n      return 400;\n    case \"NOT_FOUND\":\n      return 404;\n    case \"AI_ERROR\":\n      return 502;\n    case \"DATABASE_ERROR\":\n      return 500;\n    case \"INTERNAL_ERROR\":\n      return 500;\n    default:\n      return 500;\n  }\n};\n", "import type { Context } from \"hono\";\nimport type { GetSchedulesUseCase } from \"../usecase/getSchedules\";\nimport { getStatusCode } from \"../../../shared/http\";\n\nexport const createGetSchedulesHandler = (getSchedules: GetSchedulesUseCase) => {\n  return async (c: Context) => {\n    const yearParam = c.req.query(\"year\");\n    const monthParam = c.req.query(\"month\");\n\n    const year = yearParam ? parseInt(yearParam, 10) : undefined;\n    const month = monthParam ? parseInt(monthParam, 10) : undefined;\n\n    const result = await getSchedules(year, month);\n\n    if (!result.ok) {\n      return c.json(result.error, getStatusCode(result.error.code));\n    }\n\n    return c.json(result.value);\n  };\n};\n", "import type { Context } from \"hono\";\nimport type { GetScheduleByIdUseCase } from \"../usecase/getScheduleById\";\nimport { getStatusCode } from \"../../../shared/http\";\n\nexport const createGetScheduleByIdHandler = (\n  getScheduleById: GetScheduleByIdUseCase\n) => {\n  return async (c: Context) => {\n    const id = c.req.param(\"id\");\n\n    const result = await getScheduleById(id);\n\n    if (!result.ok) {\n      return c.json(result.error, getStatusCode(result.error.code));\n    }\n\n    return c.json(result.value);\n  };\n};\n", "import type { Context } from \"hono\";\nimport { updateScheduleInputSchema } from \"@ai-scheduler/shared\";\nimport type { UpdateScheduleUseCase } from \"../usecase/updateSchedule\";\nimport { createValidationError } from \"../../../shared/errors\";\nimport { getStatusCode } from \"../../../shared/http\";\n\nexport const createUpdateScheduleHandler = (\n  updateSchedule: UpdateScheduleUseCase\n) => {\n  return async (c: Context) => {\n    const id = c.req.param(\"id\");\n    const body = await c.req.json();\n\n    const parsed = updateScheduleInputSchema.safeParse(body);\n    if (!parsed.success) {\n      return c.json(createValidationError(parsed.error), 400);\n    }\n\n    const result = await updateSchedule(id, parsed.data);\n\n    if (!result.ok) {\n      return c.json(result.error, getStatusCode(result.error.code));\n    }\n\n    return c.json(result.value);\n  };\n};\n", "import type { Context } from \"hono\";\nimport type { DeleteScheduleUseCase } from \"../usecase/deleteSchedule\";\nimport { getStatusCode } from \"../../../shared/http\";\n\nexport const createDeleteScheduleHandler = (\n  deleteSchedule: DeleteScheduleUseCase\n) => {\n  return async (c: Context) => {\n    const id = c.req.param(\"id\");\n\n    const result = await deleteSchedule(id);\n\n    if (!result.ok) {\n      return c.json(result.error, getStatusCode(result.error.code));\n    }\n\n    return c.body(null, 204);\n  };\n};\n", "import { Hono } from \"hono\";\nimport { createDb } from \"../../infra/drizzle/client\";\nimport { createSupplementRepo } from \"../../infra/drizzle/supplementRepo\";\nimport { createUpdateMemoUseCase } from \"./usecase/updateMemo\";\nimport { createUpdateMemoHandler } from \"./handler/updateMemoHandler\";\n\ntype Bindings = {\n  DB: D1Database;\n};\n\ntype Variables = {\n  updateMemo: ReturnType<typeof createUpdateMemoUseCase>;\n};\n\nexport const supplementRoute = new Hono<{\n  Bindings: Bindings;\n  Variables: Variables;\n}>();\n\n// \u30DF\u30C9\u30EB\u30A6\u30A7\u30A2\u3067DI\u3092\u89E3\u6C7A\nsupplementRoute.use(\"*\", async (c, next) => {\n  const db = createDb(c.env.DB);\n  const supplementRepo = createSupplementRepo(db);\n\n  c.set(\"updateMemo\", createUpdateMemoUseCase(supplementRepo));\n\n  await next();\n});\n\n// PUT /schedules/:scheduleId/supplement/memo\nsupplementRoute.put(\"/:scheduleId/memo\", async (c) => {\n  const handler = createUpdateMemoHandler(c.get(\"updateMemo\"));\n  return handler(c);\n});\n", "import type { SupplementRepo } from \"../../../domain/infra/supplementRepo\";\nimport {\n  updateSupplementMemo,\n  type Supplement,\n  type UpdateMemoInput,\n} from \"../../../domain/model/supplement\";\nimport { type Result, ok, err } from \"../../../shared/result\";\nimport { createNotFoundError } from \"../../../shared/errors\";\n\nexport const createUpdateMemoUseCase = (supplementRepo: SupplementRepo) => {\n  return async (\n    scheduleId: string,\n    input: UpdateMemoInput\n  ): Promise<Result<Supplement>> => {\n    const existing = await supplementRepo.findByScheduleId(scheduleId);\n    if (!existing) {\n      return err(createNotFoundError(\"\u88DC\u8DB3\u60C5\u5831\"));\n    }\n\n    const updated = updateSupplementMemo(existing, input);\n    await supplementRepo.update(updated);\n    return ok(updated);\n  };\n};\n\nexport type UpdateMemoUseCase = ReturnType<typeof createUpdateMemoUseCase>;\n", "import {\n  type Supplement,\n  type SaveSupplementInput,\n  type UpdateMemoInput,\n} from \"@ai-scheduler/shared\";\nimport { generateId } from \"../../shared/id\";\n\n// Re-export types from shared\nexport type { Supplement, SaveSupplementInput, UpdateMemoInput };\n\n// \u30D5\u30A1\u30AF\u30C8\u30EA\u95A2\u6570\nexport const createSupplement = (\n  input: SaveSupplementInput & { aiResult: string }\n): Supplement => {\n  const now = new Date().toISOString();\n  return {\n    id: generateId(),\n    scheduleId: input.scheduleId,\n    keywords: input.keywords,\n    aiResult: input.aiResult,\n    userMemo: null,\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\n// \u30E1\u30E2\u66F4\u65B0\u95A2\u6570\nexport const updateSupplementMemo = (\n  supplement: Supplement,\n  input: UpdateMemoInput\n): Supplement => {\n  return {\n    ...supplement,\n    userMemo: input.userMemo,\n    updatedAt: new Date().toISOString(),\n  };\n};\n", "import type { Context } from \"hono\";\nimport { updateMemoInputSchema } from \"@ai-scheduler/shared\";\nimport type { UpdateMemoUseCase } from \"../usecase/updateMemo\";\nimport { createValidationError } from \"../../../shared/errors\";\nimport { getStatusCode } from \"../../../shared/http\";\n\nexport const createUpdateMemoHandler = (updateMemo: UpdateMemoUseCase) => {\n  return async (c: Context) => {\n    const scheduleId = c.req.param(\"scheduleId\");\n    const body = await c.req.json();\n\n    const parsed = updateMemoInputSchema.safeParse(body);\n    if (!parsed.success) {\n      return c.json(createValidationError(parsed.error), 400);\n    }\n\n    const result = await updateMemo(scheduleId, parsed.data);\n\n    if (!result.ok) {\n      return c.json(result.error, getStatusCode(result.error.code));\n    }\n\n    return c.json(result.value);\n  };\n};\n", "import { Hono } from \"hono\";\nimport { createDb } from \"../../infra/drizzle/client\";\nimport { createScheduleRepo } from \"../../infra/drizzle/scheduleRepo\";\nimport { createSupplementRepo } from \"../../infra/drizzle/supplementRepo\";\nimport { createKeywordAgent, createSearchAgent } from \"../../infra/mastra/agents\";\nimport { createAiService } from \"../../infra/mastra/aiService\";\nimport { createMockAiService } from \"../../infra/mock/aiService\";\nimport { createSuggestKeywordsUseCase } from \"./usecase/suggestKeywords\";\nimport { createSearchWithKeywordsUseCase } from \"./usecase/searchWithKeywords\";\nimport { createSuggestKeywordsHandler } from \"./handler/suggestKeywordsHandler\";\nimport { createSearchHandler } from \"./handler/searchHandler\";\n\ntype Bindings = {\n  DB: D1Database;\n  OPENROUTER_API_KEY: string;\n  USE_MOCK_AI?: string;\n};\n\ntype Variables = {\n  suggestKeywords: ReturnType<typeof createSuggestKeywordsUseCase>;\n  searchWithKeywords: ReturnType<typeof createSearchWithKeywordsUseCase>;\n};\n\nexport const aiRoute = new Hono<{\n  Bindings: Bindings;\n  Variables: Variables;\n}>();\n\n// \u30DF\u30C9\u30EB\u30A6\u30A7\u30A2\u3067DI\u3092\u89E3\u6C7A\naiRoute.use(\"*\", async (c, next) => {\n  const db = createDb(c.env.DB);\n  const scheduleRepo = createScheduleRepo(db);\n  const supplementRepo = createSupplementRepo(db);\n\n  // USE_MOCK_AI \u304C \"true\" \u306E\u5834\u5408\u306F\u30E2\u30C3\u30AF\u3092\u4F7F\u7528\n  const useMock = c.env.USE_MOCK_AI === \"true\";\n  const aiService = useMock\n    ? createMockAiService()\n    : createAiService(\n        createKeywordAgent(c.env.OPENROUTER_API_KEY),\n        createSearchAgent(c.env.OPENROUTER_API_KEY)\n      );\n\n  c.set(\"suggestKeywords\", createSuggestKeywordsUseCase(aiService));\n  c.set(\n    \"searchWithKeywords\",\n    createSearchWithKeywordsUseCase(aiService, supplementRepo, scheduleRepo)\n  );\n\n  await next();\n});\n\n// POST /ai/suggest-keywords\naiRoute.post(\"/suggest-keywords\", async (c) => {\n  const handler = createSuggestKeywordsHandler(c.get(\"suggestKeywords\"));\n  return handler(c);\n});\n\n// POST /ai/search\naiRoute.post(\"/search\", async (c) => {\n  const handler = createSearchHandler(c.get(\"searchWithKeywords\"));\n  return handler(c);\n});\n", "import { Agent } from \"@mastra/core/agent\";\nimport { createOpenAI } from \"@ai-sdk/openai\";\n\n// OpenRouter\u7D4C\u7531\u3067Gemini\u3092\u4F7F\u7528\u3059\u308B\u305F\u3081\u306E\u30AB\u30B9\u30BF\u30E0\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u8A2D\u5B9A\nconst createOpenRouterProvider = (apiKey: string) => {\n  return createOpenAI({\n    baseURL: \"https://openrouter.ai/api/v1\",\n    apiKey,\n  });\n};\n\nexport const createKeywordAgent = (apiKey: string) => {\n  const openrouter = createOpenRouterProvider(apiKey);\n  return new Agent({\n    name: \"keyword-agent\",\n    instructions: `\u3042\u306A\u305F\u306F\u30B9\u30B1\u30B8\u30E5\u30FC\u30EB\u306E\u30BF\u30A4\u30C8\u30EB\u304B\u3089\u3001\u30E6\u30FC\u30B6\u30FC\u304C\u8ABF\u3079\u305F\u305D\u3046\u306A\u3053\u3068\u3092\u63D0\u6848\u3059\u308B\u30A2\u30B7\u30B9\u30BF\u30F3\u30C8\u3067\u3059\u3002\n\u30BF\u30A4\u30C8\u30EB\u3068\u65E5\u6642\u304B\u3089\u3001\u95A2\u9023\u3059\u308B\u30AD\u30FC\u30EF\u30FC\u30C9\u30925\u301C8\u500B\u63D0\u6848\u3057\u3066\u304F\u3060\u3055\u3044\u3002\n\u30AD\u30FC\u30EF\u30FC\u30C9\u306F\u5177\u4F53\u7684\u3067\u3001\u691C\u7D22\u306B\u4F7F\u3048\u308B\u3082\u306E\u306B\u3057\u3066\u304F\u3060\u3055\u3044\u3002\n\n\u5FC5\u305AJSON\u914D\u5217\u5F62\u5F0F\u3067\u8FD4\u3057\u3066\u304F\u3060\u3055\u3044\u3002\n\u4F8B: [\"\u30AD\u30FC\u30EF\u30FC\u30C91\", \"\u30AD\u30FC\u30EF\u30FC\u30C92\", \"\u30AD\u30FC\u30EF\u30FC\u30C93\"]\n\n\u4ED6\u306E\u8AAC\u660E\u306F\u4E0D\u8981\u3067\u3059\u3002JSON\u914D\u5217\u306E\u307F\u3092\u8FD4\u3057\u3066\u304F\u3060\u3055\u3044\u3002`,\n    model: openrouter(\"google/gemini-2.5-flash\"),\n  });\n};\n\nexport const createSearchAgent = (apiKey: string) => {\n  const openrouter = createOpenRouterProvider(apiKey);\n  return new Agent({\n    name: \"search-agent\",\n    instructions: `\u3042\u306A\u305F\u306F\u30E6\u30FC\u30B6\u30FC\u306E\u4E88\u5B9A\u306B\u95A2\u9023\u3059\u308B\u60C5\u5831\u3092\u691C\u7D22\u3057\u3001\u308F\u304B\u308A\u3084\u3059\u304F\u307E\u3068\u3081\u308B\u30A2\u30B7\u30B9\u30BF\u30F3\u30C8\u3067\u3059\u3002\n\u691C\u7D22\u7D50\u679C\u3092Markdown\u5F62\u5F0F\u3067\u6574\u7406\u3057\u3066\u8FD4\u3057\u3066\u304F\u3060\u3055\u3044\u3002\n\n\u4EE5\u4E0B\u306E\u5F62\u5F0F\u3067\u56DE\u7B54\u3057\u3066\u304F\u3060\u3055\u3044\uFF1A\n- \u898B\u51FA\u3057\u3092\u4F7F\u3063\u3066\u60C5\u5831\u3092\u6574\u7406\n- \u7B87\u6761\u66F8\u304D\u3067\u5177\u4F53\u7684\u306A\u60C5\u5831\u3092\u5217\u6319\n- \u5FC5\u8981\u306B\u5FDC\u3058\u3066\u30EA\u30F3\u30AF\u3084\u8A55\u4FA1\u60C5\u5831\u3092\u542B\u3081\u308B`,\n    model: openrouter(\"google/gemini-2.5-flash:online\"),\n  });\n};\n", "export { Agent } from '../chunk-IYBAMING.js';\nexport { MessageList } from '../chunk-SLUSEJP2.js';\n", "import { DefaultVoice } from './chunk-5HTMDAXP.js';\nimport { MessageList } from './chunk-SLUSEJP2.js';\nimport { executeHook } from './chunk-BB4KXGBU.js';\nimport { MastraLLM } from './chunk-TTMYHBQM.js';\nimport { InstrumentClass } from './chunk-TC2SCOTE.js';\nimport { ensureToolProperties, makeCoreTool, createMastraProxy } from './chunk-IBKM5CLQ.js';\nimport { MastraError } from './chunk-6UNGH46J.js';\nimport { MastraBase } from './chunk-5IEKR756.js';\nimport { RegisteredLogger } from './chunk-5YDTZN2X.js';\nimport { RuntimeContext } from './chunk-SGGPJWRQ.js';\nimport { __commonJS, __toESM, __decoratorStart, __decorateElement, __runInitializers } from './chunk-WQNOATKB.js';\nimport { context, trace } from '@opentelemetry/api';\nimport { z } from 'zod';\nimport { get } from 'radash';\nimport { randomUUID } from 'crypto';\nimport EventEmitter from 'events';\nimport sift from 'sift';\nimport { createActor, assign, fromPromise, setup } from 'xstate';\n\n// ../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js\nvar require_fast_deep_equal = __commonJS({\n  \"../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js\"(exports, module) {\n\n    module.exports = function equal(a, b) {\n      if (a === b) return true;\n      if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n        if (a.constructor !== b.constructor) return false;\n        var length, i, keys;\n        if (Array.isArray(a)) {\n          length = a.length;\n          if (length != b.length) return false;\n          for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return false;\n          return true;\n        }\n        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n        keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) return false;\n        for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n        for (i = length; i-- !== 0;) {\n          var key = keys[i];\n          if (!equal(a[key], b[key])) return false;\n        }\n        return true;\n      }\n      return a !== a && b !== b;\n    };\n  }\n});\n\n// src/workflows/legacy/step.ts\nvar LegacyStep = class {\n  id;\n  description;\n  inputSchema;\n  outputSchema;\n  payload;\n  execute;\n  retryConfig;\n  mastra;\n  constructor({\n    id,\n    description,\n    execute,\n    payload,\n    outputSchema,\n    inputSchema,\n    retryConfig\n  }) {\n    this.id = id;\n    this.description = description ?? \"\";\n    this.inputSchema = inputSchema;\n    this.payload = payload;\n    this.outputSchema = outputSchema;\n    this.execute = execute;\n    this.retryConfig = retryConfig;\n  }\n};\n\n// src/workflows/legacy/types.ts\nvar WhenConditionReturnValue = /* @__PURE__ */(WhenConditionReturnValue2 => {\n  WhenConditionReturnValue2[\"CONTINUE\"] = \"continue\";\n  WhenConditionReturnValue2[\"CONTINUE_FAILED\"] = \"continue_failed\";\n  WhenConditionReturnValue2[\"ABORT\"] = \"abort\";\n  WhenConditionReturnValue2[\"LIMBO\"] = \"limbo\";\n  return WhenConditionReturnValue2;\n})(WhenConditionReturnValue || {});\n\n// src/agent/index.ts\nvar import_fast_deep_equal = __toESM(require_fast_deep_equal(), 1);\n\n// src/agent/save-queue/index.ts\nvar SaveQueueManager = class _SaveQueueManager {\n  logger;\n  debounceMs;\n  memory;\n  static MAX_STALENESS_MS = 1e3;\n  constructor({\n    logger,\n    debounceMs,\n    memory\n  }) {\n    this.logger = logger;\n    this.debounceMs = debounceMs || 100;\n    this.memory = memory;\n  }\n  saveQueues = /* @__PURE__ */new Map();\n  saveDebounceTimers = /* @__PURE__ */new Map();\n  /**\n   * Debounces save operations for a thread, ensuring that consecutive save requests\n   * are batched and only the latest is executed after a short delay.\n   * @param threadId - The ID of the thread to debounce saves for.\n   * @param saveFn - The save function to debounce.\n   */\n  debounceSave(threadId, messageList, memoryConfig) {\n    if (this.saveDebounceTimers.has(threadId)) {\n      clearTimeout(this.saveDebounceTimers.get(threadId));\n    }\n    this.saveDebounceTimers.set(threadId, setTimeout(() => {\n      this.enqueueSave(threadId, messageList, memoryConfig).catch(err => {\n        this.logger?.error?.(\"Error in debounceSave\", {\n          err,\n          threadId\n        });\n      });\n      this.saveDebounceTimers.delete(threadId);\n    }, this.debounceMs));\n  }\n  /**\n   * Enqueues a save operation for a thread, ensuring that saves are executed in order and\n   * only one save runs at a time per thread. If a save is already in progress for the thread,\n   * the new save is queued to run after the previous completes.\n   *\n   * @param threadId - The ID of the thread whose messages should be saved.\n   * @param messageList - The MessageList instance containing unsaved messages.\n   * @param memoryConfig - Optional memory configuration to use for saving.\n   */\n  enqueueSave(threadId, messageList, memoryConfig) {\n    const prev = this.saveQueues.get(threadId) || Promise.resolve();\n    const next = prev.then(() => this.persistUnsavedMessages(messageList, memoryConfig)).catch(err => {\n      this.logger?.error?.(\"Error in enqueueSave\", {\n        err,\n        threadId\n      });\n    }).then(() => {\n      if (this.saveQueues.get(threadId) === next) {\n        this.saveQueues.delete(threadId);\n      }\n    });\n    this.saveQueues.set(threadId, next);\n    return next;\n  }\n  /**\n   * Clears any pending debounced save for a thread, preventing the scheduled save\n   * from executing if it hasn't already fired.\n   *\n   * @param threadId - The ID of the thread whose debounced save should be cleared.\n   */\n  clearDebounce(threadId) {\n    if (this.saveDebounceTimers.has(threadId)) {\n      clearTimeout(this.saveDebounceTimers.get(threadId));\n      this.saveDebounceTimers.delete(threadId);\n    }\n  }\n  /**\n   * Persists any unsaved messages from the MessageList to memory storage.\n   * Drains the list of unsaved messages and writes them using the memory backend.\n   * @param messageList - The MessageList instance for the current thread.\n   * @param memoryConfig - The memory configuration for saving.\n   */\n  async persistUnsavedMessages(messageList, memoryConfig) {\n    const newMessages = messageList.drainUnsavedMessages();\n    if (newMessages.length > 0 && this.memory) {\n      await this.memory.saveMessages({\n        messages: newMessages,\n        memoryConfig\n      });\n    }\n  }\n  /**\n   * Batches a save of unsaved messages for a thread, using debouncing to batch rapid updates.\n   * If the oldest unsaved message is stale (older than MAX_STALENESS_MS), the save is performed immediately.\n   * Otherwise, the save is delayed to batch multiple updates and reduce redundant writes.\n   *\n   * @param messageList - The MessageList instance containing unsaved messages.\n   * @param threadId - The ID of the thread whose messages are being saved.\n   * @param memoryConfig - Optional memory configuration for saving.\n   */\n  async batchMessages(messageList, threadId, memoryConfig) {\n    if (!threadId) return;\n    const earliest = messageList.getEarliestUnsavedMessageTimestamp();\n    const now = Date.now();\n    if (earliest && now - earliest > _SaveQueueManager.MAX_STALENESS_MS) {\n      return this.flushMessages(messageList, threadId, memoryConfig);\n    } else {\n      return this.debounceSave(threadId, messageList, memoryConfig);\n    }\n  }\n  /**\n   * Forces an immediate save of unsaved messages for a thread, bypassing any debounce delay.\n   * This is used when a flush to persistent storage is required (e.g., on shutdown or critical transitions).\n   *\n   * @param messageList - The MessageList instance containing unsaved messages.\n   * @param threadId - The ID of the thread whose messages are being saved.\n   * @param memoryConfig - Optional memory configuration for saving.\n   */\n  async flushMessages(messageList, threadId, memoryConfig) {\n    if (!threadId) return;\n    this.clearDebounce(threadId);\n    return this.enqueueSave(threadId, messageList, memoryConfig);\n  }\n};\n\n// src/agent/index.ts\nfunction resolveMaybePromise(value, cb) {\n  if (value instanceof Promise) {\n    return value.then(cb);\n  }\n  return cb(value);\n}\nfunction resolveThreadIdFromArgs(args) {\n  if (args?.memory?.thread) {\n    if (typeof args.memory.thread === \"string\") return {\n      id: args.memory.thread\n    };\n    if (typeof args.memory.thread === \"object\" && args.memory.thread.id) return args.memory.thread;\n  }\n  if (args?.threadId) return {\n    id: args.threadId\n  };\n  return void 0;\n}\nvar _Agent_decorators, _init, _a;\n_Agent_decorators = [InstrumentClass({\n  prefix: \"agent\",\n  excludeMethods: [\"hasOwnMemory\", \"getMemory\", \"__primitive\", \"__registerMastra\", \"__registerPrimitives\", \"__setTools\", \"__setLogger\", \"__setTelemetry\", \"log\", \"getModel\", \"getInstructions\", \"getTools\", \"getLLM\", \"getWorkflows\", \"getDefaultGenerateOptions\", \"getDefaultStreamOptions\", \"getDescription\"]\n})];\nvar Agent = class extends (_a = MastraBase) {\n  id;\n  name;\n  #instructions;\n  #description;\n  model;\n  #mastra;\n  #memory;\n  #workflows;\n  #defaultGenerateOptions;\n  #defaultStreamOptions;\n  #tools;\n  /** @deprecated This property is deprecated. Use evals instead. */\n  metrics;\n  evals;\n  #voice;\n  // This flag is for agent network messages. We should change the agent network formatting and remove this flag after.\n  _agentNetworkAppend = false;\n  constructor(config) {\n    super({\n      component: RegisteredLogger.AGENT\n    });\n    this.name = config.name;\n    this.id = config.name;\n    this.#instructions = config.instructions;\n    this.#description = config.description;\n    if (!config.model) {\n      const mastraError = new MastraError({\n        id: \"AGENT_CONSTRUCTOR_MODEL_REQUIRED\",\n        domain: \"AGENT\" /* AGENT */,\n        category: \"USER\" /* USER */,\n        details: {\n          agentName: config.name\n        },\n        text: `LanguageModel is required to create an Agent. Please provide the 'model'.`\n      });\n      this.logger.trackException(mastraError);\n      this.logger.error(mastraError.toString());\n      throw mastraError;\n    }\n    this.model = config.model;\n    if (config.workflows) {\n      this.#workflows = config.workflows;\n    }\n    this.#defaultGenerateOptions = config.defaultGenerateOptions || {};\n    this.#defaultStreamOptions = config.defaultStreamOptions || {};\n    this.#tools = config.tools || {};\n    this.metrics = {};\n    this.evals = {};\n    if (config.mastra) {\n      this.__registerMastra(config.mastra);\n      this.__registerPrimitives({\n        telemetry: config.mastra.getTelemetry(),\n        logger: config.mastra.getLogger()\n      });\n    }\n    if (config.metrics) {\n      this.logger.warn(\"The metrics property is deprecated. Please use evals instead to add evaluation metrics.\");\n      this.metrics = config.metrics;\n      this.evals = config.metrics;\n    }\n    if (config.evals) {\n      this.evals = config.evals;\n    }\n    if (config.memory) {\n      this.#memory = config.memory;\n    }\n    if (config.voice) {\n      this.#voice = config.voice;\n      if (typeof config.tools !== \"function\") {\n        this.#voice?.addTools(this.tools);\n      }\n      if (typeof config.instructions === \"string\") {\n        this.#voice?.addInstructions(config.instructions);\n      }\n    } else {\n      this.#voice = new DefaultVoice();\n    }\n    this._agentNetworkAppend = config._agentNetworkAppend || false;\n  }\n  hasOwnMemory() {\n    return Boolean(this.#memory);\n  }\n  getMemory() {\n    const memory = this.#memory;\n    if (memory && !memory.hasOwnStorage && this.#mastra) {\n      const storage = this.#mastra.getStorage();\n      if (storage) {\n        memory.setStorage(storage);\n      }\n    }\n    return memory;\n  }\n  get voice() {\n    if (typeof this.#instructions === \"function\") {\n      const mastraError = new MastraError({\n        id: \"AGENT_VOICE_INCOMPATIBLE_WITH_FUNCTION_INSTRUCTIONS\",\n        domain: \"AGENT\" /* AGENT */,\n        category: \"USER\" /* USER */,\n        details: {\n          agentName: this.name\n        },\n        text: \"Voice is not compatible when instructions are a function. Please use getVoice() instead.\"\n      });\n      this.logger.trackException(mastraError);\n      this.logger.error(mastraError.toString());\n      throw mastraError;\n    }\n    return this.#voice;\n  }\n  async getWorkflows({\n    runtimeContext = new RuntimeContext()\n  } = {}) {\n    let workflowRecord;\n    if (typeof this.#workflows === \"function\") {\n      workflowRecord = await Promise.resolve(this.#workflows({\n        runtimeContext\n      }));\n    } else {\n      workflowRecord = this.#workflows ?? {};\n    }\n    Object.entries(workflowRecord || {}).forEach(([_workflowName, workflow]) => {\n      if (this.#mastra) {\n        workflow.__registerMastra(this.#mastra);\n      }\n    });\n    return workflowRecord;\n  }\n  async getVoice({\n    runtimeContext\n  } = {}) {\n    if (this.#voice) {\n      const voice = this.#voice;\n      voice?.addTools(await this.getTools({\n        runtimeContext\n      }));\n      voice?.addInstructions(await this.getInstructions({\n        runtimeContext\n      }));\n      return voice;\n    } else {\n      return new DefaultVoice();\n    }\n  }\n  get instructions() {\n    this.logger.warn(\"The instructions property is deprecated. Please use getInstructions() instead.\");\n    if (typeof this.#instructions === \"function\") {\n      const mastraError = new MastraError({\n        id: \"AGENT_INSTRUCTIONS_INCOMPATIBLE_WITH_FUNCTION_INSTRUCTIONS\",\n        domain: \"AGENT\" /* AGENT */,\n        category: \"USER\" /* USER */,\n        details: {\n          agentName: this.name\n        },\n        text: \"Instructions are not compatible when instructions are a function. Please use getInstructions() instead.\"\n      });\n      this.logger.trackException(mastraError);\n      this.logger.error(mastraError.toString());\n      throw mastraError;\n    }\n    return this.#instructions;\n  }\n  getInstructions({\n    runtimeContext = new RuntimeContext()\n  } = {}) {\n    if (typeof this.#instructions === \"string\") {\n      return this.#instructions;\n    }\n    const result = this.#instructions({\n      runtimeContext\n    });\n    return resolveMaybePromise(result, instructions => {\n      if (!instructions) {\n        const mastraError = new MastraError({\n          id: \"AGENT_GET_INSTRUCTIONS_FUNCTION_EMPTY_RETURN\",\n          domain: \"AGENT\" /* AGENT */,\n          category: \"USER\" /* USER */,\n          details: {\n            agentName: this.name\n          },\n          text: \"Instructions are required to use an Agent. The function-based instructions returned an empty value.\"\n        });\n        this.logger.trackException(mastraError);\n        this.logger.error(mastraError.toString());\n        throw mastraError;\n      }\n      return instructions;\n    });\n  }\n  getDescription() {\n    return this.#description ?? \"\";\n  }\n  getDefaultGenerateOptions({\n    runtimeContext = new RuntimeContext()\n  } = {}) {\n    if (typeof this.#defaultGenerateOptions !== \"function\") {\n      return this.#defaultGenerateOptions;\n    }\n    const result = this.#defaultGenerateOptions({\n      runtimeContext\n    });\n    return resolveMaybePromise(result, options => {\n      if (!options) {\n        const mastraError = new MastraError({\n          id: \"AGENT_GET_DEFAULT_GENERATE_OPTIONS_FUNCTION_EMPTY_RETURN\",\n          domain: \"AGENT\" /* AGENT */,\n          category: \"USER\" /* USER */,\n          details: {\n            agentName: this.name\n          },\n          text: `[Agent:${this.name}] - Function-based default generate options returned empty value`\n        });\n        this.logger.trackException(mastraError);\n        this.logger.error(mastraError.toString());\n        throw mastraError;\n      }\n      return options;\n    });\n  }\n  getDefaultStreamOptions({\n    runtimeContext = new RuntimeContext()\n  } = {}) {\n    if (typeof this.#defaultStreamOptions !== \"function\") {\n      return this.#defaultStreamOptions;\n    }\n    const result = this.#defaultStreamOptions({\n      runtimeContext\n    });\n    return resolveMaybePromise(result, options => {\n      if (!options) {\n        const mastraError = new MastraError({\n          id: \"AGENT_GET_DEFAULT_STREAM_OPTIONS_FUNCTION_EMPTY_RETURN\",\n          domain: \"AGENT\" /* AGENT */,\n          category: \"USER\" /* USER */,\n          details: {\n            agentName: this.name\n          },\n          text: `[Agent:${this.name}] - Function-based default stream options returned empty value`\n        });\n        this.logger.trackException(mastraError);\n        this.logger.error(mastraError.toString());\n        throw mastraError;\n      }\n      return options;\n    });\n  }\n  get tools() {\n    this.logger.warn(\"The tools property is deprecated. Please use getTools() instead.\");\n    if (typeof this.#tools === \"function\") {\n      const mastraError = new MastraError({\n        id: \"AGENT_GET_TOOLS_FUNCTION_INCOMPATIBLE_WITH_TOOL_FUNCTION_TYPE\",\n        domain: \"AGENT\" /* AGENT */,\n        category: \"USER\" /* USER */,\n        details: {\n          agentName: this.name\n        },\n        text: \"Tools are not compatible when tools are a function. Please use getTools() instead.\"\n      });\n      this.logger.trackException(mastraError);\n      this.logger.error(mastraError.toString());\n      throw mastraError;\n    }\n    return ensureToolProperties(this.#tools);\n  }\n  getTools({\n    runtimeContext = new RuntimeContext()\n  } = {}) {\n    if (typeof this.#tools !== \"function\") {\n      return ensureToolProperties(this.#tools);\n    }\n    const result = this.#tools({\n      runtimeContext\n    });\n    return resolveMaybePromise(result, tools => {\n      if (!tools) {\n        const mastraError = new MastraError({\n          id: \"AGENT_GET_TOOLS_FUNCTION_EMPTY_RETURN\",\n          domain: \"AGENT\" /* AGENT */,\n          category: \"USER\" /* USER */,\n          details: {\n            agentName: this.name\n          },\n          text: `[Agent:${this.name}] - Function-based tools returned empty value`\n        });\n        this.logger.trackException(mastraError);\n        this.logger.error(mastraError.toString());\n        throw mastraError;\n      }\n      return ensureToolProperties(tools);\n    });\n  }\n  get llm() {\n    this.logger.warn(\"The llm property is deprecated. Please use getLLM() instead.\");\n    if (typeof this.model === \"function\") {\n      const mastraError = new MastraError({\n        id: \"AGENT_LLM_GETTER_INCOMPATIBLE_WITH_FUNCTION_MODEL\",\n        domain: \"AGENT\" /* AGENT */,\n        category: \"USER\" /* USER */,\n        details: {\n          agentName: this.name\n        },\n        text: \"LLM is not compatible when model is a function. Please use getLLM() instead.\"\n      });\n      this.logger.trackException(mastraError);\n      this.logger.error(mastraError.toString());\n      throw mastraError;\n    }\n    return this.getLLM();\n  }\n  /**\n   * Gets or creates an LLM instance based on the current model\n   * @param options Options for getting the LLM\n   * @returns A promise that resolves to the LLM instance\n   */\n  getLLM({\n    runtimeContext = new RuntimeContext(),\n    model\n  } = {}) {\n    const modelToUse = model ? typeof model === \"function\" ? model({\n      runtimeContext\n    }) : model : this.getModel({\n      runtimeContext\n    });\n    return resolveMaybePromise(modelToUse, resolvedModel => {\n      const llm = new MastraLLM({\n        model: resolvedModel,\n        mastra: this.#mastra\n      });\n      if (this.#primitives) {\n        llm.__registerPrimitives(this.#primitives);\n      }\n      if (this.#mastra) {\n        llm.__registerMastra(this.#mastra);\n      }\n      return llm;\n    });\n  }\n  /**\n   * Gets the model, resolving it if it's a function\n   * @param options Options for getting the model\n   * @returns A promise that resolves to the model\n   */\n  getModel({\n    runtimeContext = new RuntimeContext()\n  } = {}) {\n    if (typeof this.model !== \"function\") {\n      if (!this.model) {\n        const mastraError = new MastraError({\n          id: \"AGENT_GET_MODEL_MISSING_MODEL_INSTANCE\",\n          domain: \"AGENT\" /* AGENT */,\n          category: \"USER\" /* USER */,\n          details: {\n            agentName: this.name\n          },\n          text: `[Agent:${this.name}] - No model provided`\n        });\n        this.logger.trackException(mastraError);\n        this.logger.error(mastraError.toString());\n        throw mastraError;\n      }\n      return this.model;\n    }\n    const result = this.model({\n      runtimeContext\n    });\n    return resolveMaybePromise(result, model => {\n      if (!model) {\n        const mastraError = new MastraError({\n          id: \"AGENT_GET_MODEL_FUNCTION_EMPTY_RETURN\",\n          domain: \"AGENT\" /* AGENT */,\n          category: \"USER\" /* USER */,\n          details: {\n            agentName: this.name\n          },\n          text: `[Agent:${this.name}] - Function-based model returned empty value`\n        });\n        this.logger.trackException(mastraError);\n        this.logger.error(mastraError.toString());\n        throw mastraError;\n      }\n      return model;\n    });\n  }\n  __updateInstructions(newInstructions) {\n    this.#instructions = newInstructions;\n    this.logger.debug(`[Agents:${this.name}] Instructions updated.`, {\n      model: this.model,\n      name: this.name\n    });\n  }\n  #primitives;\n  __registerPrimitives(p) {\n    if (p.telemetry) {\n      this.__setTelemetry(p.telemetry);\n    }\n    if (p.logger) {\n      this.__setLogger(p.logger);\n    }\n    this.#primitives = p;\n    this.logger.debug(`[Agents:${this.name}] initialized.`, {\n      model: this.model,\n      name: this.name\n    });\n  }\n  __registerMastra(mastra) {\n    this.#mastra = mastra;\n  }\n  /**\n   * Set the concrete tools for the agent\n   * @param tools\n   */\n  __setTools(tools) {\n    this.#tools = tools;\n    this.logger.debug(`[Agents:${this.name}] Tools set for agent ${this.name}`, {\n      model: this.model,\n      name: this.name\n    });\n  }\n  async generateTitleFromUserMessage({\n    message,\n    runtimeContext = new RuntimeContext(),\n    model,\n    instructions\n  }) {\n    const llm = await this.getLLM({\n      runtimeContext,\n      model\n    });\n    const normMessage = new MessageList().add(message, \"user\").get.all.ui().at(-1);\n    if (!normMessage) {\n      throw new Error(`Could not generate title from input ${JSON.stringify(message)}`);\n    }\n    const partsToGen = [];\n    for (const part of normMessage.parts) {\n      if (part.type === `text`) {\n        partsToGen.push(part);\n      } else if (part.type === `source`) {\n        partsToGen.push({\n          type: \"text\",\n          text: `User added URL: ${part.source.url.substring(0, 100)}`\n        });\n      } else if (part.type === `file`) {\n        partsToGen.push({\n          type: \"text\",\n          text: `User added ${part.mimeType} file: ${part.data.substring(0, 100)}`\n        });\n      }\n    }\n    const systemInstructions = await this.resolveTitleInstructions(runtimeContext, instructions);\n    const {\n      text\n    } = await llm.__text({\n      runtimeContext,\n      messages: [{\n        role: \"system\",\n        content: systemInstructions\n      }, {\n        role: \"user\",\n        content: JSON.stringify(partsToGen)\n      }]\n    });\n    const cleanedText = text.replace(/<think>[\\s\\S]*?<\\/think>/g, \"\").trim();\n    return cleanedText;\n  }\n  getMostRecentUserMessage(messages) {\n    const userMessages = messages.filter(message => message.role === \"user\");\n    return userMessages.at(-1);\n  }\n  async genTitle(userMessage, runtimeContext, model, instructions) {\n    try {\n      if (userMessage) {\n        const normMessage = new MessageList().add(userMessage, \"user\").get.all.ui().at(-1);\n        if (normMessage) {\n          return await this.generateTitleFromUserMessage({\n            message: normMessage,\n            runtimeContext,\n            model,\n            instructions\n          });\n        }\n      }\n      return `New Thread ${(/* @__PURE__ */new Date()).toISOString()}`;\n    } catch (e) {\n      this.logger.error(\"Error generating title:\", e);\n      return void 0;\n    }\n  }\n  /* @deprecated use agent.getMemory() and query memory directly */\n  async fetchMemory({\n    threadId,\n    thread: passedThread,\n    memoryConfig,\n    resourceId,\n    runId,\n    userMessages,\n    systemMessage,\n    messageList = new MessageList({\n      threadId,\n      resourceId\n    })\n  }) {\n    const memory = this.getMemory();\n    if (memory) {\n      const thread = passedThread ?? (await memory.getThreadById({\n        threadId\n      }));\n      if (!thread) {\n        return {\n          threadId: threadId || \"\",\n          messages: userMessages || []\n        };\n      }\n      if (userMessages && userMessages.length > 0) {\n        messageList.add(userMessages, \"memory\");\n      }\n      if (systemMessage?.role === \"system\") {\n        messageList.addSystem(systemMessage, \"memory\");\n      }\n      const [memoryMessages, memorySystemMessage] = threadId && memory ? await Promise.all([memory.rememberMessages({\n        threadId,\n        resourceId,\n        config: memoryConfig,\n        vectorMessageSearch: messageList.getLatestUserContent() || \"\"\n      }).then(r => r.messagesV2), memory.getSystemMessage({\n        threadId,\n        memoryConfig\n      })]) : [[], null];\n      this.logger.debug(\"Fetched messages from memory\", {\n        threadId,\n        runId,\n        fetchedCount: memoryMessages.length\n      });\n      if (memorySystemMessage) {\n        messageList.addSystem(memorySystemMessage, \"memory\");\n      }\n      messageList.add(memoryMessages, \"memory\");\n      const systemMessages = messageList.getSystemMessages()?.map(m => m.content)?.join(`\n`) ?? void 0;\n      const newMessages = messageList.get.input.v1();\n      const processedMemoryMessages = memory.processMessages({\n        // these will be processed\n        messages: messageList.get.remembered.v1(),\n        // these are here for inspecting but shouldn't be returned by the processor\n        // - ex TokenLimiter needs to measure all tokens even though it's only processing remembered messages\n        newMessages,\n        systemMessage: systemMessages,\n        memorySystemMessage: memorySystemMessage || void 0\n      });\n      const returnList = new MessageList().addSystem(systemMessages).add(processedMemoryMessages, \"memory\").add(newMessages, \"user\");\n      return {\n        threadId: thread.id,\n        messages: returnList.get.all.prompt()\n      };\n    }\n    return {\n      threadId: threadId || \"\",\n      messages: userMessages || []\n    };\n  }\n  async getMemoryTools({\n    runId,\n    resourceId,\n    threadId,\n    runtimeContext,\n    mastraProxy\n  }) {\n    let convertedMemoryTools = {};\n    const memory = this.getMemory();\n    const memoryTools = memory?.getTools?.();\n    if (memoryTools) {\n      const memoryToolEntries = await Promise.all(Object.entries(memoryTools).map(async ([k, tool]) => {\n        return [k, {\n          description: tool.description,\n          parameters: tool.parameters,\n          execute: typeof tool?.execute === \"function\" ? async (args, options) => {\n            try {\n              this.logger.debug(`[Agent:${this.name}] - Executing memory tool ${k}`, {\n                name: k,\n                description: tool.description,\n                args,\n                runId,\n                threadId,\n                resourceId\n              });\n              return tool?.execute?.({\n                context: args,\n                mastra: mastraProxy,\n                memory,\n                runId,\n                threadId,\n                resourceId,\n                logger: this.logger,\n                agentName: this.name,\n                runtimeContext\n              }, options) ?? void 0;\n            } catch (err) {\n              const mastraError = new MastraError({\n                id: \"AGENT_MEMORY_TOOL_EXECUTION_FAILED\",\n                domain: \"AGENT\" /* AGENT */,\n                category: \"USER\" /* USER */,\n                details: {\n                  agentName: this.name,\n                  runId: runId || \"\",\n                  threadId: threadId || \"\",\n                  resourceId: resourceId || \"\"\n                },\n                text: `[Agent:${this.name}] - Failed memory tool execution`\n              }, err);\n              this.logger.trackException(mastraError);\n              this.logger.error(mastraError.toString());\n              throw mastraError;\n            }\n          } : void 0\n        }];\n      }));\n      convertedMemoryTools = Object.fromEntries(memoryToolEntries.filter(entry => Boolean(entry)));\n    }\n    return convertedMemoryTools;\n  }\n  async getMemoryMessages({\n    resourceId,\n    threadId,\n    vectorMessageSearch,\n    memoryConfig\n  }) {\n    const memory = this.getMemory();\n    if (!memory) {\n      return [];\n    }\n    return memory.rememberMessages({\n      threadId,\n      resourceId,\n      config: memoryConfig,\n      // The new user messages aren't in the list yet cause we add memory messages first to try to make sure ordering is correct (memory comes before new user messages)\n      vectorMessageSearch\n    }).then(r => r.messagesV2);\n  }\n  async getAssignedTools({\n    runtimeContext,\n    runId,\n    resourceId,\n    threadId,\n    mastraProxy\n  }) {\n    let toolsForRequest = {};\n    this.logger.debug(`[Agents:${this.name}] - Assembling assigned tools`, {\n      runId,\n      threadId,\n      resourceId\n    });\n    const memory = this.getMemory();\n    const assignedTools = await this.getTools({\n      runtimeContext\n    });\n    const assignedToolEntries = Object.entries(assignedTools || {});\n    const assignedCoreToolEntries = await Promise.all(assignedToolEntries.map(async ([k, tool]) => {\n      if (!tool) {\n        return;\n      }\n      const options = {\n        name: k,\n        runId,\n        threadId,\n        resourceId,\n        logger: this.logger,\n        mastra: mastraProxy,\n        memory,\n        agentName: this.name,\n        runtimeContext,\n        model: typeof this.model === \"function\" ? await this.getModel({\n          runtimeContext\n        }) : this.model\n      };\n      return [k, makeCoreTool(tool, options)];\n    }));\n    const assignedToolEntriesConverted = Object.fromEntries(assignedCoreToolEntries.filter(entry => Boolean(entry)));\n    toolsForRequest = {\n      ...assignedToolEntriesConverted\n    };\n    return toolsForRequest;\n  }\n  async getToolsets({\n    runId,\n    threadId,\n    resourceId,\n    toolsets,\n    runtimeContext,\n    mastraProxy\n  }) {\n    let toolsForRequest = {};\n    const memory = this.getMemory();\n    const toolsFromToolsets = Object.values(toolsets || {});\n    if (toolsFromToolsets.length > 0) {\n      this.logger.debug(`[Agent:${this.name}] - Adding tools from toolsets ${Object.keys(toolsets || {}).join(\", \")}`, {\n        runId\n      });\n      for (const toolset of toolsFromToolsets) {\n        for (const [toolName, tool] of Object.entries(toolset)) {\n          const toolObj = tool;\n          const options = {\n            name: toolName,\n            runId,\n            threadId,\n            resourceId,\n            logger: this.logger,\n            mastra: mastraProxy,\n            memory,\n            agentName: this.name,\n            runtimeContext,\n            model: typeof this.model === \"function\" ? await this.getModel({\n              runtimeContext\n            }) : this.model\n          };\n          const convertedToCoreTool = makeCoreTool(toolObj, options, \"toolset\");\n          toolsForRequest[toolName] = convertedToCoreTool;\n        }\n      }\n    }\n    return toolsForRequest;\n  }\n  async getClientTools({\n    runId,\n    threadId,\n    resourceId,\n    runtimeContext,\n    mastraProxy,\n    clientTools\n  }) {\n    let toolsForRequest = {};\n    const memory = this.getMemory();\n    const clientToolsForInput = Object.entries(clientTools || {});\n    if (clientToolsForInput.length > 0) {\n      this.logger.debug(`[Agent:${this.name}] - Adding client tools ${Object.keys(clientTools || {}).join(\", \")}`, {\n        runId\n      });\n      for (const [toolName, tool] of clientToolsForInput) {\n        const {\n          execute,\n          ...rest\n        } = tool;\n        const options = {\n          name: toolName,\n          runId,\n          threadId,\n          resourceId,\n          logger: this.logger,\n          mastra: mastraProxy,\n          memory,\n          agentName: this.name,\n          runtimeContext,\n          model: typeof this.model === \"function\" ? await this.getModel({\n            runtimeContext\n          }) : this.model\n        };\n        const convertedToCoreTool = makeCoreTool(rest, options, \"client-tool\");\n        toolsForRequest[toolName] = convertedToCoreTool;\n      }\n    }\n    return toolsForRequest;\n  }\n  async getWorkflowTools({\n    runId,\n    threadId,\n    resourceId,\n    runtimeContext\n  }) {\n    let convertedWorkflowTools = {};\n    const workflows = await this.getWorkflows({\n      runtimeContext\n    });\n    if (Object.keys(workflows).length > 0) {\n      convertedWorkflowTools = Object.entries(workflows).reduce((memo, [workflowName, workflow]) => {\n        memo[workflowName] = {\n          description: workflow.description || `Workflow: ${workflowName}`,\n          parameters: workflow.inputSchema || {\n            type: \"object\",\n            properties: {}\n          },\n          execute: async args => {\n            try {\n              this.logger.debug(`[Agent:${this.name}] - Executing workflow as tool ${workflowName}`, {\n                name: workflowName,\n                description: workflow.description,\n                args,\n                runId,\n                threadId,\n                resourceId\n              });\n              const run = workflow.createRun();\n              const result = await run.start({\n                inputData: args,\n                runtimeContext\n              });\n              return result;\n            } catch (err) {\n              const mastraError = new MastraError({\n                id: \"AGENT_WORKFLOW_TOOL_EXECUTION_FAILED\",\n                domain: \"AGENT\" /* AGENT */,\n                category: \"USER\" /* USER */,\n                details: {\n                  agentName: this.name,\n                  runId: runId || \"\",\n                  threadId: threadId || \"\",\n                  resourceId: resourceId || \"\"\n                },\n                text: `[Agent:${this.name}] - Failed workflow tool execution`\n              }, err);\n              this.logger.trackException(mastraError);\n              this.logger.error(mastraError.toString());\n              throw mastraError;\n            }\n          }\n        };\n        return memo;\n      }, {});\n    }\n    return convertedWorkflowTools;\n  }\n  async convertTools({\n    toolsets,\n    clientTools,\n    threadId,\n    resourceId,\n    runId,\n    runtimeContext\n  }) {\n    let mastraProxy = void 0;\n    const logger = this.logger;\n    if (this.#mastra) {\n      mastraProxy = createMastraProxy({\n        mastra: this.#mastra,\n        logger\n      });\n    }\n    const assignedTools = await this.getAssignedTools({\n      runId,\n      resourceId,\n      threadId,\n      runtimeContext,\n      mastraProxy\n    });\n    const memoryTools = await this.getMemoryTools({\n      runId,\n      resourceId,\n      threadId,\n      runtimeContext,\n      mastraProxy\n    });\n    const toolsetTools = await this.getToolsets({\n      runId,\n      resourceId,\n      threadId,\n      runtimeContext,\n      mastraProxy,\n      toolsets\n    });\n    const clientsideTools = await this.getClientTools({\n      runId,\n      resourceId,\n      threadId,\n      runtimeContext,\n      mastraProxy,\n      clientTools\n    });\n    const workflowTools = await this.getWorkflowTools({\n      runId,\n      resourceId,\n      threadId,\n      runtimeContext\n    });\n    return {\n      ...assignedTools,\n      ...memoryTools,\n      ...toolsetTools,\n      ...clientsideTools,\n      ...workflowTools\n    };\n  }\n  /**\n   * Adds response messages from a step to the MessageList and schedules persistence.\n   * This is used for incremental saving: after each agent step, messages are added to a save queue\n   * and a debounced save operation is triggered to avoid redundant writes.\n   *\n   * @param result - The step result containing response messages.\n   * @param messageList - The MessageList instance for the current thread.\n   * @param threadId - The thread ID.\n   * @param memoryConfig - The memory configuration for saving.\n   * @param runId - (Optional) The run ID for logging.\n   */\n  async saveStepMessages({\n    saveQueueManager,\n    result,\n    messageList,\n    threadId,\n    memoryConfig,\n    runId\n  }) {\n    try {\n      messageList.add(result.response.messages, \"response\");\n      await saveQueueManager.batchMessages(messageList, threadId, memoryConfig);\n    } catch (e) {\n      await saveQueueManager.flushMessages(messageList, threadId, memoryConfig);\n      this.logger.error(\"Error saving memory on step finish\", {\n        error: e,\n        runId\n      });\n      throw e;\n    }\n  }\n  __primitive({\n    instructions,\n    messages,\n    context,\n    thread,\n    memoryConfig,\n    resourceId,\n    runId,\n    toolsets,\n    clientTools,\n    runtimeContext,\n    generateMessageId,\n    saveQueueManager\n  }) {\n    return {\n      before: async () => {\n        if (process.env.NODE_ENV !== \"test\") {\n          this.logger.debug(`[Agents:${this.name}] - Starting generation`, {\n            runId\n          });\n        }\n        const memory = this.getMemory();\n        const toolEnhancements = [\n        // toolsets\n        toolsets && Object.keys(toolsets || {}).length > 0 ? `toolsets present (${Object.keys(toolsets || {}).length} tools)` : void 0,\n        // memory tools\n        memory && resourceId ? \"memory and resourceId available\" : void 0].filter(Boolean).join(\", \");\n        this.logger.debug(`[Agent:${this.name}] - Enhancing tools: ${toolEnhancements}`, {\n          runId,\n          toolsets: toolsets ? Object.keys(toolsets) : void 0,\n          clientTools: clientTools ? Object.keys(clientTools) : void 0,\n          hasMemory: !!this.getMemory(),\n          hasResourceId: !!resourceId\n        });\n        const threadId = thread?.id;\n        const convertedTools = await this.convertTools({\n          toolsets,\n          clientTools,\n          threadId,\n          resourceId,\n          runId,\n          runtimeContext\n        });\n        const messageList = new MessageList({\n          threadId,\n          resourceId,\n          generateMessageId,\n          // @ts-ignore Flag for agent network messages\n          _agentNetworkAppend: this._agentNetworkAppend\n        }).addSystem({\n          role: \"system\",\n          content: instructions || `${this.instructions}.`\n        }).add(context || [], \"context\");\n        if (!memory || !threadId && !resourceId) {\n          messageList.add(messages, \"user\");\n          return {\n            messageObjects: messageList.get.all.prompt(),\n            convertedTools,\n            messageList\n          };\n        }\n        if (!threadId || !resourceId) {\n          const mastraError = new MastraError({\n            id: \"AGENT_MEMORY_MISSING_RESOURCE_ID\",\n            domain: \"AGENT\" /* AGENT */,\n            category: \"USER\" /* USER */,\n            details: {\n              agentName: this.name,\n              threadId: threadId || \"\",\n              resourceId: resourceId || \"\"\n            },\n            text: `A resourceId must be provided when passing a threadId and using Memory. Saw threadId ${threadId} but resourceId is ${resourceId}`\n          });\n          this.logger.trackException(mastraError);\n          this.logger.error(mastraError.toString());\n          throw mastraError;\n        }\n        const store = memory.constructor.name;\n        this.logger.debug(`[Agent:${this.name}] - Memory persistence enabled: store=${store}, resourceId=${resourceId}`, {\n          runId,\n          resourceId,\n          threadId,\n          memoryStore: store\n        });\n        let threadObject = void 0;\n        const existingThread = await memory.getThreadById({\n          threadId\n        });\n        if (existingThread) {\n          if (!existingThread.metadata && thread.metadata || thread.metadata && !(0, import_fast_deep_equal.default)(existingThread.metadata, thread.metadata)) {\n            threadObject = await memory.saveThread({\n              thread: {\n                ...existingThread,\n                metadata: thread.metadata\n              },\n              memoryConfig\n            });\n          } else {\n            threadObject = existingThread;\n          }\n        } else {\n          threadObject = await memory.createThread({\n            threadId,\n            metadata: thread.metadata,\n            title: thread.title,\n            memoryConfig,\n            resourceId\n          });\n        }\n        let [memoryMessages, memorySystemMessage] = thread.id && memory ? await Promise.all([this.getMemoryMessages({\n          resourceId,\n          threadId: threadObject.id,\n          vectorMessageSearch: new MessageList().add(messages, `user`).getLatestUserContent() || \"\",\n          memoryConfig\n        }), memory.getSystemMessage({\n          threadId: threadObject.id,\n          resourceId,\n          memoryConfig\n        })]) : [[], null];\n        this.logger.debug(\"Fetched messages from memory\", {\n          threadId: threadObject.id,\n          runId,\n          fetchedCount: memoryMessages.length\n        });\n        const resultsFromOtherThreads = memoryMessages.filter(m => m.threadId !== threadObject.id);\n        if (resultsFromOtherThreads.length && !memorySystemMessage) {\n          memorySystemMessage = ``;\n        }\n        if (resultsFromOtherThreads.length) {\n          memorySystemMessage += `\nThe following messages were remembered from a different conversation:\n<remembered_from_other_conversation>\n${(() => {\n            let result = ``;\n            const messages2 = new MessageList().add(resultsFromOtherThreads, \"memory\").get.all.v1();\n            let lastYmd = null;\n            for (const msg of messages2) {\n              const date = msg.createdAt;\n              const year = date.getUTCFullYear();\n              const month = date.toLocaleString(\"default\", {\n                month: \"short\"\n              });\n              const day = date.getUTCDate();\n              const ymd = `${year}, ${month}, ${day}`;\n              const utcHour = date.getUTCHours();\n              const utcMinute = date.getUTCMinutes();\n              const hour12 = utcHour % 12 || 12;\n              const ampm = utcHour < 12 ? \"AM\" : \"PM\";\n              const timeofday = `${hour12}:${utcMinute < 10 ? \"0\" : \"\"}${utcMinute} ${ampm}`;\n              if (!lastYmd || lastYmd !== ymd) {\n                result += `\nthe following messages are from ${ymd}\n`;\n              }\n              result += `\nMessage ${msg.threadId && msg.threadId !== threadObject.id ? \"from previous conversation\" : \"\"} at ${timeofday}: ${JSON.stringify(msg)}`;\n              lastYmd = ymd;\n            }\n            return result;\n          })()}\n<end_remembered_from_other_conversation>`;\n        }\n        if (memorySystemMessage) {\n          messageList.addSystem(memorySystemMessage, \"memory\");\n        }\n        messageList.add(memoryMessages.filter(m => m.threadId === threadObject.id),\n        // filter out messages from other threads. those are added to system message above\n        \"memory\").add(messages, \"user\");\n        const systemMessage = [...messageList.getSystemMessages(), ...messageList.getSystemMessages(\"memory\")]?.map(m => m.content)?.join(`\n`) ?? void 0;\n        const processedMemoryMessages = memory.processMessages({\n          // these will be processed\n          messages: messageList.get.remembered.v1(),\n          // these are here for inspecting but shouldn't be returned by the processor\n          // - ex TokenLimiter needs to measure all tokens even though it's only processing remembered messages\n          newMessages: messageList.get.input.v1(),\n          systemMessage,\n          memorySystemMessage: memorySystemMessage || void 0\n        });\n        const processedList = new MessageList({\n          threadId: threadObject.id,\n          resourceId,\n          // @ts-ignore Flag for agent network messages\n          _agentNetworkAppend: this._agentNetworkAppend\n        }).addSystem(instructions || `${this.instructions}.`).addSystem(memorySystemMessage).add(context || [], \"context\").add(processedMemoryMessages, \"memory\").add(messageList.get.input.v2(), \"user\").get.all.prompt();\n        return {\n          convertedTools,\n          thread: threadObject,\n          messageList,\n          // add old processed messages + new input messages\n          messageObjects: processedList\n        };\n      },\n      after: async ({\n        result,\n        thread: threadAfter,\n        threadId,\n        memoryConfig: memoryConfig2,\n        outputText,\n        runId: runId2,\n        messageList\n      }) => {\n        const resToLog = {\n          text: result?.text,\n          object: result?.object,\n          toolResults: result?.toolResults,\n          toolCalls: result?.toolCalls,\n          usage: result?.usage,\n          steps: result?.steps?.map(s => {\n            return {\n              stepType: s?.stepType,\n              text: result?.text,\n              object: result?.object,\n              toolResults: result?.toolResults,\n              toolCalls: result?.toolCalls,\n              usage: result?.usage\n            };\n          })\n        };\n        this.logger.debug(`[Agent:${this.name}] - Post processing LLM response`, {\n          runId: runId2,\n          result: resToLog,\n          threadId\n        });\n        const memory = this.getMemory();\n        const messageListResponses = new MessageList({\n          threadId,\n          resourceId,\n          // @ts-ignore Flag for agent network messages\n          _agentNetworkAppend: this._agentNetworkAppend\n        }).add(result.response.messages, \"response\").get.all.core();\n        const usedWorkingMemory = messageListResponses?.some(m => m.role === \"tool\" && m?.content?.some(c => c?.toolName === \"updateWorkingMemory\"));\n        const thread2 = usedWorkingMemory ? threadId ? await memory?.getThreadById({\n          threadId\n        }) : void 0 : threadAfter;\n        if (memory && resourceId && thread2) {\n          try {\n            let responseMessages = result.response.messages;\n            if (!responseMessages && result.object) {\n              responseMessages = [{\n                role: \"assistant\",\n                content: [{\n                  type: \"text\",\n                  text: outputText\n                  // outputText contains the stringified object\n                }]\n              }];\n            }\n            if (responseMessages) {\n              messageList.add(responseMessages, \"response\");\n            }\n            const promises = [saveQueueManager.flushMessages(messageList, threadId, memoryConfig2)];\n            if (thread2.title?.startsWith(\"New Thread\")) {\n              const config = memory.getMergedThreadConfig(memoryConfig2);\n              const userMessage = this.getMostRecentUserMessage(messageList.get.all.ui());\n              const {\n                shouldGenerate,\n                model: titleModel,\n                instructions: titleInstructions\n              } = this.resolveTitleGenerationConfig(config?.threads?.generateTitle);\n              if (shouldGenerate && userMessage) {\n                promises.push(this.genTitle(userMessage, runtimeContext, titleModel, titleInstructions).then(title => {\n                  if (title) {\n                    return memory.createThread({\n                      threadId: thread2.id,\n                      resourceId,\n                      memoryConfig: memoryConfig2,\n                      title,\n                      metadata: thread2.metadata\n                    });\n                  }\n                }));\n              }\n            }\n            await Promise.all(promises);\n          } catch (e) {\n            await saveQueueManager.flushMessages(messageList, threadId, memoryConfig2);\n            if (e instanceof MastraError) {\n              throw e;\n            }\n            const mastraError = new MastraError({\n              id: \"AGENT_MEMORY_PERSIST_RESPONSE_MESSAGES_FAILED\",\n              domain: \"AGENT\" /* AGENT */,\n              category: \"SYSTEM\" /* SYSTEM */,\n              details: {\n                agentName: this.name,\n                runId: runId2 || \"\",\n                threadId: threadId || \"\",\n                result: JSON.stringify(resToLog)\n              }\n            }, e);\n            this.logger.trackException(mastraError);\n            this.logger.error(mastraError.toString());\n            throw mastraError;\n          }\n        }\n        if (Object.keys(this.evals || {}).length > 0) {\n          const userInputMessages = messageList.get.all.ui().filter(m => m.role === \"user\");\n          const input = userInputMessages.map(message => typeof message.content === \"string\" ? message.content : \"\").join(\"\\n\");\n          const runIdToUse = runId2 || crypto.randomUUID();\n          for (const metric of Object.values(this.evals || {})) {\n            executeHook(\"onGeneration\" /* ON_GENERATION */, {\n              input,\n              output: outputText,\n              runId: runIdToUse,\n              metric,\n              agentName: this.name,\n              instructions: instructions || this.instructions\n            });\n          }\n        }\n      }\n    };\n  }\n  async generate(messages, generateOptions = {}) {\n    const defaultGenerateOptions = await this.getDefaultGenerateOptions({\n      runtimeContext: generateOptions.runtimeContext\n    });\n    const {\n      context,\n      memoryOptions: memoryConfigFromArgs,\n      resourceId: resourceIdFromArgs,\n      maxSteps,\n      onStepFinish,\n      output,\n      toolsets,\n      clientTools,\n      temperature,\n      toolChoice = \"auto\",\n      experimental_output,\n      telemetry,\n      runtimeContext = new RuntimeContext(),\n      savePerStep = false,\n      ...args\n    } = Object.assign({}, defaultGenerateOptions, generateOptions);\n    const generateMessageId = `experimental_generateMessageId` in args && typeof args.experimental_generateMessageId === `function` ? args.experimental_generateMessageId : void 0;\n    const threadFromArgs = resolveThreadIdFromArgs({\n      ...args,\n      ...generateOptions\n    });\n    const resourceId = args.memory?.resource || resourceIdFromArgs;\n    const memoryConfig = args.memory?.options || memoryConfigFromArgs;\n    if (resourceId && threadFromArgs && !this.getMemory()) {\n      this.logger.warn(`[Agent:${this.name}] - No memory is configured but resourceId and threadId were passed in args. This will not work.`);\n    }\n    const runId = args.runId || randomUUID();\n    const instructions = args.instructions || (await this.getInstructions({\n      runtimeContext\n    }));\n    const llm = await this.getLLM({\n      runtimeContext\n    });\n    const memory = this.getMemory();\n    const saveQueueManager = new SaveQueueManager({\n      logger: this.logger,\n      memory\n    });\n    const {\n      before,\n      after\n    } = this.__primitive({\n      messages,\n      instructions,\n      context,\n      thread: threadFromArgs,\n      memoryConfig,\n      resourceId,\n      runId,\n      toolsets,\n      clientTools,\n      runtimeContext,\n      generateMessageId,\n      saveQueueManager\n    });\n    const {\n      thread,\n      messageObjects,\n      convertedTools,\n      messageList\n    } = await before();\n    const threadId = thread?.id;\n    if (!output && experimental_output) {\n      const result2 = await llm.__text({\n        messages: messageObjects,\n        tools: convertedTools,\n        onStepFinish: async result3 => {\n          if (savePerStep) {\n            await this.saveStepMessages({\n              saveQueueManager,\n              result: result3,\n              messageList,\n              threadId,\n              memoryConfig,\n              runId\n            });\n          }\n          return onStepFinish?.({\n            ...result3,\n            runId\n          });\n        },\n        maxSteps,\n        runId,\n        temperature,\n        toolChoice: toolChoice || \"auto\",\n        experimental_output,\n        threadId,\n        resourceId,\n        memory: this.getMemory(),\n        runtimeContext,\n        telemetry,\n        ...args\n      });\n      const outputText2 = result2.text;\n      await after({\n        result: result2,\n        threadId,\n        thread,\n        memoryConfig,\n        outputText: outputText2,\n        runId,\n        messageList\n      });\n      const newResult = result2;\n      newResult.object = result2.experimental_output;\n      return newResult;\n    }\n    if (!output) {\n      const result2 = await llm.__text({\n        messages: messageObjects,\n        tools: convertedTools,\n        onStepFinish: async result3 => {\n          if (savePerStep) {\n            await this.saveStepMessages({\n              saveQueueManager,\n              result: result3,\n              messageList,\n              threadId,\n              memoryConfig,\n              runId\n            });\n          }\n          return onStepFinish?.({\n            ...result3,\n            runId\n          });\n        },\n        maxSteps,\n        runId,\n        temperature,\n        toolChoice,\n        telemetry,\n        threadId,\n        resourceId,\n        memory: this.getMemory(),\n        runtimeContext,\n        ...args\n      });\n      const outputText2 = result2.text;\n      await after({\n        result: result2,\n        thread,\n        threadId,\n        memoryConfig,\n        outputText: outputText2,\n        runId,\n        messageList\n      });\n      return result2;\n    }\n    const result = await llm.__textObject({\n      messages: messageObjects,\n      tools: convertedTools,\n      structuredOutput: output,\n      onStepFinish: async result2 => {\n        if (savePerStep) {\n          await this.saveStepMessages({\n            saveQueueManager,\n            result: result2,\n            messageList,\n            threadId,\n            memoryConfig,\n            runId\n          });\n        }\n        return onStepFinish?.({\n          ...result2,\n          runId\n        });\n      },\n      maxSteps,\n      runId,\n      temperature,\n      toolChoice,\n      telemetry,\n      memory: this.getMemory(),\n      runtimeContext,\n      ...args\n    });\n    const outputText = JSON.stringify(result.object);\n    await after({\n      result,\n      thread,\n      threadId,\n      memoryConfig,\n      outputText,\n      runId,\n      messageList\n    });\n    return result;\n  }\n  async stream(messages, streamOptions = {}) {\n    const defaultStreamOptions = await this.getDefaultStreamOptions({\n      runtimeContext: streamOptions.runtimeContext\n    });\n    const {\n      context,\n      memoryOptions: memoryConfigFromArgs,\n      resourceId: resourceIdFromArgs,\n      maxSteps,\n      onFinish,\n      onStepFinish,\n      toolsets,\n      clientTools,\n      output,\n      temperature,\n      toolChoice = \"auto\",\n      experimental_output,\n      telemetry,\n      runtimeContext = new RuntimeContext(),\n      savePerStep = false,\n      ...args\n    } = Object.assign({}, defaultStreamOptions, streamOptions);\n    const generateMessageId = `experimental_generateMessageId` in args && typeof args.experimental_generateMessageId === `function` ? args.experimental_generateMessageId : void 0;\n    const threadFromArgs = resolveThreadIdFromArgs({\n      ...args,\n      ...streamOptions\n    });\n    const resourceId = args.memory?.resource || resourceIdFromArgs;\n    const memoryConfig = args.memory?.options || memoryConfigFromArgs;\n    if (resourceId && threadFromArgs && !this.getMemory()) {\n      this.logger.warn(`[Agent:${this.name}] - No memory is configured but resourceId and threadId were passed in args. This will not work.`);\n    }\n    const runId = args.runId || randomUUID();\n    const instructions = args.instructions || (await this.getInstructions({\n      runtimeContext\n    }));\n    const llm = await this.getLLM({\n      runtimeContext\n    });\n    const memory = this.getMemory();\n    const saveQueueManager = new SaveQueueManager({\n      logger: this.logger,\n      memory\n    });\n    const {\n      before,\n      after\n    } = this.__primitive({\n      instructions,\n      messages,\n      context,\n      thread: threadFromArgs,\n      memoryConfig,\n      resourceId,\n      runId,\n      toolsets,\n      clientTools,\n      runtimeContext,\n      generateMessageId,\n      saveQueueManager\n    });\n    const {\n      thread,\n      messageObjects,\n      convertedTools,\n      messageList\n    } = await before();\n    const threadId = thread?.id;\n    if (!output && experimental_output) {\n      this.logger.debug(`Starting agent ${this.name} llm stream call`, {\n        runId\n      });\n      const streamResult = llm.__stream({\n        messages: messageObjects,\n        temperature,\n        tools: convertedTools,\n        onStepFinish: async result => {\n          if (savePerStep) {\n            await this.saveStepMessages({\n              saveQueueManager,\n              result,\n              messageList,\n              threadId,\n              memoryConfig,\n              runId\n            });\n          }\n          return onStepFinish?.({\n            ...result,\n            runId\n          });\n        },\n        onFinish: async result => {\n          try {\n            const outputText = result.text;\n            await after({\n              result,\n              thread,\n              threadId,\n              memoryConfig,\n              outputText,\n              runId,\n              messageList\n            });\n          } catch (e) {\n            this.logger.error(\"Error saving memory on finish\", {\n              error: e,\n              runId\n            });\n          }\n          await onFinish?.({\n            ...result,\n            runId\n          });\n        },\n        maxSteps,\n        runId,\n        toolChoice,\n        experimental_output,\n        telemetry,\n        memory: this.getMemory(),\n        runtimeContext,\n        threadId: thread?.id,\n        resourceId,\n        ...args\n      });\n      const newStreamResult = streamResult;\n      newStreamResult.partialObjectStream = streamResult.experimental_partialOutputStream;\n      return newStreamResult;\n    } else if (!output) {\n      this.logger.debug(`Starting agent ${this.name} llm stream call`, {\n        runId\n      });\n      return llm.__stream({\n        messages: messageObjects,\n        temperature,\n        tools: convertedTools,\n        onStepFinish: async result => {\n          if (savePerStep) {\n            await this.saveStepMessages({\n              saveQueueManager,\n              result,\n              messageList,\n              threadId,\n              memoryConfig,\n              runId\n            });\n          }\n          return onStepFinish?.({\n            ...result,\n            runId\n          });\n        },\n        onFinish: async result => {\n          try {\n            const outputText = result.text;\n            await after({\n              result,\n              thread,\n              threadId,\n              memoryConfig,\n              outputText,\n              runId,\n              messageList\n            });\n          } catch (e) {\n            this.logger.error(\"Error saving memory on finish\", {\n              error: e,\n              runId\n            });\n          }\n          await onFinish?.({\n            ...result,\n            runId\n          });\n        },\n        maxSteps,\n        runId,\n        toolChoice,\n        telemetry,\n        memory: this.getMemory(),\n        runtimeContext,\n        threadId: thread?.id,\n        resourceId,\n        ...args\n      });\n    }\n    this.logger.debug(`Starting agent ${this.name} llm streamObject call`, {\n      runId\n    });\n    return llm.__streamObject({\n      messages: messageObjects,\n      tools: convertedTools,\n      temperature,\n      structuredOutput: output,\n      onStepFinish: async result => {\n        if (savePerStep) {\n          await this.saveStepMessages({\n            saveQueueManager,\n            result,\n            messageList,\n            threadId,\n            memoryConfig,\n            runId\n          });\n        }\n        return onStepFinish?.({\n          ...result,\n          runId\n        });\n      },\n      onFinish: async result => {\n        try {\n          const outputText = JSON.stringify(result.object);\n          await after({\n            result,\n            thread,\n            threadId,\n            memoryConfig,\n            outputText,\n            runId,\n            messageList\n          });\n        } catch (e) {\n          this.logger.error(\"Error saving memory on finish\", {\n            error: e,\n            runId\n          });\n        }\n        await onFinish?.({\n          ...result,\n          runId\n        });\n      },\n      runId,\n      toolChoice,\n      telemetry,\n      memory: this.getMemory(),\n      runtimeContext,\n      threadId: thread?.id,\n      resourceId,\n      ...args\n    });\n  }\n  /**\n   * Convert text to speech using the configured voice provider\n   * @param input Text or text stream to convert to speech\n   * @param options Speech options including speaker and provider-specific options\n   * @returns Audio stream\n   * @deprecated Use agent.voice.speak() instead\n   */\n  async speak(input, options) {\n    if (!this.voice) {\n      const mastraError = new MastraError({\n        id: \"AGENT_SPEAK_METHOD_VOICE_NOT_CONFIGURED\",\n        domain: \"AGENT\" /* AGENT */,\n        category: \"USER\" /* USER */,\n        details: {\n          agentName: this.name\n        },\n        text: \"No voice provider configured\"\n      });\n      this.logger.trackException(mastraError);\n      this.logger.error(mastraError.toString());\n      throw mastraError;\n    }\n    this.logger.warn(\"Warning: agent.speak() is deprecated. Please use agent.voice.speak() instead.\");\n    try {\n      return this.voice.speak(input, options);\n    } catch (e) {\n      let err;\n      if (e instanceof MastraError) {\n        err = e;\n      } else {\n        err = new MastraError({\n          id: \"AGENT_SPEAK_METHOD_ERROR\",\n          domain: \"AGENT\" /* AGENT */,\n          category: \"UNKNOWN\" /* UNKNOWN */,\n          details: {\n            agentName: this.name\n          },\n          text: \"Error during agent speak\"\n        }, e);\n      }\n      this.logger.trackException(err);\n      this.logger.error(err.toString());\n      throw err;\n    }\n  }\n  /**\n   * Convert speech to text using the configured voice provider\n   * @param audioStream Audio stream to transcribe\n   * @param options Provider-specific transcription options\n   * @returns Text or text stream\n   * @deprecated Use agent.voice.listen() instead\n   */\n  async listen(audioStream, options) {\n    if (!this.voice) {\n      const mastraError = new MastraError({\n        id: \"AGENT_LISTEN_METHOD_VOICE_NOT_CONFIGURED\",\n        domain: \"AGENT\" /* AGENT */,\n        category: \"USER\" /* USER */,\n        details: {\n          agentName: this.name\n        },\n        text: \"No voice provider configured\"\n      });\n      this.logger.trackException(mastraError);\n      this.logger.error(mastraError.toString());\n      throw mastraError;\n    }\n    this.logger.warn(\"Warning: agent.listen() is deprecated. Please use agent.voice.listen() instead\");\n    try {\n      return this.voice.listen(audioStream, options);\n    } catch (e) {\n      let err;\n      if (e instanceof MastraError) {\n        err = e;\n      } else {\n        err = new MastraError({\n          id: \"AGENT_LISTEN_METHOD_ERROR\",\n          domain: \"AGENT\" /* AGENT */,\n          category: \"UNKNOWN\" /* UNKNOWN */,\n          details: {\n            agentName: this.name\n          },\n          text: \"Error during agent listen\"\n        }, e);\n      }\n      this.logger.trackException(err);\n      this.logger.error(err.toString());\n      throw err;\n    }\n  }\n  /**\n   * Get a list of available speakers from the configured voice provider\n   * @throws {Error} If no voice provider is configured\n   * @returns {Promise<Array<{voiceId: string}>>} List of available speakers\n   * @deprecated Use agent.voice.getSpeakers() instead\n   */\n  async getSpeakers() {\n    if (!this.voice) {\n      const mastraError = new MastraError({\n        id: \"AGENT_SPEAKERS_METHOD_VOICE_NOT_CONFIGURED\",\n        domain: \"AGENT\" /* AGENT */,\n        category: \"USER\" /* USER */,\n        details: {\n          agentName: this.name\n        },\n        text: \"No voice provider configured\"\n      });\n      this.logger.trackException(mastraError);\n      this.logger.error(mastraError.toString());\n      throw mastraError;\n    }\n    this.logger.warn(\"Warning: agent.getSpeakers() is deprecated. Please use agent.voice.getSpeakers() instead.\");\n    try {\n      return await this.voice.getSpeakers();\n    } catch (e) {\n      let err;\n      if (e instanceof MastraError) {\n        err = e;\n      } else {\n        err = new MastraError({\n          id: \"AGENT_GET_SPEAKERS_METHOD_ERROR\",\n          domain: \"AGENT\" /* AGENT */,\n          category: \"UNKNOWN\" /* UNKNOWN */,\n          details: {\n            agentName: this.name\n          },\n          text: \"Error during agent getSpeakers\"\n        }, e);\n      }\n      this.logger.trackException(err);\n      this.logger.error(err.toString());\n      throw err;\n    }\n  }\n  toStep() {\n    const x = agentToStep(this);\n    return new LegacyStep(x);\n  }\n  /**\n   * Resolves the configuration for title generation.\n   * @private\n   */\n  resolveTitleGenerationConfig(generateTitleConfig) {\n    if (typeof generateTitleConfig === \"boolean\") {\n      return {\n        shouldGenerate: generateTitleConfig\n      };\n    }\n    if (typeof generateTitleConfig === \"object\" && generateTitleConfig !== null) {\n      return {\n        shouldGenerate: true,\n        model: generateTitleConfig.model,\n        instructions: generateTitleConfig.instructions\n      };\n    }\n    return {\n      shouldGenerate: false\n    };\n  }\n  /**\n   * Resolves title generation instructions, handling both static strings and dynamic functions\n   * @private\n   */\n  async resolveTitleInstructions(runtimeContext, instructions) {\n    const DEFAULT_TITLE_INSTRUCTIONS = `\n    - you will generate a short title based on the first message a user begins a conversation with\n    - ensure it is not more than 80 characters long\n    - the title should be a summary of the user's message\n    - do not use quotes or colons\n    - the entire text you return will be used as the title`;\n    if (!instructions) {\n      return DEFAULT_TITLE_INSTRUCTIONS;\n    }\n    if (typeof instructions === \"string\") {\n      return instructions;\n    } else {\n      const result = instructions({\n        runtimeContext\n      });\n      return resolveMaybePromise(result, resolvedInstructions => {\n        return resolvedInstructions || DEFAULT_TITLE_INSTRUCTIONS;\n      });\n    }\n  }\n};\nAgent = /*@__PURE__*/(_ => {\n  _init = __decoratorStart(_a);\n  Agent = __decorateElement(_init, 0, \"Agent\", _Agent_decorators, Agent);\n  __runInitializers(_init, 1, Agent);\n\n  // src/workflows/legacy/utils.ts\n  return Agent;\n})();\n// src/workflows/legacy/utils.ts\nfunction isErrorEvent(stateEvent) {\n  return stateEvent.type.startsWith(\"xstate.error.actor.\");\n}\nfunction isTransitionEvent(stateEvent) {\n  return stateEvent.type.startsWith(\"xstate.done.actor.\");\n}\nfunction isVariableReference(value) {\n  return typeof value === \"object\" && \"step\" in value && \"path\" in value;\n}\nfunction getStepResult(result) {\n  if (result?.status === \"success\") return result.output;\n  return void 0;\n}\nfunction getSuspendedPaths({\n  value,\n  path,\n  suspendedPaths\n}) {\n  if (typeof value === \"string\") {\n    if (value === \"suspended\") {\n      suspendedPaths.add(path);\n    }\n  } else {\n    Object.keys(value).forEach(key => getSuspendedPaths({\n      value: value[key],\n      path: path ? `${path}.${key}` : key,\n      suspendedPaths\n    }));\n  }\n}\nfunction isFinalState(status) {\n  return [\"completed\", \"failed\"].includes(status);\n}\nfunction isLimboState(status) {\n  return status === \"limbo\";\n}\nfunction recursivelyCheckForFinalState({\n  value,\n  suspendedPaths,\n  path\n}) {\n  if (typeof value === \"string\") {\n    return isFinalState(value) || isLimboState(value) || suspendedPaths.has(path);\n  }\n  return Object.keys(value).every(key => recursivelyCheckForFinalState({\n    value: value[key],\n    suspendedPaths,\n    path: path ? `${path}.${key}` : key\n  }));\n}\nfunction getActivePathsAndStatus(value) {\n  const paths = [];\n  const traverse = (current, path = []) => {\n    for (const [key, value2] of Object.entries(current)) {\n      const currentPath = [...path, key];\n      if (typeof value2 === \"string\") {\n        paths.push({\n          stepPath: currentPath,\n          stepId: key,\n          status: value2\n        });\n      } else if (typeof value2 === \"object\" && value2 !== null) {\n        traverse(value2, currentPath);\n      }\n    }\n  };\n  traverse(value);\n  return paths;\n}\nfunction mergeChildValue(startStepId, parent, child) {\n  const traverse = current => {\n    const obj = {};\n    for (const [key, value] of Object.entries(current)) {\n      if (key === startStepId) {\n        obj[key] = {\n          ...child\n        };\n      } else if (typeof value === \"string\") {\n        obj[key] = value;\n      } else if (typeof value === \"object\" && value !== null) {\n        obj[key] = traverse(value);\n      }\n    }\n    return obj;\n  };\n  return traverse(parent);\n}\nvar updateStepInHierarchy = (value, targetStepId) => {\n  const result = {};\n  for (const key of Object.keys(value)) {\n    const currentValue = value[key];\n    if (key === targetStepId) {\n      result[key] = \"pending\";\n    } else if (typeof currentValue === \"object\" && currentValue !== null) {\n      result[key] = updateStepInHierarchy(currentValue, targetStepId);\n    } else {\n      result[key] = currentValue;\n    }\n  }\n  return result;\n};\nfunction getResultActivePaths(state) {\n  const activePaths = getActivePathsAndStatus(state.value);\n  const activePathsAndStatus = activePaths.reduce((acc, curr) => {\n    const entry = {\n      status: curr.status,\n      stepPath: curr.stepPath\n    };\n    if (curr.status === \"suspended\") {\n      entry.suspendPayload = state.context.steps[curr.stepId].suspendPayload;\n      entry.stepPath = curr.stepPath;\n    }\n    acc.set(curr.stepId, entry);\n    return acc;\n  }, /* @__PURE__ */new Map());\n  return activePathsAndStatus;\n}\nfunction isWorkflow(step) {\n  return step instanceof LegacyWorkflow;\n}\nfunction isAgent(step) {\n  return step instanceof Agent;\n}\nfunction resolveVariables({\n  runId,\n  logger,\n  variables,\n  context\n}) {\n  const resolvedData = {};\n  for (const [key, variable] of Object.entries(variables)) {\n    const sourceData = variable.step === \"trigger\" ? context.triggerData : getStepResult(context.steps[variable.step.id ?? variable.step.name]);\n    logger.debug(`Got source data for ${key} variable from ${variable.step === \"trigger\" ? \"trigger\" : variable.step.id ?? variable.step.name}`, {\n      sourceData,\n      path: variable.path,\n      runId\n    });\n    if (!sourceData && variable.step !== \"trigger\") {\n      resolvedData[key] = void 0;\n      continue;\n    }\n    const value = variable.path === \"\" || variable.path === \".\" ? sourceData : get(sourceData, variable.path);\n    logger.debug(`Resolved variable ${key}`, {\n      value,\n      runId\n    });\n    resolvedData[key] = value;\n  }\n  return resolvedData;\n}\nfunction agentToStep(agent, {\n  mastra\n} = {}) {\n  return {\n    id: agent.name,\n    inputSchema: z.object({\n      prompt: z.string(),\n      resourceId: z.string().optional(),\n      threadId: z.string().optional()\n    }),\n    outputSchema: z.object({\n      text: z.string()\n    }),\n    execute: async ({\n      context,\n      runId,\n      mastra: mastraFromExecute\n    }) => {\n      const realMastra = mastraFromExecute ?? mastra;\n      if (!realMastra) {\n        throw new Error(\"Mastra instance not found\");\n      }\n      agent.__registerMastra(realMastra);\n      agent.__registerPrimitives({\n        logger: realMastra.getLogger(),\n        telemetry: realMastra.getTelemetry()\n      });\n      const result = await agent.generate(context.inputData.prompt, {\n        runId,\n        resourceId: context.inputData.resourceId,\n        threadId: context.inputData.threadId\n      });\n      return {\n        text: result.text\n      };\n    }\n  };\n}\nfunction workflowToStep(workflow, {\n  mastra\n}) {\n  workflow.setNested(true);\n  return {\n    id: workflow.name,\n    workflow,\n    workflowId: toCamelCaseWithRandomSuffix(workflow.name),\n    execute: async ({\n      context,\n      suspend,\n      emit,\n      mastra: mastraFromExecute,\n      runtimeContext\n    }) => {\n      const realMastra = mastraFromExecute ?? mastra;\n      if (realMastra) {\n        workflow.__registerMastra(realMastra);\n        workflow.__registerPrimitives({\n          logger: realMastra.getLogger(),\n          telemetry: realMastra.getTelemetry()\n        });\n      }\n      const run = context.isResume ? workflow.createRun({\n        runId: context.isResume.runId\n      }) : workflow.createRun();\n      const unwatch = run.watch(state => {\n        emit(\"state-update\", workflow.name, state.results, {\n          ...context,\n          ...{\n            [workflow.name]: state.results\n          }\n        });\n      });\n      const awaitedResult = context.isResume && context.isResume.stepId.includes(\".\") ? await run.resume({\n        stepId: context.isResume.stepId.split(\".\").slice(1).join(\".\"),\n        context: context.inputData,\n        runtimeContext\n      }) : await run.start({\n        triggerData: context.inputData,\n        runtimeContext\n      });\n      unwatch();\n      if (!awaitedResult) {\n        throw new Error(\"LegacyWorkflow run failed\");\n      }\n      if (awaitedResult.activePaths?.size > 0) {\n        const suspendedStep = [...awaitedResult.activePaths.entries()].find(([, {\n          status\n        }]) => {\n          return status === \"suspended\";\n        });\n        if (suspendedStep) {\n          await suspend(suspendedStep[1].suspendPayload, {\n            ...awaitedResult,\n            runId: run.runId\n          });\n        }\n      }\n      return {\n        ...awaitedResult,\n        runId: run.runId\n      };\n    }\n  };\n}\nfunction toCamelCaseWithRandomSuffix(str) {\n  if (!str) return \"\";\n  const normalizedStr = str.replace(/[-_]/g, \" \");\n  const words = normalizedStr.split(\" \").filter(word => word.length > 0);\n  const camelCase = words.map((word, index) => {\n    word = word.replace(/[^a-zA-Z0-9]/g, \"\");\n    if (index === 0) {\n      return word.toLowerCase();\n    }\n    return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();\n  }).join(\"\");\n  const randomString = generateRandomLetters(3);\n  return camelCase + randomString;\n}\nfunction generateRandomLetters(length) {\n  const characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  let result = \"\";\n  for (let i = 0; i < length; i++) {\n    const randomIndex = Math.floor(Math.random() * characters.length);\n    result += characters.charAt(randomIndex);\n  }\n  return result;\n}\nfunction isConditionalKey(key) {\n  return key.startsWith(\"__\") && (key.includes(\"_if\") || key.includes(\"_else\"));\n}\nvar Machine = class extends EventEmitter {\n  logger;\n  #mastra;\n  #runtimeContext;\n  #workflowInstance;\n  #executionSpan;\n  #stepGraph;\n  #machine;\n  #runId;\n  #startStepId;\n  name;\n  #actor = null;\n  #steps = {};\n  #retryConfig;\n  constructor({\n    logger,\n    mastra,\n    runtimeContext,\n    workflowInstance,\n    executionSpan,\n    name,\n    runId,\n    steps,\n    stepGraph,\n    retryConfig,\n    startStepId\n  }) {\n    super();\n    this.#mastra = mastra;\n    this.#workflowInstance = workflowInstance;\n    this.#runtimeContext = runtimeContext;\n    this.#executionSpan = executionSpan;\n    this.logger = logger;\n    this.#runId = runId;\n    this.#startStepId = startStepId;\n    this.name = name;\n    this.#stepGraph = stepGraph;\n    this.#steps = steps;\n    this.#retryConfig = retryConfig;\n    this.initializeMachine();\n  }\n  get startStepId() {\n    return this.#startStepId;\n  }\n  async execute({\n    stepId,\n    input,\n    snapshot,\n    resumeData\n  } = {}) {\n    if (snapshot) {\n      this.logger.debug(`Workflow snapshot received`, {\n        runId: this.#runId,\n        snapshot\n      });\n    }\n    const origSteps = input.steps;\n    const isResumedInitialStep = this.#stepGraph?.initial[0]?.step?.id === stepId;\n    if (isResumedInitialStep) {\n      snapshot = void 0;\n      input.steps = {};\n    }\n    this.logger.debug(`Machine input prepared`, {\n      runId: this.#runId,\n      input\n    });\n    const actorSnapshot = snapshot ? {\n      ...snapshot,\n      context: {\n        ...input,\n        inputData: {\n          ...(snapshot?.context?.inputData || {}),\n          ...resumeData\n        },\n        // ts-ignore is needed here because our snapshot types don't really match xstate snapshot types right now. We should fix this in general.\n        // @ts-ignore\n        isResume: {\n          runId: snapshot?.context?.steps[stepId.split(\".\")?.[0]]?.output?.runId || this.#runId,\n          stepId\n        }\n      }\n    } : void 0;\n    this.logger.debug(`Creating actor with configuration`, {\n      input,\n      actorSnapshot,\n      runId: this.#runId,\n      machineStates: this.#machine.config.states\n    });\n    this.#actor = createActor(this.#machine, {\n      inspect: inspectionEvent => {\n        this.logger.debug(\"XState inspection event\", {\n          type: inspectionEvent.type,\n          event: inspectionEvent.event,\n          runId: this.#runId\n        });\n      },\n      input: {\n        ...input,\n        inputData: {\n          ...(snapshot?.context?.inputData || {}),\n          ...resumeData\n        }\n      },\n      snapshot: actorSnapshot\n    });\n    this.#actor.start();\n    if (stepId) {\n      this.#actor.send({\n        type: \"RESET_TO_PENDING\",\n        stepId\n      });\n    }\n    this.logger.debug(\"Actor started\", {\n      runId: this.#runId\n    });\n    return new Promise((resolve, reject) => {\n      if (!this.#actor) {\n        this.logger.error(\"Actor not initialized\", {\n          runId: this.#runId\n        });\n        const e = new Error(\"Actor not initialized\");\n        this.#executionSpan?.recordException(e);\n        this.#executionSpan?.end();\n        reject(e);\n        return;\n      }\n      const suspendedPaths = /* @__PURE__ */new Set();\n      this.#actor.subscribe(async state => {\n        this.emit(\"state-update\", this.#startStepId, state);\n        getSuspendedPaths({\n          value: state.value,\n          path: \"\",\n          suspendedPaths\n        });\n        const allStatesValue = state.value;\n        const allStatesComplete = recursivelyCheckForFinalState({\n          value: allStatesValue,\n          suspendedPaths,\n          path: \"\"\n        });\n        this.logger.debug(\"State completion check\", {\n          allStatesComplete,\n          suspendedPaths: Array.from(suspendedPaths),\n          runId: this.#runId\n        });\n        if (!allStatesComplete) {\n          this.logger.debug(\"Not all states complete\", {\n            allStatesComplete,\n            suspendedPaths: Array.from(suspendedPaths),\n            runId: this.#runId\n          });\n          return;\n        }\n        try {\n          this.logger.debug(\"All states complete\", {\n            runId: this.#runId\n          });\n          await this.#workflowInstance.persistWorkflowSnapshot();\n          this.#cleanup();\n          this.#executionSpan?.end();\n          resolve({\n            runId: this.#runId,\n            results: isResumedInitialStep ? {\n              ...origSteps,\n              ...state.context.steps\n            } : state.context.steps,\n            activePaths: getResultActivePaths(state),\n            timestamp: Date.now()\n          });\n        } catch (error) {\n          this.logger.debug(\"Failed to persist final snapshot\", {\n            error\n          });\n          this.#cleanup();\n          this.#executionSpan?.end();\n          resolve({\n            runId: this.#runId,\n            results: isResumedInitialStep ? {\n              ...origSteps,\n              ...state.context.steps\n            } : state.context.steps,\n            activePaths: getResultActivePaths(state),\n            timestamp: Date.now()\n          });\n        }\n      });\n    });\n  }\n  #cleanup() {\n    if (this.#actor) {\n      this.#actor.stop();\n      this.#actor = null;\n    }\n    this.removeAllListeners();\n  }\n  #makeDelayMap() {\n    const delayMap = {};\n    Object.keys(this.#steps).forEach(stepId => {\n      delayMap[stepId] = this.#steps[stepId]?.step?.retryConfig?.delay || this.#retryConfig?.delay || 1e3;\n    });\n    return delayMap;\n  }\n  #getDefaultActions() {\n    return {\n      updateStepResult: assign({\n        steps: ({\n          context,\n          event\n        }) => {\n          if (!isTransitionEvent(event)) return context.steps;\n          const {\n            stepId,\n            result\n          } = event.output;\n          return {\n            ...context.steps,\n            [stepId]: {\n              status: \"success\",\n              output: result\n            }\n          };\n        }\n      }),\n      setStepError: assign({\n        steps: ({\n          context,\n          event\n        }, params) => {\n          if (!isErrorEvent(event)) return context.steps;\n          const {\n            stepId\n          } = params;\n          if (!stepId) return context.steps;\n          return {\n            ...context.steps,\n            [stepId]: {\n              status: \"failed\",\n              error: event.error.message\n            }\n          };\n        }\n      }),\n      notifyStepCompletion: async (_, params) => {\n        const {\n          stepId\n        } = params;\n        this.logger.debug(`Step ${stepId} completed`);\n      },\n      snapshotStep: assign({\n        _snapshot: ({}, params) => {\n          const {\n            stepId\n          } = params;\n          return {\n            stepId\n          };\n        }\n      }),\n      persistSnapshot: async ({\n        context\n      }) => {\n        if (context._snapshot) {\n          await this.#workflowInstance.persistWorkflowSnapshot();\n        }\n        return;\n      },\n      decrementAttemptCount: assign({\n        attempts: ({\n          context,\n          event\n        }, params) => {\n          if (!isTransitionEvent(event)) return context.attempts;\n          const {\n            stepId\n          } = params;\n          const attemptCount = context.attempts[stepId];\n          if (attemptCount === void 0) return context.attempts;\n          return {\n            ...context.attempts,\n            [stepId]: attemptCount - 1\n          };\n        }\n      })\n    };\n  }\n  #getDefaultActors() {\n    return {\n      resolverFunction: fromPromise(async ({\n        input\n      }) => {\n        const {\n          stepNode,\n          context\n        } = input;\n        const attemptCount = context.attempts[stepNode.id];\n        const resolvedData = this.#resolveVariables({\n          stepConfig: stepNode.config,\n          context,\n          stepId: stepNode.id\n        });\n        this.logger.debug(`Resolved variables for ${stepNode.id}`, {\n          resolvedData,\n          runId: this.#runId\n        });\n        const logger = this.logger;\n        let mastraProxy = void 0;\n        if (this.#mastra) {\n          mastraProxy = createMastraProxy({\n            mastra: this.#mastra,\n            logger\n          });\n        }\n        let result = void 0;\n        try {\n          result = await stepNode.config.handler({\n            context: {\n              ...context,\n              inputData: {\n                ...(context?.inputData || {}),\n                ...resolvedData\n              },\n              getStepResult: stepId => {\n                const resolvedStepId = typeof stepId === \"string\" ? stepId : stepId.id;\n                if (resolvedStepId === \"trigger\") {\n                  return context.triggerData;\n                }\n                const result2 = context.steps[resolvedStepId];\n                if (result2 && result2.status === \"success\") {\n                  return result2.output;\n                }\n                return void 0;\n              }\n            },\n            emit: (event, ...args) => {\n              this.emit(event, ...args);\n            },\n            suspend: async (payload, softSuspend) => {\n              await this.#workflowInstance.suspend(stepNode.id, this);\n              if (this.#actor) {\n                context.steps[stepNode.id] = {\n                  status: \"suspended\",\n                  suspendPayload: payload,\n                  output: softSuspend\n                };\n                this.logger.debug(`Sending SUSPENDED event for step ${stepNode.id}`);\n                this.#actor?.send({\n                  type: \"SUSPENDED\",\n                  suspendPayload: payload,\n                  stepId: stepNode.id,\n                  softSuspend\n                });\n              } else {\n                this.logger.debug(`Actor not available for step ${stepNode.id}`);\n              }\n            },\n            runId: this.#runId,\n            mastra: mastraProxy,\n            runtimeContext: this.#runtimeContext\n          });\n        } catch (error) {\n          this.logger.debug(`Step ${stepNode.id} failed`, {\n            stepId: stepNode.id,\n            error,\n            runId: this.#runId\n          });\n          this.logger.debug(`Attempt count for step ${stepNode.id}`, {\n            attemptCount,\n            attempts: context.attempts,\n            runId: this.#runId,\n            stepId: stepNode.id\n          });\n          if (!attemptCount || attemptCount < 0) {\n            return {\n              type: \"STEP_FAILED\",\n              error: error instanceof Error ? error.message : `Step:${stepNode.id} failed with error: ${error}`,\n              stepId: stepNode.id\n            };\n          }\n          return {\n            type: \"STEP_WAITING\",\n            stepId: stepNode.id\n          };\n        }\n        this.logger.debug(`Step ${stepNode.id} result`, {\n          stepId: stepNode.id,\n          result,\n          runId: this.#runId\n        });\n        return {\n          type: \"STEP_SUCCESS\",\n          result,\n          stepId: stepNode.id\n        };\n      }),\n      conditionCheck: fromPromise(async ({\n        input\n      }) => {\n        const {\n          context,\n          stepNode\n        } = input;\n        const stepConfig = stepNode.config;\n        this.logger.debug(`Checking conditions for step ${stepNode.id}`, {\n          stepId: stepNode.id,\n          runId: this.#runId\n        });\n        if (!stepConfig?.when) {\n          return {\n            type: \"CONDITIONS_MET\"\n          };\n        }\n        this.logger.debug(`Checking conditions for step ${stepNode.id}`, {\n          stepId: stepNode.id,\n          runId: this.#runId\n        });\n        if (typeof stepConfig?.when === \"function\") {\n          let conditionMet = await stepConfig.when({\n            context: {\n              ...context,\n              getStepResult: stepId => {\n                const resolvedStepId = typeof stepId === \"string\" ? stepId : stepId.id;\n                if (resolvedStepId === \"trigger\") {\n                  return context.triggerData;\n                }\n                const result = context.steps[resolvedStepId];\n                if (result && result.status === \"success\") {\n                  return result.output;\n                }\n                return void 0;\n              }\n            },\n            mastra: this.#mastra\n          });\n          if (conditionMet === \"abort\" /* ABORT */) {\n            conditionMet = false;\n          } else if (conditionMet === \"continue_failed\" /* CONTINUE_FAILED */) {\n            return {\n              type: \"CONDITIONS_SKIP_TO_COMPLETED\"\n            };\n          } else if (conditionMet === \"limbo\" /* LIMBO */) {\n            return {\n              type: \"CONDITIONS_LIMBO\"\n            };\n          } else if (conditionMet) {\n            this.logger.debug(`Condition met for step ${stepNode.id}`, {\n              stepId: stepNode.id,\n              runId: this.#runId\n            });\n            return {\n              type: \"CONDITIONS_MET\"\n            };\n          }\n          if (isConditionalKey(stepNode.id)) {\n            return {\n              type: \"CONDITIONS_LIMBO\"\n            };\n          }\n          return this.#workflowInstance.hasSubscribers(stepNode.id) ? {\n            type: \"CONDITIONS_SKIPPED\"\n          } : {\n            type: \"CONDITIONS_LIMBO\"\n          };\n        } else {\n          const conditionMet = this.#evaluateCondition(stepConfig.when, context);\n          if (!conditionMet) {\n            return {\n              type: \"CONDITION_FAILED\",\n              error: `Step:${stepNode.id} condition check failed`\n            };\n          }\n        }\n        return {\n          type: \"CONDITIONS_MET\"\n        };\n      }),\n      spawnSubscriberFunction: fromPromise(async ({\n        input\n      }) => {\n        const {\n          parentStepId,\n          context\n        } = input;\n        const result = await this.#workflowInstance.runMachine(parentStepId, context, this.#runtimeContext);\n        return Promise.resolve({\n          steps: result.reduce((acc, r) => {\n            return {\n              ...acc,\n              ...r?.results\n            };\n          }, {})\n        });\n      })\n    };\n  }\n  #resolveVariables({\n    stepConfig,\n    context,\n    stepId\n  }) {\n    this.logger.debug(`Resolving variables for step ${stepId}`, {\n      stepId,\n      runId: this.#runId\n    });\n    const resolvedData = {};\n    for (const [key, variable] of Object.entries(stepConfig.data)) {\n      const sourceData = variable.step === \"trigger\" ? context.triggerData : getStepResult(context.steps[variable.step.id]);\n      this.logger.debug(`Got source data for ${key} variable from ${variable.step === \"trigger\" ? \"trigger\" : variable.step.id}`, {\n        sourceData,\n        path: variable.path,\n        runId: this.#runId\n      });\n      if (!sourceData && variable.step !== \"trigger\") {\n        resolvedData[key] = void 0;\n        continue;\n      }\n      const value = variable.path === \"\" || variable.path === \".\" ? sourceData : get(sourceData, variable.path);\n      this.logger.debug(`Resolved variable ${key}`, {\n        value,\n        runId: this.#runId\n      });\n      resolvedData[key] = value;\n    }\n    return resolvedData;\n  }\n  initializeMachine() {\n    const machine = setup({\n      types: {},\n      delays: this.#makeDelayMap(),\n      actions: this.#getDefaultActions(),\n      actors: this.#getDefaultActors()\n    }).createMachine({\n      id: this.name,\n      type: \"parallel\",\n      context: ({\n        input\n      }) => ({\n        ...input\n      }),\n      states: this.#buildStateHierarchy(this.#stepGraph)\n    });\n    this.#machine = machine;\n    return machine;\n  }\n  #buildStateHierarchy(stepGraph) {\n    const states = {};\n    stepGraph.initial.forEach(stepNode => {\n      const nextSteps = [...(stepGraph[stepNode.id] || [])];\n      states[stepNode.id] = {\n        ...this.#buildBaseState(stepNode, nextSteps)\n      };\n    });\n    return states;\n  }\n  #buildBaseState(stepNode, nextSteps = []) {\n    const nextStep = nextSteps.shift();\n    return {\n      initial: \"pending\",\n      on: {\n        RESET_TO_PENDING: {\n          target: \".pending\"\n          // Note the dot to target child state\n        }\n      },\n      states: {\n        pending: {\n          entry: () => {\n            this.logger.debug(`Step ${stepNode.id} pending`, {\n              stepId: stepNode.id,\n              runId: this.#runId\n            });\n          },\n          exit: () => {\n            this.logger.debug(`Step ${stepNode.id} finished pending`, {\n              stepId: stepNode.id,\n              runId: this.#runId\n            });\n          },\n          invoke: {\n            src: \"conditionCheck\",\n            input: ({\n              context\n            }) => {\n              return {\n                context,\n                stepNode\n              };\n            },\n            onDone: [{\n              guard: ({\n                event\n              }) => {\n                return event.output.type === \"SUSPENDED\";\n              },\n              target: \"suspended\",\n              actions: [assign({\n                steps: ({\n                  context,\n                  event\n                }) => {\n                  if (event.output.type !== \"SUSPENDED\") return context.steps;\n                  if (event.output.softSuspend) {\n                    return {\n                      ...context.steps,\n                      [stepNode.id]: {\n                        status: \"suspended\",\n                        ...(context.steps?.[stepNode.id] || {}),\n                        output: event.output.softSuspend\n                      }\n                    };\n                  }\n                  return {\n                    ...context.steps,\n                    [stepNode.id]: {\n                      status: \"suspended\",\n                      ...(context.steps?.[stepNode.id] || {})\n                    }\n                  };\n                },\n                attempts: ({\n                  context,\n                  event\n                }) => {\n                  if (event.output.type !== \"SUSPENDED\") return context.attempts;\n                  return {\n                    ...context.attempts,\n                    [stepNode.id]: stepNode.step.retryConfig?.attempts || 0\n                  };\n                }\n              })]\n            }, {\n              guard: ({\n                event\n              }) => {\n                return event.output.type === \"WAITING\";\n              },\n              target: \"waiting\",\n              actions: [{\n                type: \"decrementAttemptCount\",\n                params: {\n                  stepId: stepNode.id\n                }\n              }, assign({\n                steps: ({\n                  context,\n                  event\n                }) => {\n                  if (event.output.type !== \"WAITING\") return context.steps;\n                  return {\n                    ...context.steps,\n                    [stepNode.id]: {\n                      status: \"waiting\"\n                    }\n                  };\n                }\n              })]\n            }, {\n              guard: ({\n                event\n              }) => {\n                return event.output.type === \"CONDITIONS_MET\";\n              },\n              target: \"executing\"\n            }, {\n              guard: ({\n                event\n              }) => {\n                return event.output.type === \"CONDITIONS_SKIP_TO_COMPLETED\";\n              },\n              target: \"completed\"\n            }, {\n              guard: ({\n                event\n              }) => {\n                return event.output.type === \"CONDITIONS_SKIPPED\";\n              },\n              actions: assign({\n                steps: ({\n                  context\n                }) => {\n                  const newStep = {\n                    ...context.steps,\n                    [stepNode.id]: {\n                      status: \"skipped\"\n                    }\n                  };\n                  this.logger.debug(`Step ${stepNode.id} skipped`, {\n                    stepId: stepNode.id,\n                    runId: this.#runId\n                  });\n                  return newStep;\n                }\n              }),\n              target: \"runningSubscribers\"\n            }, {\n              guard: ({\n                event\n              }) => {\n                return event.output.type === \"CONDITIONS_LIMBO\";\n              },\n              target: \"limbo\",\n              actions: assign({\n                steps: ({\n                  context\n                }) => {\n                  const newStep = {\n                    ...context.steps,\n                    [stepNode.id]: {\n                      status: \"skipped\"\n                    }\n                  };\n                  this.logger.debug(`Step ${stepNode.id} skipped`, {\n                    stepId: stepNode.id,\n                    runId: this.#runId\n                  });\n                  return newStep;\n                }\n              })\n            }, {\n              guard: ({\n                event\n              }) => {\n                return event.output.type === \"CONDITION_FAILED\";\n              },\n              target: \"failed\",\n              actions: assign({\n                steps: ({\n                  context,\n                  event\n                }) => {\n                  if (event.output.type !== \"CONDITION_FAILED\") return context.steps;\n                  this.logger.debug(`Workflow condition check failed`, {\n                    error: event.output.error,\n                    stepId: stepNode.id\n                  });\n                  return {\n                    ...context.steps,\n                    [stepNode.id]: {\n                      status: \"failed\",\n                      error: event.output.error\n                    }\n                  };\n                }\n              })\n            }]\n          }\n        },\n        waiting: {\n          entry: () => {\n            this.logger.debug(`Step ${stepNode.id} waiting`, {\n              stepId: stepNode.id,\n              timestamp: (/* @__PURE__ */new Date()).toISOString(),\n              runId: this.#runId\n            });\n          },\n          exit: () => {\n            this.logger.debug(`Step ${stepNode.id} finished waiting`, {\n              stepId: stepNode.id,\n              timestamp: (/* @__PURE__ */new Date()).toISOString(),\n              runId: this.#runId\n            });\n          },\n          after: {\n            [stepNode.id]: {\n              target: \"pending\"\n            }\n          }\n        },\n        limbo: {\n          // no target, will stay in limbo indefinitely\n          entry: () => {\n            this.logger.debug(`Step ${stepNode.id} limbo`, {\n              stepId: stepNode.id,\n              timestamp: (/* @__PURE__ */new Date()).toISOString(),\n              runId: this.#runId\n            });\n          },\n          exit: () => {\n            this.logger.debug(`Step ${stepNode.id} finished limbo`, {\n              stepId: stepNode.id,\n              timestamp: (/* @__PURE__ */new Date()).toISOString(),\n              runId: this.#runId\n            });\n          }\n        },\n        suspended: {\n          type: \"final\",\n          entry: [() => {\n            this.logger.debug(`Step ${stepNode.id} suspended`, {\n              stepId: stepNode.id,\n              runId: this.#runId\n            });\n          }, assign({\n            steps: ({\n              context,\n              event\n            }) => {\n              return {\n                ...context.steps,\n                [stepNode.id]: {\n                  ...(context?.steps?.[stepNode.id] || {}),\n                  status: \"suspended\",\n                  suspendPayload: event.type === \"SUSPENDED\" ? event.suspendPayload : void 0,\n                  output: event.type === \"SUSPENDED\" ? event.softSuspend : void 0\n                }\n              };\n            }\n          })]\n        },\n        executing: {\n          entry: () => {\n            this.logger.debug(`Step ${stepNode.id} executing`, {\n              stepId: stepNode.id,\n              runId: this.#runId\n            });\n          },\n          on: {\n            SUSPENDED: {\n              target: \"suspended\",\n              actions: [assign({\n                steps: ({\n                  context,\n                  event\n                }) => {\n                  return {\n                    ...context.steps,\n                    [stepNode.id]: {\n                      status: \"suspended\",\n                      suspendPayload: event.type === \"SUSPENDED\" ? event.suspendPayload : void 0,\n                      output: event.type === \"SUSPENDED\" ? event.softSuspend : void 0\n                    }\n                  };\n                }\n              })]\n            }\n          },\n          invoke: {\n            src: \"resolverFunction\",\n            input: ({\n              context\n            }) => ({\n              context,\n              stepNode\n            }),\n            onDone: [{\n              guard: ({\n                event\n              }) => {\n                return event.output.type === \"STEP_FAILED\";\n              },\n              target: \"failed\",\n              actions: assign({\n                steps: ({\n                  context,\n                  event\n                }) => {\n                  if (event.output.type !== \"STEP_FAILED\") return context.steps;\n                  const newStep = {\n                    ...context.steps,\n                    [stepNode.id]: {\n                      status: \"failed\",\n                      error: event.output.error\n                    }\n                  };\n                  this.logger.debug(`Step ${stepNode.id} failed`, {\n                    error: event.output.error,\n                    stepId: stepNode.id\n                  });\n                  return newStep;\n                }\n              })\n            }, {\n              guard: ({\n                event\n              }) => {\n                return event.output.type === \"STEP_SUCCESS\";\n              },\n              actions: [({\n                event\n              }) => {\n                this.logger.debug(`Step ${stepNode.id} finished executing`, {\n                  stepId: stepNode.id,\n                  output: event.output,\n                  runId: this.#runId\n                });\n              }, {\n                type: \"updateStepResult\",\n                params: {\n                  stepId: stepNode.id\n                }\n              }, {\n                type: \"spawnSubscribers\",\n                params: {\n                  stepId: stepNode.id\n                }\n              }],\n              target: \"runningSubscribers\"\n            }, {\n              guard: ({\n                event\n              }) => {\n                return event.output.type === \"STEP_WAITING\";\n              },\n              target: \"waiting\",\n              actions: [{\n                type: \"decrementAttemptCount\",\n                params: {\n                  stepId: stepNode.id\n                }\n              }, assign({\n                steps: ({\n                  context,\n                  event\n                }) => {\n                  if (event.output.type !== \"STEP_WAITING\") return context.steps;\n                  return {\n                    ...context.steps,\n                    [stepNode.id]: {\n                      status: \"waiting\"\n                    }\n                  };\n                }\n              })]\n            }],\n            onError: {\n              target: \"failed\",\n              actions: [{\n                type: \"setStepError\",\n                params: {\n                  stepId: stepNode.id\n                }\n              }]\n            }\n          }\n        },\n        runningSubscribers: {\n          entry: () => {\n            this.logger.debug(`Step ${stepNode.id} running subscribers`, {\n              stepId: stepNode.id,\n              runId: this.#runId\n            });\n          },\n          exit: () => {\n            this.logger.debug(`Step ${stepNode.id} finished running subscribers`, {\n              stepId: stepNode.id,\n              runId: this.#runId\n            });\n          },\n          invoke: {\n            src: \"spawnSubscriberFunction\",\n            input: ({\n              context\n            }) => ({\n              parentStepId: stepNode.id,\n              context\n            }),\n            onDone: {\n              target: nextStep ? nextStep.id : \"completed\",\n              actions: [assign({\n                steps: ({\n                  context,\n                  event\n                }) => ({\n                  ...context.steps,\n                  ...event.output.steps\n                })\n              }), () => this.logger.debug(`Subscriber execution completed`, {\n                stepId: stepNode.id\n              })]\n            },\n            onError: {\n              target: nextStep ? nextStep.id : \"completed\",\n              actions: ({\n                event\n              }) => {\n                this.logger.debug(`Subscriber execution failed`, {\n                  error: event.error,\n                  stepId: stepNode.id\n                });\n              }\n            }\n          }\n        },\n        completed: {\n          type: \"final\",\n          entry: [{\n            type: \"notifyStepCompletion\",\n            params: {\n              stepId: stepNode.id\n            }\n          }, {\n            type: \"snapshotStep\",\n            params: {\n              stepId: stepNode.id\n            }\n          }, {\n            type: \"persistSnapshot\"\n          }]\n        },\n        failed: {\n          type: \"final\",\n          entry: [{\n            type: \"notifyStepCompletion\",\n            params: {\n              stepId: stepNode.id\n            }\n          }, {\n            type: \"snapshotStep\",\n            params: {\n              stepId: stepNode.id\n            }\n          }, {\n            type: \"persistSnapshot\"\n          }]\n        },\n        // build chain of next steps recursively\n        ...(nextStep ? {\n          [nextStep.id]: {\n            ...this.#buildBaseState(nextStep, nextSteps)\n          }\n        } : {})\n      }\n    };\n  }\n  #evaluateCondition(condition, context) {\n    let andBranchResult = true;\n    let baseResult = true;\n    let orBranchResult = true;\n    const simpleCondition = Object.entries(condition).find(([key]) => key.includes(\".\"));\n    if (simpleCondition) {\n      const [key, queryValue] = simpleCondition;\n      const [stepId, ...pathParts] = key.split(\".\");\n      const path = pathParts.join(\".\");\n      const sourceData = stepId === \"trigger\" ? context.triggerData : getStepResult(context.steps[stepId]);\n      this.logger.debug(`Got condition data from step ${stepId}`, {\n        stepId,\n        sourceData,\n        runId: this.#runId\n      });\n      if (!sourceData) {\n        return false;\n      }\n      let value = get(sourceData, path);\n      if (stepId !== \"trigger\" && path === \"status\" && !value) {\n        value = \"success\";\n      }\n      if (typeof queryValue === \"object\" && queryValue !== null) {\n        baseResult = sift(queryValue)(value);\n      } else {\n        baseResult = value === queryValue;\n      }\n    }\n    if (\"ref\" in condition) {\n      const {\n        ref,\n        query\n      } = condition;\n      const sourceData = ref.step === \"trigger\" ? context.triggerData : getStepResult(context.steps[ref.step.id]);\n      this.logger.debug(`Got condition data from ${ref.step === \"trigger\" ? \"trigger\" : ref.step.id}`, {\n        sourceData,\n        runId: this.#runId\n      });\n      if (!sourceData) {\n        return false;\n      }\n      let value = get(sourceData, ref.path);\n      if (ref.step !== \"trigger\" && ref.path === \"status\" && !value) {\n        value = \"success\";\n      }\n      baseResult = sift(query)(value);\n    }\n    if (\"and\" in condition) {\n      andBranchResult = condition.and.every(cond => this.#evaluateCondition(cond, context));\n      this.logger.debug(`Evaluated AND condition`, {\n        andBranchResult,\n        runId: this.#runId\n      });\n    }\n    if (\"or\" in condition) {\n      orBranchResult = condition.or.some(cond => this.#evaluateCondition(cond, context));\n      this.logger.debug(`Evaluated OR condition`, {\n        orBranchResult,\n        runId: this.#runId\n      });\n    }\n    if (\"not\" in condition) {\n      baseResult = !this.#evaluateCondition(condition.not, context);\n      this.logger.debug(`Evaluated NOT condition`, {\n        baseResult,\n        runId: this.#runId\n      });\n    }\n    const finalResult = baseResult && andBranchResult && orBranchResult;\n    this.logger.debug(`Evaluated condition`, {\n      finalResult,\n      runId: this.#runId\n    });\n    return finalResult;\n  }\n  getSnapshot() {\n    const snapshot = this.#actor?.getSnapshot();\n    return snapshot;\n  }\n};\n\n// src/workflows/legacy/workflow-instance.ts\nvar WorkflowInstance = class {\n  name;\n  #mastra;\n  #machines = {};\n  logger;\n  #steps = {};\n  #stepGraph;\n  #stepSubscriberGraph = {};\n  #retryConfig;\n  events;\n  #runId;\n  #state = null;\n  #executionSpan;\n  #onStepTransition = /* @__PURE__ */new Set();\n  #onFinish;\n  #resultMapping;\n  // indexed by stepId\n  #suspendedMachines = {};\n  // {step1&&step2: {step1: true, step2: true}}\n  #compoundDependencies = {};\n  constructor({\n    name,\n    logger,\n    steps,\n    runId,\n    retryConfig,\n    mastra,\n    stepGraph,\n    stepSubscriberGraph,\n    onFinish,\n    onStepTransition,\n    resultMapping,\n    events\n  }) {\n    this.name = name;\n    this.logger = logger;\n    this.#steps = steps;\n    this.#stepGraph = stepGraph;\n    this.#stepSubscriberGraph = stepSubscriberGraph;\n    this.#retryConfig = retryConfig;\n    this.#mastra = mastra;\n    this.#runId = runId ?? crypto.randomUUID();\n    this.#onFinish = onFinish;\n    this.#resultMapping = resultMapping;\n    this.events = events;\n    onStepTransition?.forEach(handler => this.#onStepTransition.add(handler));\n    this.#initializeCompoundDependencies();\n  }\n  setState(state) {\n    this.#state = state;\n  }\n  get runId() {\n    return this.#runId;\n  }\n  get executionSpan() {\n    return this.#executionSpan;\n  }\n  watch(onTransition) {\n    this.#onStepTransition.add(onTransition);\n    return () => {\n      this.#onStepTransition.delete(onTransition);\n    };\n  }\n  async start({\n    triggerData,\n    runtimeContext\n  } = {}) {\n    const results = await this.execute({\n      triggerData,\n      runtimeContext: runtimeContext ?? new RuntimeContext()\n    });\n    if (this.#onFinish) {\n      const activePathsObj = Object.fromEntries(results.activePaths);\n      const hasSuspendedActivePaths = Object.values(activePathsObj).some(value => value.status === \"suspended\");\n      if (!hasSuspendedActivePaths) {\n        this.#onFinish();\n      }\n    }\n    return {\n      ...results,\n      runId: this.runId\n    };\n  }\n  isCompoundDependencyMet(stepKey) {\n    if (!this.#isCompoundKey(stepKey)) return true;\n    const dependencies = this.#compoundDependencies[stepKey];\n    return dependencies ? Object.values(dependencies).every(status => status === true) : true;\n  }\n  async execute({\n    triggerData,\n    snapshot,\n    stepId,\n    resumeData,\n    runtimeContext\n  } = {\n    runtimeContext: new RuntimeContext()\n  }) {\n    this.#executionSpan = this.#mastra?.getTelemetry()?.tracer.startSpan(`workflow.${this.name}.execute`, {\n      attributes: {\n        componentName: this.name,\n        runId: this.runId\n      }\n    });\n    let machineInput = {\n      // Maintain the original step results and their output\n      steps: {},\n      triggerData: triggerData || {},\n      attempts: Object.keys(this.#steps).reduce((acc, stepKey) => {\n        acc[stepKey] = this.#steps[stepKey]?.step?.retryConfig?.attempts || this.#retryConfig?.attempts || 0;\n        return acc;\n      }, {})\n    };\n    let stepGraph = this.#stepGraph;\n    let startStepId = \"trigger\";\n    if (snapshot) {\n      const runState = snapshot;\n      if (stepId && runState?.suspendedSteps?.[stepId]) {\n        startStepId = runState.suspendedSteps[stepId];\n        stepGraph = this.#stepSubscriberGraph[startStepId] ?? this.#stepGraph;\n        machineInput = runState.context;\n      }\n    }\n    const defaultMachine = new Machine({\n      logger: this.logger,\n      mastra: this.#mastra,\n      runtimeContext,\n      workflowInstance: this,\n      name: this.name,\n      runId: this.runId,\n      steps: this.#steps,\n      stepGraph,\n      executionSpan: this.#executionSpan,\n      startStepId,\n      retryConfig: this.#retryConfig\n    });\n    this.#machines[startStepId] = defaultMachine;\n    const stateUpdateHandler = (startStepId2, state, ctx) => {\n      let fullState = {\n        value: {},\n        context: {}\n      };\n      if (ctx) {\n        fullState[\"value\"] = state;\n        fullState[\"context\"] = ctx;\n      } else {\n        fullState = state;\n      }\n      if (startStepId2 === \"trigger\") {\n        this.#state = fullState.value;\n      } else {\n        this.#state = mergeChildValue(startStepId2, this.#state, fullState.value);\n      }\n      const now = Date.now();\n      if (this.#onStepTransition) {\n        this.#onStepTransition.forEach(onTransition => {\n          void onTransition({\n            runId: this.#runId,\n            results: fullState.context.steps,\n            activePaths: getResultActivePaths(fullState),\n            timestamp: now\n          });\n        });\n      }\n    };\n    defaultMachine.on(\"state-update\", stateUpdateHandler);\n    const {\n      results,\n      activePaths\n    } = await defaultMachine.execute({\n      snapshot,\n      stepId,\n      input: machineInput,\n      resumeData\n    });\n    await this.persistWorkflowSnapshot();\n    const result = {\n      results,\n      activePaths,\n      timestamp: Date.now()\n    };\n    if (this.#resultMapping) {\n      result.result = resolveVariables({\n        runId: this.#runId,\n        logger: this.logger,\n        variables: this.#resultMapping,\n        context: {\n          steps: results,\n          triggerData}\n      });\n    }\n    return result;\n  }\n  hasSubscribers(stepId) {\n    return Object.keys(this.#stepSubscriberGraph).some(key => key.split(\"&&\").includes(stepId));\n  }\n  async runMachine(parentStepId, input, runtimeContext = new RuntimeContext()) {\n    const stepStatus = input.steps[parentStepId]?.status;\n    const subscriberKeys = Object.keys(this.#stepSubscriberGraph).filter(key => key.split(\"&&\").includes(parentStepId));\n    subscriberKeys.forEach(key => {\n      if ([\"success\", \"failure\", \"skipped\"].includes(stepStatus) && this.#isCompoundKey(key)) {\n        this.#compoundDependencies[key][parentStepId] = true;\n      }\n    });\n    const stateUpdateHandler = (startStepId, state, ctx) => {\n      let fullState = {\n        value: {},\n        context: {}\n      };\n      if (ctx) {\n        fullState[\"value\"] = state;\n        fullState[\"context\"] = ctx;\n      } else {\n        fullState = state;\n      }\n      if (startStepId === \"trigger\") {\n        this.#state = fullState.value;\n      } else {\n        this.#state = mergeChildValue(startStepId, this.#state, fullState.value);\n      }\n      const now = Date.now();\n      if (this.#onStepTransition) {\n        this.#onStepTransition.forEach(onTransition => {\n          void onTransition({\n            runId: this.#runId,\n            results: fullState.context.steps,\n            activePaths: getResultActivePaths(fullState),\n            timestamp: now\n          });\n        });\n      }\n    };\n    const results = await Promise.all(subscriberKeys.map(async key => {\n      if (!this.#stepSubscriberGraph[key] || !this.isCompoundDependencyMet(key)) {\n        return;\n      }\n      this.#resetCompoundDependency(key);\n      const machine = new Machine({\n        logger: this.logger,\n        mastra: this.#mastra,\n        runtimeContext,\n        workflowInstance: this,\n        name: parentStepId === \"trigger\" ? this.name : `${this.name}-${parentStepId}`,\n        runId: this.runId,\n        steps: this.#steps,\n        stepGraph: this.#stepSubscriberGraph[key],\n        executionSpan: this.#executionSpan,\n        startStepId: parentStepId\n      });\n      machine.on(\"state-update\", stateUpdateHandler);\n      this.#machines[parentStepId] = machine;\n      return machine.execute({\n        input\n      });\n    }));\n    return results;\n  }\n  async suspend(stepId, machine) {\n    this.#suspendedMachines[stepId] = machine;\n  }\n  /**\n   * Persists the workflow state to the database\n   */\n  async persistWorkflowSnapshot() {\n    const storage = this.#mastra?.getStorage();\n    if (!storage) {\n      this.logger.debug(\"Snapshot cannot be persisted. Mastra engine is not initialized\", {\n        runId: this.#runId\n      });\n      return;\n    }\n    const existingSnapshot = await storage.loadWorkflowSnapshot({\n      workflowName: this.name,\n      runId: this.#runId\n    });\n    const machineSnapshots = {};\n    for (const [stepId, machine] of Object.entries(this.#machines)) {\n      const machineSnapshot = machine?.getSnapshot();\n      if (machineSnapshot) {\n        machineSnapshots[stepId] = {\n          ...machineSnapshot\n        };\n      }\n    }\n    let snapshot = machineSnapshots[\"trigger\"];\n    delete machineSnapshots[\"trigger\"];\n    const suspendedSteps = Object.entries(this.#suspendedMachines).reduce((acc, [stepId, machine]) => {\n      acc[stepId] = machine.startStepId;\n      return acc;\n    }, {});\n    if (!snapshot && existingSnapshot) {\n      existingSnapshot.childStates = {\n        ...existingSnapshot.childStates,\n        ...machineSnapshots\n      };\n      existingSnapshot.suspendedSteps = {\n        ...existingSnapshot.suspendedSteps,\n        ...suspendedSteps\n      };\n      await storage.persistWorkflowSnapshot({\n        workflowName: this.name,\n        runId: this.#runId,\n        snapshot: existingSnapshot\n      });\n      return;\n    } else if (snapshot && !existingSnapshot) {\n      snapshot.suspendedSteps = suspendedSteps;\n      snapshot.childStates = {\n        ...machineSnapshots\n      };\n      await storage.persistWorkflowSnapshot({\n        workflowName: this.name,\n        runId: this.#runId,\n        snapshot\n      });\n      return;\n    } else if (!snapshot) {\n      this.logger.debug(\"Snapshot cannot be persisted. No snapshot received.\", {\n        runId: this.#runId\n      });\n      return;\n    }\n    snapshot.suspendedSteps = {\n      ...existingSnapshot.suspendedSteps,\n      ...suspendedSteps\n    };\n    if (!existingSnapshot || snapshot === existingSnapshot) {\n      await storage.persistWorkflowSnapshot({\n        workflowName: this.name,\n        runId: this.#runId,\n        snapshot\n      });\n      return;\n    }\n    if (existingSnapshot?.childStates) {\n      snapshot.childStates = {\n        ...existingSnapshot.childStates,\n        ...machineSnapshots\n      };\n    } else {\n      snapshot.childStates = machineSnapshots;\n    }\n    await storage.persistWorkflowSnapshot({\n      workflowName: this.name,\n      runId: this.#runId,\n      snapshot\n    });\n  }\n  async getState() {\n    const storedSnapshot = await this.#mastra?.storage?.loadWorkflowSnapshot({\n      workflowName: this.name,\n      runId: this.runId\n    });\n    const prevSnapshot = storedSnapshot ? {\n      trigger: storedSnapshot,\n      ...Object.entries(storedSnapshot?.childStates ?? {}).reduce((acc, [stepId, snapshot2]) => ({\n        ...acc,\n        [stepId]: snapshot2\n      }), {})\n    } : {};\n    const currentSnapshot = Object.entries(this.#machines).reduce((acc, [stepId, machine]) => {\n      const snapshot2 = machine.getSnapshot();\n      if (!snapshot2) {\n        return acc;\n      }\n      return {\n        ...acc,\n        [stepId]: snapshot2\n      };\n    }, {});\n    Object.assign(prevSnapshot, currentSnapshot);\n    const trigger = prevSnapshot.trigger;\n    delete prevSnapshot.trigger;\n    const snapshot = {\n      ...trigger};\n    const m = getActivePathsAndStatus(prevSnapshot.value);\n    return {\n      runId: this.runId,\n      value: snapshot.value,\n      context: snapshot.context,\n      activePaths: m,\n      timestamp: Date.now()\n    };\n  }\n  async resumeWithEvent(eventName, data, runtimeContext = new RuntimeContext()) {\n    const event = this.events?.[eventName];\n    if (!event) {\n      throw new Error(`Event ${eventName} not found`);\n    }\n    const results = await this.resume({\n      stepId: `__${eventName}_event`,\n      context: {\n        resumedEvent: data\n      },\n      runtimeContext\n    });\n    return results;\n  }\n  async resume({\n    stepId,\n    context: resumeContext,\n    runtimeContext = new RuntimeContext()\n  }) {\n    await new Promise(resolve => setTimeout(resolve, 0));\n    return this._resume({\n      stepId,\n      context: resumeContext,\n      runtimeContext\n    });\n  }\n  async #loadWorkflowSnapshot(runId) {\n    const storage = this.#mastra?.getStorage();\n    if (!storage) {\n      this.logger.debug(\"Snapshot cannot be loaded. Mastra engine is not initialized\", {\n        runId\n      });\n      return;\n    }\n    await this.persistWorkflowSnapshot();\n    return storage.loadWorkflowSnapshot({\n      runId,\n      workflowName: this.name\n    });\n  }\n  async _resume({\n    stepId,\n    context: resumeContext,\n    runtimeContext\n  }) {\n    const snapshot = await this.#loadWorkflowSnapshot(this.runId);\n    if (!snapshot) {\n      throw new Error(`No snapshot found for workflow run ${this.runId}`);\n    }\n    const stepParts = stepId.split(\".\");\n    const stepPath = stepParts.join(\".\");\n    if (stepParts.length > 1) {\n      stepId = stepParts[0] ?? stepId;\n    }\n    let parsedSnapshot;\n    try {\n      parsedSnapshot = typeof snapshot === \"string\" ? JSON.parse(snapshot) : snapshot;\n    } catch (error) {\n      this.logger.debug(\"Failed to parse workflow snapshot for resume\", {\n        error,\n        runId: this.runId\n      });\n      throw new Error(\"Failed to parse workflow snapshot\");\n    }\n    const startStepId = parsedSnapshot.suspendedSteps?.[stepId];\n    if (!startStepId) {\n      return;\n    }\n    parsedSnapshot = startStepId === \"trigger\" ? parsedSnapshot : {\n      ...parsedSnapshot?.childStates?.[startStepId],\n      ...{\n        suspendedSteps: parsedSnapshot.suspendedSteps\n      }\n    };\n    if (!parsedSnapshot) {\n      throw new Error(`No snapshot found for step: ${stepId} starting at ${startStepId}`);\n    }\n    if (resumeContext) {\n      parsedSnapshot.context.steps[stepId] = {\n        status: \"success\",\n        output: {\n          ...(parsedSnapshot?.context?.steps?.[stepId]?.output || {}),\n          ...resumeContext\n        }\n      };\n    }\n    if (parsedSnapshot.children) {\n      Object.entries(parsedSnapshot.children).forEach(([, child]) => {\n        if (child.snapshot?.input?.stepNode) {\n          const stepDef = this.#makeStepDef(child.snapshot.input.stepNode.step.id);\n          child.snapshot.input.stepNode.config = {\n            ...child.snapshot.input.stepNode.config,\n            ...stepDef\n          };\n          child.snapshot.input.context = parsedSnapshot.context;\n        }\n      });\n    }\n    parsedSnapshot.value = updateStepInHierarchy(parsedSnapshot.value, stepId);\n    if (parsedSnapshot.context?.attempts) {\n      parsedSnapshot.context.attempts[stepId] = this.#steps[stepId]?.step?.retryConfig?.attempts || this.#retryConfig?.attempts || 0;\n    }\n    this.logger.debug(\"Resuming workflow with updated snapshot\", {\n      updatedSnapshot: parsedSnapshot,\n      runId: this.runId,\n      stepId\n    });\n    return this.execute({\n      snapshot: parsedSnapshot,\n      stepId: stepPath,\n      resumeData: resumeContext,\n      runtimeContext\n    });\n  }\n  #initializeCompoundDependencies() {\n    Object.keys(this.#stepSubscriberGraph).forEach(stepKey => {\n      if (this.#isCompoundKey(stepKey)) {\n        const requiredSteps = stepKey.split(\"&&\");\n        this.#compoundDependencies[stepKey] = requiredSteps.reduce((acc, step) => {\n          acc[step] = false;\n          return acc;\n        }, {});\n      }\n    });\n  }\n  #resetCompoundDependency(key) {\n    if (this.#isCompoundKey(key)) {\n      const requiredSteps = key.split(\"&&\");\n      this.#compoundDependencies[key] = requiredSteps.reduce((acc, step) => {\n        acc[step] = false;\n        return acc;\n      }, {});\n    }\n  }\n  #makeStepDef(stepId) {\n    const executeStep = (handler2, spanName, attributes) => {\n      return async data => {\n        return await context.with(trace.setSpan(context.active(), this.#executionSpan), async () => {\n          if (this.#mastra?.getTelemetry()) {\n            return this.#mastra.getTelemetry()?.traceMethod(handler2, {\n              spanName,\n              attributes\n            })(data);\n          } else {\n            return handler2(data);\n          }\n        });\n      };\n    };\n    const handler = async ({\n      context,\n      ...rest\n    }) => {\n      const targetStep = this.#steps[stepId];\n      if (!targetStep) throw new Error(`Step not found`);\n      const {\n        payload = {},\n        execute = async () => {}\n      } = targetStep.step;\n      const mergedData = {\n        ...payload,\n        ...context\n      };\n      const finalAction = this.#mastra?.getTelemetry() ? executeStep(execute, `workflow.${this.name}.action.${stepId}`, {\n        componentName: this.name,\n        runId: rest.runId\n      }) : execute;\n      return finalAction ? await finalAction({\n        context: mergedData,\n        ...rest\n      }) : {};\n    };\n    const finalHandler = ({\n      context,\n      ...rest\n    }) => {\n      if (this.#executionSpan) {\n        return executeStep(handler, `workflow.${this.name}.step.${stepId}`, {\n          componentName: this.name,\n          runId: rest?.runId\n        })({\n          context,\n          ...rest\n        });\n      }\n      return handler({\n        context,\n        ...rest\n      });\n    };\n    return {\n      handler: finalHandler,\n      data: {}\n    };\n  }\n  #isCompoundKey(key) {\n    return key.includes(\"&&\");\n  }\n};\n\n// src/workflows/legacy/workflow.ts\nvar LegacyWorkflow = class extends MastraBase {\n  name;\n  triggerSchema;\n  resultSchema;\n  resultMapping;\n  events;\n  #retryConfig;\n  #mastra;\n  #runs = /* @__PURE__ */new Map();\n  isNested = false;\n  #onStepTransition = /* @__PURE__ */new Set();\n  // registers stepIds on `after` calls\n  #afterStepStack = [];\n  #lastStepStack = [];\n  #lastBuilderType = null;\n  #ifStack = [];\n  #stepGraph = {\n    initial: []\n  };\n  #serializedStepGraph = {\n    initial: []\n  };\n  #stepSubscriberGraph = {};\n  #serializedStepSubscriberGraph = {};\n  #steps = {};\n  #ifCount = 0;\n  /**\n   * Creates a new LegacyWorkflow instance\n   * @param name - Identifier for the workflow (not necessarily unique)\n   * @param logger - Optional logger instance\n   */\n  constructor({\n    name,\n    triggerSchema,\n    result,\n    retryConfig,\n    mastra,\n    events\n  }) {\n    super({\n      component: \"WORKFLOW\",\n      name\n    });\n    this.name = name;\n    this.#retryConfig = retryConfig;\n    this.triggerSchema = triggerSchema;\n    this.resultSchema = result?.schema;\n    this.resultMapping = result?.mapping;\n    this.events = events;\n    if (mastra) {\n      this.__registerPrimitives({\n        telemetry: mastra.getTelemetry(),\n        logger: mastra.getLogger()\n      });\n      this.#mastra = mastra;\n    }\n  }\n  step(next, config) {\n    const that = this;\n    if (Array.isArray(next)) {\n      const nextSteps = next.map(step2 => {\n        if (isWorkflow(step2)) {\n          const asStep = step2.toStep();\n          return asStep;\n        } else if (isAgent(step2)) {\n          return agentToStep(step2);\n        } else {\n          return step2;\n        }\n      });\n      nextSteps.forEach(step2 => this.step(step2, config));\n      this.after(nextSteps);\n      this.step(new LegacyStep({\n        id: `__after_${next.map(step2 => config?.id ?? step2?.id ?? step2?.name).join(\"_\")}`,\n        execute: async () => {\n          return {\n            success: true\n          };\n        }\n      }));\n      return this;\n    }\n    const {\n      variables = {}\n    } = config || {};\n    const requiredData = {};\n    for (const [key, variable] of Object.entries(variables)) {\n      if (variable && isVariableReference(variable)) {\n        requiredData[key] = variable;\n      }\n    }\n    const step = isWorkflow(next) ?\n    // @ts-ignore\n    workflowToStep(next, {\n      mastra: this.#mastra\n    }) : isAgent(next) ?\n    // @ts-ignore\n    agentToStep(next, {\n      mastra: this.#mastra\n    }) : next;\n    const stepKey = this.#makeStepKey(step, config);\n    const when = config?.[\"#internal\"]?.when || config?.when;\n    const graphEntry = {\n      step,\n      config: {\n        ...this.#makeStepDef(stepKey),\n        ...config,\n        loopLabel: config?.[\"#internal\"]?.loopLabel,\n        loopType: config?.[\"#internal\"]?.loopType,\n        serializedWhen: typeof when === \"function\" ? when.toString() : when,\n        data: requiredData\n      },\n      get id() {\n        return that.#makeStepKey(this.step, this.config);\n      }\n    };\n    this.#steps[stepKey] = graphEntry;\n    const parentStepKey = this.#getParentStepKey({\n      loop_check: true\n    });\n    const stepGraph = this.#stepSubscriberGraph[parentStepKey || \"\"];\n    const serializedStepGraph = this.#serializedStepSubscriberGraph[parentStepKey || \"\"];\n    if (parentStepKey && stepGraph) {\n      if (!stepGraph.initial.some(step2 => step2.config.id === stepKey || step2.step.id === stepKey)) {\n        stepGraph.initial.push(graphEntry);\n        if (serializedStepGraph) serializedStepGraph.initial.push(graphEntry);\n      }\n      stepGraph[stepKey] = [];\n      if (serializedStepGraph) serializedStepGraph[stepKey] = [];\n    } else {\n      if (!this.#stepGraph[stepKey]) this.#stepGraph[stepKey] = [];\n      this.#stepGraph.initial.push(graphEntry);\n      this.#serializedStepGraph.initial.push(graphEntry);\n    }\n    this.#lastStepStack.push(stepKey);\n    this.#lastBuilderType = \"step\";\n    return this;\n  }\n  #__internalStep(next, config, internalUse) {\n    const that = this;\n    if (Array.isArray(next)) {\n      const nextSteps = next.map(step2 => {\n        if (isWorkflow(step2)) {\n          const asStep = step2.toStep();\n          return asStep;\n        } else {\n          return step2;\n        }\n      });\n      nextSteps.forEach(step2 => this.#__internalStep(step2, config, internalUse));\n      this.after(nextSteps);\n      this.#__internalStep(new LegacyStep({\n        id: `__after_${next.map(step2 => step2?.id ?? step2?.name).join(\"_\")}`,\n        execute: async () => {\n          return {\n            success: true\n          };\n        }\n      }), void 0, internalUse);\n      return this;\n    }\n    const {\n      variables = {}\n    } = config || {};\n    const requiredData = {};\n    for (const [key, variable] of Object.entries(variables)) {\n      if (variable && isVariableReference(variable)) {\n        requiredData[key] = variable;\n      }\n    }\n    const step = isWorkflow(next) ?\n    // @ts-ignore\n    workflowToStep(next, {\n      mastra: this.#mastra\n    }) : next;\n    const stepKey = this.#makeStepKey(step, config);\n    const when = config?.[\"#internal\"]?.when || config?.when;\n    const graphEntry = {\n      step,\n      config: {\n        ...this.#makeStepDef(stepKey),\n        ...config,\n        loopLabel: config?.[\"#internal\"]?.loopLabel,\n        loopType: config?.[\"#internal\"]?.loopType,\n        serializedWhen: typeof when === \"function\" ? when.toString() : when,\n        data: requiredData\n      },\n      get id() {\n        return that.#makeStepKey(this.step, this.config);\n      }\n    };\n    this.#steps[stepKey] = graphEntry;\n    const parentStepKey = this.#getParentStepKey();\n    const stepGraph = this.#stepSubscriberGraph[parentStepKey || \"\"];\n    const serializedStepGraph = this.#serializedStepSubscriberGraph[parentStepKey || \"\"];\n    if (parentStepKey && stepGraph) {\n      if (!stepGraph.initial.some(step2 => step2.step.id === stepKey)) {\n        stepGraph.initial.push(graphEntry);\n        if (serializedStepGraph) serializedStepGraph.initial.push(graphEntry);\n      }\n      stepGraph[stepKey] = [];\n      if (serializedStepGraph) serializedStepGraph[stepKey] = [];\n    } else {\n      if (!this.#stepGraph[stepKey]) this.#stepGraph[stepKey] = [];\n      this.#stepGraph.initial.push(graphEntry);\n      this.#serializedStepGraph.initial.push(graphEntry);\n    }\n    this.#lastStepStack.push(stepKey);\n    this.#lastBuilderType = \"step\";\n    return this;\n  }\n  #makeStepKey(step, config) {\n    if (typeof step === \"string\") return step;\n    return `${config?.id ?? step.id ?? step.name}`;\n  }\n  then(next, config) {\n    const that = this;\n    if (Array.isArray(next)) {\n      const lastStep = this.#steps[this.#lastStepStack[this.#lastStepStack.length - 1] ?? \"\"];\n      if (!lastStep) {\n        throw new Error(\"Condition requires a step to be executed after\");\n      }\n      this.after(lastStep.step);\n      const nextSteps = next.map(step2 => {\n        if (isWorkflow(step2)) {\n          return workflowToStep(step2, {\n            mastra: this.#mastra\n          });\n        }\n        if (isAgent(step2)) {\n          return agentToStep(step2);\n        }\n        return step2;\n      });\n      nextSteps.forEach(step2 => this.step(step2, config));\n      this.step(new LegacyStep({\n        // @ts-ignore\n        id: `__after_${next.map(step2 => step2?.id ?? step2?.name).join(\"_\")}`,\n        execute: async () => {\n          return {\n            success: true\n          };\n        }\n      }));\n      return this;\n    }\n    const {\n      variables = {}\n    } = config || {};\n    const requiredData = {};\n    for (const [key, variable] of Object.entries(variables)) {\n      if (variable && isVariableReference(variable)) {\n        requiredData[key] = variable;\n      }\n    }\n    const lastStepKey = this.#lastStepStack[this.#lastStepStack.length - 1];\n    const step = isWorkflow(next) ? workflowToStep(next, {\n      mastra: this.#mastra\n    }) : isAgent(next) ? agentToStep(next) : next;\n    const stepKey = this.#makeStepKey(step, config);\n    const when = config?.[\"#internal\"]?.when || config?.when;\n    const graphEntry = {\n      step,\n      config: {\n        ...this.#makeStepDef(stepKey),\n        ...config,\n        loopLabel: config?.[\"#internal\"]?.loopLabel,\n        loopType: config?.[\"#internal\"]?.loopType,\n        serializedWhen: typeof when === \"function\" ? when.toString() : when,\n        data: requiredData\n      },\n      get id() {\n        return that.#makeStepKey(this.step, this.config);\n      }\n    };\n    this.#steps[stepKey] = graphEntry;\n    if (!lastStepKey) return this;\n    const parentStepKey = this.#getParentStepKey();\n    const stepGraph = this.#stepSubscriberGraph[parentStepKey || \"\"];\n    const serializedStepGraph = this.#serializedStepSubscriberGraph[parentStepKey || \"\"];\n    if (parentStepKey && this.#lastBuilderType === \"after\") {\n      return this.step(step, config);\n    }\n    if (parentStepKey && stepGraph && stepGraph[lastStepKey]) {\n      stepGraph[lastStepKey].push(graphEntry);\n      if (serializedStepGraph && serializedStepGraph[lastStepKey]) serializedStepGraph[lastStepKey].push(graphEntry);\n    } else {\n      if (!this.#stepGraph[lastStepKey]) this.#stepGraph[lastStepKey] = [];\n      if (!this.#serializedStepGraph[lastStepKey]) this.#serializedStepGraph[lastStepKey] = [];\n      this.#stepGraph[lastStepKey].push(graphEntry);\n      this.#serializedStepGraph[lastStepKey].push(graphEntry);\n    }\n    this.#lastBuilderType = \"then\";\n    return this;\n  }\n  loop(applyOperator, condition, fallbackStep, loopType, variables) {\n    const lastStepKey = this.#lastStepStack[this.#lastStepStack.length - 1];\n    if (!lastStepKey) return this;\n    const fallbackStepKey = this.#makeStepKey(fallbackStep);\n    const fallbackStepNode = {\n      step: fallbackStep,\n      config: {\n        ...this.#makeStepDef(fallbackStepKey)\n      },\n      get id() {\n        return fallbackStepKey;\n      }\n    };\n    this.#steps[fallbackStepKey] = fallbackStepNode;\n    const checkStepKey = `__${fallbackStepKey}_${loopType}_loop_check`;\n    const checkStep = {\n      id: checkStepKey,\n      execute: async ({\n        context\n      }) => {\n        if (typeof condition === \"function\") {\n          const result = await condition({\n            context\n          });\n          switch (loopType) {\n            case \"while\":\n              return {\n                status: result ? \"continue\" : \"complete\"\n              };\n            case \"until\":\n              return {\n                status: result ? \"complete\" : \"continue\"\n              };\n            default:\n              throw new Error(`Invalid loop type: ${loopType}`);\n          }\n        }\n        if (condition && \"ref\" in condition) {\n          const {\n            ref,\n            query\n          } = condition;\n          const stepId = typeof ref.step === \"string\" ? ref.step : \"id\" in ref.step ? ref.step.id : null;\n          if (!stepId) {\n            return {\n              status: \"continue\"\n            };\n          }\n          const stepOutput = context.steps?.[stepId]?.output;\n          if (!stepOutput) {\n            return {\n              status: \"continue\"\n            };\n          }\n          const value = ref.path.split(\".\").reduce((obj, key) => obj?.[key], stepOutput);\n          const operator = Object.keys(query)[0];\n          const target = query[operator];\n          return applyOperator(operator, value, target);\n        }\n        return {\n          status: \"continue\"\n        };\n      },\n      outputSchema: z.object({\n        status: z.enum([\"continue\", \"complete\"])\n      })\n    };\n    const checkStepNode = {\n      step: checkStep,\n      config: {\n        ...this.#makeStepDef(checkStepKey)\n      },\n      get id() {\n        return checkStepKey;\n      }\n    };\n    this.#steps[checkStepKey] = checkStepNode;\n    const loopFinishedStepKey = `__${fallbackStepKey}_${loopType}_loop_finished`;\n    const loopFinishedStep = {\n      id: loopFinishedStepKey,\n      execute: async () => {\n        return {\n          success: true\n        };\n      }\n    };\n    const loopFinishedStepNode = {\n      step: loopFinishedStep,\n      config: {\n        ...this.#makeStepDef(loopFinishedStepKey)\n      },\n      get id() {\n        return loopFinishedStepKey;\n      }\n    };\n    this.#steps[loopFinishedStepKey] = loopFinishedStepNode;\n    this.then(checkStep, {\n      id: checkStepKey,\n      \"#internal\": {\n        loopLabel: `${fallbackStepKey} ${loopType} loop check`\n      }\n    });\n    this.after(checkStep);\n    this.#__internalStep(fallbackStep, {\n      when: async ({\n        context\n      }) => {\n        const checkStepResult = context.steps?.[checkStepKey];\n        if (checkStepResult?.status !== \"success\") {\n          return \"abort\" /* ABORT */;\n        }\n        const status = checkStepResult?.output?.status;\n        return status === \"continue\" ? \"continue\" /* CONTINUE */ : \"continue_failed\" /* CONTINUE_FAILED */;\n      },\n      variables,\n      \"#internal\": {\n        // @ts-ignore\n        when: condition,\n        loopType\n      }\n    }).then(checkStep, {\n      id: checkStepKey,\n      \"#internal\": {\n        loopLabel: `${fallbackStepKey} ${loopType} loop check`\n      }\n    });\n    this.#__internalStep(loopFinishedStep, {\n      id: loopFinishedStepKey,\n      when: async ({\n        context\n      }) => {\n        const checkStepResult = context.steps?.[checkStepKey];\n        if (checkStepResult?.status !== \"success\") {\n          return \"continue_failed\" /* CONTINUE_FAILED */;\n        }\n        const status = checkStepResult?.output?.status;\n        return status === \"complete\" ? \"continue\" /* CONTINUE */ : \"continue_failed\" /* CONTINUE_FAILED */;\n      },\n      \"#internal\": {\n        loopLabel: `${fallbackStepKey} ${loopType} loop finished`,\n        //@ts-ignore\n        loopType\n      }\n    });\n    return this;\n  }\n  while(condition, fallbackStep, variables) {\n    const applyOperator = (operator, value, target) => {\n      switch (operator) {\n        case \"$eq\":\n          return {\n            status: value !== target ? \"complete\" : \"continue\"\n          };\n        case \"$ne\":\n          return {\n            status: value === target ? \"complete\" : \"continue\"\n          };\n        case \"$gt\":\n          return {\n            status: value <= target ? \"complete\" : \"continue\"\n          };\n        case \"$gte\":\n          return {\n            status: value < target ? \"complete\" : \"continue\"\n          };\n        case \"$lt\":\n          return {\n            status: value >= target ? \"complete\" : \"continue\"\n          };\n        case \"$lte\":\n          return {\n            status: value > target ? \"complete\" : \"continue\"\n          };\n        default:\n          return {\n            status: \"continue\"\n          };\n      }\n    };\n    const res = this.loop(applyOperator, condition, fallbackStep, \"while\", variables);\n    this.#lastBuilderType = \"while\";\n    return res;\n  }\n  until(condition, fallbackStep, variables) {\n    const applyOperator = (operator, value, target) => {\n      switch (operator) {\n        case \"$eq\":\n          return {\n            status: value === target ? \"complete\" : \"continue\"\n          };\n        case \"$ne\":\n          return {\n            status: value !== target ? \"complete\" : \"continue\"\n          };\n        case \"$gt\":\n          return {\n            status: value > target ? \"complete\" : \"continue\"\n          };\n        case \"$gte\":\n          return {\n            status: value >= target ? \"complete\" : \"continue\"\n          };\n        case \"$lt\":\n          return {\n            status: value < target ? \"complete\" : \"continue\"\n          };\n        case \"$lte\":\n          return {\n            status: value <= target ? \"complete\" : \"continue\"\n          };\n        default:\n          return {\n            status: \"continue\"\n          };\n      }\n    };\n    const res = this.loop(applyOperator, condition, fallbackStep, \"until\", variables);\n    this.#lastBuilderType = \"until\";\n    return res;\n  }\n  if(condition, ifStep, elseStep) {\n    this.#ifCount++;\n    const lastStep = this.#getLastStep({\n      if_else_check: this.#lastBuilderType !== \"else\"\n    });\n    if (!lastStep) {\n      throw new Error(\"Condition requires a step to be executed after\");\n    }\n    this.after(lastStep.step);\n    if (ifStep) {\n      const _ifStep = isWorkflow(ifStep) ? workflowToStep(ifStep, {\n        mastra: this.#mastra\n      }) : ifStep;\n      this.step(_ifStep, {\n        id: _ifStep.id,\n        when: condition\n      });\n      if (elseStep) {\n        const _elseStep = isWorkflow(elseStep) ? workflowToStep(elseStep, {\n          mastra: this.#mastra\n        }) : elseStep;\n        this.step(_elseStep, {\n          id: _elseStep.id,\n          when: typeof condition === \"function\" ? async payload => {\n            const result = await condition(payload);\n            return !result;\n          } : {\n            not: condition\n          }\n        });\n        this.after([_ifStep, _elseStep]);\n      } else {\n        this.after(_ifStep);\n      }\n      this.step(new LegacyStep({\n        id: `${lastStep.id}_if_else`,\n        execute: async () => {\n          return {\n            executed: true\n          };\n        }\n      }));\n      return this;\n    }\n    const ifStepKey = `__${lastStep.id}_if_${this.#ifCount}`;\n    this.step({\n      id: ifStepKey,\n      execute: async () => {\n        return {\n          executed: true\n        };\n      }\n    }, {\n      id: ifStepKey,\n      when: condition\n    });\n    const elseStepKey = `__${lastStep.id}_else_${this.#ifCount}`;\n    this.#ifStack.push({\n      condition,\n      elseStepKey,\n      condStep: lastStep.step\n    });\n    this.#lastBuilderType = \"if\";\n    return this;\n  }\n  else() {\n    const activeCondition = this.#ifStack.pop();\n    if (!activeCondition) {\n      throw new Error(\"No active condition found\");\n    }\n    this.after(activeCondition.condStep).step({\n      id: activeCondition.elseStepKey,\n      execute: async () => {\n        return {\n          executed: true\n        };\n      }\n    }, {\n      id: activeCondition.elseStepKey,\n      when: typeof activeCondition.condition === \"function\" ? async payload => {\n        const result = await activeCondition.condition(payload);\n        return !result;\n      } : {\n        not: activeCondition.condition\n      }\n    });\n    this.#lastBuilderType = \"else\";\n    return this;\n  }\n  after(steps) {\n    const stepsArray = Array.isArray(steps) ? steps : [steps];\n    const stepKeys = stepsArray.map(step => this.#makeStepKey(step));\n    const compoundKey = stepKeys.join(\"&&\");\n    this.#afterStepStack.push(compoundKey);\n    if (!this.#stepSubscriberGraph[compoundKey]) {\n      this.#stepSubscriberGraph[compoundKey] = {\n        initial: []\n      };\n      this.#serializedStepSubscriberGraph[compoundKey] = {\n        initial: []\n      };\n    }\n    this.#lastBuilderType = \"after\";\n    return this;\n  }\n  afterEvent(eventName) {\n    const event = this.events?.[eventName];\n    if (!event) {\n      throw new Error(`Event ${eventName} not found`);\n    }\n    const lastStep = this.#steps[this.#lastStepStack[this.#lastStepStack.length - 1] ?? \"\"];\n    if (!lastStep) {\n      throw new Error(\"Condition requires a step to be executed after\");\n    }\n    const eventStepKey = `__${eventName}_event`;\n    const eventStep = new LegacyStep({\n      id: eventStepKey,\n      execute: async ({\n        context,\n        suspend\n      }) => {\n        if (context.inputData?.resumedEvent) {\n          return {\n            executed: true,\n            resumedEvent: context.inputData?.resumedEvent\n          };\n        }\n        await suspend();\n        return {\n          executed: false\n        };\n      }\n    });\n    this.after(lastStep.step).step(eventStep).after(eventStep);\n    this.#lastBuilderType = \"afterEvent\";\n    return this;\n  }\n  /**\n   * Executes the workflow with the given trigger data\n   * @param triggerData - Initial data to start the workflow with\n   * @returns Promise resolving to workflow results or rejecting with error\n   * @throws Error if trigger schema validation fails\n   */\n  createRun({\n    runId,\n    events\n  } = {}) {\n    const run = new WorkflowInstance({\n      logger: this.logger,\n      name: this.name,\n      mastra: this.#mastra,\n      retryConfig: this.#retryConfig,\n      steps: this.#steps,\n      runId,\n      stepGraph: this.#stepGraph,\n      stepSubscriberGraph: this.#stepSubscriberGraph,\n      onStepTransition: this.#onStepTransition,\n      resultMapping: this.resultMapping,\n      onFinish: () => {\n        this.#runs.delete(run.runId);\n      },\n      events\n    });\n    this.#runs.set(run.runId, run);\n    return {\n      start: run.start.bind(run),\n      runId: run.runId,\n      watch: run.watch.bind(run),\n      resume: run.resume.bind(run),\n      resumeWithEvent: run.resumeWithEvent.bind(run)\n    };\n  }\n  /**\n   * Gets a workflow run instance by ID\n   * @param runId - ID of the run to retrieve\n   * @returns The workflow run instance if found, undefined otherwise\n   */\n  async getRun(runId) {\n    const inMemoryRun = this.#runs.get(runId);\n    if (inMemoryRun) {\n      return inMemoryRun;\n    }\n    const storage = this.#mastra?.getStorage();\n    if (!storage) {\n      this.logger.debug(\"Cannot get workflow run. Mastra engine is not initialized\");\n      return null;\n    }\n    return await storage.getWorkflowRunById({\n      runId,\n      workflowName: this.name\n    });\n  }\n  /**\n   * Gets a workflow run instance by ID, from memory\n   * @param runId - ID of the run to retrieve\n   * @returns The workflow run instance if found, undefined otherwise\n   */\n  getMemoryRun(runId) {\n    return this.#runs.get(runId);\n  }\n  /**\n   * Rebuilds the machine with the current steps configuration and validates the workflow\n   *\n   * This is the last step of a workflow builder method chain\n   * @throws Error if validation fails\n   *\n   * @returns this instance for method chaining\n   */\n  commit() {\n    return this;\n  }\n  // record all object paths that leads to a suspended state\n  #getSuspendedPaths({\n    value,\n    path,\n    suspendedPaths\n  }) {\n    if (typeof value === \"string\") {\n      if (value === \"suspended\") {\n        suspendedPaths.add(path);\n      }\n    } else {\n      Object.keys(value).forEach(key => this.#getSuspendedPaths({\n        value: value[key],\n        path: path ? `${path}.${key}` : key,\n        suspendedPaths\n      }));\n    }\n  }\n  async getWorkflowRuns(args) {\n    const storage = this.#mastra?.getStorage();\n    if (!storage) {\n      this.logger.debug(\"Cannot get workflow runs. Mastra engine is not initialized\");\n      return {\n        runs: [],\n        total: 0\n      };\n    }\n    return storage.getWorkflowRuns({\n      workflowName: this.name,\n      ...(args ?? {})\n    });\n  }\n  getExecutionSpan(runId) {\n    return this.#runs.get(runId)?.executionSpan;\n  }\n  #getParentStepKey({\n    loop_check = false,\n    if_else_check = false\n  } = {}) {\n    for (let i = this.#afterStepStack.length - 1; i >= 0; i--) {\n      const stepKey = this.#afterStepStack[i];\n      if (!stepKey) continue;\n      const isValidStep = this.#stepSubscriberGraph[stepKey] && (!loop_check || !stepKey.includes(\"loop_check\")) && (!if_else_check || !isConditionalKey(stepKey));\n      if (isValidStep) {\n        return stepKey;\n      }\n    }\n    return void 0;\n  }\n  #getLastStep({\n    if_else_check\n  }) {\n    for (let i = this.#lastStepStack.length - 1; i >= 0; i--) {\n      const stepKey = this.#lastStepStack[i];\n      if (!stepKey) continue;\n      const step = this.#steps[stepKey];\n      const isInvalidStep = !step || if_else_check && isConditionalKey(stepKey);\n      if (isInvalidStep) continue;\n      return step;\n    }\n    return void 0;\n  }\n  #makeStepDef(stepId) {\n    const executeStep = (handler2, spanName, attributes) => {\n      return async data => {\n        return await context.with(trace.setSpan(context.active(), this.getExecutionSpan(attributes?.runId ?? data?.runId)), async () => {\n          if (this?.telemetry) {\n            return this.telemetry.traceMethod(handler2, {\n              spanName,\n              attributes\n            })(data);\n          } else {\n            return handler2(data);\n          }\n        });\n      };\n    };\n    const handler = async ({\n      context,\n      ...rest\n    }) => {\n      const targetStep = this.#steps[stepId];\n      if (!targetStep) throw new Error(`Step not found`);\n      const {\n        payload = {},\n        execute = async () => {}\n      } = targetStep.step;\n      const finalAction = this.telemetry ? executeStep(execute, `workflow.${this.name}.action.${stepId}`, {\n        componentName: this.name,\n        runId: rest.runId\n      }) : execute;\n      return finalAction ? await finalAction({\n        context: {\n          ...context,\n          inputData: {\n            ...(context?.inputData || {}),\n            ...payload\n          }\n        },\n        ...rest\n      }) : {};\n    };\n    const finalHandler = ({\n      context,\n      ...rest\n    }) => {\n      if (this.getExecutionSpan(rest?.runId)) {\n        return executeStep(handler, `workflow.${this.name}.step.${stepId}`, {\n          componentName: this.name,\n          runId: rest?.runId\n        })({\n          context,\n          ...rest\n        });\n      }\n      return handler({\n        context,\n        ...rest\n      });\n    };\n    return {\n      handler: finalHandler,\n      data: {}\n    };\n  }\n  #getActivePathsAndStatus(value) {\n    const paths = [];\n    const traverse = (current, path = []) => {\n      for (const [key, value2] of Object.entries(current)) {\n        const currentPath = [...path, key];\n        if (typeof value2 === \"string\") {\n          paths.push({\n            stepPath: currentPath,\n            stepId: key,\n            status: value2\n          });\n        } else if (typeof value2 === \"object\" && value2 !== null) {\n          traverse(value2, currentPath);\n        }\n      }\n    };\n    traverse(value);\n    return paths;\n  }\n  async getState(runId) {\n    const run = this.#runs.get(runId);\n    if (run) {\n      return run.getState();\n    }\n    const storage = this.#mastra?.getStorage();\n    const storedSnapshot = await storage?.loadWorkflowSnapshot({\n      runId,\n      workflowName: this.name\n    });\n    if (storedSnapshot) {\n      const parsed = storedSnapshot;\n      const m = this.#getActivePathsAndStatus(parsed.value);\n      return {\n        runId,\n        value: parsed.value,\n        context: parsed.context,\n        activePaths: m,\n        timestamp: Date.now()\n      };\n    }\n    return null;\n  }\n  async resume({\n    runId,\n    stepId,\n    context: resumeContext,\n    runtimeContext = new RuntimeContext()\n  }) {\n    this.logger.warn(`Please use 'resume' on the 'createRun' call instead, resume is deprecated`);\n    const activeRun = this.#runs.get(runId);\n    if (activeRun) {\n      return activeRun.resume({\n        stepId,\n        context: resumeContext,\n        runtimeContext\n      });\n    }\n    const run = this.createRun({\n      runId\n    });\n    return run.resume({\n      stepId,\n      context: resumeContext,\n      runtimeContext\n    });\n  }\n  watch(onTransition) {\n    this.logger.warn(`Please use 'watch' on the 'createRun' call instead, watch is deprecated`);\n    this.#onStepTransition.add(onTransition);\n    return () => {\n      this.#onStepTransition.delete(onTransition);\n    };\n  }\n  async resumeWithEvent(runId, eventName, data) {\n    this.logger.warn(`Please use 'resumeWithEvent' on the 'createRun' call instead, resumeWithEvent is deprecated`);\n    const event = this.events?.[eventName];\n    if (!event) {\n      throw new Error(`Event ${eventName} not found`);\n    }\n    const results = await this.resume({\n      runId,\n      stepId: `__${eventName}_event`,\n      context: {\n        resumedEvent: data\n      },\n      runtimeContext: new RuntimeContext()\n    });\n    return results;\n  }\n  __registerMastra(mastra) {\n    this.#mastra = mastra;\n  }\n  __registerPrimitives(p) {\n    if (p.telemetry) {\n      this.__setTelemetry(p.telemetry);\n    }\n    if (p.logger) {\n      this.__setLogger(p.logger);\n    }\n  }\n  get stepGraph() {\n    return this.#stepGraph;\n  }\n  get stepSubscriberGraph() {\n    return this.#stepSubscriberGraph;\n  }\n  get serializedStepGraph() {\n    return this.#serializedStepGraph;\n  }\n  get serializedStepSubscriberGraph() {\n    return this.#serializedStepSubscriberGraph;\n  }\n  get steps() {\n    return Object.entries(this.#steps).reduce((acc, [key, step]) => {\n      acc[key] = step.step;\n      return acc;\n    }, {});\n  }\n  setNested(isNested) {\n    this.isNested = isNested;\n  }\n  toStep() {\n    const x = workflowToStep(this, {\n      mastra: this.#mastra\n    });\n    return new LegacyStep(x);\n  }\n};\n\nexport { Agent, LegacyStep, LegacyWorkflow, WhenConditionReturnValue, agentToStep, getActivePathsAndStatus, getResultActivePaths, getStepResult, getSuspendedPaths, isAgent, isConditionalKey, isErrorEvent, isFinalState, isLimboState, isTransitionEvent, isVariableReference, isWorkflow, mergeChildValue, recursivelyCheckForFinalState, resolveVariables, updateStepInHierarchy, workflowToStep };\n", "import { InstrumentClass } from './chunk-TC2SCOTE.js';\nimport { MastraError } from './chunk-6UNGH46J.js';\nimport { MastraBase } from './chunk-5IEKR756.js';\nimport { __decoratorStart, __decorateElement, __runInitializers } from './chunk-WQNOATKB.js';\n\n// src/voice/voice.ts\nvar _MastraVoice_decorators, _init, _a;\n_MastraVoice_decorators = [InstrumentClass({\n  prefix: \"voice\",\n  excludeMethods: [\"__setTools\", \"__setLogger\", \"__setTelemetry\", \"#log\"]\n})];\nvar MastraVoice = class extends (_a = MastraBase) {\n  listeningModel;\n  speechModel;\n  speaker;\n  realtimeConfig;\n  constructor({\n    listeningModel,\n    speechModel,\n    speaker,\n    realtimeConfig,\n    name\n  } = {}) {\n    super({\n      component: \"VOICE\",\n      name\n    });\n    this.listeningModel = listeningModel;\n    this.speechModel = speechModel;\n    this.speaker = speaker;\n    this.realtimeConfig = realtimeConfig;\n  }\n  traced(method, methodName) {\n    return this.telemetry?.traceMethod(method, {\n      spanName: `voice.${methodName}`,\n      attributes: {\n        \"voice.type\": this.speechModel?.name || this.listeningModel?.name || \"unknown\"\n      }\n    }) ?? method;\n  }\n  updateConfig(_options) {\n    this.logger.warn(\"updateConfig not implemented by this voice provider\");\n  }\n  /**\n   * Initializes a WebSocket or WebRTC connection for real-time communication\n   * @returns Promise that resolves when the connection is established\n   */\n  connect(_options) {\n    this.logger.warn(\"connect not implemented by this voice provider\");\n    return Promise.resolve();\n  }\n  /**\n   * Relay audio data to the voice provider for real-time processing\n   * @param audioData Audio data to relay\n   */\n  send(_audioData) {\n    this.logger.warn(\"relay not implemented by this voice provider\");\n    return Promise.resolve();\n  }\n  /**\n   * Trigger voice providers to respond\n   */\n  answer(_options) {\n    this.logger.warn(\"answer not implemented by this voice provider\");\n    return Promise.resolve();\n  }\n  /**\n   * Equip the voice provider with instructions\n   * @param instructions Instructions to add\n   */\n  addInstructions(_instructions) {}\n  /**\n   * Equip the voice provider with tools\n   * @param tools Array of tools to add\n   */\n  addTools(_tools) {}\n  /**\n   * Disconnect from the WebSocket or WebRTC connection\n   */\n  close() {\n    this.logger.warn(\"close not implemented by this voice provider\");\n  }\n  /**\n   * Register an event listener\n   * @param event Event name (e.g., 'speaking', 'writing', 'error')\n   * @param callback Callback function that receives event data\n   */\n  on(_event, _callback) {\n    this.logger.warn(\"on not implemented by this voice provider\");\n  }\n  /**\n   * Remove an event listener\n   * @param event Event name (e.g., 'speaking', 'writing', 'error')\n   * @param callback Callback function to remove\n   */\n  off(_event, _callback) {\n    this.logger.warn(\"off not implemented by this voice provider\");\n  }\n  /**\n   * Get available speakers/voices\n   * @returns Array of available voice IDs and their metadata\n   */\n  getSpeakers() {\n    this.logger.warn(\"getSpeakers not implemented by this voice provider\");\n    return Promise.resolve([]);\n  }\n  /**\n   * Get available speakers/voices\n   * @returns Array of available voice IDs and their metadata\n   */\n  getListener() {\n    this.logger.warn(\"getListener not implemented by this voice provider\");\n    return Promise.resolve({\n      enabled: false\n    });\n  }\n};\nMastraVoice = /*@__PURE__*/(_ => {\n  _init = __decoratorStart(_a);\n  MastraVoice = __decorateElement(_init, 0, \"MastraVoice\", _MastraVoice_decorators, MastraVoice);\n  __runInitializers(_init, 1, MastraVoice);\n\n  // src/voice/composite-voice.ts\n  return MastraVoice;\n})();\n// src/voice/composite-voice.ts\nvar CompositeVoice = class extends MastraVoice {\n  speakProvider;\n  listenProvider;\n  realtimeProvider;\n  constructor({\n    input,\n    output,\n    realtime,\n    speakProvider,\n    listenProvider,\n    realtimeProvider\n  }) {\n    super();\n    this.speakProvider = output || speakProvider;\n    this.listenProvider = input || listenProvider;\n    this.realtimeProvider = realtime || realtimeProvider;\n  }\n  /**\n   * Convert text to speech using the configured provider\n   * @param input Text or text stream to convert to speech\n   * @param options Speech options including speaker and provider-specific options\n   * @returns Audio stream or void if in realtime mode\n   */\n  async speak(input, options) {\n    if (this.realtimeProvider) {\n      return this.realtimeProvider.speak(input, options);\n    } else if (this.speakProvider) {\n      return this.speakProvider.speak(input, options);\n    }\n    throw new MastraError({\n      id: \"VOICE_COMPOSITE_NO_SPEAK_PROVIDER\",\n      text: \"No speak provider or realtime provider configured\",\n      domain: \"MASTRA_VOICE\" /* MASTRA_VOICE */,\n      category: \"USER\" /* USER */\n    });\n  }\n  async listen(audioStream, options) {\n    if (this.realtimeProvider) {\n      return await this.realtimeProvider.listen(audioStream, options);\n    } else if (this.listenProvider) {\n      return await this.listenProvider.listen(audioStream, options);\n    }\n    throw new MastraError({\n      id: \"VOICE_COMPOSITE_NO_LISTEN_PROVIDER\",\n      text: \"No listen provider or realtime provider configured\",\n      domain: \"MASTRA_VOICE\" /* MASTRA_VOICE */,\n      category: \"USER\" /* USER */\n    });\n  }\n  async getSpeakers() {\n    if (this.realtimeProvider) {\n      return this.realtimeProvider.getSpeakers();\n    } else if (this.speakProvider) {\n      return this.speakProvider.getSpeakers();\n    }\n    throw new MastraError({\n      id: \"VOICE_COMPOSITE_NO_SPEAKERS_PROVIDER\",\n      text: \"No speak provider or realtime provider configured\",\n      domain: \"MASTRA_VOICE\" /* MASTRA_VOICE */,\n      category: \"USER\" /* USER */\n    });\n  }\n  async getListener() {\n    if (this.realtimeProvider) {\n      return this.realtimeProvider.getListener();\n    } else if (this.listenProvider) {\n      return this.listenProvider.getListener();\n    }\n    throw new MastraError({\n      id: \"VOICE_COMPOSITE_NO_LISTENER_PROVIDER\",\n      text: \"No listener provider or realtime provider configured\",\n      domain: \"MASTRA_VOICE\" /* MASTRA_VOICE */,\n      category: \"USER\" /* USER */\n    });\n  }\n  updateConfig(options) {\n    if (!this.realtimeProvider) {\n      return;\n    }\n    this.realtimeProvider.updateConfig(options);\n  }\n  /**\n   * Initializes a WebSocket or WebRTC connection for real-time communication\n   * @returns Promise that resolves when the connection is established\n   */\n  connect(options) {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: \"VOICE_COMPOSITE_NO_REALTIME_PROVIDER_CONNECT\",\n        text: \"No realtime provider configured\",\n        domain: \"MASTRA_VOICE\" /* MASTRA_VOICE */,\n        category: \"USER\" /* USER */\n      });\n    }\n    return this.realtimeProvider.connect(options);\n  }\n  /**\n   * Relay audio data to the voice provider for real-time processing\n   * @param audioData Audio data to send\n   */\n  send(audioData) {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: \"VOICE_COMPOSITE_NO_REALTIME_PROVIDER_SEND\",\n        text: \"No realtime provider configured\",\n        domain: \"MASTRA_VOICE\" /* MASTRA_VOICE */,\n        category: \"USER\" /* USER */\n      });\n    }\n    return this.realtimeProvider.send(audioData);\n  }\n  /**\n   * Trigger voice providers to respond\n   */\n  answer(options) {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: \"VOICE_COMPOSITE_NO_REALTIME_PROVIDER_ANSWER\",\n        text: \"No realtime provider configured\",\n        domain: \"MASTRA_VOICE\" /* MASTRA_VOICE */,\n        category: \"USER\" /* USER */\n      });\n    }\n    return this.realtimeProvider.answer(options);\n  }\n  /**\n   * Equip the voice provider with instructions\n   * @param instructions Instructions to add\n   */\n  addInstructions(instructions) {\n    if (!this.realtimeProvider) {\n      return;\n    }\n    this.realtimeProvider.addInstructions(instructions);\n  }\n  /**\n   * Equip the voice provider with tools\n   * @param tools Array of tools to add\n   */\n  addTools(tools) {\n    if (!this.realtimeProvider) {\n      return;\n    }\n    this.realtimeProvider.addTools(tools);\n  }\n  /**\n   * Disconnect from the WebSocket or WebRTC connection\n   */\n  close() {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: \"VOICE_COMPOSITE_NO_REALTIME_PROVIDER_CLOSE\",\n        text: \"No realtime provider configured\",\n        domain: \"MASTRA_VOICE\" /* MASTRA_VOICE */,\n        category: \"USER\" /* USER */\n      });\n    }\n    this.realtimeProvider.close();\n  }\n  /**\n   * Register an event listener\n   * @param event Event name (e.g., 'speaking', 'writing', 'error')\n   * @param callback Callback function that receives event data\n   */\n  on(event, callback) {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: \"VOICE_COMPOSITE_NO_REALTIME_PROVIDER_ON\",\n        text: \"No realtime provider configured\",\n        domain: \"MASTRA_VOICE\" /* MASTRA_VOICE */,\n        category: \"USER\" /* USER */\n      });\n    }\n    this.realtimeProvider.on(event, callback);\n  }\n  /**\n   * Remove an event listener\n   * @param event Event name (e.g., 'speaking', 'writing', 'error')\n   * @param callback Callback function to remove\n   */\n  off(event, callback) {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: \"VOICE_COMPOSITE_NO_REALTIME_PROVIDER_OFF\",\n        text: \"No realtime provider configured\",\n        domain: \"MASTRA_VOICE\" /* MASTRA_VOICE */,\n        category: \"USER\" /* USER */\n      });\n    }\n    this.realtimeProvider.off(event, callback);\n  }\n};\n\n// src/voice/default-voice.ts\nvar DefaultVoice = class extends MastraVoice {\n  constructor() {\n    super();\n  }\n  async speak(_input) {\n    throw new MastraError({\n      id: \"VOICE_DEFAULT_NO_SPEAK_PROVIDER\",\n      text: \"No voice provider configured\",\n      domain: \"MASTRA_VOICE\" /* MASTRA_VOICE */,\n      category: \"USER\" /* USER */\n    });\n  }\n  async listen(_input) {\n    throw new MastraError({\n      id: \"VOICE_DEFAULT_NO_LISTEN_PROVIDER\",\n      text: \"No voice provider configured\",\n      domain: \"MASTRA_VOICE\" /* MASTRA_VOICE */,\n      category: \"USER\" /* USER */\n    });\n  }\n  async getSpeakers() {\n    throw new MastraError({\n      id: \"VOICE_DEFAULT_NO_SPEAKERS_PROVIDER\",\n      text: \"No voice provider configured\",\n      domain: \"MASTRA_VOICE\" /* MASTRA_VOICE */,\n      category: \"USER\" /* USER */\n    });\n  }\n  async getListener() {\n    throw new MastraError({\n      id: \"VOICE_DEFAULT_NO_LISTENER_PROVIDER\",\n      text: \"No voice provider configured\",\n      domain: \"MASTRA_VOICE\" /* MASTRA_VOICE */,\n      category: \"USER\" /* USER */\n    });\n  }\n};\n\nexport { CompositeVoice, DefaultVoice, MastraVoice };\n", "import { MastraError } from './chunk-6UNGH46J.js';\nimport { trace, propagation, context, SpanStatusCode, SpanKind } from '@opentelemetry/api';\nimport { ExportResultCode } from '@opentelemetry/core';\nimport { JsonTraceSerializer } from '@opentelemetry/otlp-transformer';\n\nfunction hasActiveTelemetry(tracerName = \"default-tracer\") {\n  try {\n    return !!trace.getTracer(tracerName);\n  } catch {\n    return false;\n  }\n}\nfunction getBaggageValues(ctx) {\n  const currentBaggage = propagation.getBaggage(ctx);\n  const requestId = currentBaggage?.getEntry(\"http.request_id\")?.value;\n  const componentName = currentBaggage?.getEntry(\"componentName\")?.value;\n  const runId = currentBaggage?.getEntry(\"runId\")?.value;\n  return {\n    requestId,\n    componentName,\n    runId\n  };\n}\n\n// src/telemetry/telemetry.decorators.ts\nfunction withSpan(options) {\n  return function(_target, propertyKey, descriptor) {\n    if (!descriptor || typeof descriptor === \"number\") return;\n    const originalMethod = descriptor.value;\n    const methodName = String(propertyKey);\n    descriptor.value = function(...args) {\n      if (options?.skipIfNoTelemetry && !hasActiveTelemetry(options?.tracerName)) {\n        return originalMethod.apply(this, args);\n      }\n      const tracer = trace.getTracer(options?.tracerName ?? \"default-tracer\");\n      let spanName;\n      let spanKind;\n      if (typeof options === \"string\") {\n        spanName = options;\n      } else if (options) {\n        spanName = options.spanName || methodName;\n        spanKind = options.spanKind;\n      } else {\n        spanName = methodName;\n      }\n      const span = tracer.startSpan(spanName, { kind: spanKind });\n      let ctx = trace.setSpan(context.active(), span);\n      args.forEach((arg, index) => {\n        try {\n          span.setAttribute(`${spanName}.argument.${index}`, JSON.stringify(arg));\n        } catch {\n          span.setAttribute(`${spanName}.argument.${index}`, \"[Not Serializable]\");\n        }\n      });\n      const { requestId, componentName, runId } = getBaggageValues(ctx);\n      if (requestId) {\n        span.setAttribute(\"http.request_id\", requestId);\n      }\n      if (componentName) {\n        span.setAttribute(\"componentName\", componentName);\n        span.setAttribute(\"runId\", runId);\n      } else if (this && this.name) {\n        span.setAttribute(\"componentName\", this.name);\n        span.setAttribute(\"runId\", this.runId);\n        ctx = propagation.setBaggage(\n          ctx,\n          propagation.createBaggage({\n            // @ts-ignore\n            componentName: { value: this.name },\n            // @ts-ignore\n            runId: { value: this.runId },\n            // @ts-ignore\n            \"http.request_id\": { value: requestId }\n          })\n        );\n      }\n      let result;\n      try {\n        result = context.with(ctx, () => originalMethod.apply(this, args));\n        if (result instanceof Promise) {\n          return result.then((resolvedValue) => {\n            try {\n              span.setAttribute(`${spanName}.result`, JSON.stringify(resolvedValue));\n            } catch {\n              span.setAttribute(`${spanName}.result`, \"[Not Serializable]\");\n            }\n            return resolvedValue;\n          }).finally(() => span.end());\n        }\n        try {\n          span.setAttribute(`${spanName}.result`, JSON.stringify(result));\n        } catch {\n          span.setAttribute(`${spanName}.result`, \"[Not Serializable]\");\n        }\n        return result;\n      } catch (error) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: error instanceof Error ? error.message : \"Unknown error\"\n        });\n        if (error instanceof Error) {\n          span.recordException(error);\n        }\n        throw error;\n      } finally {\n        if (!(result instanceof Promise)) {\n          span.end();\n        }\n      }\n    };\n    return descriptor;\n  };\n}\nfunction InstrumentClass(options) {\n  return function(target) {\n    const methods = Object.getOwnPropertyNames(target.prototype);\n    methods.forEach((method) => {\n      if (options?.excludeMethods?.includes(method) || method === \"constructor\") return;\n      if (options?.methodFilter && !options.methodFilter(method)) return;\n      const descriptor = Object.getOwnPropertyDescriptor(target.prototype, method);\n      if (descriptor && typeof descriptor.value === \"function\") {\n        Object.defineProperty(\n          target.prototype,\n          method,\n          withSpan({\n            spanName: options?.prefix ? `${options.prefix}.${method}` : method,\n            skipIfNoTelemetry: true,\n            spanKind: options?.spanKind || SpanKind.INTERNAL,\n            tracerName: options?.tracerName\n          })(target, method, descriptor)\n        );\n      }\n    });\n    return target;\n  };\n}\n\n// src/storage/constants.ts\nvar TABLE_WORKFLOW_SNAPSHOT = \"mastra_workflow_snapshot\";\nvar TABLE_EVALS = \"mastra_evals\";\nvar TABLE_MESSAGES = \"mastra_messages\";\nvar TABLE_THREADS = \"mastra_threads\";\nvar TABLE_TRACES = \"mastra_traces\";\nvar TABLE_RESOURCES = \"mastra_resources\";\nvar TABLE_SCHEMAS = {\n  [TABLE_WORKFLOW_SNAPSHOT]: {\n    workflow_name: {\n      type: \"text\"\n    },\n    run_id: {\n      type: \"text\"\n    },\n    resourceId: { type: \"text\", nullable: true },\n    snapshot: {\n      type: \"text\"\n    },\n    createdAt: {\n      type: \"timestamp\"\n    },\n    updatedAt: {\n      type: \"timestamp\"\n    }\n  },\n  [TABLE_EVALS]: {\n    input: {\n      type: \"text\"\n    },\n    output: {\n      type: \"text\"\n    },\n    result: {\n      type: \"jsonb\"\n    },\n    agent_name: {\n      type: \"text\"\n    },\n    metric_name: {\n      type: \"text\"\n    },\n    instructions: {\n      type: \"text\"\n    },\n    test_info: {\n      type: \"jsonb\",\n      nullable: true\n    },\n    global_run_id: {\n      type: \"text\"\n    },\n    run_id: {\n      type: \"text\"\n    },\n    created_at: {\n      type: \"timestamp\"\n    },\n    createdAt: {\n      type: \"timestamp\",\n      nullable: true\n    }\n  },\n  [TABLE_THREADS]: {\n    id: { type: \"text\", nullable: false, primaryKey: true },\n    resourceId: { type: \"text\", nullable: false },\n    title: { type: \"text\", nullable: false },\n    metadata: { type: \"text\", nullable: true },\n    createdAt: { type: \"timestamp\", nullable: false },\n    updatedAt: { type: \"timestamp\", nullable: false }\n  },\n  [TABLE_MESSAGES]: {\n    id: { type: \"text\", nullable: false, primaryKey: true },\n    thread_id: { type: \"text\", nullable: false },\n    content: { type: \"text\", nullable: false },\n    role: { type: \"text\", nullable: false },\n    type: { type: \"text\", nullable: false },\n    createdAt: { type: \"timestamp\", nullable: false },\n    resourceId: { type: \"text\", nullable: true }\n  },\n  [TABLE_TRACES]: {\n    id: { type: \"text\", nullable: false, primaryKey: true },\n    parentSpanId: { type: \"text\", nullable: true },\n    name: { type: \"text\", nullable: false },\n    traceId: { type: \"text\", nullable: false },\n    scope: { type: \"text\", nullable: false },\n    kind: { type: \"integer\", nullable: false },\n    attributes: { type: \"jsonb\", nullable: true },\n    status: { type: \"jsonb\", nullable: true },\n    events: { type: \"jsonb\", nullable: true },\n    links: { type: \"jsonb\", nullable: true },\n    other: { type: \"text\", nullable: true },\n    startTime: { type: \"bigint\", nullable: false },\n    endTime: { type: \"bigint\", nullable: false },\n    createdAt: { type: \"timestamp\", nullable: false }\n  },\n  [TABLE_RESOURCES]: {\n    id: { type: \"text\", nullable: false, primaryKey: true },\n    workingMemory: { type: \"text\", nullable: true },\n    metadata: { type: \"jsonb\", nullable: true },\n    createdAt: { type: \"timestamp\", nullable: false },\n    updatedAt: { type: \"timestamp\", nullable: false }\n  }\n};\n\n// src/telemetry/storage-exporter.ts\nvar OTLPTraceExporter = class {\n  storage;\n  queue = [];\n  serializer;\n  logger;\n  activeFlush = void 0;\n  constructor({ logger, storage }) {\n    this.storage = storage;\n    this.serializer = JsonTraceSerializer;\n    this.logger = logger;\n  }\n  export(internalRepresentation, resultCallback) {\n    const serializedRequest = this.serializer.serializeRequest(internalRepresentation);\n    const payload = JSON.parse(Buffer.from(serializedRequest.buffer, \"utf8\"));\n    const items = payload?.resourceSpans?.[0]?.scopeSpans;\n    this.logger.debug(`Exporting telemetry: ${items.length} scope spans to be processed [trace batch]`);\n    this.queue.push({ data: items, resultCallback });\n    if (!this.activeFlush) {\n      this.activeFlush = this.flush();\n    }\n  }\n  shutdown() {\n    return this.forceFlush();\n  }\n  flush() {\n    const now = /* @__PURE__ */ new Date();\n    const items = this.queue.shift();\n    if (!items) return Promise.resolve();\n    const allSpans = items.data.reduce((acc, scopedSpans) => {\n      const { scope, spans } = scopedSpans;\n      for (const span of spans) {\n        const {\n          spanId,\n          parentSpanId,\n          traceId,\n          name,\n          kind,\n          attributes,\n          status,\n          events,\n          links,\n          startTimeUnixNano,\n          endTimeUnixNano,\n          ...rest\n        } = span;\n        const startTime = Number(BigInt(startTimeUnixNano) / 1000n);\n        const endTime = Number(BigInt(endTimeUnixNano) / 1000n);\n        acc.push({\n          id: spanId,\n          parentSpanId,\n          traceId,\n          name,\n          scope: scope.name,\n          kind,\n          status: JSON.stringify(status),\n          events: JSON.stringify(events),\n          links: JSON.stringify(links),\n          attributes: JSON.stringify(\n            attributes.reduce((acc2, attr) => {\n              const valueKey = Object.keys(attr.value)[0];\n              if (valueKey) {\n                acc2[attr.key] = attr.value[valueKey];\n              }\n              return acc2;\n            }, {})\n          ),\n          startTime,\n          endTime,\n          other: JSON.stringify(rest),\n          createdAt: now\n        });\n      }\n      return acc;\n    }, []);\n    return this.storage.batchInsert({\n      tableName: TABLE_TRACES,\n      records: allSpans\n    }).then(() => {\n      items.resultCallback({\n        code: ExportResultCode.SUCCESS\n      });\n    }).catch((e) => {\n      const mastraError = new MastraError(\n        {\n          id: \"OTLP_TRACE_EXPORT_FAILURE\",\n          text: \"Failed to export telemetry spans\",\n          domain: \"MASTRA_TELEMETRY\" /* MASTRA_TELEMETRY */,\n          category: \"SYSTEM\" /* SYSTEM */,\n          details: {\n            attemptedSpanCount: allSpans.length,\n            targetTable: TABLE_TRACES,\n            firstSpanName: allSpans.length > 0 ? allSpans[0].name : \"\",\n            firstSpanKind: allSpans.length > 0 ? allSpans[0].kind : \"\",\n            firstSpanScope: allSpans.length > 0 ? allSpans[0].scope : \"\"\n          }\n        },\n        e\n      );\n      this.logger.trackException(mastraError);\n      this.logger.error(\"span err:\" + mastraError.toString());\n      items.resultCallback({\n        code: ExportResultCode.FAILED,\n        error: e\n      });\n    }).finally(() => {\n      this.activeFlush = void 0;\n    });\n  }\n  async forceFlush() {\n    if (!this.queue.length) {\n      return;\n    }\n    await this.activeFlush;\n    while (this.queue.length) {\n      await this.flush();\n    }\n  }\n  __setLogger(logger) {\n    this.logger = logger;\n  }\n};\nvar Telemetry = class _Telemetry {\n  tracer = trace.getTracer(\"default\");\n  name = \"default-service\";\n  constructor(config) {\n    this.name = config.serviceName ?? \"default-service\";\n    this.tracer = trace.getTracer(this.name);\n  }\n  /**\n   * @deprecated This method does not do anything\n   */\n  async shutdown() {\n  }\n  /**\n   * Initialize telemetry with the given configuration\n   * @param config - Optional telemetry configuration object\n   * @returns Telemetry instance that can be used for tracing\n   */\n  static init(config = {}) {\n    try {\n      if (!globalThis.__TELEMETRY__) {\n        globalThis.__TELEMETRY__ = new _Telemetry(config);\n      }\n      return globalThis.__TELEMETRY__;\n    } catch (error) {\n      const wrappedError = new MastraError(\n        {\n          id: \"TELEMETRY_INIT_FAILED\",\n          text: \"Failed to initialize telemetry\",\n          domain: \"MASTRA_TELEMETRY\" /* MASTRA_TELEMETRY */,\n          category: \"SYSTEM\" /* SYSTEM */\n        },\n        error\n      );\n      throw wrappedError;\n    }\n  }\n  static getActiveSpan() {\n    const span = trace.getActiveSpan();\n    return span;\n  }\n  /**\n   * Get the global telemetry instance\n   * @throws {Error} If telemetry has not been initialized\n   * @returns {Telemetry} The global telemetry instance\n   */\n  static get() {\n    if (!globalThis.__TELEMETRY__) {\n      throw new MastraError({\n        id: \"TELEMETRY_GETTER_FAILED_GLOBAL_TELEMETRY_NOT_INITIALIZED\",\n        text: \"Telemetry not initialized\",\n        domain: \"MASTRA_TELEMETRY\" /* MASTRA_TELEMETRY */,\n        category: \"USER\" /* USER */\n      });\n    }\n    return globalThis.__TELEMETRY__;\n  }\n  /**\n   * Wraps a class instance with telemetry tracing\n   * @param instance The class instance to wrap\n   * @param options Optional configuration for tracing\n   * @returns Wrapped instance with all methods traced\n   */\n  traceClass(instance, options = {}) {\n    const { skipIfNoTelemetry = true } = options;\n    if (skipIfNoTelemetry && !hasActiveTelemetry()) {\n      return instance;\n    }\n    const { spanNamePrefix = instance.constructor.name.toLowerCase(), attributes = {}, excludeMethods = [] } = options;\n    return new Proxy(instance, {\n      get: (target, prop) => {\n        const value = target[prop];\n        if (typeof value === \"function\" && prop !== \"constructor\" && !prop.toString().startsWith(\"_\") && !excludeMethods.includes(prop.toString())) {\n          return this.traceMethod(value.bind(target), {\n            spanName: `${spanNamePrefix}.${prop.toString()}`,\n            attributes: {\n              ...attributes,\n              [`${spanNamePrefix}.name`]: target.constructor.name,\n              [`${spanNamePrefix}.method.name`]: prop.toString()\n            }\n          });\n        }\n        return value;\n      }\n    });\n  }\n  static setBaggage(baggage, ctx = context.active()) {\n    const currentBaggage = Object.fromEntries(propagation.getBaggage(ctx)?.getAllEntries() ?? []);\n    const newCtx = propagation.setBaggage(\n      ctx,\n      propagation.createBaggage({\n        ...currentBaggage,\n        ...baggage\n      })\n    );\n    return newCtx;\n  }\n  static withContext(ctx, fn) {\n    return context.with(ctx, fn);\n  }\n  /**\n   * method to trace individual methods with proper context\n   * @param method The method to trace\n   * @param context Additional context for the trace\n   * @returns Wrapped method with tracing\n   */\n  traceMethod(method, context3) {\n    let ctx = context.active();\n    const { skipIfNoTelemetry = true } = context3;\n    if (skipIfNoTelemetry && !hasActiveTelemetry()) {\n      return method;\n    }\n    return (...args) => {\n      const span = this.tracer.startSpan(context3.spanName);\n      function handleError(error) {\n        span.recordException(error);\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: error.message\n        });\n        span.end();\n        throw error;\n      }\n      try {\n        let recordResult2 = function(res) {\n          try {\n            span.setAttribute(`${context3.spanName}.result`, JSON.stringify(res));\n          } catch {\n            span.setAttribute(`${context3.spanName}.result`, \"[Not Serializable]\");\n          }\n          span.end();\n          return res;\n        };\n        const { requestId, componentName, runId } = getBaggageValues(ctx);\n        if (context3.attributes) {\n          span.setAttributes(context3.attributes);\n        }\n        if (requestId) {\n          span.setAttribute(\"http.request_id\", requestId);\n        }\n        if (context3.attributes?.componentName) {\n          ctx = propagation.setBaggage(\n            ctx,\n            propagation.createBaggage({\n              componentName: { value: context3.attributes.componentName },\n              // @ts-ignore\n              runId: { value: context3.attributes.runId },\n              // @ts-ignore\n              \"http.request_id\": { value: requestId }\n            })\n          );\n        } else {\n          if (componentName) {\n            span.setAttribute(\"componentName\", componentName);\n            span.setAttribute(\"runId\", runId);\n          } else if (this && this.name) {\n            span.setAttribute(\"componentName\", this.name);\n            span.setAttribute(\"runId\", this.runId);\n            ctx = propagation.setBaggage(\n              ctx,\n              propagation.createBaggage({\n                componentName: { value: this.name },\n                // @ts-ignore\n                runId: { value: this.runId },\n                // @ts-ignore\n                \"http.request_id\": { value: requestId }\n              })\n            );\n          }\n        }\n        args.forEach((arg, index) => {\n          try {\n            span.setAttribute(`${context3.spanName}.argument.${index}`, JSON.stringify(arg));\n          } catch {\n            span.setAttribute(`${context3.spanName}.argument.${index}`, \"[Not Serializable]\");\n          }\n        });\n        let result;\n        context.with(trace.setSpan(ctx, span), () => {\n          result = method(...args);\n        });\n        if (result instanceof Promise) {\n          return result.then(recordResult2).catch(handleError);\n        } else {\n          return recordResult2(result);\n        }\n      } catch (error) {\n        handleError(error);\n      }\n    };\n  }\n  getBaggageTracer() {\n    return new BaggageTracer(this.tracer);\n  }\n};\nvar BaggageTracer = class {\n  _tracer;\n  constructor(tracer) {\n    this._tracer = tracer;\n  }\n  startSpan(name, options = {}, ctx) {\n    ctx = ctx ?? context.active();\n    const span = this._tracer.startSpan(name, options, ctx);\n    const { componentName, runId, requestId } = getBaggageValues(ctx);\n    span.setAttribute(\"componentName\", componentName);\n    span.setAttribute(\"runId\", runId);\n    span.setAttribute(\"http.request_id\", requestId);\n    return span;\n  }\n  startActiveSpan(name, optionsOrFn, ctxOrFn, fn) {\n    if (typeof optionsOrFn === \"function\") {\n      const wrappedFn2 = (span) => {\n        const { componentName, runId, requestId } = getBaggageValues(context.active());\n        span.setAttribute(\"componentName\", componentName);\n        span.setAttribute(\"runId\", runId);\n        span.setAttribute(\"http.request_id\", requestId);\n        return optionsOrFn(span);\n      };\n      return this._tracer.startActiveSpan(name, {}, context.active(), wrappedFn2);\n    }\n    if (typeof ctxOrFn === \"function\") {\n      const wrappedFn2 = (span) => {\n        const { componentName, runId, requestId } = getBaggageValues(context.active());\n        span.setAttribute(\"componentName\", componentName);\n        span.setAttribute(\"runId\", runId);\n        span.setAttribute(\"http.request_id\", requestId);\n        return ctxOrFn(span);\n      };\n      return this._tracer.startActiveSpan(name, optionsOrFn, context.active(), wrappedFn2);\n    }\n    const wrappedFn = (span) => {\n      const { componentName, runId, requestId } = getBaggageValues(ctxOrFn ?? context.active());\n      span.setAttribute(\"componentName\", componentName);\n      span.setAttribute(\"runId\", runId);\n      span.setAttribute(\"http.request_id\", requestId);\n      return fn(span);\n    };\n    return this._tracer.startActiveSpan(name, optionsOrFn, ctxOrFn, wrappedFn);\n  }\n};\n\nexport { InstrumentClass, OTLPTraceExporter, TABLE_EVALS, TABLE_MESSAGES, TABLE_RESOURCES, TABLE_SCHEMAS, TABLE_THREADS, TABLE_TRACES, TABLE_WORKFLOW_SNAPSHOT, Telemetry, getBaggageValues, hasActiveTelemetry, withSpan };\n", "// src/error/index.ts\nvar ErrorDomain = /* @__PURE__ */ ((ErrorDomain2) => {\n  ErrorDomain2[\"TOOL\"] = \"TOOL\";\n  ErrorDomain2[\"AGENT\"] = \"AGENT\";\n  ErrorDomain2[\"MCP\"] = \"MCP\";\n  ErrorDomain2[\"AGENT_NETWORK\"] = \"AGENT_NETWORK\";\n  ErrorDomain2[\"MASTRA_SERVER\"] = \"MASTRA_SERVER\";\n  ErrorDomain2[\"MASTRA_TELEMETRY\"] = \"MASTRA_TELEMETRY\";\n  ErrorDomain2[\"MASTRA_WORKFLOW\"] = \"MASTRA_WORKFLOW\";\n  ErrorDomain2[\"MASTRA_VOICE\"] = \"MASTRA_VOICE\";\n  ErrorDomain2[\"MASTRA_VECTOR\"] = \"MASTRA_VECTOR\";\n  ErrorDomain2[\"LLM\"] = \"LLM\";\n  ErrorDomain2[\"EVAL\"] = \"EVAL\";\n  ErrorDomain2[\"A2A\"] = \"A2A\";\n  ErrorDomain2[\"MASTRA_INSTANCE\"] = \"MASTRA_INSTANCE\";\n  ErrorDomain2[\"MASTRA\"] = \"MASTRA\";\n  ErrorDomain2[\"DEPLOYER\"] = \"DEPLOYER\";\n  ErrorDomain2[\"STORAGE\"] = \"STORAGE\";\n  return ErrorDomain2;\n})(ErrorDomain || {});\nvar ErrorCategory = /* @__PURE__ */ ((ErrorCategory2) => {\n  ErrorCategory2[\"UNKNOWN\"] = \"UNKNOWN\";\n  ErrorCategory2[\"USER\"] = \"USER\";\n  ErrorCategory2[\"SYSTEM\"] = \"SYSTEM\";\n  ErrorCategory2[\"THIRD_PARTY\"] = \"THIRD_PARTY\";\n  return ErrorCategory2;\n})(ErrorCategory || {});\nvar MastraBaseError = class extends Error {\n  id;\n  domain;\n  category;\n  details = {};\n  message;\n  constructor(errorDefinition, originalError) {\n    let error;\n    if (originalError instanceof Error) {\n      error = originalError;\n    } else if (originalError) {\n      error = new Error(String(originalError));\n    }\n    const message = errorDefinition.text ?? error?.message ?? \"Unknown error\";\n    super(message, { cause: error });\n    this.id = errorDefinition.id;\n    this.domain = errorDefinition.domain;\n    this.category = errorDefinition.category;\n    this.details = errorDefinition.details ?? {};\n    this.message = message;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n  /**\n   * Returns a structured representation of the error, useful for logging or API responses.\n   */\n  toJSONDetails() {\n    return {\n      message: this.message,\n      domain: this.domain,\n      category: this.category,\n      details: this.details\n    };\n  }\n  toJSON() {\n    return {\n      message: this.message,\n      details: this.toJSONDetails(),\n      code: this.id\n    };\n  }\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n};\nvar MastraError = class extends MastraBaseError {\n};\n\nexport { ErrorCategory, ErrorDomain, MastraBaseError, MastraError };\n", "import { RegisteredLogger, ConsoleLogger } from './chunk-5YDTZN2X.js';\n\n// src/base.ts\nvar MastraBase = class {\n  component = RegisteredLogger.LLM;\n  logger;\n  name;\n  telemetry;\n  constructor({ component, name }) {\n    this.component = component || RegisteredLogger.LLM;\n    this.name = name;\n    this.logger = new ConsoleLogger({ name: `${this.component} - ${this.name}` });\n  }\n  /**\n   * Set the logger for the agent\n   * @param logger\n   */\n  __setLogger(logger) {\n    this.logger = logger;\n    if (this.component !== RegisteredLogger.LLM) {\n      this.logger.debug(`Logger updated [component=${this.component}] [name=${this.name}]`);\n    }\n  }\n  /**\n   * Set the telemetry for the\n   * @param telemetry\n   */\n  __setTelemetry(telemetry) {\n    this.telemetry = telemetry;\n    if (this.component !== RegisteredLogger.LLM) {\n      this.logger.debug(`Telemetry updated [component=${this.component}] [name=${this.telemetry.name}]`);\n    }\n  }\n  /**\n   * Get the telemetry on the vector\n   * @returns telemetry\n   */\n  __getTelemetry() {\n    return this.telemetry;\n  }\n  /* \n    get experimental_telemetry config\n    */\n  get experimental_telemetry() {\n    return this.telemetry ? {\n      // tracer: this.telemetry.tracer,\n      tracer: this.telemetry.getBaggageTracer(),\n      isEnabled: !!this.telemetry.tracer\n    } : void 0;\n  }\n};\n\nexport { MastraBase };\n", "// src/logger/constants.ts\nvar RegisteredLogger = {\n  AGENT: \"AGENT\",\n  AUTH: \"AUTH\",\n  NETWORK: \"NETWORK\",\n  WORKFLOW: \"WORKFLOW\",\n  LLM: \"LLM\",\n  TTS: \"TTS\",\n  VOICE: \"VOICE\",\n  VECTOR: \"VECTOR\",\n  BUNDLER: \"BUNDLER\",\n  DEPLOYER: \"DEPLOYER\",\n  MEMORY: \"MEMORY\",\n  STORAGE: \"STORAGE\",\n  EMBEDDINGS: \"EMBEDDINGS\",\n  MCP_SERVER: \"MCP_SERVER\"\n};\nvar LogLevel = {\n  DEBUG: \"debug\",\n  INFO: \"info\",\n  WARN: \"warn\",\n  ERROR: \"error\",\n  NONE: \"silent\"\n};\n\n// src/logger/logger.ts\nvar MastraLogger = class {\n  name;\n  level;\n  transports;\n  constructor(options = {}) {\n    this.name = options.name || \"Mastra\";\n    this.level = options.level || LogLevel.ERROR;\n    this.transports = new Map(Object.entries(options.transports || {}));\n  }\n  getTransports() {\n    return this.transports;\n  }\n  trackException(_error) {\n  }\n  async getLogs(transportId, params) {\n    if (!transportId || !this.transports.has(transportId)) {\n      return { logs: [], total: 0, page: params?.page ?? 1, perPage: params?.perPage ?? 100, hasMore: false };\n    }\n    return this.transports.get(transportId).getLogs(params) ?? {\n      logs: [],\n      total: 0,\n      page: params?.page ?? 1,\n      perPage: params?.perPage ?? 100,\n      hasMore: false\n    };\n  }\n  async getLogsByRunId({\n    transportId,\n    runId,\n    fromDate,\n    toDate,\n    logLevel,\n    filters,\n    page,\n    perPage\n  }) {\n    if (!transportId || !this.transports.has(transportId) || !runId) {\n      return { logs: [], total: 0, page: page ?? 1, perPage: perPage ?? 100, hasMore: false };\n    }\n    return this.transports.get(transportId).getLogsByRunId({ runId, fromDate, toDate, logLevel, filters, page, perPage }) ?? {\n      logs: [],\n      total: 0,\n      page: page ?? 1,\n      perPage: perPage ?? 100,\n      hasMore: false\n    };\n  }\n};\n\n// src/logger/default-logger.ts\nvar createLogger = (options) => {\n  const logger = new ConsoleLogger(options);\n  logger.warn(`createLogger is deprecated. Please use \"new ConsoleLogger()\" from \"@mastra/core/logger\" instead.`);\n  return logger;\n};\nvar ConsoleLogger = class extends MastraLogger {\n  constructor(options = {}) {\n    super(options);\n  }\n  debug(message, ...args) {\n    if (this.level === LogLevel.DEBUG) {\n      console.debug(message, ...args);\n    }\n  }\n  info(message, ...args) {\n    if (this.level === LogLevel.INFO || this.level === LogLevel.DEBUG) {\n      console.info(message, ...args);\n    }\n  }\n  warn(message, ...args) {\n    if (this.level === LogLevel.WARN || this.level === LogLevel.INFO || this.level === LogLevel.DEBUG) {\n      console.warn(message, ...args);\n    }\n  }\n  error(message, ...args) {\n    if (this.level === LogLevel.ERROR || this.level === LogLevel.WARN || this.level === LogLevel.INFO || this.level === LogLevel.DEBUG) {\n      console.error(message, ...args);\n    }\n  }\n  async getLogs(_transportId, _params) {\n    return { logs: [], total: 0, page: _params?.page ?? 1, perPage: _params?.perPage ?? 100, hasMore: false };\n  }\n  async getLogsByRunId(_args) {\n    return { logs: [], total: 0, page: _args.page ?? 1, perPage: _args.perPage ?? 100, hasMore: false };\n  }\n};\n\nexport { ConsoleLogger, LogLevel, MastraLogger, RegisteredLogger, createLogger };\n", "var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for(\"Symbol.\" + name);\nvar __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {\n    exports: {}\n  }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n// If the importer is in node compatibility mode or this is not an ESM\n// file that has been converted to a CommonJS file using a Babel-\n// compatible transform (i.e. \"__esModule\" has not been set), then set\n// \"default\" to the CommonJS \"module.exports\" for node compatibility.\nisNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __decoratorStart = base => [,,, __create(base?.[__knownSymbol(\"metadata\")] ?? null)];\nvar __decoratorStrings = [\"class\", \"method\", \"getter\", \"setter\", \"accessor\", \"field\", \"value\", \"get\", \"set\"];\nvar __expectFn = fn => fn !== void 0 && typeof fn !== \"function\" ? __typeError(\"Function expected\") : fn;\nvar __decoratorContext = (kind, name, done, metadata, fns) => ({\n  kind: __decoratorStrings[kind],\n  name,\n  metadata,\n  addInitializer: fn => done._ ? __typeError(\"Already initialized\") : fns.push(__expectFn(fn || null))\n});\nvar __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol(\"metadata\"), array[3]);\nvar __runInitializers = (array, flags, self, value) => {\n  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);\n  return value;\n};\nvar __decorateElement = (array, flags, name, decorators, target, extra) => {\n  var fn,\n    it,\n    done,\n    ctx,\n    access,\n    k = flags & 7,\n    s = !!(flags & 8),\n    p = !!(flags & 16);\n  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0,\n    key = __decoratorStrings[k + 5];\n  var initializers = k > 3 && (array[j - 1] = []),\n    extraInitializers = array[j] || (array[j] = []);\n  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : {\n    get [name]() {\n      return __privateGet(this, extra);\n    },\n    set [name](x) {\n      return __privateSet(this, extra, x);\n    }\n  }, name));\n  k ? p && k < 4 && __name(extra, (k > 2 ? \"set \" : k > 1 ? \"get \" : \"\") + name) : __name(target, name);\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);\n    if (k) {\n      ctx.static = s, ctx.private = p, access = ctx.access = {\n        has: p ? x => __privateIn(target, x) : x => name in x\n      };\n      if (k ^ 3) access.get = p ? x => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : x => x[name];\n      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;\n    }\n    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : {\n      get: desc.get,\n      set: desc.set\n    } : target, ctx), done._ = 1;\n    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);else if (typeof it !== \"object\" || it === null) __typeError(\"Object expected\");else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);\n  }\n  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the \"in\" operator on this value') : member.has(obj);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\n\nexport { __commonJS, __decorateElement, __decoratorStart, __runInitializers, __toESM };\n", "import { isUiMessage, isCoreMessage } from './chunk-IBKM5CLQ.js';\nimport { MastraError } from './chunk-6UNGH46J.js';\nimport { randomUUID } from 'crypto';\nimport { convertToCoreMessages } from 'ai';\nimport { convertUint8ArrayToBase64 } from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\n\n// src/agent/message-list/prompt/attachments-to-parts.ts\nfunction attachmentsToParts(attachments) {\n  const parts = [];\n  for (const attachment of attachments) {\n    let url;\n    try {\n      url = new URL(attachment.url);\n    } catch {\n      throw new Error(`Invalid URL: ${attachment.url}`);\n    }\n    switch (url.protocol) {\n      case \"http:\":\n      case \"https:\": {\n        if (attachment.contentType?.startsWith(\"image/\")) {\n          parts.push({ type: \"image\", image: url.toString(), mimeType: attachment.contentType });\n        } else {\n          if (!attachment.contentType) {\n            throw new Error(\"If the attachment is not an image, it must specify a content type\");\n          }\n          parts.push({\n            type: \"file\",\n            data: url.toString(),\n            mimeType: attachment.contentType\n          });\n        }\n        break;\n      }\n      case \"data:\": {\n        if (attachment.contentType?.startsWith(\"image/\")) {\n          parts.push({\n            type: \"image\",\n            image: attachment.url,\n            mimeType: attachment.contentType\n          });\n        } else if (attachment.contentType?.startsWith(\"text/\")) {\n          parts.push({\n            type: \"file\",\n            data: attachment.url,\n            mimeType: attachment.contentType\n          });\n        } else {\n          if (!attachment.contentType) {\n            throw new Error(\"If the attachment is not an image or text, it must specify a content type\");\n          }\n          parts.push({\n            type: \"file\",\n            data: attachment.url,\n            mimeType: attachment.contentType\n          });\n        }\n        break;\n      }\n      default: {\n        throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n      }\n    }\n  }\n  return parts;\n}\n\n// src/agent/message-list/prompt/convert-to-mastra-v1.ts\nvar makePushOrCombine = (v1Messages) => (msg) => {\n  const previousMessage = v1Messages.at(-1);\n  if (msg.role === previousMessage?.role && Array.isArray(previousMessage.content) && Array.isArray(msg.content) && // we were creating new messages for tool calls before and not appending to the assistant message\n  // so don't append here so everything works as before\n  (msg.role !== `assistant` || msg.role === `assistant` && msg.content.at(-1)?.type !== `tool-call`)) {\n    for (const part of msg.content) {\n      previousMessage.content.push(part);\n    }\n  } else {\n    v1Messages.push(msg);\n  }\n};\nfunction convertToV1Messages(messages) {\n  const v1Messages = [];\n  const pushOrCombine = makePushOrCombine(v1Messages);\n  for (let i = 0; i < messages.length; i++) {\n    const message = messages[i];\n    const isLastMessage = i === messages.length - 1;\n    if (!message?.content) continue;\n    const { content, experimental_attachments: inputAttachments = [], parts: inputParts } = message.content;\n    const { role } = message;\n    const fields = {\n      id: message.id,\n      createdAt: message.createdAt,\n      resourceId: message.resourceId,\n      threadId: message.threadId\n    };\n    const experimental_attachments = [...inputAttachments];\n    const parts = [];\n    for (const part of inputParts) {\n      if (part.type === \"file\") {\n        experimental_attachments.push({\n          url: part.data,\n          contentType: part.mimeType\n        });\n      } else {\n        parts.push(part);\n      }\n    }\n    switch (role) {\n      case \"user\": {\n        if (parts == null) {\n          const userContent = experimental_attachments ? [{ type: \"text\", text: content || \"\" }, ...attachmentsToParts(experimental_attachments)] : { type: \"text\", text: content || \"\" };\n          pushOrCombine({\n            role: \"user\",\n            ...fields,\n            type: \"text\",\n            // @ts-ignore\n            content: userContent\n          });\n        } else {\n          const textParts = message.content.parts.filter((part) => part.type === \"text\").map((part) => ({\n            type: \"text\",\n            text: part.text\n          }));\n          const userContent = experimental_attachments ? [...textParts, ...attachmentsToParts(experimental_attachments)] : textParts;\n          pushOrCombine({\n            role: \"user\",\n            ...fields,\n            type: \"text\",\n            content: Array.isArray(userContent) && userContent.length === 1 && userContent[0]?.type === `text` && typeof content !== `undefined` ? content : userContent\n          });\n        }\n        break;\n      }\n      case \"assistant\": {\n        if (message.content.parts != null) {\n          let processBlock2 = function() {\n            const content2 = [];\n            for (const part of block) {\n              switch (part.type) {\n                case \"file\":\n                case \"text\": {\n                  content2.push(part);\n                  break;\n                }\n                case \"reasoning\": {\n                  for (const detail of part.details) {\n                    switch (detail.type) {\n                      case \"text\":\n                        content2.push({\n                          type: \"reasoning\",\n                          text: detail.text,\n                          signature: detail.signature\n                        });\n                        break;\n                      case \"redacted\":\n                        content2.push({\n                          type: \"redacted-reasoning\",\n                          data: detail.data\n                        });\n                        break;\n                    }\n                  }\n                  break;\n                }\n                case \"tool-invocation\":\n                  content2.push({\n                    type: \"tool-call\",\n                    toolCallId: part.toolInvocation.toolCallId,\n                    toolName: part.toolInvocation.toolName,\n                    args: part.toolInvocation.args\n                  });\n                  break;\n              }\n            }\n            pushOrCombine({\n              role: \"assistant\",\n              ...fields,\n              type: content2.some((c) => c.type === `tool-call`) ? \"tool-call\" : \"text\",\n              // content: content,\n              content: typeof content2 !== `string` && Array.isArray(content2) && content2.length === 1 && content2[0]?.type === `text` ? message?.content?.content || content2 : content2\n            });\n            const stepInvocations = block.filter((part) => `type` in part && part.type === \"tool-invocation\").map((part) => part.toolInvocation);\n            if (stepInvocations.length > 0) {\n              pushOrCombine({\n                role: \"tool\",\n                ...fields,\n                type: \"tool-result\",\n                // @ts-ignore\n                content: stepInvocations.map((toolInvocation) => {\n                  const { toolCallId, toolName } = toolInvocation;\n                  return {\n                    type: \"tool-result\",\n                    toolCallId,\n                    toolName,\n                    // @ts-ignore\n                    result: toolInvocation.result\n                  };\n                })\n              });\n            }\n            block = [];\n            blockHasToolInvocations = false;\n            currentStep++;\n          };\n          let currentStep = 0;\n          let blockHasToolInvocations = false;\n          let block = [];\n          for (const part of message.content.parts) {\n            switch (part.type) {\n              case \"text\": {\n                if (blockHasToolInvocations) {\n                  processBlock2();\n                }\n                block.push(part);\n                break;\n              }\n              case \"file\":\n              case \"reasoning\": {\n                block.push(part);\n                break;\n              }\n              case \"tool-invocation\": {\n                if ((part.toolInvocation.step ?? 0) !== currentStep) {\n                  processBlock2();\n                }\n                block.push(part);\n                blockHasToolInvocations = true;\n                break;\n              }\n            }\n          }\n          processBlock2();\n          break;\n        }\n        const toolInvocations = message.content.toolInvocations;\n        if (toolInvocations == null || toolInvocations.length === 0) {\n          pushOrCombine({ role: \"assistant\", ...fields, content: content || \"\", type: \"text\" });\n          break;\n        }\n        const maxStep = toolInvocations.reduce((max, toolInvocation) => {\n          return Math.max(max, toolInvocation.step ?? 0);\n        }, 0);\n        for (let i2 = 0; i2 <= maxStep; i2++) {\n          const stepInvocations = toolInvocations.filter((toolInvocation) => (toolInvocation.step ?? 0) === i2);\n          if (stepInvocations.length === 0) {\n            continue;\n          }\n          pushOrCombine({\n            role: \"assistant\",\n            ...fields,\n            type: \"tool-call\",\n            content: [\n              ...isLastMessage && content && i2 === 0 ? [{ type: \"text\", text: content }] : [],\n              ...stepInvocations.map(({ toolCallId, toolName, args }) => ({\n                type: \"tool-call\",\n                toolCallId,\n                toolName,\n                args\n              }))\n            ]\n          });\n          pushOrCombine({\n            role: \"tool\",\n            ...fields,\n            type: \"tool-result\",\n            content: stepInvocations.map((toolInvocation) => {\n              if (!(\"result\" in toolInvocation)) {\n                return toolInvocation;\n              }\n              const { toolCallId, toolName, result } = toolInvocation;\n              return {\n                type: \"tool-result\",\n                toolCallId,\n                toolName,\n                result\n              };\n            })\n          });\n        }\n        if (content && !isLastMessage) {\n          pushOrCombine({ role: \"assistant\", ...fields, type: \"text\", content: content || \"\" });\n        }\n        break;\n      }\n    }\n  }\n  return v1Messages;\n}\nz.union([\n  z.string(),\n  z.instanceof(Uint8Array),\n  z.instanceof(ArrayBuffer),\n  z.custom(\n    // Buffer might not be available in some environments such as CloudFlare:\n    (value) => globalThis.Buffer?.isBuffer(value) ?? false,\n    { message: \"Must be a Buffer\" }\n  )\n]);\nfunction convertDataContentToBase64String(content) {\n  if (typeof content === \"string\") {\n    return content;\n  }\n  if (content instanceof ArrayBuffer) {\n    return convertUint8ArrayToBase64(new Uint8Array(content));\n  }\n  return convertUint8ArrayToBase64(content);\n}\n\n// src/agent/message-list/index.ts\nfunction isToolCallMessage(message) {\n  if (message.role === \"tool\") {\n    return true;\n  }\n  if (message.role === \"assistant\" && Array.isArray(message.content)) {\n    return message.content.some((part) => part.type === \"tool-call\");\n  }\n  return false;\n}\nvar MessageList = class _MessageList {\n  messages = [];\n  // passed in by dev in input or context\n  systemMessages = [];\n  // passed in by us for a specific purpose, eg memory system message\n  taggedSystemMessages = {};\n  memoryInfo = null;\n  // used to filter this.messages by how it was added: input/response/memory\n  memoryMessages = /* @__PURE__ */ new Set();\n  newUserMessages = /* @__PURE__ */ new Set();\n  newResponseMessages = /* @__PURE__ */ new Set();\n  userContextMessages = /* @__PURE__ */ new Set();\n  generateMessageId;\n  _agentNetworkAppend = false;\n  constructor({\n    threadId,\n    resourceId,\n    generateMessageId,\n    // @ts-ignore Flag for agent network messages\n    _agentNetworkAppend\n  } = {}) {\n    if (threadId) {\n      this.memoryInfo = { threadId, resourceId };\n      this.generateMessageId = generateMessageId;\n    }\n    this._agentNetworkAppend = _agentNetworkAppend || false;\n  }\n  add(messages, messageSource) {\n    if (!messages) return this;\n    for (const message of Array.isArray(messages) ? messages : [messages]) {\n      this.addOne(\n        typeof message === `string` ? {\n          role: \"user\",\n          content: message\n        } : message,\n        messageSource\n      );\n    }\n    return this;\n  }\n  getLatestUserContent() {\n    const currentUserMessages = this.all.core().filter((m) => m.role === \"user\");\n    const content = currentUserMessages.at(-1)?.content;\n    if (!content) return null;\n    return _MessageList.coreContentToString(content);\n  }\n  get get() {\n    return {\n      all: this.all,\n      remembered: this.remembered,\n      input: this.input,\n      response: this.response\n    };\n  }\n  all = {\n    v2: () => this.messages,\n    v1: () => convertToV1Messages(this.messages),\n    ui: () => this.messages.map(_MessageList.toUIMessage),\n    core: () => this.convertToCoreMessages(this.all.ui()),\n    prompt: () => {\n      const coreMessages = this.all.core();\n      while (coreMessages[0] && isToolCallMessage(coreMessages[0])) {\n        coreMessages.shift();\n      }\n      const messages = [...this.systemMessages, ...Object.values(this.taggedSystemMessages).flat(), ...coreMessages];\n      return messages;\n    }\n  };\n  remembered = {\n    v2: () => this.messages.filter((m) => this.memoryMessages.has(m)),\n    v1: () => convertToV1Messages(this.remembered.v2()),\n    ui: () => this.remembered.v2().map(_MessageList.toUIMessage),\n    core: () => this.convertToCoreMessages(this.remembered.ui())\n  };\n  input = {\n    v2: () => this.messages.filter((m) => this.newUserMessages.has(m)),\n    v1: () => convertToV1Messages(this.input.v2()),\n    ui: () => this.input.v2().map(_MessageList.toUIMessage),\n    core: () => this.convertToCoreMessages(this.input.ui())\n  };\n  response = {\n    v2: () => this.messages.filter((m) => this.newResponseMessages.has(m))\n  };\n  drainUnsavedMessages() {\n    const messages = this.messages.filter((m) => this.newUserMessages.has(m) || this.newResponseMessages.has(m));\n    this.newUserMessages.clear();\n    this.newResponseMessages.clear();\n    return messages;\n  }\n  getEarliestUnsavedMessageTimestamp() {\n    const unsavedMessages = this.messages.filter((m) => this.newUserMessages.has(m) || this.newResponseMessages.has(m));\n    if (unsavedMessages.length === 0) return void 0;\n    return Math.min(...unsavedMessages.map((m) => new Date(m.createdAt).getTime()));\n  }\n  getSystemMessages(tag) {\n    if (tag) {\n      return this.taggedSystemMessages[tag] || [];\n    }\n    return this.systemMessages;\n  }\n  addSystem(messages, tag) {\n    if (!messages) return this;\n    for (const message of Array.isArray(messages) ? messages : [messages]) {\n      this.addOneSystem(message, tag);\n    }\n    return this;\n  }\n  convertToCoreMessages(messages) {\n    return convertToCoreMessages(this.sanitizeUIMessages(messages));\n  }\n  sanitizeUIMessages(messages) {\n    const msgs = messages.map((m) => {\n      if (m.parts.length === 0) return false;\n      const safeParts = m.parts.filter(\n        (p) => p.type !== `tool-invocation` || // calls and partial-calls should be updated to be results at this point\n        // if they haven't we can't send them back to the llm and need to remove them.\n        p.toolInvocation.state !== `call` && p.toolInvocation.state !== `partial-call`\n      );\n      if (!safeParts.length) return false;\n      const sanitized = {\n        ...m,\n        parts: safeParts\n      };\n      if (`toolInvocations` in m && m.toolInvocations) {\n        sanitized.toolInvocations = m.toolInvocations.filter((t) => t.state === `result`);\n      }\n      return sanitized;\n    }).filter((m) => Boolean(m));\n    return msgs;\n  }\n  addOneSystem(message, tag) {\n    if (typeof message === `string`) message = { role: \"system\", content: message };\n    if (tag && !this.isDuplicateSystem(message, tag)) {\n      this.taggedSystemMessages[tag] ||= [];\n      this.taggedSystemMessages[tag].push(message);\n    } else if (!this.isDuplicateSystem(message)) {\n      this.systemMessages.push(message);\n    }\n  }\n  isDuplicateSystem(message, tag) {\n    if (tag) {\n      if (!this.taggedSystemMessages[tag]) return false;\n      return this.taggedSystemMessages[tag].some(\n        (m) => _MessageList.cacheKeyFromContent(m.content) === _MessageList.cacheKeyFromContent(message.content)\n      );\n    }\n    return this.systemMessages.some(\n      (m) => _MessageList.cacheKeyFromContent(m.content) === _MessageList.cacheKeyFromContent(message.content)\n    );\n  }\n  static toUIMessage(m) {\n    const experimentalAttachments = m.content.experimental_attachments ? [...m.content.experimental_attachments] : [];\n    const contentString = typeof m.content.content === `string` && m.content.content !== \"\" ? m.content.content : m.content.parts.reduce((prev, part) => {\n      if (part.type === `text`) {\n        return part.text;\n      }\n      return prev;\n    }, \"\");\n    const parts = [];\n    if (m.content.parts.length) {\n      for (const part of m.content.parts) {\n        if (part.type === `file`) {\n          experimentalAttachments.push({\n            contentType: part.mimeType,\n            url: part.data\n          });\n        } else if (part.type === \"tool-invocation\" && (part.toolInvocation.state === \"call\" || part.toolInvocation.state === \"partial-call\")) {\n          continue;\n        } else {\n          parts.push(part);\n        }\n      }\n    }\n    if (parts.length === 0 && experimentalAttachments.length > 0) {\n      parts.push({ type: \"text\", text: \"\" });\n    }\n    if (m.role === `user`) {\n      return {\n        id: m.id,\n        role: m.role,\n        content: m.content.content || contentString,\n        createdAt: m.createdAt,\n        parts,\n        experimental_attachments: experimentalAttachments\n      };\n    } else if (m.role === `assistant`) {\n      return {\n        id: m.id,\n        role: m.role,\n        content: m.content.content || contentString,\n        createdAt: m.createdAt,\n        parts,\n        reasoning: void 0,\n        toolInvocations: `toolInvocations` in m.content ? m.content.toolInvocations?.filter((t) => t.state === \"result\") : void 0\n      };\n    }\n    return {\n      id: m.id,\n      role: m.role,\n      content: m.content.content || contentString,\n      createdAt: m.createdAt,\n      parts,\n      experimental_attachments: experimentalAttachments\n    };\n  }\n  getMessageById(id) {\n    return this.messages.find((m) => m.id === id);\n  }\n  shouldReplaceMessage(message) {\n    if (!this.messages.length) return { exists: false };\n    if (!(`id` in message) || !message?.id) {\n      return { exists: false };\n    }\n    const existingMessage = this.getMessageById(message.id);\n    if (!existingMessage) return { exists: false };\n    return {\n      exists: true,\n      shouldReplace: !_MessageList.messagesAreEqual(existingMessage, message),\n      id: existingMessage.id\n    };\n  }\n  addOne(message, messageSource) {\n    if ((!(`content` in message) || !message.content && // allow empty strings\n    typeof message.content !== \"string\") && (!(`parts` in message) || !message.parts)) {\n      throw new MastraError({\n        id: \"INVALID_MESSAGE_CONTENT\",\n        domain: \"AGENT\" /* AGENT */,\n        category: \"USER\" /* USER */,\n        text: `Message with role \"${message.role}\" must have either a 'content' property (string or array) or a 'parts' property (array) that is not empty, null, or undefined. Received message: ${JSON.stringify(message, null, 2)}`,\n        details: {\n          role: message.role,\n          messageSource,\n          hasContent: \"content\" in message,\n          hasParts: \"parts\" in message\n        }\n      });\n    }\n    if (message.role === `system` && _MessageList.isVercelCoreMessage(message)) return this.addSystem(message);\n    if (message.role === `system`) {\n      throw new MastraError({\n        id: \"INVALID_SYSTEM_MESSAGE_FORMAT\",\n        domain: \"AGENT\" /* AGENT */,\n        category: \"USER\" /* USER */,\n        text: `Invalid system message format. System messages must be CoreMessage format with 'role' and 'content' properties. The content should be a string or valid content array.`,\n        details: {\n          messageSource,\n          receivedMessage: JSON.stringify(message, null, 2)\n        }\n      });\n    }\n    const messageV2 = this.inputToMastraMessageV2(message, messageSource);\n    const { exists, shouldReplace, id } = this.shouldReplaceMessage(messageV2);\n    const latestMessage = this.messages.at(-1);\n    if (messageSource === `memory`) {\n      for (const existingMessage of this.messages) {\n        if (_MessageList.messagesAreEqual(existingMessage, messageV2)) {\n          return;\n        }\n      }\n    }\n    const shouldAppendToLastAssistantMessage = latestMessage?.role === \"assistant\" && messageV2.role === \"assistant\" && latestMessage.threadId === messageV2.threadId && // If the message is from memory, don't append to the last assistant message\n    messageSource !== \"memory\";\n    const appendNetworkMessage = this._agentNetworkAppend && latestMessage && !this.memoryMessages.has(latestMessage) || !this._agentNetworkAppend;\n    if (shouldAppendToLastAssistantMessage && appendNetworkMessage) {\n      latestMessage.createdAt = messageV2.createdAt || latestMessage.createdAt;\n      for (const [index, part] of messageV2.content.parts.entries()) {\n        if (part.type === \"tool-invocation\" && part.toolInvocation.state === \"result\") {\n          const existingCallPart = [...latestMessage.content.parts].reverse().find((p) => p.type === \"tool-invocation\" && p.toolInvocation.toolCallId === part.toolInvocation.toolCallId);\n          if (existingCallPart && existingCallPart.type === \"tool-invocation\") {\n            existingCallPart.toolInvocation = {\n              ...existingCallPart.toolInvocation,\n              state: \"result\",\n              result: part.toolInvocation.result\n            };\n            if (!latestMessage.content.toolInvocations) {\n              latestMessage.content.toolInvocations = [];\n            }\n            const toolInvocationIndex = latestMessage.content.toolInvocations.findIndex(\n              (t) => t.toolCallId === existingCallPart.toolInvocation.toolCallId\n            );\n            if (toolInvocationIndex === -1) {\n              latestMessage.content.toolInvocations.push(existingCallPart.toolInvocation);\n            } else {\n              latestMessage.content.toolInvocations[toolInvocationIndex] = existingCallPart.toolInvocation;\n            }\n          }\n        } else if (\n          // if there's no part at this index yet in the existing message we're merging into\n          !latestMessage.content.parts[index] || // or there is and the parts are not identical\n          _MessageList.cacheKeyFromParts([latestMessage.content.parts[index]]) !== _MessageList.cacheKeyFromParts([part])\n        ) {\n          latestMessage.content.parts.push(part);\n        }\n      }\n      if (latestMessage.createdAt.getTime() < messageV2.createdAt.getTime()) {\n        latestMessage.createdAt = messageV2.createdAt;\n      }\n      if (!latestMessage.content.content && messageV2.content.content) {\n        latestMessage.content.content = messageV2.content.content;\n      }\n      if (latestMessage.content.content && messageV2.content.content && latestMessage.content.content !== messageV2.content.content) {\n        latestMessage.content.content = messageV2.content.content;\n      }\n      this.newResponseMessages.add(latestMessage);\n    } else {\n      const existingIndex = shouldReplace && this.messages.findIndex((m) => m.id === id) || -1;\n      const existingMessage = existingIndex !== -1 && this.messages[existingIndex];\n      if (shouldReplace && existingMessage) {\n        this.messages[existingIndex] = messageV2;\n      } else if (!exists) {\n        this.messages.push(messageV2);\n      }\n      if (messageSource === `memory`) {\n        this.memoryMessages.add(messageV2);\n      } else if (messageSource === `response`) {\n        this.newResponseMessages.add(messageV2);\n      } else if (messageSource === `user`) {\n        this.newUserMessages.add(messageV2);\n      } else if (messageSource === `context`) {\n        this.userContextMessages.add(messageV2);\n      } else {\n        throw new Error(`Missing message source for message ${messageV2}`);\n      }\n    }\n    this.messages.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());\n    return this;\n  }\n  inputToMastraMessageV2(message, messageSource) {\n    if (\n      // we can't throw if the threadId doesn't match and this message came from memory\n      // this is because per-user semantic recall can retrieve messages from other threads\n      messageSource !== `memory` && `threadId` in message && message.threadId && this.memoryInfo && message.threadId !== this.memoryInfo.threadId\n    ) {\n      throw new Error(\n        `Received input message with wrong threadId. Input ${message.threadId}, expected ${this.memoryInfo.threadId}`\n      );\n    }\n    if (`resourceId` in message && message.resourceId && this.memoryInfo?.resourceId && message.resourceId !== this.memoryInfo.resourceId) {\n      throw new Error(\n        `Received input message with wrong resourceId. Input ${message.resourceId}, expected ${this.memoryInfo.resourceId}`\n      );\n    }\n    if (_MessageList.isMastraMessageV1(message)) {\n      return this.mastraMessageV1ToMastraMessageV2(message, messageSource);\n    }\n    if (_MessageList.isMastraMessageV2(message)) {\n      return this.hydrateMastraMessageV2Fields(message);\n    }\n    if (_MessageList.isVercelCoreMessage(message)) {\n      return this.vercelCoreMessageToMastraMessageV2(message, messageSource);\n    }\n    if (_MessageList.isVercelUIMessage(message)) {\n      return this.vercelUIMessageToMastraMessageV2(message, messageSource);\n    }\n    throw new Error(`Found unhandled message ${JSON.stringify(message)}`);\n  }\n  lastCreatedAt;\n  // this makes sure messages added in order will always have a date atleast 1ms apart.\n  generateCreatedAt(messageSource, start) {\n    start = start instanceof Date ? start : start ? new Date(start) : void 0;\n    if (start && !this.lastCreatedAt) {\n      this.lastCreatedAt = start.getTime();\n      return start;\n    }\n    if (start && messageSource === `memory`) {\n      return start;\n    }\n    const now = /* @__PURE__ */ new Date();\n    const nowTime = start?.getTime() || now.getTime();\n    const lastTime = this.messages.reduce((p, m) => {\n      if (m.createdAt.getTime() > p) return m.createdAt.getTime();\n      return p;\n    }, this.lastCreatedAt || 0);\n    if (nowTime <= lastTime) {\n      const newDate = new Date(lastTime + 1);\n      this.lastCreatedAt = newDate.getTime();\n      return newDate;\n    }\n    this.lastCreatedAt = nowTime;\n    return now;\n  }\n  newMessageId() {\n    if (this.generateMessageId) {\n      return this.generateMessageId();\n    }\n    return randomUUID();\n  }\n  mastraMessageV1ToMastraMessageV2(message, messageSource) {\n    const coreV2 = this.vercelCoreMessageToMastraMessageV2(\n      {\n        content: message.content,\n        role: message.role\n      },\n      messageSource\n    );\n    return {\n      id: message.id,\n      role: coreV2.role,\n      createdAt: this.generateCreatedAt(messageSource, message.createdAt),\n      threadId: message.threadId,\n      resourceId: message.resourceId,\n      content: coreV2.content\n    };\n  }\n  hydrateMastraMessageV2Fields(message) {\n    if (!(message.createdAt instanceof Date)) message.createdAt = new Date(message.createdAt);\n    return message;\n  }\n  vercelUIMessageToMastraMessageV2(message, messageSource) {\n    const content = {\n      format: 2,\n      parts: message.parts\n    };\n    if (message.toolInvocations) content.toolInvocations = message.toolInvocations;\n    if (message.reasoning) content.reasoning = message.reasoning;\n    if (message.annotations) content.annotations = message.annotations;\n    if (message.experimental_attachments) {\n      content.experimental_attachments = message.experimental_attachments;\n    }\n    return {\n      id: message.id || this.newMessageId(),\n      role: _MessageList.getRole(message),\n      createdAt: this.generateCreatedAt(messageSource, message.createdAt),\n      threadId: this.memoryInfo?.threadId,\n      resourceId: this.memoryInfo?.resourceId,\n      content\n    };\n  }\n  vercelCoreMessageToMastraMessageV2(coreMessage, messageSource) {\n    const id = `id` in coreMessage ? coreMessage.id : this.newMessageId();\n    const parts = [];\n    const experimentalAttachments = [];\n    const toolInvocations = [];\n    if (typeof coreMessage.content === \"string\") {\n      parts.push({ type: \"step-start\" });\n      parts.push({\n        type: \"text\",\n        text: coreMessage.content\n      });\n    } else if (Array.isArray(coreMessage.content)) {\n      for (const part of coreMessage.content) {\n        switch (part.type) {\n          case \"text\":\n            parts.push({\n              type: \"text\",\n              text: part.text\n            });\n            break;\n          case \"tool-call\":\n            parts.push({\n              type: \"tool-invocation\",\n              toolInvocation: {\n                state: \"call\",\n                toolCallId: part.toolCallId,\n                toolName: part.toolName,\n                args: part.args\n              }\n            });\n            break;\n          case \"tool-result\":\n            const invocation = {\n              state: \"result\",\n              toolCallId: part.toolCallId,\n              toolName: part.toolName,\n              result: part.result ?? \"\",\n              // undefined will cause AI SDK to throw an error, but for client side tool calls this really could be undefined\n              args: {}\n              // when we combine this invocation onto the existing tool-call part it will have args already\n            };\n            parts.push({\n              type: \"tool-invocation\",\n              toolInvocation: invocation\n            });\n            toolInvocations.push(invocation);\n            break;\n          case \"reasoning\":\n            parts.push({\n              type: \"reasoning\",\n              reasoning: \"\",\n              // leave this blank so we aren't double storing it in the db along with details\n              details: [{ type: \"text\", text: part.text, signature: part.signature }]\n            });\n            break;\n          case \"redacted-reasoning\":\n            parts.push({\n              type: \"reasoning\",\n              reasoning: \"\",\n              // No text reasoning for redacted parts\n              details: [{ type: \"redacted\", data: part.data }]\n            });\n            break;\n          case \"image\":\n            parts.push({ type: \"file\", data: part.image.toString(), mimeType: part.mimeType });\n            break;\n          case \"file\":\n            if (part.data instanceof URL) {\n              parts.push({\n                type: \"file\",\n                data: part.data.toString(),\n                mimeType: part.mimeType\n              });\n            } else {\n              try {\n                parts.push({\n                  type: \"file\",\n                  mimeType: part.mimeType,\n                  data: convertDataContentToBase64String(part.data)\n                });\n              } catch (error) {\n                console.error(`Failed to convert binary data to base64 in CoreMessage file part: ${error}`, error);\n              }\n            }\n            break;\n        }\n      }\n    }\n    const content = {\n      format: 2,\n      parts\n    };\n    if (toolInvocations.length) content.toolInvocations = toolInvocations;\n    if (typeof coreMessage.content === `string`) content.content = coreMessage.content;\n    if (experimentalAttachments.length) content.experimental_attachments = experimentalAttachments;\n    return {\n      id,\n      role: _MessageList.getRole(coreMessage),\n      createdAt: this.generateCreatedAt(messageSource),\n      threadId: this.memoryInfo?.threadId,\n      resourceId: this.memoryInfo?.resourceId,\n      content\n    };\n  }\n  static isVercelUIMessage(msg) {\n    return !_MessageList.isMastraMessage(msg) && isUiMessage(msg);\n  }\n  static isVercelCoreMessage(msg) {\n    return !_MessageList.isMastraMessage(msg) && isCoreMessage(msg);\n  }\n  static isMastraMessage(msg) {\n    return _MessageList.isMastraMessageV2(msg) || _MessageList.isMastraMessageV1(msg);\n  }\n  static isMastraMessageV1(msg) {\n    return !_MessageList.isMastraMessageV2(msg) && (`threadId` in msg || `resourceId` in msg);\n  }\n  static isMastraMessageV2(msg) {\n    return Boolean(\n      msg.content && !Array.isArray(msg.content) && typeof msg.content !== `string` && // any newly saved Mastra message v2 shape will have content: { format: 2 }\n      `format` in msg.content && msg.content.format === 2\n    );\n  }\n  static getRole(message) {\n    if (message.role === `assistant` || message.role === `tool`) return `assistant`;\n    if (message.role === `user`) return `user`;\n    throw new Error(\n      `BUG: add handling for message role ${message.role} in message ${JSON.stringify(message, null, 2)}`\n    );\n  }\n  static cacheKeyFromParts(parts) {\n    let key = ``;\n    for (const part of parts) {\n      key += part.type;\n      if (part.type === `text`) {\n        key += `${part.text.length}${part.text}`;\n      }\n      if (part.type === `tool-invocation`) {\n        key += part.toolInvocation.toolCallId;\n        key += part.toolInvocation.state;\n      }\n      if (part.type === `reasoning`) {\n        key += part.reasoning.length;\n        key += part.details.reduce((prev, current) => {\n          if (current.type === `text`) {\n            return prev + current.text.length + (current.signature?.length || 0);\n          }\n          return prev;\n        }, 0);\n      }\n      if (part.type === `file`) {\n        key += part.data.length;\n        key += part.mimeType;\n      }\n    }\n    return key;\n  }\n  static coreContentToString(content) {\n    if (typeof content === `string`) return content;\n    return content.reduce((p, c) => {\n      if (c.type === `text`) {\n        p += c.text;\n      }\n      return p;\n    }, \"\");\n  }\n  static cacheKeyFromContent(content) {\n    if (typeof content === `string`) return content;\n    let key = ``;\n    for (const part of content) {\n      key += part.type;\n      if (part.type === `text`) {\n        key += part.text.length;\n      }\n      if (part.type === `reasoning`) {\n        key += part.text.length;\n      }\n      if (part.type === `tool-call`) {\n        key += part.toolCallId;\n        key += part.toolName;\n      }\n      if (part.type === `tool-result`) {\n        key += part.toolCallId;\n        key += part.toolName;\n      }\n      if (part.type === `file`) {\n        key += part.filename;\n        key += part.mimeType;\n      }\n      if (part.type === `image`) {\n        key += part.image instanceof URL ? part.image.toString() : part.image.toString().length;\n        key += part.mimeType;\n      }\n      if (part.type === `redacted-reasoning`) {\n        key += part.data.length;\n      }\n    }\n    return key;\n  }\n  static messagesAreEqual(one, two) {\n    const oneUI = _MessageList.isVercelUIMessage(one) && one;\n    const twoUI = _MessageList.isVercelUIMessage(two) && two;\n    if (oneUI && !twoUI) return false;\n    if (oneUI && twoUI) {\n      return _MessageList.cacheKeyFromParts(one.parts) === _MessageList.cacheKeyFromParts(two.parts);\n    }\n    const oneCM = _MessageList.isVercelCoreMessage(one) && one;\n    const twoCM = _MessageList.isVercelCoreMessage(two) && two;\n    if (oneCM && !twoCM) return false;\n    if (oneCM && twoCM) {\n      return _MessageList.cacheKeyFromContent(oneCM.content) === _MessageList.cacheKeyFromContent(twoCM.content);\n    }\n    const oneMM1 = _MessageList.isMastraMessageV1(one) && one;\n    const twoMM1 = _MessageList.isMastraMessageV1(two) && two;\n    if (oneMM1 && !twoMM1) return false;\n    if (oneMM1 && twoMM1) {\n      return oneMM1.id === twoMM1.id && _MessageList.cacheKeyFromContent(oneMM1.content) === _MessageList.cacheKeyFromContent(twoMM1.content);\n    }\n    const oneMM2 = _MessageList.isMastraMessageV2(one) && one;\n    const twoMM2 = _MessageList.isMastraMessageV2(two) && two;\n    if (oneMM2 && !twoMM2) return false;\n    if (oneMM2 && twoMM2) {\n      return oneMM2.id === twoMM2.id && _MessageList.cacheKeyFromParts(oneMM2.content.parts) === _MessageList.cacheKeyFromParts(twoMM2.content.parts);\n    }\n    return true;\n  }\n};\n\nexport { MessageList };\n", "import { isVercelTool } from './chunk-C4LMN2IR.js';\nimport { MastraError } from './chunk-6UNGH46J.js';\nimport { MastraBase } from './chunk-5IEKR756.js';\nimport { RuntimeContext } from './chunk-SGGPJWRQ.js';\nimport { createHash } from 'crypto';\nimport jsonSchemaToZod from 'json-schema-to-zod';\nimport { z } from 'zod';\nimport { convertZodSchemaToAISDKSchema, OpenAIReasoningSchemaCompatLayer, OpenAISchemaCompatLayer, GoogleSchemaCompatLayer, AnthropicSchemaCompatLayer, DeepSeekSchemaCompatLayer, MetaSchemaCompatLayer, applyCompatLayer } from '@mastra/schema-compat';\n\nvar CoreToolBuilder = class extends MastraBase {\n  originalTool;\n  options;\n  logType;\n  constructor(input) {\n    super({ name: \"CoreToolBuilder\" });\n    this.originalTool = input.originalTool;\n    this.options = input.options;\n    this.logType = input.logType;\n  }\n  // Helper to get parameters based on tool type\n  getParameters = () => {\n    if (isVercelTool(this.originalTool)) {\n      return this.originalTool.parameters ?? z.object({});\n    }\n    return this.originalTool.inputSchema ?? z.object({});\n  };\n  getOutputSchema = () => {\n    if (\"outputSchema\" in this.originalTool) return this.originalTool.outputSchema;\n    return null;\n  };\n  // For provider-defined tools, we need to include all required properties\n  buildProviderTool(tool) {\n    if (\"type\" in tool && tool.type === \"provider-defined\" && \"id\" in tool && typeof tool.id === \"string\" && tool.id.includes(\".\")) {\n      const parameters = this.getParameters();\n      const outputSchema = this.getOutputSchema();\n      return {\n        type: \"provider-defined\",\n        id: tool.id,\n        args: \"args\" in this.originalTool ? this.originalTool.args : {},\n        description: tool.description,\n        parameters: convertZodSchemaToAISDKSchema(parameters),\n        ...outputSchema ? { outputSchema: convertZodSchemaToAISDKSchema(outputSchema) } : {},\n        execute: this.originalTool.execute ? this.createExecute(\n          this.originalTool,\n          { ...this.options, description: this.originalTool.description },\n          this.logType\n        ) : void 0\n      };\n    }\n    return void 0;\n  }\n  createLogMessageOptions({ agentName, toolName, type }) {\n    if (!agentName) {\n      return {\n        start: `Executing tool ${toolName}`,\n        error: `Failed tool execution`\n      };\n    }\n    const prefix = `[Agent:${agentName}]`;\n    const toolType = type === \"toolset\" ? \"toolset\" : \"tool\";\n    return {\n      start: `${prefix} - Executing ${toolType} ${toolName}`,\n      error: `${prefix} - Failed ${toolType} execution`\n    };\n  }\n  createExecute(tool, options, logType) {\n    const { logger, mastra: _mastra, memory: _memory, runtimeContext, ...rest } = options;\n    const { start, error } = this.createLogMessageOptions({\n      agentName: options.agentName,\n      toolName: options.name,\n      type: logType\n    });\n    const execFunction = async (args, execOptions) => {\n      if (isVercelTool(tool)) {\n        return tool?.execute?.(args, execOptions) ?? void 0;\n      }\n      return tool?.execute?.(\n        {\n          context: args,\n          threadId: options.threadId,\n          resourceId: options.resourceId,\n          mastra: options.mastra,\n          memory: options.memory,\n          runId: options.runId,\n          runtimeContext: options.runtimeContext ?? new RuntimeContext()\n        },\n        execOptions\n      ) ?? void 0;\n    };\n    return async (args, execOptions) => {\n      let logger2 = options.logger || this.logger;\n      try {\n        logger2.debug(start, { ...rest, args });\n        return await execFunction(args, execOptions);\n      } catch (err) {\n        const mastraError = new MastraError(\n          {\n            id: \"TOOL_EXECUTION_FAILED\",\n            domain: \"TOOL\" /* TOOL */,\n            category: \"USER\" /* USER */,\n            details: {\n              error,\n              args,\n              model: rest.model?.modelId ?? \"\"\n            }\n          },\n          err\n        );\n        logger2.trackException(mastraError);\n        logger2.error(error, { ...rest, error: mastraError, args });\n        return mastraError;\n      }\n    };\n  }\n  build() {\n    const providerTool = this.buildProviderTool(this.originalTool);\n    if (providerTool) {\n      return providerTool;\n    }\n    const definition = {\n      type: \"function\",\n      description: this.originalTool.description,\n      parameters: this.getParameters(),\n      outputSchema: this.getOutputSchema(),\n      execute: this.originalTool.execute ? this.createExecute(\n        this.originalTool,\n        { ...this.options, description: this.originalTool.description },\n        this.logType\n      ) : void 0\n    };\n    const model = this.options.model;\n    const schemaCompatLayers = [];\n    if (model) {\n      schemaCompatLayers.push(\n        new OpenAIReasoningSchemaCompatLayer(model),\n        new OpenAISchemaCompatLayer(model),\n        new GoogleSchemaCompatLayer(model),\n        new AnthropicSchemaCompatLayer(model),\n        new DeepSeekSchemaCompatLayer(model),\n        new MetaSchemaCompatLayer(model)\n      );\n    }\n    const processedSchema = applyCompatLayer({\n      schema: this.getParameters(),\n      compatLayers: schemaCompatLayers,\n      mode: \"aiSdkSchema\"\n    });\n    let processedOutputSchema;\n    if (this.getOutputSchema()) {\n      processedOutputSchema = applyCompatLayer({\n        schema: this.getOutputSchema(),\n        compatLayers: schemaCompatLayers,\n        mode: \"aiSdkSchema\"\n      });\n    }\n    return {\n      ...definition,\n      parameters: processedSchema,\n      outputSchema: processedOutputSchema\n    };\n  }\n};\n\n// src/utils.ts\nvar delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\nfunction deepMerge(target, source) {\n  const output = { ...target };\n  if (!source) return output;\n  Object.keys(source).forEach((key) => {\n    const targetValue = output[key];\n    const sourceValue = source[key];\n    if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {\n      output[key] = sourceValue;\n    } else if (sourceValue instanceof Object && targetValue instanceof Object && !Array.isArray(sourceValue) && !Array.isArray(targetValue)) {\n      output[key] = deepMerge(targetValue, sourceValue);\n    } else if (sourceValue !== void 0) {\n      output[key] = sourceValue;\n    }\n  });\n  return output;\n}\nfunction generateEmptyFromSchema(schema) {\n  try {\n    const parsedSchema = JSON.parse(schema);\n    if (!parsedSchema || parsedSchema.type !== \"object\" || !parsedSchema.properties) return {};\n    const obj = {};\n    const TYPE_DEFAULTS = {\n      string: \"\",\n      array: [],\n      object: {},\n      number: 0,\n      integer: 0,\n      boolean: false\n    };\n    for (const [key, prop] of Object.entries(parsedSchema.properties)) {\n      obj[key] = TYPE_DEFAULTS[prop.type] ?? null;\n    }\n    return obj;\n  } catch {\n    return {};\n  }\n}\nasync function* maskStreamTags(stream, tag, options = {}) {\n  const { onStart, onEnd, onMask } = options;\n  const openTag = `<${tag}>`;\n  const closeTag = `</${tag}>`;\n  let buffer = \"\";\n  let fullContent = \"\";\n  let isMasking = false;\n  let isBuffering = false;\n  const trimOutsideDelimiter = (text, delimiter, trim) => {\n    if (!text.includes(delimiter)) {\n      return text;\n    }\n    const parts = text.split(delimiter);\n    if (trim === `before-start`) {\n      return `${delimiter}${parts[1]}`;\n    }\n    return `${parts[0]}${delimiter}`;\n  };\n  const startsWith = (text, pattern) => {\n    if (pattern.includes(openTag.substring(0, 3))) {\n      pattern = trimOutsideDelimiter(pattern, `<`, `before-start`);\n    }\n    return text.trim().startsWith(pattern.trim());\n  };\n  for await (const chunk of stream) {\n    fullContent += chunk;\n    if (isBuffering) buffer += chunk;\n    const chunkHasTag = startsWith(chunk, openTag);\n    const bufferHasTag = !chunkHasTag && isBuffering && startsWith(openTag, buffer);\n    let toYieldBeforeMaskedStartTag = ``;\n    if (!isMasking && (chunkHasTag || bufferHasTag)) {\n      isMasking = true;\n      isBuffering = false;\n      const taggedTextToMask = trimOutsideDelimiter(buffer, `<`, `before-start`);\n      if (taggedTextToMask !== buffer.trim()) {\n        toYieldBeforeMaskedStartTag = buffer.replace(taggedTextToMask, ``);\n      }\n      buffer = \"\";\n      onStart?.();\n    }\n    if (!isMasking && !isBuffering && startsWith(openTag, chunk) && chunk.trim() !== \"\") {\n      isBuffering = true;\n      buffer += chunk;\n      continue;\n    }\n    if (isBuffering && buffer && !startsWith(openTag, buffer)) {\n      yield buffer;\n      buffer = \"\";\n      isBuffering = false;\n      continue;\n    }\n    if (isMasking && fullContent.includes(closeTag)) {\n      onMask?.(chunk);\n      onEnd?.();\n      isMasking = false;\n      const lastFullContent = fullContent;\n      fullContent = ``;\n      const textUntilEndTag = trimOutsideDelimiter(lastFullContent, closeTag, \"after-end\");\n      if (textUntilEndTag !== lastFullContent) {\n        yield lastFullContent.replace(textUntilEndTag, ``);\n      }\n      continue;\n    }\n    if (isMasking) {\n      onMask?.(chunk);\n      if (toYieldBeforeMaskedStartTag) {\n        yield toYieldBeforeMaskedStartTag;\n      }\n      continue;\n    }\n    yield chunk;\n  }\n}\nfunction resolveSerializedZodOutput(schema) {\n  return Function(\"z\", `\"use strict\";return (${schema});`)(z);\n}\nfunction isZodType(value) {\n  return typeof value === \"object\" && value !== null && \"_def\" in value && \"parse\" in value && typeof value.parse === \"function\" && \"safeParse\" in value && typeof value.safeParse === \"function\";\n}\nfunction createDeterministicId(input) {\n  return createHash(\"sha256\").update(input).digest(\"hex\").slice(0, 8);\n}\nfunction setVercelToolProperties(tool) {\n  const inputSchema = convertVercelToolParameters(tool);\n  const toolId = !(\"id\" in tool) ? tool.description ? `tool-${createDeterministicId(tool.description)}` : `tool-${Math.random().toString(36).substring(2, 9)}` : tool.id;\n  return {\n    ...tool,\n    id: toolId,\n    inputSchema\n  };\n}\nfunction ensureToolProperties(tools) {\n  const toolsWithProperties = Object.keys(tools).reduce((acc, key) => {\n    const tool = tools?.[key];\n    if (tool) {\n      if (isVercelTool(tool)) {\n        acc[key] = setVercelToolProperties(tool);\n      } else {\n        acc[key] = tool;\n      }\n    }\n    return acc;\n  }, {});\n  return toolsWithProperties;\n}\nfunction convertVercelToolParameters(tool) {\n  const schema = tool.parameters ?? z.object({});\n  return isZodType(schema) ? schema : resolveSerializedZodOutput(jsonSchemaToZod(schema));\n}\nfunction makeCoreTool(originalTool, options, logType) {\n  return new CoreToolBuilder({ originalTool, options, logType }).build();\n}\nfunction createMastraProxy({ mastra, logger }) {\n  return new Proxy(mastra, {\n    get(target, prop) {\n      const hasProp = Reflect.has(target, prop);\n      if (hasProp) {\n        const value = Reflect.get(target, prop);\n        const isFunction = typeof value === \"function\";\n        if (isFunction) {\n          return value.bind(target);\n        }\n        return value;\n      }\n      if (prop === \"logger\") {\n        logger.warn(`Please use 'getLogger' instead, logger is deprecated`);\n        return Reflect.apply(target.getLogger, target, []);\n      }\n      if (prop === \"telemetry\") {\n        logger.warn(`Please use 'getTelemetry' instead, telemetry is deprecated`);\n        return Reflect.apply(target.getTelemetry, target, []);\n      }\n      if (prop === \"storage\") {\n        logger.warn(`Please use 'getStorage' instead, storage is deprecated`);\n        return Reflect.get(target, \"storage\");\n      }\n      if (prop === \"agents\") {\n        logger.warn(`Please use 'getAgents' instead, agents is deprecated`);\n        return Reflect.apply(target.getAgents, target, []);\n      }\n      if (prop === \"tts\") {\n        logger.warn(`Please use 'getTTS' instead, tts is deprecated`);\n        return Reflect.apply(target.getTTS, target, []);\n      }\n      if (prop === \"vectors\") {\n        logger.warn(`Please use 'getVectors' instead, vectors is deprecated`);\n        return Reflect.apply(target.getVectors, target, []);\n      }\n      if (prop === \"memory\") {\n        logger.warn(`Please use 'getMemory' instead, memory is deprecated`);\n        return Reflect.get(target, \"memory\");\n      }\n      return Reflect.get(target, prop);\n    }\n  });\n}\nfunction checkEvalStorageFields(traceObject, logger) {\n  const missingFields = [];\n  if (!traceObject.input) missingFields.push(\"input\");\n  if (!traceObject.output) missingFields.push(\"output\");\n  if (!traceObject.agentName) missingFields.push(\"agent_name\");\n  if (!traceObject.metricName) missingFields.push(\"metric_name\");\n  if (!traceObject.instructions) missingFields.push(\"instructions\");\n  if (!traceObject.globalRunId) missingFields.push(\"global_run_id\");\n  if (!traceObject.runId) missingFields.push(\"run_id\");\n  if (missingFields.length > 0) {\n    if (logger) {\n      logger.warn(\"Skipping evaluation storage due to missing required fields\", {\n        missingFields,\n        runId: traceObject.runId,\n        agentName: traceObject.agentName\n      });\n    } else {\n      console.warn(\"Skipping evaluation storage due to missing required fields\", {\n        missingFields,\n        runId: traceObject.runId,\n        agentName: traceObject.agentName\n      });\n    }\n    return false;\n  }\n  return true;\n}\nfunction detectSingleMessageCharacteristics(message) {\n  if (typeof message === \"object\" && message !== null && (message.role === \"function\" || // UI-only role\n  message.role === \"data\" || // UI-only role\n  \"toolInvocations\" in message || // UI-specific field\n  \"parts\" in message || // UI-specific field\n  \"experimental_attachments\" in message)) {\n    return \"has-ui-specific-parts\";\n  } else if (typeof message === \"object\" && message !== null && \"content\" in message && (Array.isArray(message.content) || // Core messages can have array content\n  \"experimental_providerMetadata\" in message || \"providerOptions\" in message)) {\n    return \"has-core-specific-parts\";\n  } else if (typeof message === \"object\" && message !== null && \"role\" in message && \"content\" in message && typeof message.content === \"string\" && [\"system\", \"user\", \"assistant\", \"tool\"].includes(message.role)) {\n    return \"message\";\n  } else {\n    return \"other\";\n  }\n}\nfunction isUiMessage(message) {\n  return detectSingleMessageCharacteristics(message) === `has-ui-specific-parts`;\n}\nfunction isCoreMessage(message) {\n  return [`has-core-specific-parts`, `message`].includes(detectSingleMessageCharacteristics(message));\n}\nvar SQL_IDENTIFIER_PATTERN = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nfunction parseSqlIdentifier(name, kind = \"identifier\") {\n  if (!SQL_IDENTIFIER_PATTERN.test(name) || name.length > 63) {\n    throw new Error(\n      `Invalid ${kind}: ${name}. Must start with a letter or underscore, contain only letters, numbers, or underscores, and be at most 63 characters long.`\n    );\n  }\n  return name;\n}\nfunction parseFieldKey(key) {\n  if (!key) throw new Error(\"Field key cannot be empty\");\n  const segments = key.split(\".\");\n  for (const segment of segments) {\n    if (!SQL_IDENTIFIER_PATTERN.test(segment) || segment.length > 63) {\n      throw new Error(`Invalid field key segment: ${segment} in ${key}`);\n    }\n  }\n  return key;\n}\n\nexport { checkEvalStorageFields, createMastraProxy, deepMerge, delay, ensureToolProperties, generateEmptyFromSchema, isCoreMessage, isUiMessage, isZodType, makeCoreTool, maskStreamTags, parseFieldKey, parseSqlIdentifier, resolveSerializedZodOutput };\n", "// src/tools/tool.ts\nvar Tool = class {\n  id;\n  description;\n  inputSchema;\n  outputSchema;\n  execute;\n  mastra;\n  constructor(opts) {\n    this.id = opts.id;\n    this.description = opts.description;\n    this.inputSchema = opts.inputSchema;\n    this.outputSchema = opts.outputSchema;\n    this.execute = opts.execute;\n    this.mastra = opts.mastra;\n  }\n};\nfunction createTool(opts) {\n  return new Tool(opts);\n}\n\n// src/tools/toolchecks.ts\nfunction isVercelTool(tool) {\n  return !!(tool && !(tool instanceof Tool) && \"parameters\" in tool);\n}\n\nexport { Tool, createTool, isVercelTool };\n", "// src/runtime-context/index.ts\nvar RuntimeContext = class {\n  registry = /* @__PURE__ */ new Map();\n  constructor(iterable) {\n    this.registry = new Map(iterable);\n  }\n  /**\n   * set a value with strict typing if `Values` is a Record and the key exists in it.\n   */\n  set(key, value) {\n    this.registry.set(key, value);\n  }\n  /**\n   * Get a value with its type\n   */\n  get(key) {\n    return this.registry.get(key);\n  }\n  /**\n   * Check if a key exists in the container\n   */\n  has(key) {\n    return this.registry.has(key);\n  }\n  /**\n   * Delete a value by key\n   */\n  delete(key) {\n    return this.registry.delete(key);\n  }\n  /**\n   * Clear all values from the container\n   */\n  clear() {\n    this.registry.clear();\n  }\n  /**\n   * Get all keys in the container\n   */\n  keys() {\n    return this.registry.keys();\n  }\n  /**\n   * Get all values in the container\n   */\n  values() {\n    return this.registry.values();\n  }\n  /**\n   * Get all entries in the container\n   */\n  entries() {\n    return this.registry.entries();\n  }\n  /**\n   * Get the size of the container\n   */\n  size() {\n    return this.registry.size;\n  }\n  /**\n   * Execute a function for each entry in the container\n   */\n  forEach(callbackfn) {\n    this.registry.forEach(callbackfn);\n  }\n};\n\nexport { RuntimeContext };\n", "import {\n  Cipher,\n  Cipheriv,\n  constants,\n  createCipher,\n  createCipheriv,\n  createDecipher,\n  createDecipheriv,\n  createECDH,\n  createSign,\n  createVerify,\n  Decipher,\n  Decipheriv,\n  diffieHellman,\n  ECDH,\n  getCipherInfo,\n  hash,\n  privateDecrypt,\n  privateEncrypt,\n  pseudoRandomBytes,\n  publicDecrypt,\n  publicEncrypt,\n  Sign,\n  sign,\n  webcrypto as unenvCryptoWebcrypto,\n  Verify,\n  verify\n} from \"unenv/node/crypto\";\nexport {\n  Cipher,\n  Cipheriv,\n  Decipher,\n  Decipheriv,\n  ECDH,\n  Sign,\n  Verify,\n  constants,\n  createCipheriv,\n  createDecipheriv,\n  createECDH,\n  createSign,\n  createVerify,\n  diffieHellman,\n  getCipherInfo,\n  hash,\n  privateDecrypt,\n  privateEncrypt,\n  publicDecrypt,\n  publicEncrypt,\n  sign,\n  verify\n} from \"unenv/node/crypto\";\nconst workerdCrypto = process.getBuiltinModule(\"node:crypto\");\nexport const {\n  Certificate,\n  DiffieHellman,\n  DiffieHellmanGroup,\n  Hash,\n  Hmac,\n  KeyObject,\n  X509Certificate,\n  checkPrime,\n  checkPrimeSync,\n  createDiffieHellman,\n  createDiffieHellmanGroup,\n  createHash,\n  createHmac,\n  createPrivateKey,\n  createPublicKey,\n  createSecretKey,\n  generateKey,\n  generateKeyPair,\n  generateKeyPairSync,\n  generateKeySync,\n  generatePrime,\n  generatePrimeSync,\n  getCiphers,\n  getCurves,\n  getDiffieHellman,\n  getFips,\n  getHashes,\n  hkdf,\n  hkdfSync,\n  pbkdf2,\n  pbkdf2Sync,\n  randomBytes,\n  randomFill,\n  randomFillSync,\n  randomInt,\n  randomUUID,\n  scrypt,\n  scryptSync,\n  secureHeapUsed,\n  setEngine,\n  setFips,\n  subtle,\n  timingSafeEqual\n} = workerdCrypto;\nexport const getRandomValues = workerdCrypto.getRandomValues.bind(\n  workerdCrypto.webcrypto\n);\nexport const webcrypto = {\n  // @ts-expect-error unenv has unknown type\n  CryptoKey: unenvCryptoWebcrypto.CryptoKey,\n  getRandomValues,\n  randomUUID,\n  subtle\n};\nconst fips = workerdCrypto.fips;\nexport default {\n  /**\n   * manually unroll unenv-polyfilled-symbols to make it tree-shakeable\n   */\n  Certificate,\n  Cipher,\n  Cipheriv,\n  Decipher,\n  Decipheriv,\n  ECDH,\n  Sign,\n  Verify,\n  X509Certificate,\n  // @ts-expect-error @types/node is out of date - this is a bug in typings\n  constants,\n  // @ts-expect-error unenv has unknown type\n  createCipheriv,\n  // @ts-expect-error unenv has unknown type\n  createDecipheriv,\n  // @ts-expect-error unenv has unknown type\n  createECDH,\n  // @ts-expect-error unenv has unknown type\n  createSign,\n  // @ts-expect-error unenv has unknown type\n  createVerify,\n  // @ts-expect-error unenv has unknown type\n  diffieHellman,\n  // @ts-expect-error unenv has unknown type\n  getCipherInfo,\n  // @ts-expect-error unenv has unknown type\n  hash,\n  // @ts-expect-error unenv has unknown type\n  privateDecrypt,\n  // @ts-expect-error unenv has unknown type\n  privateEncrypt,\n  // @ts-expect-error unenv has unknown type\n  publicDecrypt,\n  // @ts-expect-error unenv has unknown type\n  publicEncrypt,\n  scrypt,\n  scryptSync,\n  // @ts-expect-error unenv has unknown type\n  sign,\n  // @ts-expect-error unenv has unknown type\n  verify,\n  // default-only export from unenv\n  // @ts-expect-error unenv has unknown type\n  createCipher,\n  // @ts-expect-error unenv has unknown type\n  createDecipher,\n  // @ts-expect-error unenv has unknown type\n  pseudoRandomBytes,\n  /**\n   * manually unroll workerd-polyfilled-symbols to make it tree-shakeable\n   */\n  DiffieHellman,\n  DiffieHellmanGroup,\n  Hash,\n  Hmac,\n  KeyObject,\n  checkPrime,\n  checkPrimeSync,\n  createDiffieHellman,\n  createDiffieHellmanGroup,\n  createHash,\n  createHmac,\n  createPrivateKey,\n  createPublicKey,\n  createSecretKey,\n  generateKey,\n  generateKeyPair,\n  generateKeyPairSync,\n  generateKeySync,\n  generatePrime,\n  generatePrimeSync,\n  getCiphers,\n  getCurves,\n  getDiffieHellman,\n  getFips,\n  getHashes,\n  getRandomValues,\n  hkdf,\n  hkdfSync,\n  pbkdf2,\n  pbkdf2Sync,\n  randomBytes,\n  randomFill,\n  randomFillSync,\n  randomInt,\n  randomUUID,\n  secureHeapUsed,\n  setEngine,\n  setFips,\n  subtle,\n  timingSafeEqual,\n  // default-only export from workerd\n  fips,\n  // special-cased deep merged symbols\n  webcrypto\n};\n", "import { notImplemented, notImplementedClass } from \"../../../_internal/utils.mjs\";\nimport { getRandomValues } from \"./web.mjs\";\nconst MAX_RANDOM_VALUE_BYTES = 65536;\nexport const webcrypto = new Proxy(globalThis.crypto, { get(_, key) {\n\tif (key === \"CryptoKey\") {\n\t\treturn globalThis.CryptoKey;\n\t}\n\tif (typeof globalThis.crypto[key] === \"function\") {\n\t\treturn globalThis.crypto[key].bind(globalThis.crypto);\n\t}\n\treturn globalThis.crypto[key];\n} });\nexport const randomBytes = (size, cb) => {\n\tconst bytes = Buffer.alloc(size, 0, undefined);\n\tfor (let generated = 0; generated < size; generated += MAX_RANDOM_VALUE_BYTES) {\n\t\tgetRandomValues(\n\t\t\t// Use subarray to get a view of the buffer\n\t\t\tUint8Array.prototype.subarray.call(bytes, generated, generated + MAX_RANDOM_VALUE_BYTES)\n);\n\t}\n\tif (typeof cb === \"function\") {\n\t\tcb(null, bytes);\n\t\treturn undefined;\n\t}\n\treturn bytes;\n};\nexport const rng = randomBytes;\nexport const prng = randomBytes;\nexport const fips = false;\nexport const checkPrime = /*@__PURE__*/ notImplemented(\"crypto.checkPrime\");\nexport const checkPrimeSync = /*@__PURE__*/ notImplemented(\"crypto.checkPrimeSync\");\n/** @deprecated */\nexport const createCipher = /*@__PURE__*/ notImplemented(\"crypto.createCipher\");\n/** @deprecated */\nexport const createDecipher = /*@__PURE__*/ notImplemented(\"crypto.createDecipher\");\nexport const pseudoRandomBytes = /*@__PURE__*/ notImplemented(\"crypto.pseudoRandomBytes\");\nexport const createCipheriv = /*@__PURE__*/ notImplemented(\"crypto.createCipheriv\");\nexport const createDecipheriv = /*@__PURE__*/ notImplemented(\"crypto.createDecipheriv\");\nexport const createDiffieHellman = /*@__PURE__*/ notImplemented(\"crypto.createDiffieHellman\");\nexport const createDiffieHellmanGroup = /*@__PURE__*/ notImplemented(\"crypto.createDiffieHellmanGroup\");\nexport const createECDH = /*@__PURE__*/ notImplemented(\"crypto.createECDH\");\nexport const createHash = /*@__PURE__*/ notImplemented(\"crypto.createHash\");\nexport const createHmac = /*@__PURE__*/ notImplemented(\"crypto.createHmac\");\nexport const createPrivateKey = /*@__PURE__*/ notImplemented(\"crypto.createPrivateKey\");\nexport const createPublicKey = /*@__PURE__*/ notImplemented(\"crypto.createPublicKey\");\nexport const createSecretKey = /*@__PURE__*/ notImplemented(\"crypto.createSecretKey\");\nexport const createSign = /*@__PURE__*/ notImplemented(\"crypto.createSign\");\nexport const createVerify = /*@__PURE__*/ notImplemented(\"crypto.createVerify\");\nexport const diffieHellman = /*@__PURE__*/ notImplemented(\"crypto.diffieHellman\");\nexport const generatePrime = /*@__PURE__*/ notImplemented(\"crypto.generatePrime\");\nexport const generatePrimeSync = /*@__PURE__*/ notImplemented(\"crypto.generatePrimeSync\");\nexport const getCiphers = /*@__PURE__*/ notImplemented(\"crypto.getCiphers\");\nexport const getCipherInfo = /*@__PURE__*/ notImplemented(\"crypto.getCipherInfo\");\nexport const getCurves = /*@__PURE__*/ notImplemented(\"crypto.getCurves\");\nexport const getDiffieHellman = /*@__PURE__*/ notImplemented(\"crypto.getDiffieHellman\");\nexport const getHashes = /*@__PURE__*/ notImplemented(\"crypto.getHashes\");\nexport const hkdf = /*@__PURE__*/ notImplemented(\"crypto.hkdf\");\nexport const hkdfSync = /*@__PURE__*/ notImplemented(\"crypto.hkdfSync\");\nexport const pbkdf2 = /*@__PURE__*/ notImplemented(\"crypto.pbkdf2\");\nexport const pbkdf2Sync = /*@__PURE__*/ notImplemented(\"crypto.pbkdf2Sync\");\nexport const generateKeyPair = /*@__PURE__*/ notImplemented(\"crypto.generateKeyPair\");\nexport const generateKeyPairSync = /*@__PURE__*/ notImplemented(\"crypto.generateKeyPairSync\");\nexport const generateKey = /*@__PURE__*/ notImplemented(\"crypto.generateKey\");\nexport const generateKeySync = /*@__PURE__*/ notImplemented(\"crypto.generateKeySync\");\nexport const privateDecrypt = /*@__PURE__*/ notImplemented(\"crypto.privateDecrypt\");\nexport const privateEncrypt = /*@__PURE__*/ notImplemented(\"crypto.privateEncrypt\");\nexport const publicDecrypt = /*@__PURE__*/ notImplemented(\"crypto.publicDecrypt\");\nexport const publicEncrypt = /*@__PURE__*/ notImplemented(\"crypto.publicEncrypt\");\nexport const randomFill = /*@__PURE__*/ notImplemented(\"crypto.randomFill\");\nexport const randomFillSync = /*@__PURE__*/ notImplemented(\"crypto.randomFillSync\");\nexport const randomInt = /*@__PURE__*/ notImplemented(\"crypto.randomInt\");\nexport const scrypt = /*@__PURE__*/ notImplemented(\"crypto.scrypt\");\nexport const scryptSync = /*@__PURE__*/ notImplemented(\"crypto.scryptSync\");\nexport const sign = /*@__PURE__*/ notImplemented(\"crypto.sign\");\nexport const setEngine = /*@__PURE__*/ notImplemented(\"crypto.setEngine\");\nexport const timingSafeEqual = /*@__PURE__*/ notImplemented(\"crypto.timingSafeEqual\");\nexport const getFips = /*@__PURE__*/ notImplemented(\"crypto.getFips\");\nexport const setFips = /*@__PURE__*/ notImplemented(\"crypto.setFips\");\nexport const verify = /*@__PURE__*/ notImplemented(\"crypto.verify\");\nexport const secureHeapUsed = /*@__PURE__*/ notImplemented(\"crypto.secureHeapUsed\");\nexport const hash = /*@__PURE__*/ notImplemented(\"crypto.hash\");\nexport const Certificate = /*@__PURE__*/ notImplementedClass(\"crypto.Certificate\");\nexport const Cipher = /*@__PURE__*/ notImplementedClass(\"crypto.Cipher\");\nexport const Cipheriv = /*@__PURE__*/ notImplementedClass(\n\t\"crypto.Cipheriv\"\n\t// @ts-expect-error not typed yet\n);\nexport const Decipher = /*@__PURE__*/ notImplementedClass(\"crypto.Decipher\");\nexport const Decipheriv = /*@__PURE__*/ notImplementedClass(\n\t\"crypto.Decipheriv\"\n\t// @ts-expect-error not typed yet\n);\nexport const DiffieHellman = /*@__PURE__*/ notImplementedClass(\"crypto.DiffieHellman\");\nexport const DiffieHellmanGroup = /*@__PURE__*/ notImplementedClass(\"crypto.DiffieHellmanGroup\");\nexport const ECDH = /*@__PURE__*/ notImplementedClass(\"crypto.ECDH\");\nexport const Hash = /*@__PURE__*/ notImplementedClass(\"crypto.Hash\");\nexport const Hmac = /*@__PURE__*/ notImplementedClass(\"crypto.Hmac\");\nexport const KeyObject = /*@__PURE__*/ notImplementedClass(\"crypto.KeyObject\");\nexport const Sign = /*@__PURE__*/ notImplementedClass(\"crypto.Sign\");\nexport const Verify = /*@__PURE__*/ notImplementedClass(\"crypto.Verify\");\nexport const X509Certificate = /*@__PURE__*/ notImplementedClass(\"crypto.X509Certificate\");\n", "export * from \"./Types.js\";\nexport * from \"./jsonSchemaToZod.js\";\nexport * from \"./parsers/parseAllOf.js\";\nexport * from \"./parsers/parseAnyOf.js\";\nexport * from \"./parsers/parseArray.js\";\nexport * from \"./parsers/parseBoolean.js\";\nexport * from \"./parsers/parseConst.js\";\nexport * from \"./parsers/parseDefault.js\";\nexport * from \"./parsers/parseEnum.js\";\nexport * from \"./parsers/parseIfThenElse.js\";\nexport * from \"./parsers/parseMultipleType.js\";\nexport * from \"./parsers/parseNot.js\";\nexport * from \"./parsers/parseNull.js\";\nexport * from \"./parsers/parseNullable.js\";\nexport * from \"./parsers/parseNumber.js\";\nexport * from \"./parsers/parseObject.js\";\nexport * from \"./parsers/parseOneOf.js\";\nexport * from \"./parsers/parseSchema.js\";\nexport * from \"./parsers/parseSimpleDiscriminatedOneOf.js\";\nexport * from \"./parsers/parseString.js\";\nexport * from \"./utils/half.js\";\nexport * from \"./utils/jsdocs.js\";\nexport * from \"./utils/omit.js\";\nexport * from \"./utils/withMessage.js\";\nimport { jsonSchemaToZod } from \"./jsonSchemaToZod.js\";\nexport default jsonSchemaToZod;\n", "export {};\n", "import { parseSchema } from \"./parsers/parseSchema.js\";\nimport { expandJsdocs } from \"./utils/jsdocs.js\";\nexport const jsonSchemaToZod = (schema, { module, name, type, noImport, ...rest } = {}) => {\n    if (type && (!name || module !== \"esm\")) {\n        throw new Error(\"Option `type` requires `name` to be set and `module` to be `esm`\");\n    }\n    let result = parseSchema(schema, {\n        module,\n        name,\n        path: [],\n        seen: new Map(),\n        ...rest,\n    });\n    const jsdocs = rest.withJsdocs && typeof schema !== \"boolean\" && schema.description\n        ? expandJsdocs(schema.description)\n        : \"\";\n    if (module === \"cjs\") {\n        result = `${jsdocs}module.exports = ${name ? `{ ${JSON.stringify(name)}: ${result} }` : result}\n`;\n        if (!noImport) {\n            result = `${jsdocs}const { z } = require(\"zod\")\n\n${result}`;\n        }\n    }\n    else if (module === \"esm\") {\n        result = `${jsdocs}export ${name ? `const ${name} =` : `default`} ${result}\n`;\n        if (!noImport) {\n            result = `import { z } from \"zod\"\n\n${result}`;\n        }\n    }\n    else if (name) {\n        result = `${jsdocs}const ${name} = ${result}`;\n    }\n    if (type && name) {\n        let typeName = typeof type === \"string\"\n            ? type\n            : `${name[0].toUpperCase()}${name.substring(1)}`;\n        result += `export type ${typeName} = z.infer<typeof ${name}>\n`;\n    }\n    return result;\n};\n", "import { parseAnyOf } from \"./parseAnyOf.js\";\nimport { parseBoolean } from \"./parseBoolean.js\";\nimport { parseDefault } from \"./parseDefault.js\";\nimport { parseMultipleType } from \"./parseMultipleType.js\";\nimport { parseNot } from \"./parseNot.js\";\nimport { parseNull } from \"./parseNull.js\";\nimport { parseAllOf } from \"./parseAllOf.js\";\nimport { parseArray } from \"./parseArray.js\";\nimport { parseConst } from \"./parseConst.js\";\nimport { parseEnum } from \"./parseEnum.js\";\nimport { parseIfThenElse } from \"./parseIfThenElse.js\";\nimport { parseNumber } from \"./parseNumber.js\";\nimport { parseObject } from \"./parseObject.js\";\nimport { parseString } from \"./parseString.js\";\nimport { parseOneOf } from \"./parseOneOf.js\";\nimport { parseSimpleDiscriminatedOneOf } from \"./parseSimpleDiscriminatedOneOf.js\";\nimport { parseNullable } from \"./parseNullable.js\";\nexport const parseSchema = (schema, refs = { seen: new Map(), path: [] }, blockMeta) => {\n    if (typeof schema !== \"object\")\n        return schema ? \"z.any()\" : \"z.never()\";\n    if (refs.parserOverride) {\n        const custom = refs.parserOverride(schema, refs);\n        if (typeof custom === \"string\") {\n            return custom;\n        }\n    }\n    let seen = refs.seen.get(schema);\n    if (seen) {\n        if (seen.r !== undefined) {\n            return seen.r;\n        }\n        if (refs.depth === undefined || seen.n >= refs.depth) {\n            return \"z.any()\";\n        }\n        seen.n += 1;\n    }\n    else {\n        seen = { r: undefined, n: 0 };\n        refs.seen.set(schema, seen);\n    }\n    let parsed = selectParser(schema, refs);\n    if (!blockMeta) {\n        if (!refs.withoutDescribes) {\n            parsed = addDescribes(schema, parsed);\n        }\n        if (!refs.withoutDefaults) {\n            parsed = addDefaults(schema, parsed);\n        }\n        parsed = addAnnotations(schema, parsed);\n    }\n    seen.r = parsed;\n    return parsed;\n};\nconst addDescribes = (schema, parsed) => {\n    if (schema.description) {\n        parsed += `.describe(${JSON.stringify(schema.description)})`;\n    }\n    return parsed;\n};\nconst addDefaults = (schema, parsed) => {\n    if (schema.default !== undefined) {\n        parsed += `.default(${JSON.stringify(schema.default)})`;\n    }\n    return parsed;\n};\nconst addAnnotations = (schema, parsed) => {\n    if (schema.readOnly) {\n        parsed += \".readonly()\";\n    }\n    return parsed;\n};\nconst selectParser = (schema, refs) => {\n    if (its.a.nullable(schema)) {\n        return parseNullable(schema, refs);\n    }\n    else if (its.an.object(schema)) {\n        return parseObject(schema, refs);\n    }\n    else if (its.an.array(schema)) {\n        return parseArray(schema, refs);\n    }\n    else if (its.an.anyOf(schema)) {\n        return parseAnyOf(schema, refs);\n    }\n    else if (its.an.allOf(schema)) {\n        return parseAllOf(schema, refs);\n    }\n    else if (its.a.simpleDiscriminatedOneOf(schema)) {\n        return parseSimpleDiscriminatedOneOf(schema, refs);\n    }\n    else if (its.a.oneOf(schema)) {\n        return parseOneOf(schema, refs);\n    }\n    else if (its.a.not(schema)) {\n        return parseNot(schema, refs);\n    }\n    else if (its.an.enum(schema)) {\n        return parseEnum(schema); //<-- needs to come before primitives\n    }\n    else if (its.a.const(schema)) {\n        return parseConst(schema);\n    }\n    else if (its.a.multipleType(schema)) {\n        return parseMultipleType(schema, refs);\n    }\n    else if (its.a.primitive(schema, \"string\")) {\n        return parseString(schema);\n    }\n    else if (its.a.primitive(schema, \"number\") ||\n        its.a.primitive(schema, \"integer\")) {\n        return parseNumber(schema);\n    }\n    else if (its.a.primitive(schema, \"boolean\")) {\n        return parseBoolean(schema);\n    }\n    else if (its.a.primitive(schema, \"null\")) {\n        return parseNull(schema);\n    }\n    else if (its.a.conditional(schema)) {\n        return parseIfThenElse(schema, refs);\n    }\n    else {\n        return parseDefault(schema);\n    }\n};\nexport const its = {\n    an: {\n        object: (x) => x.type === \"object\",\n        array: (x) => x.type === \"array\",\n        anyOf: (x) => x.anyOf !== undefined,\n        allOf: (x) => x.allOf !== undefined,\n        enum: (x) => x.enum !== undefined,\n    },\n    a: {\n        nullable: (x) => x.nullable === true,\n        multipleType: (x) => Array.isArray(x.type),\n        not: (x) => x.not !== undefined,\n        const: (x) => x.const !== undefined,\n        primitive: (x, p) => x.type === p,\n        conditional: (x) => Boolean(\"if\" in x && x.if && \"then\" in x && \"else\" in x && x.then && x.else),\n        simpleDiscriminatedOneOf: (x) => {\n            if (!x.oneOf ||\n                !Array.isArray(x.oneOf) ||\n                x.oneOf.length === 0 ||\n                !x.discriminator ||\n                typeof x.discriminator !== \"object\" ||\n                !(\"propertyName\" in x.discriminator) ||\n                typeof x.discriminator.propertyName !== \"string\") {\n                return false;\n            }\n            const discriminatorProp = x.discriminator.propertyName;\n            return x.oneOf.every((schema) => {\n                if (!schema ||\n                    typeof schema !== \"object\" ||\n                    schema.type !== \"object\" ||\n                    !schema.properties ||\n                    typeof schema.properties !== \"object\" ||\n                    !(discriminatorProp in schema.properties)) {\n                    return false;\n                }\n                const property = schema.properties[discriminatorProp];\n                return (property &&\n                    typeof property === \"object\" &&\n                    property.type === \"string\" &&\n                    // Ensure discriminator has a constant value (const or single-value enum)\n                    (property.const !== undefined ||\n                        (property.enum && Array.isArray(property.enum) && property.enum.length === 1)) &&\n                    // Ensure discriminator property is required\n                    Array.isArray(schema.required) &&\n                    schema.required.includes(discriminatorProp));\n            });\n        },\n        oneOf: (x) => x.oneOf !== undefined,\n    },\n};\n", "import { parseSchema } from \"./parseSchema.js\";\nexport const parseAnyOf = (schema, refs) => {\n    return schema.anyOf.length\n        ? schema.anyOf.length === 1\n            ? parseSchema(schema.anyOf[0], {\n                ...refs,\n                path: [...refs.path, \"anyOf\", 0],\n            })\n            : `z.union([${schema.anyOf\n                .map((schema, i) => parseSchema(schema, { ...refs, path: [...refs.path, \"anyOf\", i] }))\n                .join(\", \")}])`\n        : `z.any()`;\n};\n", "export const parseBoolean = (_schema) => {\n    return \"z.boolean()\";\n};\n", "export const parseDefault = (_schema) => {\n    return \"z.any()\";\n};\n", "import { parseSchema } from \"./parseSchema.js\";\nexport const parseMultipleType = (schema, refs) => {\n    return `z.union([${schema.type\n        .map((type) => parseSchema({ ...schema, type }, { ...refs, withoutDefaults: true }))\n        .join(\", \")}])`;\n};\n", "import { parseSchema } from \"./parseSchema.js\";\nexport const parseNot = (schema, refs) => {\n    return `z.any().refine((value) => !${parseSchema(schema.not, {\n        ...refs,\n        path: [...refs.path, \"not\"],\n    })}.safeParse(value).success, \"Invalid input: Should NOT be valid against schema\")`;\n};\n", "export const parseNull = (_schema) => {\n    return \"z.null()\";\n};\n", "import { parseSchema } from \"./parseSchema.js\";\nimport { half } from \"../utils/half.js\";\nconst originalIndex = Symbol(\"Original index\");\nconst ensureOriginalIndex = (arr) => {\n    let newArr = [];\n    for (let i = 0; i < arr.length; i++) {\n        const item = arr[i];\n        if (typeof item === \"boolean\") {\n            newArr.push(item ? { [originalIndex]: i } : { [originalIndex]: i, not: {} });\n        }\n        else if (originalIndex in item) {\n            return arr;\n        }\n        else {\n            newArr.push({ ...item, [originalIndex]: i });\n        }\n    }\n    return newArr;\n};\nexport function parseAllOf(schema, refs) {\n    if (schema.allOf.length === 0) {\n        return \"z.never()\";\n    }\n    else if (schema.allOf.length === 1) {\n        const item = schema.allOf[0];\n        return parseSchema(item, {\n            ...refs,\n            path: [...refs.path, \"allOf\", item[originalIndex]],\n        });\n    }\n    else {\n        const [left, right] = half(ensureOriginalIndex(schema.allOf));\n        return `z.intersection(${parseAllOf({ allOf: left }, refs)}, ${parseAllOf({\n            allOf: right,\n        }, refs)})`;\n    }\n}\n", "export const half = (arr) => {\n    return [arr.slice(0, arr.length / 2), arr.slice(arr.length / 2)];\n};\n", "import { withMessage } from \"../utils/withMessage.js\";\nimport { parseSchema } from \"./parseSchema.js\";\nexport const parseArray = (schema, refs) => {\n    if (Array.isArray(schema.items)) {\n        return `z.tuple([${schema.items.map((v, i) => parseSchema(v, { ...refs, path: [...refs.path, \"items\", i] }))}])`;\n    }\n    let r = !schema.items\n        ? \"z.array(z.any())\"\n        : `z.array(${parseSchema(schema.items, {\n            ...refs,\n            path: [...refs.path, \"items\"],\n        })})`;\n    r += withMessage(schema, \"minItems\", ({ json }) => [\n        `.min(${json}`,\n        \", \",\n        \")\",\n    ]);\n    r += withMessage(schema, \"maxItems\", ({ json }) => [\n        `.max(${json}`,\n        \", \",\n        \")\",\n    ]);\n    if (schema.uniqueItems === true) {\n        r += withMessage(schema, \"uniqueItems\", () => [\n            \".unique(\",\n            \"\",\n            \")\",\n        ]);\n    }\n    return r;\n};\n", "export function withMessage(schema, key, get) {\n    const value = schema[key];\n    let r = \"\";\n    if (value !== undefined) {\n        const got = get({ value, json: JSON.stringify(value) });\n        if (got) {\n            const opener = got[0];\n            const prefix = got.length === 3 ? got[1] : \"\";\n            const closer = got.length === 3 ? got[2] : got[1];\n            r += opener;\n            if (schema.errorMessage?.[key] !== undefined) {\n                r += prefix + JSON.stringify(schema.errorMessage[key]);\n            }\n            r;\n            r += closer;\n        }\n    }\n    return r;\n}\n", "export const parseConst = (schema) => {\n    return `z.literal(${JSON.stringify(schema.const)})`;\n};\n", "export const parseEnum = (schema) => {\n    if (schema.enum.length === 0) {\n        return \"z.never()\";\n    }\n    else if (schema.enum.length === 1) {\n        // union does not work when there is only one element\n        return `z.literal(${JSON.stringify(schema.enum[0])})`;\n    }\n    else if (schema.enum.every((x) => typeof x === \"string\")) {\n        return `z.enum([${schema.enum.map((x) => JSON.stringify(x))}])`;\n    }\n    else {\n        return `z.union([${schema.enum\n            .map((x) => `z.literal(${JSON.stringify(x)})`)\n            .join(\", \")}])`;\n    }\n};\n", "import { parseSchema } from \"./parseSchema.js\";\nexport const parseIfThenElse = (schema, refs) => {\n    const $if = parseSchema(schema.if, { ...refs, path: [...refs.path, \"if\"] });\n    const $then = parseSchema(schema.then, {\n        ...refs,\n        path: [...refs.path, \"then\"],\n    });\n    const $else = parseSchema(schema.else, {\n        ...refs,\n        path: [...refs.path, \"else\"],\n    });\n    return `z.union([${$then}, ${$else}]).superRefine((value,ctx) => {\n  const result = ${$if}.safeParse(value).success\n    ? ${$then}.safeParse(value)\n    : ${$else}.safeParse(value);\n  if (!result.success) {\n    result.error.errors.forEach((error) => ctx.addIssue(error))\n  }\n})`;\n};\n", "import { withMessage } from \"../utils/withMessage.js\";\nexport const parseNumber = (schema) => {\n    let r = \"z.number()\";\n    if (schema.type === \"integer\") {\n        r += withMessage(schema, \"type\", () => [\".int(\", \")\"]);\n    }\n    else {\n        r += withMessage(schema, \"format\", ({ value }) => {\n            if (value === \"int64\") {\n                return [\".int(\", \")\"];\n            }\n        });\n    }\n    r += withMessage(schema, \"multipleOf\", ({ value, json }) => {\n        if (value === 1) {\n            if (r.startsWith(\"z.number().int(\")) {\n                return;\n            }\n            return [\".int(\", \")\"];\n        }\n        return [`.multipleOf(${json}`, \", \", \")\"];\n    });\n    if (typeof schema.minimum === \"number\") {\n        if (schema.exclusiveMinimum === true) {\n            r += withMessage(schema, \"minimum\", ({ json }) => [\n                `.gt(${json}`,\n                \", \",\n                \")\",\n            ]);\n        }\n        else {\n            r += withMessage(schema, \"minimum\", ({ json }) => [\n                `.gte(${json}`,\n                \", \",\n                \")\",\n            ]);\n        }\n    }\n    else if (typeof schema.exclusiveMinimum === \"number\") {\n        r += withMessage(schema, \"exclusiveMinimum\", ({ json }) => [\n            `.gt(${json}`,\n            \", \",\n            \")\",\n        ]);\n    }\n    if (typeof schema.maximum === \"number\") {\n        if (schema.exclusiveMaximum === true) {\n            r += withMessage(schema, \"maximum\", ({ json }) => [\n                `.lt(${json}`,\n                \", \",\n                \")\",\n            ]);\n        }\n        else {\n            r += withMessage(schema, \"maximum\", ({ json }) => [\n                `.lte(${json}`,\n                \", \",\n                \")\",\n            ]);\n        }\n    }\n    else if (typeof schema.exclusiveMaximum === \"number\") {\n        r += withMessage(schema, \"exclusiveMaximum\", ({ json }) => [\n            `.lt(${json}`,\n            \", \",\n            \")\",\n        ]);\n    }\n    return r;\n};\n", "import { parseAnyOf } from \"./parseAnyOf.js\";\nimport { parseOneOf } from \"./parseOneOf.js\";\nimport { its, parseSchema } from \"./parseSchema.js\";\nimport { parseAllOf } from \"./parseAllOf.js\";\nimport { addJsdocs } from \"../utils/jsdocs.js\";\nexport function parseObject(objectSchema, refs) {\n    let properties = undefined;\n    if (objectSchema.properties) {\n        if (!Object.keys(objectSchema.properties).length) {\n            properties = \"z.object({})\";\n        }\n        else {\n            properties = \"z.object({ \";\n            properties += Object.keys(objectSchema.properties)\n                .map((key) => {\n                const propSchema = objectSchema.properties[key];\n                let result = `${JSON.stringify(key)}: ${parseSchema(propSchema, {\n                    ...refs,\n                    path: [...refs.path, \"properties\", key],\n                })}`;\n                if (refs.withJsdocs && typeof propSchema === \"object\") {\n                    result = addJsdocs(propSchema, result);\n                }\n                const hasDefault = typeof propSchema === \"object\" && propSchema.default !== undefined;\n                const required = Array.isArray(objectSchema.required)\n                    ? objectSchema.required.includes(key)\n                    : typeof propSchema === \"object\" && propSchema.required === true;\n                const optional = !hasDefault && !required;\n                return optional ? `${result}.optional()` : result;\n            })\n                .join(\", \");\n            properties += \" })\";\n        }\n    }\n    const additionalProperties = objectSchema.additionalProperties !== undefined\n        ? parseSchema(objectSchema.additionalProperties, {\n            ...refs,\n            path: [...refs.path, \"additionalProperties\"],\n        })\n        : undefined;\n    let patternProperties = undefined;\n    if (objectSchema.patternProperties) {\n        const parsedPatternProperties = Object.fromEntries(Object.entries(objectSchema.patternProperties).map(([key, value]) => {\n            return [\n                key,\n                parseSchema(value, {\n                    ...refs,\n                    path: [...refs.path, \"patternProperties\", key],\n                }),\n            ];\n        }, {}));\n        patternProperties = \"\";\n        if (properties) {\n            if (additionalProperties) {\n                patternProperties += `.catchall(z.union([${[\n                    ...Object.values(parsedPatternProperties),\n                    additionalProperties,\n                ].join(\", \")}]))`;\n            }\n            else if (Object.keys(parsedPatternProperties).length > 1) {\n                patternProperties += `.catchall(z.union([${Object.values(parsedPatternProperties).join(\", \")}]))`;\n            }\n            else {\n                patternProperties += `.catchall(${Object.values(parsedPatternProperties)})`;\n            }\n        }\n        else {\n            if (additionalProperties) {\n                patternProperties += `z.record(z.union([${[\n                    ...Object.values(parsedPatternProperties),\n                    additionalProperties,\n                ].join(\", \")}]))`;\n            }\n            else if (Object.keys(parsedPatternProperties).length > 1) {\n                patternProperties += `z.record(z.union([${Object.values(parsedPatternProperties).join(\", \")}]))`;\n            }\n            else {\n                patternProperties += `z.record(${Object.values(parsedPatternProperties)})`;\n            }\n        }\n        patternProperties += \".superRefine((value, ctx) => {\\n\";\n        patternProperties += \"for (const key in value) {\\n\";\n        if (additionalProperties) {\n            if (objectSchema.properties) {\n                patternProperties += `let evaluated = [${Object.keys(objectSchema.properties)\n                    .map((key) => JSON.stringify(key))\n                    .join(\", \")}].includes(key)\\n`;\n            }\n            else {\n                patternProperties += `let evaluated = false\\n`;\n            }\n        }\n        for (const key in objectSchema.patternProperties) {\n            patternProperties +=\n                \"if (key.match(new RegExp(\" + JSON.stringify(key) + \"))) {\\n\";\n            if (additionalProperties) {\n                patternProperties += \"evaluated = true\\n\";\n            }\n            patternProperties +=\n                \"const result = \" +\n                    parsedPatternProperties[key] +\n                    \".safeParse(value[key])\\n\";\n            patternProperties += \"if (!result.success) {\\n\";\n            patternProperties += `ctx.addIssue({\n          path: [...ctx.path, key],\n          code: 'custom',\n          message: \\`Invalid input: Key matching regex /\\${key}/ must match schema\\`,\n          params: {\n            issues: result.error.issues\n          }\n        })\\n`;\n            patternProperties += \"}\\n\";\n            patternProperties += \"}\\n\";\n        }\n        if (additionalProperties) {\n            patternProperties += \"if (!evaluated) {\\n\";\n            patternProperties +=\n                \"const result = \" + additionalProperties + \".safeParse(value[key])\\n\";\n            patternProperties += \"if (!result.success) {\\n\";\n            patternProperties += `ctx.addIssue({\n          path: [...ctx.path, key],\n          code: 'custom',\n          message: \\`Invalid input: must match catchall schema\\`,\n          params: {\n            issues: result.error.issues\n          }\n        })\\n`;\n            patternProperties += \"}\\n\";\n            patternProperties += \"}\\n\";\n        }\n        patternProperties += \"}\\n\";\n        patternProperties += \"})\";\n    }\n    let output = properties\n        ? patternProperties\n            ? properties + patternProperties\n            : additionalProperties\n                ? additionalProperties === \"z.never()\"\n                    ? properties + \".strict()\"\n                    : properties + `.catchall(${additionalProperties})`\n                : properties\n        : patternProperties\n            ? patternProperties\n            : additionalProperties\n                ? `z.record(${additionalProperties})`\n                : \"z.record(z.any())\";\n    if (its.an.anyOf(objectSchema)) {\n        output += `.and(${parseAnyOf({\n            ...objectSchema,\n            anyOf: objectSchema.anyOf.map((x) => typeof x === \"object\" &&\n                !x.type &&\n                (x.properties || x.additionalProperties || x.patternProperties)\n                ? { ...x, type: \"object\" }\n                : x),\n        }, refs)})`;\n    }\n    if (its.a.oneOf(objectSchema)) {\n        output += `.and(${parseOneOf({\n            ...objectSchema,\n            oneOf: objectSchema.oneOf.map((x) => typeof x === \"object\" &&\n                !x.type &&\n                (x.properties || x.additionalProperties || x.patternProperties)\n                ? { ...x, type: \"object\" }\n                : x),\n        }, refs)})`;\n    }\n    if (its.an.allOf(objectSchema)) {\n        output += `.and(${parseAllOf({\n            ...objectSchema,\n            allOf: objectSchema.allOf.map((x) => typeof x === \"object\" &&\n                !x.type &&\n                (x.properties || x.additionalProperties || x.patternProperties)\n                ? { ...x, type: \"object\" }\n                : x),\n        }, refs)})`;\n    }\n    return output;\n}\n", "import { parseSchema } from \"./parseSchema.js\";\nexport const parseOneOf = (schema, refs) => {\n    return schema.oneOf.length\n        ? schema.oneOf.length === 1\n            ? parseSchema(schema.oneOf[0], {\n                ...refs,\n                path: [...refs.path, \"oneOf\", 0],\n            })\n            : `z.any().superRefine((x, ctx) => {\n    const schemas = [${schema.oneOf\n                .map((schema, i) => parseSchema(schema, {\n                ...refs,\n                path: [...refs.path, \"oneOf\", i],\n            }))\n                .join(\", \")}];\n    const errors = schemas.reduce<z.ZodError[]>(\n      (errors, schema) =>\n        ((result) =>\n          result.error ? [...errors, result.error] : errors)(\n          schema.safeParse(x),\n        ),\n      [],\n    );\n    if (schemas.length - errors.length !== 1) {\n      ctx.addIssue({\n        path: ctx.path,\n        code: \"invalid_union\",\n        unionErrors: errors,\n        message: \"Invalid input: Should pass single schema\",\n      });\n    }\n  })`\n        : \"z.any()\";\n};\n", "export const expandJsdocs = (jsdocs) => {\n    const lines = jsdocs.split(\"\\n\");\n    const result = lines.length === 1\n        ? lines[0]\n        : `\\n${lines.map(x => `* ${x}`)\n            .join(\"\\n\")}\\n`;\n    return `/**${result}*/\\n`;\n};\nexport const addJsdocs = (schema, parsed) => {\n    const description = schema.description;\n    if (!description) {\n        return parsed;\n    }\n    return `\\n${expandJsdocs(description)}${parsed}`;\n};\n", "import { withMessage } from \"../utils/withMessage.js\";\nimport { parseSchema } from \"./parseSchema.js\";\nexport const parseString = (schema) => {\n    let r = \"z.string()\";\n    r += withMessage(schema, \"format\", ({ value }) => {\n        switch (value) {\n            case \"email\":\n                return [\".email(\", \")\"];\n            case \"ip\":\n                return [\".ip(\", \")\"];\n            case \"ipv4\":\n                return ['.ip({ version: \"v4\"', \", message: \", \" })\"];\n            case \"ipv6\":\n                return ['.ip({ version: \"v6\"', \", message: \", \" })\"];\n            case \"uri\":\n                return [\".url(\", \")\"];\n            case \"uuid\":\n                return [\".uuid(\", \")\"];\n            case \"date-time\":\n                return [\".datetime({ offset: true\", \", message: \", \" })\"];\n            case \"time\":\n                return [\".time(\", \")\"];\n            case \"date\":\n                return [\".date(\", \")\"];\n            case \"binary\":\n                return [\".base64(\", \")\"];\n            case \"duration\":\n                return [\".duration(\", \")\"];\n        }\n    });\n    r += withMessage(schema, \"pattern\", ({ json }) => [\n        `.regex(new RegExp(${json})`,\n        \", \",\n        \")\",\n    ]);\n    r += withMessage(schema, \"minLength\", ({ json }) => [\n        `.min(${json}`,\n        \", \",\n        \")\",\n    ]);\n    r += withMessage(schema, \"maxLength\", ({ json }) => [\n        `.max(${json}`,\n        \", \",\n        \")\",\n    ]);\n    r += withMessage(schema, \"contentEncoding\", ({ value }) => {\n        if (value === \"base64\") {\n            return [\".base64(\", \")\"];\n        }\n    });\n    const contentMediaType = withMessage(schema, \"contentMediaType\", ({ value }) => {\n        if (value === \"application/json\") {\n            return [\n                \".transform((str, ctx) => { try { return JSON.parse(str); } catch (err) { ctx.addIssue({ code: \\\"custom\\\", message: \\\"Invalid JSON\\\" }); }}\",\n                \", \",\n                \")\"\n            ];\n        }\n    });\n    if (contentMediaType != \"\") {\n        r += contentMediaType;\n        r += withMessage(schema, \"contentSchema\", ({ value }) => {\n            if (value && value instanceof Object) {\n                return [\n                    `.pipe(${parseSchema(value)}`,\n                    \", \",\n                    \")\"\n                ];\n            }\n        });\n    }\n    return r;\n};\n", "import { parseSchema } from \"./parseSchema.js\";\nexport const parseSimpleDiscriminatedOneOf = (schema, refs) => {\n    return schema.oneOf.length\n        ? schema.oneOf.length === 1\n            ? parseSchema(schema.oneOf[0], {\n                ...refs,\n                path: [...refs.path, \"oneOf\", 0],\n            })\n            : `z.discriminatedUnion(\"${schema.discriminator.propertyName}\", [${schema.oneOf\n                .map((schema, i) => parseSchema(schema, {\n                ...refs,\n                path: [...refs.path, \"oneOf\", i],\n            }))\n                .join(\", \")}])`\n        : \"z.any()\";\n};\n", "import { omit } from \"../utils/omit.js\";\nimport { parseSchema } from \"./parseSchema.js\";\n/**\n * For compatibility with open api 3.0 nullable\n */\nexport const parseNullable = (schema, refs) => {\n    return `${parseSchema(omit(schema, \"nullable\"), refs, true)}.nullable()`;\n};\n", "export const omit = (obj, ...keys) => Object.keys(obj).reduce((acc, key) => {\n    if (!keys.includes(key)) {\n        acc[key] = obj[key];\n    }\n    return acc;\n}, {});\n", "import { ZodOptional, ZodObject, ZodArray, ZodUnion, ZodString, ZodNumber, z, ZodNull, ZodDefault, ZodDate } from 'zod';\nimport { jsonSchema } from 'ai';\nimport { convertJsonSchemaToZod } from 'zod-from-json-schema';\nimport { zodToJsonSchema } from 'zod-to-json-schema';\n\n// src/schema-compatibility.ts\nfunction convertZodSchemaToAISDKSchema(zodSchema, target = \"jsonSchema7\") {\n  return jsonSchema(\n    zodToJsonSchema(zodSchema, {\n      $refStrategy: \"none\",\n      target\n    }),\n    {\n      validate: (value) => {\n        const result = zodSchema.safeParse(value);\n        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n      }\n    }\n  );\n}\nfunction isZodType(value) {\n  return typeof value === \"object\" && value !== null && \"_def\" in value && \"parse\" in value && typeof value.parse === \"function\" && \"safeParse\" in value && typeof value.safeParse === \"function\";\n}\nfunction convertSchemaToZod(schema) {\n  if (isZodType(schema)) {\n    return schema;\n  } else {\n    const jsonSchemaToConvert = \"jsonSchema\" in schema ? schema.jsonSchema : schema;\n    try {\n      return convertJsonSchemaToZod(jsonSchemaToConvert);\n    } catch (e) {\n      const errorMessage = `[Schema Builder] Failed to convert schema parameters to Zod. Original schema: ${JSON.stringify(jsonSchemaToConvert)}`;\n      console.error(errorMessage, e);\n      throw new Error(errorMessage + (e instanceof Error ? `\n${e.stack}` : \"\\nUnknown error object\"));\n    }\n  }\n}\nfunction applyCompatLayer({\n  schema,\n  compatLayers,\n  mode\n}) {\n  let zodSchema;\n  if (!isZodType(schema)) {\n    zodSchema = convertSchemaToZod(schema);\n  } else {\n    zodSchema = schema;\n  }\n  for (const compat of compatLayers) {\n    if (compat.shouldApply()) {\n      return mode === \"jsonSchema\" ? compat.processToJSONSchema(zodSchema) : compat.processToAISDKSchema(zodSchema);\n    }\n  }\n  if (mode === \"jsonSchema\") {\n    return zodToJsonSchema(zodSchema, { $refStrategy: \"none\", target: \"jsonSchema7\" });\n  } else {\n    return convertZodSchemaToAISDKSchema(zodSchema);\n  }\n}\n\n// src/schema-compatibility.ts\nvar ALL_STRING_CHECKS = [\"regex\", \"emoji\", \"email\", \"url\", \"uuid\", \"cuid\", \"min\", \"max\"];\nvar ALL_NUMBER_CHECKS = [\n  \"min\",\n  // gte internally\n  \"max\",\n  // lte internally\n  \"multipleOf\"\n];\nvar ALL_ARRAY_CHECKS = [\"min\", \"max\", \"length\"];\nvar isOptional = (v) => v instanceof ZodOptional;\nvar isObj = (v) => v instanceof ZodObject;\nvar isNull = (v) => v instanceof ZodNull;\nvar isArr = (v) => v instanceof ZodArray;\nvar isUnion = (v) => v instanceof ZodUnion;\nvar isString = (v) => v instanceof ZodString;\nvar isNumber = (v) => v instanceof ZodNumber;\nvar isDate = (v) => v instanceof ZodDate;\nvar isDefault = (v) => v instanceof ZodDefault;\nvar UNSUPPORTED_ZOD_TYPES = [\"ZodIntersection\", \"ZodNever\", \"ZodNull\", \"ZodTuple\", \"ZodUndefined\"];\nvar SUPPORTED_ZOD_TYPES = [\n  \"ZodObject\",\n  \"ZodArray\",\n  \"ZodUnion\",\n  \"ZodString\",\n  \"ZodNumber\",\n  \"ZodDate\",\n  \"ZodAny\",\n  \"ZodDefault\"\n];\nvar ALL_ZOD_TYPES = [...SUPPORTED_ZOD_TYPES, ...UNSUPPORTED_ZOD_TYPES];\nvar SchemaCompatLayer = class {\n  model;\n  /**\n   * Creates a new schema compatibility instance.\n   *\n   * @param model - The language model this compatibility layer applies to\n   */\n  constructor(model) {\n    this.model = model;\n  }\n  /**\n   * Gets the language model associated with this compatibility layer.\n   *\n   * @returns The language model instance\n   */\n  getModel() {\n    return this.model;\n  }\n  /**\n   * Default handler for Zod object types. Recursively processes all properties in the object.\n   *\n   * @param value - The Zod object to process\n   * @returns The processed Zod object\n   */\n  defaultZodObjectHandler(value, options = { passthrough: true }) {\n    const processedShape = Object.entries(value.shape).reduce((acc, [key, propValue]) => {\n      acc[key] = this.processZodType(propValue);\n      return acc;\n    }, {});\n    let result = z.object(processedShape);\n    if (value._def.unknownKeys === \"strict\") {\n      result = result.strict();\n    }\n    if (value._def.catchall && !(value._def.catchall instanceof z.ZodNever)) {\n      result = result.catchall(value._def.catchall);\n    }\n    if (value.description) {\n      result = result.describe(value.description);\n    }\n    if (options.passthrough && value._def.unknownKeys === \"passthrough\") {\n      result = result.passthrough();\n    }\n    return result;\n  }\n  /**\n   * Merges validation constraints into a parameter description.\n   *\n   * This helper method converts validation constraints that may not be supported\n   * by a provider into human-readable descriptions.\n   *\n   * @param description - The existing parameter description\n   * @param constraints - The validation constraints to merge\n   * @returns The updated description with constraints, or undefined if no constraints\n   */\n  mergeParameterDescription(description, constraints) {\n    if (Object.keys(constraints).length > 0) {\n      return (description ? description + \"\\n\" : \"\") + JSON.stringify(constraints);\n    } else {\n      return description;\n    }\n  }\n  /**\n   * Default handler for unsupported Zod types. Throws an error for specified unsupported types.\n   *\n   * @param value - The Zod type to check\n   * @param throwOnTypes - Array of type names to throw errors for\n   * @returns The original value if not in the throw list\n   * @throws Error if the type is in the unsupported list\n   */\n  defaultUnsupportedZodTypeHandler(value, throwOnTypes = UNSUPPORTED_ZOD_TYPES) {\n    if (throwOnTypes.includes(value._def?.typeName)) {\n      throw new Error(`${this.model.modelId} does not support zod type: ${value._def?.typeName}`);\n    }\n    return value;\n  }\n  /**\n   * Default handler for Zod array types. Processes array constraints according to provider support.\n   *\n   * @param value - The Zod array to process\n   * @param handleChecks - Array constraints to convert to descriptions vs keep as validation\n   * @returns The processed Zod array\n   */\n  defaultZodArrayHandler(value, handleChecks = ALL_ARRAY_CHECKS) {\n    const zodArrayDef = value._def;\n    const processedType = this.processZodType(zodArrayDef.type);\n    let result = z.array(processedType);\n    const constraints = {};\n    if (zodArrayDef.minLength?.value !== void 0) {\n      if (handleChecks.includes(\"min\")) {\n        constraints.minLength = zodArrayDef.minLength.value;\n      } else {\n        result = result.min(zodArrayDef.minLength.value);\n      }\n    }\n    if (zodArrayDef.maxLength?.value !== void 0) {\n      if (handleChecks.includes(\"max\")) {\n        constraints.maxLength = zodArrayDef.maxLength.value;\n      } else {\n        result = result.max(zodArrayDef.maxLength.value);\n      }\n    }\n    if (zodArrayDef.exactLength?.value !== void 0) {\n      if (handleChecks.includes(\"length\")) {\n        constraints.exactLength = zodArrayDef.exactLength.value;\n      } else {\n        result = result.length(zodArrayDef.exactLength.value);\n      }\n    }\n    const description = this.mergeParameterDescription(value.description, constraints);\n    if (description) {\n      result = result.describe(description);\n    }\n    return result;\n  }\n  /**\n   * Default handler for Zod union types. Processes all union options.\n   *\n   * @param value - The Zod union to process\n   * @returns The processed Zod union\n   * @throws Error if union has fewer than 2 options\n   */\n  defaultZodUnionHandler(value) {\n    const processedOptions = value._def.options.map((option) => this.processZodType(option));\n    if (processedOptions.length < 2) throw new Error(\"Union must have at least 2 options\");\n    let result = z.union(processedOptions);\n    if (value.description) {\n      result = result.describe(value.description);\n    }\n    return result;\n  }\n  /**\n   * Default handler for Zod string types. Processes string validation constraints.\n   *\n   * @param value - The Zod string to process\n   * @param handleChecks - String constraints to convert to descriptions vs keep as validation\n   * @returns The processed Zod string\n   */\n  defaultZodStringHandler(value, handleChecks = ALL_STRING_CHECKS) {\n    const constraints = {};\n    const checks = value._def.checks || [];\n    const newChecks = [];\n    for (const check of checks) {\n      if (\"kind\" in check) {\n        if (handleChecks.includes(check.kind)) {\n          switch (check.kind) {\n            case \"regex\": {\n              constraints.regex = {\n                pattern: check.regex.source,\n                flags: check.regex.flags\n              };\n              break;\n            }\n            case \"emoji\": {\n              constraints.emoji = true;\n              break;\n            }\n            case \"email\": {\n              constraints.email = true;\n              break;\n            }\n            case \"url\": {\n              constraints.url = true;\n              break;\n            }\n            case \"uuid\": {\n              constraints.uuid = true;\n              break;\n            }\n            case \"cuid\": {\n              constraints.cuid = true;\n              break;\n            }\n            case \"min\": {\n              constraints.minLength = check.value;\n              break;\n            }\n            case \"max\": {\n              constraints.maxLength = check.value;\n              break;\n            }\n          }\n        } else {\n          newChecks.push(check);\n        }\n      }\n    }\n    let result = z.string();\n    for (const check of newChecks) {\n      result = result._addCheck(check);\n    }\n    const description = this.mergeParameterDescription(value.description, constraints);\n    if (description) {\n      result = result.describe(description);\n    }\n    return result;\n  }\n  /**\n   * Default handler for Zod number types. Processes number validation constraints.\n   *\n   * @param value - The Zod number to process\n   * @param handleChecks - Number constraints to convert to descriptions vs keep as validation\n   * @returns The processed Zod number\n   */\n  defaultZodNumberHandler(value, handleChecks = ALL_NUMBER_CHECKS) {\n    const constraints = {};\n    const checks = value._def.checks || [];\n    const newChecks = [];\n    for (const check of checks) {\n      if (\"kind\" in check) {\n        if (handleChecks.includes(check.kind)) {\n          switch (check.kind) {\n            case \"min\":\n              if (check.inclusive) {\n                constraints.gte = check.value;\n              } else {\n                constraints.gt = check.value;\n              }\n              break;\n            case \"max\":\n              if (check.inclusive) {\n                constraints.lte = check.value;\n              } else {\n                constraints.lt = check.value;\n              }\n              break;\n            case \"multipleOf\": {\n              constraints.multipleOf = check.value;\n              break;\n            }\n          }\n        } else {\n          newChecks.push(check);\n        }\n      }\n    }\n    let result = z.number();\n    for (const check of newChecks) {\n      switch (check.kind) {\n        case \"int\":\n          result = result.int();\n          break;\n        case \"finite\":\n          result = result.finite();\n          break;\n        default:\n          result = result._addCheck(check);\n      }\n    }\n    const description = this.mergeParameterDescription(value.description, constraints);\n    if (description) {\n      result = result.describe(description);\n    }\n    return result;\n  }\n  /**\n   * Default handler for Zod date types. Converts dates to ISO strings with constraint descriptions.\n   *\n   * @param value - The Zod date to process\n   * @returns A Zod string schema representing the date in ISO format\n   */\n  defaultZodDateHandler(value) {\n    const constraints = {};\n    const checks = value._def.checks || [];\n    for (const check of checks) {\n      if (\"kind\" in check) {\n        switch (check.kind) {\n          case \"min\":\n            const minDate = new Date(check.value);\n            if (!isNaN(minDate.getTime())) {\n              constraints.minDate = minDate.toISOString();\n            }\n            break;\n          case \"max\":\n            const maxDate = new Date(check.value);\n            if (!isNaN(maxDate.getTime())) {\n              constraints.maxDate = maxDate.toISOString();\n            }\n            break;\n        }\n      }\n    }\n    constraints.dateFormat = \"date-time\";\n    let result = z.string().describe(\"date-time\");\n    const description = this.mergeParameterDescription(value.description, constraints);\n    if (description) {\n      result = result.describe(description);\n    }\n    return result;\n  }\n  /**\n   * Default handler for Zod optional types. Processes the inner type and maintains optionality.\n   *\n   * @param value - The Zod optional to process\n   * @param handleTypes - Types that should be processed vs passed through\n   * @returns The processed Zod optional\n   */\n  defaultZodOptionalHandler(value, handleTypes = SUPPORTED_ZOD_TYPES) {\n    if (handleTypes.includes(value._def.innerType._def.typeName)) {\n      return this.processZodType(value._def.innerType).optional();\n    } else {\n      return value;\n    }\n  }\n  /**\n   * Processes a Zod object schema and converts it to an AI SDK Schema.\n   *\n   * @param zodSchema - The Zod object schema to process\n   * @returns An AI SDK Schema with provider-specific compatibility applied\n   */\n  processToAISDKSchema(zodSchema) {\n    const processedSchema = this.processZodType(zodSchema);\n    return convertZodSchemaToAISDKSchema(processedSchema, this.getSchemaTarget());\n  }\n  /**\n   * Processes a Zod object schema and converts it to a JSON Schema.\n   *\n   * @param zodSchema - The Zod object schema to process\n   * @returns A JSONSchema7 object with provider-specific compatibility applied\n   */\n  processToJSONSchema(zodSchema) {\n    return this.processToAISDKSchema(zodSchema).jsonSchema;\n  }\n};\n\n// src/provider-compats/anthropic.ts\nvar AnthropicSchemaCompatLayer = class extends SchemaCompatLayer {\n  constructor(model) {\n    super(model);\n  }\n  getSchemaTarget() {\n    return \"jsonSchema7\";\n  }\n  shouldApply() {\n    return this.getModel().modelId.includes(\"claude\");\n  }\n  processZodType(value) {\n    if (isOptional(value)) {\n      const handleTypes = [\"ZodObject\", \"ZodArray\", \"ZodUnion\", \"ZodNever\", \"ZodUndefined\", \"ZodTuple\"];\n      if (this.getModel().modelId.includes(\"claude-3.5-haiku\")) handleTypes.push(\"ZodString\");\n      return this.defaultZodOptionalHandler(value, handleTypes);\n    } else if (isObj(value)) {\n      return this.defaultZodObjectHandler(value);\n    } else if (isArr(value)) {\n      return this.defaultZodArrayHandler(value, []);\n    } else if (isUnion(value)) {\n      return this.defaultZodUnionHandler(value);\n    } else if (isString(value)) {\n      if (this.getModel().modelId.includes(\"claude-3.5-haiku\")) {\n        return this.defaultZodStringHandler(value, [\"max\", \"min\"]);\n      } else {\n        return value;\n      }\n    }\n    return this.defaultUnsupportedZodTypeHandler(value, [\"ZodNever\", \"ZodTuple\", \"ZodUndefined\"]);\n  }\n};\n\n// src/provider-compats/deepseek.ts\nvar DeepSeekSchemaCompatLayer = class extends SchemaCompatLayer {\n  constructor(model) {\n    super(model);\n  }\n  getSchemaTarget() {\n    return \"jsonSchema7\";\n  }\n  shouldApply() {\n    return this.getModel().modelId.includes(\"deepseek\") && !this.getModel().modelId.includes(\"r1\");\n  }\n  processZodType(value) {\n    if (isOptional(value)) {\n      return this.defaultZodOptionalHandler(value, [\"ZodObject\", \"ZodArray\", \"ZodUnion\", \"ZodString\", \"ZodNumber\"]);\n    } else if (isObj(value)) {\n      return this.defaultZodObjectHandler(value);\n    } else if (isArr(value)) {\n      return this.defaultZodArrayHandler(value, [\"min\", \"max\"]);\n    } else if (isUnion(value)) {\n      return this.defaultZodUnionHandler(value);\n    } else if (isString(value)) {\n      return this.defaultZodStringHandler(value);\n    }\n    return value;\n  }\n};\nvar GoogleSchemaCompatLayer = class extends SchemaCompatLayer {\n  constructor(model) {\n    super(model);\n  }\n  getSchemaTarget() {\n    return \"jsonSchema7\";\n  }\n  shouldApply() {\n    return this.getModel().provider.includes(\"google\") || this.getModel().modelId.includes(\"google\");\n  }\n  processZodType(value) {\n    if (isOptional(value)) {\n      return this.defaultZodOptionalHandler(value, [\n        \"ZodObject\",\n        \"ZodArray\",\n        \"ZodUnion\",\n        \"ZodString\",\n        \"ZodNumber\",\n        ...UNSUPPORTED_ZOD_TYPES\n      ]);\n    } else if (isNull(value)) {\n      return z.any().refine((v) => v === null, { message: \"must be null\" }).describe(value._def.description || \"must be null\");\n    } else if (isObj(value)) {\n      return this.defaultZodObjectHandler(value);\n    } else if (isArr(value)) {\n      return this.defaultZodArrayHandler(value, []);\n    } else if (isUnion(value)) {\n      return this.defaultZodUnionHandler(value);\n    } else if (isString(value)) {\n      return this.defaultZodStringHandler(value);\n    } else if (isNumber(value)) {\n      return this.defaultZodNumberHandler(value);\n    }\n    return this.defaultUnsupportedZodTypeHandler(value);\n  }\n};\n\n// src/provider-compats/meta.ts\nvar MetaSchemaCompatLayer = class extends SchemaCompatLayer {\n  constructor(model) {\n    super(model);\n  }\n  getSchemaTarget() {\n    return \"jsonSchema7\";\n  }\n  shouldApply() {\n    return this.getModel().modelId.includes(\"meta\");\n  }\n  processZodType(value) {\n    if (isOptional(value)) {\n      return this.defaultZodOptionalHandler(value, [\"ZodObject\", \"ZodArray\", \"ZodUnion\", \"ZodString\", \"ZodNumber\"]);\n    } else if (isObj(value)) {\n      return this.defaultZodObjectHandler(value);\n    } else if (isArr(value)) {\n      return this.defaultZodArrayHandler(value, [\"min\", \"max\"]);\n    } else if (isUnion(value)) {\n      return this.defaultZodUnionHandler(value);\n    } else if (isNumber(value)) {\n      return this.defaultZodNumberHandler(value);\n    } else if (isString(value)) {\n      return this.defaultZodStringHandler(value);\n    }\n    return value;\n  }\n};\n\n// src/provider-compats/openai.ts\nvar OpenAISchemaCompatLayer = class extends SchemaCompatLayer {\n  constructor(model) {\n    super(model);\n  }\n  getSchemaTarget() {\n    return `jsonSchema7`;\n  }\n  shouldApply() {\n    if (!this.getModel().supportsStructuredOutputs && (this.getModel().provider.includes(`openai`) || this.getModel().modelId.includes(`openai`))) {\n      return true;\n    }\n    return false;\n  }\n  processZodType(value) {\n    if (isOptional(value)) {\n      return this.defaultZodOptionalHandler(value, [\n        \"ZodObject\",\n        \"ZodArray\",\n        \"ZodUnion\",\n        \"ZodString\",\n        \"ZodNever\",\n        \"ZodUndefined\",\n        \"ZodTuple\"\n      ]);\n    } else if (isObj(value)) {\n      return this.defaultZodObjectHandler(value);\n    } else if (isUnion(value)) {\n      return this.defaultZodUnionHandler(value);\n    } else if (isArr(value)) {\n      return this.defaultZodArrayHandler(value);\n    } else if (isString(value)) {\n      const model = this.getModel();\n      const checks = [\"emoji\"];\n      if (model.modelId.includes(\"gpt-4o-mini\")) {\n        checks.push(\"regex\");\n      }\n      return this.defaultZodStringHandler(value, checks);\n    }\n    return this.defaultUnsupportedZodTypeHandler(value, [\"ZodNever\", \"ZodUndefined\", \"ZodTuple\"]);\n  }\n};\nvar OpenAIReasoningSchemaCompatLayer = class extends SchemaCompatLayer {\n  constructor(model) {\n    super(model);\n  }\n  getSchemaTarget() {\n    return `openApi3`;\n  }\n  isReasoningModel() {\n    return this.getModel().modelId.includes(`o3`) || this.getModel().modelId.includes(`o4`);\n  }\n  shouldApply() {\n    if ((this.getModel().supportsStructuredOutputs || this.isReasoningModel()) && (this.getModel().provider.includes(`openai`) || this.getModel().modelId.includes(`openai`))) {\n      return true;\n    }\n    return false;\n  }\n  processZodType(value) {\n    if (isOptional(value)) {\n      const innerZodType = this.processZodType(value._def.innerType);\n      return innerZodType.nullable();\n    } else if (isObj(value)) {\n      return this.defaultZodObjectHandler(value, { passthrough: false });\n    } else if (isArr(value)) {\n      return this.defaultZodArrayHandler(value);\n    } else if (isUnion(value)) {\n      return this.defaultZodUnionHandler(value);\n    } else if (isDefault(value)) {\n      const defaultDef = value._def;\n      const innerType = defaultDef.innerType;\n      const defaultValue = defaultDef.defaultValue();\n      const constraints = {};\n      if (defaultValue !== void 0) {\n        constraints.defaultValue = defaultValue;\n      }\n      const description = this.mergeParameterDescription(value.description, constraints);\n      let result = this.processZodType(innerType);\n      if (description) {\n        result = result.describe(description);\n      }\n      return result;\n    } else if (isNumber(value)) {\n      return this.defaultZodNumberHandler(value);\n    } else if (isString(value)) {\n      return this.defaultZodStringHandler(value);\n    } else if (isDate(value)) {\n      return this.defaultZodDateHandler(value);\n    } else if (value._def.typeName === \"ZodAny\") {\n      return z.string().describe(\n        (value.description ?? \"\") + `\nArgument was an \"any\" type, but you (the LLM) do not support \"any\", so it was cast to a \"string\" type`\n      );\n    }\n    return this.defaultUnsupportedZodTypeHandler(value);\n  }\n};\n\nexport { ALL_ARRAY_CHECKS, ALL_NUMBER_CHECKS, ALL_STRING_CHECKS, ALL_ZOD_TYPES, AnthropicSchemaCompatLayer, DeepSeekSchemaCompatLayer, GoogleSchemaCompatLayer, MetaSchemaCompatLayer, OpenAIReasoningSchemaCompatLayer, OpenAISchemaCompatLayer, SUPPORTED_ZOD_TYPES, SchemaCompatLayer, UNSUPPORTED_ZOD_TYPES, applyCompatLayer, convertSchemaToZod, convertZodSchemaToAISDKSchema, isArr, isNumber, isObj, isOptional, isString, isUnion };\n", "/**\n * Symbol used for identifying AI SDK Error instances.\n * Enables checking if an error is an instance of AISDKError across package versions.\n */\nconst marker = 'vercel.ai.error';\nconst symbol = Symbol.for(marker);\n\n/**\n * Custom error class for AI SDK related errors.\n * @extends Error\n */\nexport class AISDKError extends Error {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n   * The underlying cause of the error, if any.\n   */\n  readonly cause?: unknown;\n\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name,\n    message,\n    cause,\n  }: {\n    name: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super(message);\n\n    this.name = name;\n    this.cause = cause;\n  }\n\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error: unknown): error is AISDKError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  protected static hasMarker(error: unknown, marker: string): boolean {\n    const markerSymbol = Symbol.for(marker);\n    return (\n      error != null &&\n      typeof error === 'object' &&\n      markerSymbol in error &&\n      typeof error[markerSymbol] === 'boolean' &&\n      error[markerSymbol] === true\n    );\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_APICallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class APICallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly url: string;\n  readonly requestBodyValues: unknown;\n  readonly statusCode?: number;\n\n  readonly responseHeaders?: Record<string, string>;\n  readonly responseBody?: string;\n\n  readonly isRetryable: boolean;\n  readonly data?: unknown;\n\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null &&\n      (statusCode === 408 || // request timeout\n        statusCode === 409 || // conflict\n        statusCode === 429 || // too many requests\n        statusCode >= 500), // server error\n    data,\n  }: {\n    message: string;\n    url: string;\n    requestBodyValues: unknown;\n    statusCode?: number;\n    responseHeaders?: Record<string, string>;\n    responseBody?: string;\n    cause?: unknown;\n    isRetryable?: boolean;\n    data?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is APICallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_EmptyResponseBodyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class EmptyResponseBodyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message = 'Empty response body' }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is EmptyResponseBodyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidArgumentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A function argument is invalid.\n */\nexport class InvalidArgumentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly argument: string;\n\n  constructor({\n    message,\n    cause,\n    argument,\n  }: {\n    argument: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.argument = argument;\n  }\n\n  static isInstance(error: unknown): error is InvalidArgumentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidPromptError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A prompt is invalid. This error should be thrown by providers when they cannot\n * process a prompt.\n */\nexport class InvalidPromptError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly prompt: unknown;\n\n  constructor({\n    prompt,\n    message,\n    cause,\n  }: {\n    prompt: unknown;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message: `Invalid prompt: ${message}`, cause });\n\n    this.prompt = prompt;\n  }\n\n  static isInstance(error: unknown): error is InvalidPromptError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidResponseDataError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * Server returned a response with invalid data content.\n * This should be thrown by providers when they cannot parse the response from the API.\n */\nexport class InvalidResponseDataError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly data: unknown;\n\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`,\n  }: {\n    data: unknown;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is InvalidResponseDataError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_JSONParseError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n// TODO v5: rename to ParseError\nexport class JSONParseError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly text: string;\n\n  constructor({ text, cause }: { text: string; cause: unknown }) {\n    super({\n      name,\n      message:\n        `JSON parsing failed: ` +\n        `Text: ${text}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.text = text;\n  }\n\n  static isInstance(error: unknown): error is JSONParseError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadAPIKeyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadAPIKeyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadAPIKeyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadSettingError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadSettingError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadSettingError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoContentGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when the AI provider fails to generate any content.\n */\nexport class NoContentGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({\n    message = 'No content generated.',\n  }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is NoContentGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoSuchModelError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchModelError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly modelId: string;\n  readonly modelType: 'languageModel' | 'textEmbeddingModel' | 'imageModel';\n\n  constructor({\n    errorName = name,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`,\n  }: {\n    errorName?: string;\n    modelId: string;\n    modelType: 'languageModel' | 'textEmbeddingModel' | 'imageModel';\n    message?: string;\n  }) {\n    super({ name: errorName, message });\n\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n\n  static isInstance(error: unknown): error is NoSuchModelError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_TooManyEmbeddingValuesForCallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TooManyEmbeddingValuesForCallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly provider: string;\n  readonly modelId: string;\n  readonly maxEmbeddingsPerCall: number;\n  readonly values: Array<unknown>;\n\n  constructor(options: {\n    provider: string;\n    modelId: string;\n    maxEmbeddingsPerCall: number;\n    values: Array<unknown>;\n  }) {\n    super({\n      name,\n      message:\n        `Too many values for a single embedding call. ` +\n        `The ${options.provider} model \"${options.modelId}\" can only embed up to ` +\n        `${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`,\n    });\n\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n\n  static isInstance(\n    error: unknown,\n  ): error is TooManyEmbeddingValuesForCallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_TypeValidationError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TypeValidationError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly value: unknown;\n\n  constructor({ value, cause }: { value: unknown; cause: unknown }) {\n    super({\n      name,\n      message:\n        `Type validation failed: ` +\n        `Value: ${JSON.stringify(value)}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is TypeValidationError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause,\n  }: {\n    value: unknown;\n    cause: unknown;\n  }): TypeValidationError {\n    return TypeValidationError.isInstance(cause) && cause.value === value\n      ? cause\n      : new TypeValidationError({ value, cause });\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_UnsupportedFunctionalityError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class UnsupportedFunctionalityError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly functionality: string;\n\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`,\n  }: {\n    functionality: string;\n    message?: string;\n  }) {\n    super({ name, message });\n    this.functionality = functionality;\n  }\n\n  static isInstance(error: unknown): error is UnsupportedFunctionalityError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { JSONArray, JSONObject, JSONValue } from './json-value';\n\nexport function isJSONValue(value: unknown): value is JSONValue {\n  if (\n    value === null ||\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean'\n  ) {\n    return true;\n  }\n\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n\n  if (typeof value === 'object') {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === 'string' && isJSONValue(val),\n    );\n  }\n\n  return false;\n}\n\nexport function isJSONArray(value: unknown): value is JSONArray {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\n\nexport function isJSONObject(value: unknown): value is JSONObject {\n  return (\n    value != null &&\n    typeof value === 'object' &&\n    Object.entries(value).every(\n      ([key, val]) => typeof key === 'string' && isJSONValue(val),\n    )\n  );\n}\n", "let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size | 0\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size | 0\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\nexport { nanoid, customAlphabet }\n", "export function combineHeaders(\n  ...headers: Array<Record<string, string | undefined> | undefined>\n): Record<string, string | undefined> {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...(currentHeaders ?? {}),\n    }),\n    {},\n  ) as Record<string, string | undefined>;\n}\n", "/**\n * Converts an AsyncIterator to a ReadableStream.\n *\n * @template T - The type of elements produced by the AsyncIterator.\n * @param { <T>} iterator - The AsyncIterator to convert.\n * @returns {ReadableStream<T>} - A ReadableStream that provides the same data as the AsyncIterator.\n */\nexport function convertAsyncIteratorToReadableStream<T>(\n  iterator: AsyncIterator<T>,\n): ReadableStream<T> {\n  return new ReadableStream<T>({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {},\n  });\n}\n", "/**\n * Creates a Promise that resolves after a specified delay\n * @param delayInMs - The delay duration in milliseconds. If null or undefined, resolves immediately.\n * @returns A Promise that resolves after the specified delay\n */\nexport async function delay(delayInMs?: number | null): Promise<void> {\n  return delayInMs == null\n    ? Promise.resolve()\n    : new Promise(resolve => setTimeout(resolve, delayInMs));\n}\n", "export type EventSourceChunk = {\n  event: string | undefined;\n  data: string;\n  id?: string;\n  retry?: number;\n};\n\nexport function createEventSourceParserStream() {\n  let buffer = '';\n  let event: string | undefined = undefined;\n  let data: string[] = [];\n  let lastEventId: string | undefined = undefined;\n  let retry: number | undefined = undefined;\n\n  function parseLine(\n    line: string,\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    // Empty line means dispatch the event\n    if (line === '') {\n      dispatchEvent(controller);\n      return;\n    }\n\n    // Comments start with colon\n    if (line.startsWith(':')) {\n      return;\n    }\n\n    // Field parsing\n    const colonIndex = line.indexOf(':');\n    if (colonIndex === -1) {\n      // field with no value\n      handleField(line, '');\n      return;\n    }\n\n    const field = line.slice(0, colonIndex);\n    // If there's a space after the colon, it should be ignored\n    const valueStart = colonIndex + 1;\n    const value =\n      valueStart < line.length && line[valueStart] === ' '\n        ? line.slice(valueStart + 1)\n        : line.slice(valueStart);\n\n    handleField(field, value);\n  }\n\n  function dispatchEvent(\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    if (data.length > 0) {\n      controller.enqueue({\n        event,\n        data: data.join('\\n'),\n        id: lastEventId,\n        retry,\n      });\n\n      // Reset data but keep lastEventId as per spec\n      data = [];\n      event = undefined;\n      retry = undefined;\n    }\n  }\n\n  function handleField(field: string, value: string) {\n    switch (field) {\n      case 'event':\n        event = value;\n        break;\n      case 'data':\n        data.push(value);\n        break;\n      case 'id':\n        lastEventId = value;\n        break;\n      case 'retry':\n        const parsedRetry = parseInt(value, 10);\n        if (!isNaN(parsedRetry)) {\n          retry = parsedRetry;\n        }\n        break;\n    }\n  }\n\n  return new TransformStream<string, EventSourceChunk>({\n    transform(chunk, controller) {\n      const { lines, incompleteLine } = splitLines(buffer, chunk);\n\n      buffer = incompleteLine;\n\n      // using for loop for performance\n      for (let i = 0; i < lines.length; i++) {\n        parseLine(lines[i], controller);\n      }\n    },\n\n    flush(controller) {\n      parseLine(buffer, controller);\n      dispatchEvent(controller);\n    },\n  });\n}\n\n// performance: send in already scanned buffer separately, do not scan again\nfunction splitLines(buffer: string, chunk: string) {\n  const lines: Array<string> = [];\n  let currentLine = buffer;\n\n  // using for loop for performance\n  for (let i = 0; i < chunk.length; ) {\n    const char = chunk[i++];\n\n    // order is performance-optimized\n    if (char === '\\n') {\n      // Standalone LF\n      lines.push(currentLine);\n      currentLine = '';\n    } else if (char === '\\r') {\n      lines.push(currentLine);\n      currentLine = '';\n      if (chunk[i] === '\\n') {\n        i++; // CRLF case: Skip the LF character\n      }\n    } else {\n      currentLine += char;\n    }\n  }\n\n  return { lines, incompleteLine: currentLine };\n}\n", "/**\nExtracts the headers from a response object and returns them as a key-value object.\n\n@param response - The response object to extract headers from.\n@returns The headers as a key-value object.\n*/\nexport function extractResponseHeaders(\n  response: Response,\n): Record<string, string> {\n  const headers: Record<string, string> = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n", "import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { customAlphabet } from 'nanoid/non-secure';\n\n/**\nCreates an ID generator.\nThe total length of the ID is the sum of the prefix, separator, and random part length.\nNon-secure.\n\n@param alphabet - The alphabet to use for the ID. Default: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.\n@param prefix - The prefix of the ID to generate. Default: ''.\n@param separator - The separator between the prefix and the random part of the ID. Default: '-'.\n@param size - The size of the random part of the ID to generate. Default: 16.\n */\n// TODO 5.0 breaking change: change the return type to IDGenerator\nexport const createIdGenerator = ({\n  prefix,\n  size: defaultSize = 16,\n  alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  separator = '-',\n}: {\n  prefix?: string;\n  separator?: string;\n  size?: number;\n  alphabet?: string;\n} = {}): ((size?: number) => string) => {\n  const generator = customAlphabet(alphabet, defaultSize);\n\n  if (prefix == null) {\n    return generator;\n  }\n\n  // check that the prefix is not part of the alphabet (otherwise prefix checking can fail randomly)\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: 'separator',\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`,\n    });\n  }\n\n  return size => `${prefix}${separator}${generator(size)}`;\n};\n\n/**\nA function that generates an ID.\n */\nexport type IDGenerator = () => string;\n\n/**\nGenerates a 16-character random string to use for IDs. Not secure.\n\n@param size - The size of the ID to generate. Default: 16.\n */\nexport const generateId = createIdGenerator();\n", "export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n", "import { APICallError } from '@ai-sdk/provider';\nimport { FetchFunction } from './fetch-function';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\nimport { isAbortError } from './is-abort-error';\nimport { extractResponseHeaders } from './extract-response-headers';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const getFromApi = async <T>({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: removeUndefinedEntries(headers),\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {},\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {},\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {},\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {},\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n      if (cause != null) {\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          isRetryable: true,\n          requestBodyValues: {},\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n", "/**\n * Removes entries from a record where the value is null or undefined.\n * @param record - The input object whose entries may be null or undefined.\n * @returns A new object containing only entries with non-null and non-undefined values.\n */\nexport function removeUndefinedEntries<T>(\n  record: Record<string, T | undefined>,\n): Record<string, T> {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null),\n  ) as Record<string, T>;\n}\n", "export function isAbortError(error: unknown): error is Error {\n  return (\n    error instanceof Error &&\n    (error.name === 'AbortError' || error.name === 'TimeoutError')\n  );\n}\n", "import { LoadAPIKeyError } from '@ai-sdk/provider';\n\nexport function loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = 'apiKey',\n  description,\n}: {\n  apiKey: string | undefined;\n  environmentVariableName: string;\n  apiKeyParameterName?: string;\n  description: string;\n}): string {\n  if (typeof apiKey === 'string') {\n    return apiKey;\n  }\n\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`,\n    });\n  }\n\n  apiKey = process.env[environmentVariableName];\n\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof apiKey !== 'string') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return apiKey;\n}\n", "/**\n * Loads an optional `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @returns The setting value.\n */\nexport function loadOptionalSetting({\n  settingValue,\n  environmentVariableName,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n}): string | undefined {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null || typeof process === 'undefined') {\n    return undefined;\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null || typeof settingValue !== 'string') {\n    return undefined;\n  }\n\n  return settingValue;\n}\n", "import { LoadSettingError } from '@ai-sdk/provider';\n\n/**\n * Loads a `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @param settingName - The setting name.\n * @param description - The description of the setting.\n * @returns The setting value.\n */\nexport function loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n  settingName: string;\n  description: string;\n}): string {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null) {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter. ` +\n        `Environment variables is not supported in this environment.`,\n    });\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null) {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter ` +\n        `or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof settingValue !== 'string') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting must be a string. ` +\n        `The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return settingValue;\n}\n", "import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport SecureJSON from 'secure-json-parse';\nimport { ZodSchema } from 'zod';\nimport { safeValidateTypes, validateTypes } from './validate-types';\nimport { Validator } from './validator';\n\n/**\n * Parses a JSON string into an unknown object.\n *\n * @param text - The JSON string to parse.\n * @returns {JSONValue} - The parsed JSON object.\n */\nexport function parseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): JSONValue;\n/**\n * Parses a JSON string into a strongly-typed object using the provided schema.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns {T} - The parsed object.\n */\nexport function parseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): T;\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): T {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return value;\n    }\n\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (\n      JSONParseError.isInstance(error) ||\n      TypeValidationError.isInstance(error)\n    ) {\n      throw error;\n    }\n\n    throw new JSONParseError({ text, cause: error });\n  }\n}\n\nexport type ParseResult<T> =\n  | { success: true; value: T; rawValue: unknown }\n  | { success: false; error: JSONParseError | TypeValidationError };\n\n/**\n * Safely parses a JSON string and returns the result as an object of type `unknown`.\n *\n * @param text - The JSON string to parse.\n * @returns {object} Either an object with `success: true` and the parsed data, or an object with `success: false` and the error that occurred.\n */\nexport function safeParseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): ParseResult<JSONValue>;\n/**\n * Safely parses a JSON string into a strongly-typed object, using a provided schema to validate the object.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeParseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): ParseResult<T>;\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): ParseResult<T> {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return { success: true, value: value as T, rawValue: value };\n    }\n\n    const validationResult = safeValidateTypes({ value, schema });\n\n    return validationResult.success\n      ? { ...validationResult, rawValue: value }\n      : validationResult;\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error)\n        ? error\n        : new JSONParseError({ text, cause: error }),\n    };\n  }\n}\n\nexport function isParsableJson(input: string): boolean {\n  try {\n    SecureJSON.parse(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n", "import { TypeValidationError } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { Validator, asValidator } from './validator';\n\n/**\n * Validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns {T} - The typed object.\n */\nexport function validateTypes<T>({\n  value,\n  schema: inputSchema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}): T {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n\n  return result.value;\n}\n\n/**\n * Safely validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The JSON object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeValidateTypes<T>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: TypeValidationError } {\n  const validator = asValidator(schema);\n\n  try {\n    if (validator.validate == null) {\n      return { success: true, value: value as T };\n    }\n\n    const result = validator.validate(value);\n\n    if (result.success) {\n      return result;\n    }\n\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error }),\n    };\n  }\n}\n", "import { z } from 'zod';\n\n/**\n * Used to mark validator functions so we can support both Zod and custom schemas.\n */\nexport const validatorSymbol = Symbol.for('vercel.ai.validator');\n\nexport type ValidationResult<OBJECT> =\n  | { success: true; value: OBJECT }\n  | { success: false; error: Error };\n\nexport type Validator<OBJECT = unknown> = {\n  /**\n   * Used to mark validator functions so we can support both Zod and custom schemas.\n   */\n  [validatorSymbol]: true;\n\n  /**\n   * Optional. Validates that the structure of a value matches this schema,\n   * and returns a typed version of the value if it does.\n   */\n  readonly validate?: (value: unknown) => ValidationResult<OBJECT>;\n};\n\n/**\n * Create a validator.\n *\n * @param validate A validation function for the schema.\n */\nexport function validator<OBJECT>(\n  validate?: undefined | ((value: unknown) => ValidationResult<OBJECT>),\n): Validator<OBJECT> {\n  return { [validatorSymbol]: true, validate };\n}\n\nexport function isValidator(value: unknown): value is Validator {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    validatorSymbol in value &&\n    value[validatorSymbol] === true &&\n    'validate' in value\n  );\n}\n\nexport function asValidator<OBJECT>(\n  value: Validator<OBJECT> | z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return isValidator(value) ? value : zodValidator(value);\n}\n\nexport function zodValidator<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return validator(value => {\n    const result = zodSchema.safeParse(value);\n    return result.success\n      ? { success: true, value: result.data }\n      : { success: false, error: result.error };\n  });\n}\n", "import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { safeValidateTypes } from './validate-types';\nimport { z } from 'zod';\n\nexport function parseProviderOptions<T>({\n  provider,\n  providerOptions,\n  schema,\n}: {\n  provider: string;\n  providerOptions: Record<string, unknown> | undefined;\n  schema: z.ZodSchema<T>;\n}): T | undefined {\n  if (providerOptions?.[provider] == null) {\n    return undefined;\n  }\n\n  const parsedProviderOptions = safeValidateTypes({\n    value: providerOptions[provider],\n    schema,\n  });\n\n  if (!parsedProviderOptions.success) {\n    throw new InvalidArgumentError({\n      argument: 'providerOptions',\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error,\n    });\n  }\n\n  return parsedProviderOptions.value;\n}\n", "import { APICallError } from '@ai-sdk/provider';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { FetchFunction } from './fetch-function';\nimport { isAbortError } from './is-abort-error';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const postJsonToApi = async <T>({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: unknown;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n    body: {\n      content: JSON.stringify(body),\n      values: body,\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postFormDataToApi = async <T>({\n  url,\n  headers,\n  formData,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  formData: FormData;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers,\n    body: {\n      content: formData,\n      values: Object.fromEntries((formData as any).entries()),\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postToApi = async <T>({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: {\n    content: string | FormData | Uint8Array;\n    values: unknown;\n  };\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values,\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values,\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values,\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values,\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    // unwrap original error when fetch failed (for easier debugging):\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n\n      if (cause != null) {\n        // Failed to connect to server:\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true, // retry when network error\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n", "export type Resolvable<T> =\n  | T // Raw value\n  | Promise<T> // Promise of value\n  | (() => T) // Function returning value\n  | (() => Promise<T>); // Function returning promise of value\n\n/**\n * Resolves a value that could be a raw value, a Promise, a function returning a value,\n * or a function returning a Promise.\n */\nexport async function resolve<T>(value: Resolvable<T>): Promise<T> {\n  // If it's a function, call it to get the value/promise\n  if (typeof value === 'function') {\n    value = (value as Function)();\n  }\n\n  // Otherwise just resolve whatever we got (value or promise)\n  return Promise.resolve(value as T);\n}\n", "import { APICallError, EmptyResponseBodyError } from '@ai-sdk/provider';\nimport { ZodSchema } from 'zod';\nimport {\n  createEventSourceParserStream,\n  EventSourceChunk,\n} from './event-source-parser-stream';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { parseJSON, ParseResult, safeParseJSON } from './parse-json';\n\nexport type ResponseHandler<RETURN_TYPE> = (options: {\n  url: string;\n  requestBodyValues: unknown;\n  response: Response;\n}) => PromiseLike<{\n  value: RETURN_TYPE;\n  rawValue?: unknown;\n  responseHeaders?: Record<string, string>;\n}>;\n\nexport const createJsonErrorResponseHandler =\n  <T>({\n    errorSchema,\n    errorToMessage,\n    isRetryable,\n  }: {\n    errorSchema: ZodSchema<T>;\n    errorToMessage: (error: T) => string;\n    isRetryable?: (response: Response, error?: T) => boolean;\n  }): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n    const responseHeaders = extractResponseHeaders(response);\n\n    // Some providers return an empty response body for some errors:\n    if (responseBody.trim() === '') {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n\n    // resilient parsing in case the response is not JSON or does not match the schema:\n    try {\n      const parsedError = parseJSON({\n        text: responseBody,\n        schema: errorSchema,\n      });\n\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: errorToMessage(parsedError),\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          data: parsedError,\n          isRetryable: isRetryable?.(response, parsedError),\n        }),\n      };\n    } catch (parseError) {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n  };\n\nexport const createEventSourceResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    return {\n      responseHeaders,\n      value: response.body\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(createEventSourceParserStream())\n        .pipeThrough(\n          new TransformStream<EventSourceChunk, ParseResult<T>>({\n            transform({ data }, controller) {\n              // ignore the 'DONE' event that e.g. OpenAI sends:\n              if (data === '[DONE]') {\n                return;\n              }\n\n              controller.enqueue(\n                safeParseJSON({\n                  text: data,\n                  schema: chunkSchema,\n                }),\n              );\n            },\n          }),\n        ),\n    };\n  };\n\nexport const createJsonStreamResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    let buffer = '';\n\n    return {\n      responseHeaders,\n      value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n        new TransformStream<string, ParseResult<T>>({\n          transform(chunkText, controller) {\n            if (chunkText.endsWith('\\n')) {\n              controller.enqueue(\n                safeParseJSON({\n                  text: buffer + chunkText,\n                  schema: chunkSchema,\n                }),\n              );\n              buffer = '';\n            } else {\n              buffer += chunkText;\n            }\n          },\n        }),\n      ),\n    };\n  };\n\nexport const createJsonResponseHandler =\n  <T>(responseSchema: ZodSchema<T>): ResponseHandler<T> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n\n    const parsedResult = safeParseJSON({\n      text: responseBody,\n      schema: responseSchema,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!parsedResult.success) {\n      throw new APICallError({\n        message: 'Invalid JSON response',\n        cause: parsedResult.error,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        url,\n        requestBodyValues,\n      });\n    }\n\n    return {\n      responseHeaders,\n      value: parsedResult.value,\n      rawValue: parsedResult.rawValue,\n    };\n  };\n\nexport const createBinaryResponseHandler =\n  (): ResponseHandler<Uint8Array> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.body) {\n      throw new APICallError({\n        message: 'Response body is empty',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n      });\n    }\n\n    try {\n      const buffer = await response.arrayBuffer();\n      return {\n        responseHeaders,\n        value: new Uint8Array(buffer),\n      };\n    } catch (error) {\n      throw new APICallError({\n        message: 'Failed to read response as array buffer',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n        cause: error,\n      });\n    }\n  };\n\nexport const createStatusCodeErrorResponseHandler =\n  (): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n    const responseBody = await response.text();\n\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues: requestBodyValues as Record<string, unknown>,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n      }),\n    };\n  };\n", "// btoa and atob need to be invoked as a function call, not as a method call.\n// Otherwise CloudFlare will throw a\n// \"TypeError: Illegal invocation: function called with incorrect this reference\"\nconst { btoa, atob } = globalThis;\n\nexport function convertBase64ToUint8Array(base64String: string) {\n  const base64Url = base64String.replace(/-/g, '+').replace(/_/g, '/');\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0)!);\n}\n\nexport function convertUint8ArrayToBase64(array: Uint8Array): string {\n  let latin1string = '';\n\n  // Note: regular for loop to support older JavaScript versions that\n  // do not support for..of on Uint8Array\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n\n  return btoa(latin1string);\n}\n", "export function withoutTrailingSlash(url: string | undefined) {\n  return url?.replace(/\\/$/, '');\n}\n", "export * from \"./Options.js\";\nexport * from \"./Refs.js\";\nexport * from \"./errorMessages.js\";\nexport * from \"./getRelativePath.js\";\nexport * from \"./parseDef.js\";\nexport * from \"./parseTypes.js\";\nexport * from \"./parsers/any.js\";\nexport * from \"./parsers/array.js\";\nexport * from \"./parsers/bigint.js\";\nexport * from \"./parsers/boolean.js\";\nexport * from \"./parsers/branded.js\";\nexport * from \"./parsers/catch.js\";\nexport * from \"./parsers/date.js\";\nexport * from \"./parsers/default.js\";\nexport * from \"./parsers/effects.js\";\nexport * from \"./parsers/enum.js\";\nexport * from \"./parsers/intersection.js\";\nexport * from \"./parsers/literal.js\";\nexport * from \"./parsers/map.js\";\nexport * from \"./parsers/nativeEnum.js\";\nexport * from \"./parsers/never.js\";\nexport * from \"./parsers/null.js\";\nexport * from \"./parsers/nullable.js\";\nexport * from \"./parsers/number.js\";\nexport * from \"./parsers/object.js\";\nexport * from \"./parsers/optional.js\";\nexport * from \"./parsers/pipeline.js\";\nexport * from \"./parsers/promise.js\";\nexport * from \"./parsers/readonly.js\";\nexport * from \"./parsers/record.js\";\nexport * from \"./parsers/set.js\";\nexport * from \"./parsers/string.js\";\nexport * from \"./parsers/tuple.js\";\nexport * from \"./parsers/undefined.js\";\nexport * from \"./parsers/union.js\";\nexport * from \"./parsers/unknown.js\";\nexport * from \"./selectParser.js\";\nexport * from \"./zodToJsonSchema.js\";\nimport { zodToJsonSchema } from \"./zodToJsonSchema.js\";\nexport default zodToJsonSchema;\n", "export const ignoreOverride = Symbol(\"Let zodToJsonSchema decide on which parser to use\");\nexport const jsonDescription = (jsonSchema, def) => {\n    if (def.description) {\n        try {\n            return {\n                ...jsonSchema,\n                ...JSON.parse(def.description),\n            };\n        }\n        catch { }\n    }\n    return jsonSchema;\n};\nexport const defaultOptions = {\n    name: undefined,\n    $refStrategy: \"root\",\n    basePath: [\"#\"],\n    effectStrategy: \"input\",\n    pipeStrategy: \"all\",\n    dateStrategy: \"format:date-time\",\n    mapStrategy: \"entries\",\n    removeAdditionalStrategy: \"passthrough\",\n    allowedAdditionalProperties: true,\n    rejectedAdditionalProperties: false,\n    definitionPath: \"definitions\",\n    target: \"jsonSchema7\",\n    strictUnions: false,\n    definitions: {},\n    errorMessages: false,\n    markdownDescription: false,\n    patternStrategy: \"escape\",\n    applyRegexFlags: false,\n    emailStrategy: \"format:email\",\n    base64Strategy: \"contentEncoding:base64\",\n    nameStrategy: \"ref\",\n    openAiAnyTypeName: \"OpenAiAnyType\"\n};\nexport const getDefaultOptions = (options) => (typeof options === \"string\"\n    ? {\n        ...defaultOptions,\n        name: options,\n    }\n    : {\n        ...defaultOptions,\n        ...options,\n    });\n", "import { getDefaultOptions } from \"./Options.js\";\nexport const getRefs = (options) => {\n    const _options = getDefaultOptions(options);\n    const currentPath = _options.name !== undefined\n        ? [..._options.basePath, _options.definitionPath, _options.name]\n        : _options.basePath;\n    return {\n        ..._options,\n        flags: { hasReferencedOpenAiAnyType: false },\n        currentPath: currentPath,\n        propertyPath: undefined,\n        seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [\n            def._def,\n            {\n                def: def._def,\n                path: [..._options.basePath, _options.definitionPath, name],\n                // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n                jsonSchema: undefined,\n            },\n        ])),\n    };\n};\n", "export function addErrorMessage(res, key, errorMessage, refs) {\n    if (!refs?.errorMessages)\n        return;\n    if (errorMessage) {\n        res.errorMessage = {\n            ...res.errorMessage,\n            [key]: errorMessage,\n        };\n    }\n}\nexport function setResponseValueAndErrors(res, key, value, errorMessage, refs) {\n    res[key] = value;\n    addErrorMessage(res, key, errorMessage, refs);\n}\n", "export const getRelativePath = (pathA, pathB) => {\n    let i = 0;\n    for (; i < pathA.length && i < pathB.length; i++) {\n        if (pathA[i] !== pathB[i])\n            break;\n    }\n    return [(pathA.length - i).toString(), ...pathB.slice(i)].join(\"/\");\n};\n", "import { ignoreOverride } from \"./Options.js\";\nimport { selectParser } from \"./selectParser.js\";\nimport { getRelativePath } from \"./getRelativePath.js\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nexport function parseDef(def, refs, forceResolution = false) {\n    const seenItem = refs.seen.get(def);\n    if (refs.override) {\n        const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);\n        if (overrideResult !== ignoreOverride) {\n            return overrideResult;\n        }\n    }\n    if (seenItem && !forceResolution) {\n        const seenSchema = get$ref(seenItem, refs);\n        if (seenSchema !== undefined) {\n            return seenSchema;\n        }\n    }\n    const newItem = { def, path: refs.currentPath, jsonSchema: undefined };\n    refs.seen.set(def, newItem);\n    const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);\n    // If the return was a function, then the inner definition needs to be extracted before a call to parseDef (recursive)\n    const jsonSchema = typeof jsonSchemaOrGetter === \"function\"\n        ? parseDef(jsonSchemaOrGetter(), refs)\n        : jsonSchemaOrGetter;\n    if (jsonSchema) {\n        addMeta(def, refs, jsonSchema);\n    }\n    if (refs.postProcess) {\n        const postProcessResult = refs.postProcess(jsonSchema, def, refs);\n        newItem.jsonSchema = jsonSchema;\n        return postProcessResult;\n    }\n    newItem.jsonSchema = jsonSchema;\n    return jsonSchema;\n}\nconst get$ref = (item, refs) => {\n    switch (refs.$refStrategy) {\n        case \"root\":\n            return { $ref: item.path.join(\"/\") };\n        case \"relative\":\n            return { $ref: getRelativePath(refs.currentPath, item.path) };\n        case \"none\":\n        case \"seen\": {\n            if (item.path.length < refs.currentPath.length &&\n                item.path.every((value, index) => refs.currentPath[index] === value)) {\n                console.warn(`Recursive reference detected at ${refs.currentPath.join(\"/\")}! Defaulting to any`);\n                return parseAnyDef(refs);\n            }\n            return refs.$refStrategy === \"seen\" ? parseAnyDef(refs) : undefined;\n        }\n    }\n};\nconst addMeta = (def, refs, jsonSchema) => {\n    if (def.description) {\n        jsonSchema.description = def.description;\n        if (refs.markdownDescription) {\n            jsonSchema.markdownDescription = def.description;\n        }\n    }\n    return jsonSchema;\n};\n", "import { ZodFirstPartyTypeKind } from \"zod/v3\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nimport { parseArrayDef } from \"./parsers/array.js\";\nimport { parseBigintDef } from \"./parsers/bigint.js\";\nimport { parseBooleanDef } from \"./parsers/boolean.js\";\nimport { parseBrandedDef } from \"./parsers/branded.js\";\nimport { parseCatchDef } from \"./parsers/catch.js\";\nimport { parseDateDef } from \"./parsers/date.js\";\nimport { parseDefaultDef } from \"./parsers/default.js\";\nimport { parseEffectsDef } from \"./parsers/effects.js\";\nimport { parseEnumDef } from \"./parsers/enum.js\";\nimport { parseIntersectionDef } from \"./parsers/intersection.js\";\nimport { parseLiteralDef } from \"./parsers/literal.js\";\nimport { parseMapDef } from \"./parsers/map.js\";\nimport { parseNativeEnumDef } from \"./parsers/nativeEnum.js\";\nimport { parseNeverDef } from \"./parsers/never.js\";\nimport { parseNullDef } from \"./parsers/null.js\";\nimport { parseNullableDef } from \"./parsers/nullable.js\";\nimport { parseNumberDef } from \"./parsers/number.js\";\nimport { parseObjectDef } from \"./parsers/object.js\";\nimport { parseOptionalDef } from \"./parsers/optional.js\";\nimport { parsePipelineDef } from \"./parsers/pipeline.js\";\nimport { parsePromiseDef } from \"./parsers/promise.js\";\nimport { parseRecordDef } from \"./parsers/record.js\";\nimport { parseSetDef } from \"./parsers/set.js\";\nimport { parseStringDef } from \"./parsers/string.js\";\nimport { parseTupleDef } from \"./parsers/tuple.js\";\nimport { parseUndefinedDef } from \"./parsers/undefined.js\";\nimport { parseUnionDef } from \"./parsers/union.js\";\nimport { parseUnknownDef } from \"./parsers/unknown.js\";\nimport { parseReadonlyDef } from \"./parsers/readonly.js\";\nexport const selectParser = (def, typeName, refs) => {\n    switch (typeName) {\n        case ZodFirstPartyTypeKind.ZodString:\n            return parseStringDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodNumber:\n            return parseNumberDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodObject:\n            return parseObjectDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBigInt:\n            return parseBigintDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBoolean:\n            return parseBooleanDef();\n        case ZodFirstPartyTypeKind.ZodDate:\n            return parseDateDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodUndefined:\n            return parseUndefinedDef(refs);\n        case ZodFirstPartyTypeKind.ZodNull:\n            return parseNullDef(refs);\n        case ZodFirstPartyTypeKind.ZodArray:\n            return parseArrayDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodUnion:\n        case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n            return parseUnionDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodIntersection:\n            return parseIntersectionDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodTuple:\n            return parseTupleDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodRecord:\n            return parseRecordDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodLiteral:\n            return parseLiteralDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodEnum:\n            return parseEnumDef(def);\n        case ZodFirstPartyTypeKind.ZodNativeEnum:\n            return parseNativeEnumDef(def);\n        case ZodFirstPartyTypeKind.ZodNullable:\n            return parseNullableDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodOptional:\n            return parseOptionalDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodMap:\n            return parseMapDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodSet:\n            return parseSetDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodLazy:\n            return () => def.getter()._def;\n        case ZodFirstPartyTypeKind.ZodPromise:\n            return parsePromiseDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodNaN:\n        case ZodFirstPartyTypeKind.ZodNever:\n            return parseNeverDef(refs);\n        case ZodFirstPartyTypeKind.ZodEffects:\n            return parseEffectsDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodAny:\n            return parseAnyDef(refs);\n        case ZodFirstPartyTypeKind.ZodUnknown:\n            return parseUnknownDef(refs);\n        case ZodFirstPartyTypeKind.ZodDefault:\n            return parseDefaultDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBranded:\n            return parseBrandedDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodReadonly:\n            return parseReadonlyDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodCatch:\n            return parseCatchDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodPipeline:\n            return parsePipelineDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodFunction:\n        case ZodFirstPartyTypeKind.ZodVoid:\n        case ZodFirstPartyTypeKind.ZodSymbol:\n            return undefined;\n        default:\n            return ((_) => undefined)(typeName);\n    }\n};\n", "import { getRelativePath } from \"../getRelativePath.js\";\nexport function parseAnyDef(refs) {\n    if (refs.target !== \"openAi\") {\n        return {};\n    }\n    const anyDefinitionPath = [\n        ...refs.basePath,\n        refs.definitionPath,\n        refs.openAiAnyTypeName,\n    ];\n    refs.flags.hasReferencedOpenAiAnyType = true;\n    return {\n        $ref: refs.$refStrategy === \"relative\"\n            ? getRelativePath(anyDefinitionPath, refs.currentPath)\n            : anyDefinitionPath.join(\"/\"),\n    };\n}\n", "import { ZodFirstPartyTypeKind } from \"zod/v3\";\nimport { setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseArrayDef(def, refs) {\n    const res = {\n        type: \"array\",\n    };\n    if (def.type?._def &&\n        def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {\n        res.items = parseDef(def.type._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"items\"],\n        });\n    }\n    if (def.minLength) {\n        setResponseValueAndErrors(res, \"minItems\", def.minLength.value, def.minLength.message, refs);\n    }\n    if (def.maxLength) {\n        setResponseValueAndErrors(res, \"maxItems\", def.maxLength.value, def.maxLength.message, refs);\n    }\n    if (def.exactLength) {\n        setResponseValueAndErrors(res, \"minItems\", def.exactLength.value, def.exactLength.message, refs);\n        setResponseValueAndErrors(res, \"maxItems\", def.exactLength.value, def.exactLength.message, refs);\n    }\n    return res;\n}\n", "import { setResponseValueAndErrors } from \"../errorMessages.js\";\nexport function parseBigintDef(def, refs) {\n    const res = {\n        type: \"integer\",\n        format: \"int64\",\n    };\n    if (!def.checks)\n        return res;\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"min\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMinimum = true;\n                    }\n                    setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                }\n                break;\n            case \"max\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMaximum = true;\n                    }\n                    setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                }\n                break;\n            case \"multipleOf\":\n                setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n                break;\n        }\n    }\n    return res;\n}\n", "export function parseBooleanDef() {\n    return {\n        type: \"boolean\",\n    };\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport function parseBrandedDef(_def, refs) {\n    return parseDef(_def.type._def, refs);\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport const parseCatchDef = (def, refs) => {\n    return parseDef(def.innerType._def, refs);\n};\n", "import { setResponseValueAndErrors } from \"../errorMessages.js\";\nexport function parseDateDef(def, refs, overrideDateStrategy) {\n    const strategy = overrideDateStrategy ?? refs.dateStrategy;\n    if (Array.isArray(strategy)) {\n        return {\n            anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)),\n        };\n    }\n    switch (strategy) {\n        case \"string\":\n        case \"format:date-time\":\n            return {\n                type: \"string\",\n                format: \"date-time\",\n            };\n        case \"format:date\":\n            return {\n                type: \"string\",\n                format: \"date\",\n            };\n        case \"integer\":\n            return integerDateParser(def, refs);\n    }\n}\nconst integerDateParser = (def, refs) => {\n    const res = {\n        type: \"integer\",\n        format: \"unix-time\",\n    };\n    if (refs.target === \"openApi3\") {\n        return res;\n    }\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"min\":\n                setResponseValueAndErrors(res, \"minimum\", check.value, // This is in milliseconds\n                check.message, refs);\n                break;\n            case \"max\":\n                setResponseValueAndErrors(res, \"maximum\", check.value, // This is in milliseconds\n                check.message, refs);\n                break;\n        }\n    }\n    return res;\n};\n", "import { parseDef } from \"../parseDef.js\";\nexport function parseDefaultDef(_def, refs) {\n    return {\n        ...parseDef(_def.innerType._def, refs),\n        default: _def.defaultValue(),\n    };\n}\n", "import { parseDef } from \"../parseDef.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport function parseEffectsDef(_def, refs) {\n    return refs.effectStrategy === \"input\"\n        ? parseDef(_def.schema._def, refs)\n        : parseAnyDef(refs);\n}\n", "export function parseEnumDef(def) {\n    return {\n        type: \"string\",\n        enum: Array.from(def.values),\n    };\n}\n", "import { parseDef } from \"../parseDef.js\";\nconst isJsonSchema7AllOfType = (type) => {\n    if (\"type\" in type && type.type === \"string\")\n        return false;\n    return \"allOf\" in type;\n};\nexport function parseIntersectionDef(def, refs) {\n    const allOf = [\n        parseDef(def.left._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n        }),\n        parseDef(def.right._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"1\"],\n        }),\n    ].filter((x) => !!x);\n    let unevaluatedProperties = refs.target === \"jsonSchema2019-09\"\n        ? { unevaluatedProperties: false }\n        : undefined;\n    const mergedAllOf = [];\n    // If either of the schemas is an allOf, merge them into a single allOf\n    allOf.forEach((schema) => {\n        if (isJsonSchema7AllOfType(schema)) {\n            mergedAllOf.push(...schema.allOf);\n            if (schema.unevaluatedProperties === undefined) {\n                // If one of the schemas has no unevaluatedProperties set,\n                // the merged schema should also have no unevaluatedProperties set\n                unevaluatedProperties = undefined;\n            }\n        }\n        else {\n            let nestedSchema = schema;\n            if (\"additionalProperties\" in schema &&\n                schema.additionalProperties === false) {\n                const { additionalProperties, ...rest } = schema;\n                nestedSchema = rest;\n            }\n            else {\n                // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties\n                unevaluatedProperties = undefined;\n            }\n            mergedAllOf.push(nestedSchema);\n        }\n    });\n    return mergedAllOf.length\n        ? {\n            allOf: mergedAllOf,\n            ...unevaluatedProperties,\n        }\n        : undefined;\n}\n", "export function parseLiteralDef(def, refs) {\n    const parsedType = typeof def.value;\n    if (parsedType !== \"bigint\" &&\n        parsedType !== \"number\" &&\n        parsedType !== \"boolean\" &&\n        parsedType !== \"string\") {\n        return {\n            type: Array.isArray(def.value) ? \"array\" : \"object\",\n        };\n    }\n    if (refs.target === \"openApi3\") {\n        return {\n            type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n            enum: [def.value],\n        };\n    }\n    return {\n        type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n        const: def.value,\n    };\n}\n", "import { parseDef } from \"../parseDef.js\";\nimport { parseRecordDef } from \"./record.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport function parseMapDef(def, refs) {\n    if (refs.mapStrategy === \"record\") {\n        return parseRecordDef(def, refs);\n    }\n    const keys = parseDef(def.keyType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", \"items\", \"0\"],\n    }) || parseAnyDef(refs);\n    const values = parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", \"items\", \"1\"],\n    }) || parseAnyDef(refs);\n    return {\n        type: \"array\",\n        maxItems: 125,\n        items: {\n            type: \"array\",\n            items: [keys, values],\n            minItems: 2,\n            maxItems: 2,\n        },\n    };\n}\n", "import { ZodFirstPartyTypeKind, } from \"zod/v3\";\nimport { parseDef } from \"../parseDef.js\";\nimport { parseStringDef } from \"./string.js\";\nimport { parseBrandedDef } from \"./branded.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport function parseRecordDef(def, refs) {\n    if (refs.target === \"openAi\") {\n        console.warn(\"Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.\");\n    }\n    if (refs.target === \"openApi3\" &&\n        def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n        return {\n            type: \"object\",\n            required: def.keyType._def.values,\n            properties: def.keyType._def.values.reduce((acc, key) => ({\n                ...acc,\n                [key]: parseDef(def.valueType._def, {\n                    ...refs,\n                    currentPath: [...refs.currentPath, \"properties\", key],\n                }) ?? parseAnyDef(refs),\n            }), {}),\n            additionalProperties: refs.rejectedAdditionalProperties,\n        };\n    }\n    const schema = {\n        type: \"object\",\n        additionalProperties: parseDef(def.valueType._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"additionalProperties\"],\n        }) ?? refs.allowedAdditionalProperties,\n    };\n    if (refs.target === \"openApi3\") {\n        return schema;\n    }\n    if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n        def.keyType._def.checks?.length) {\n        const { type, ...keyType } = parseStringDef(def.keyType._def, refs);\n        return {\n            ...schema,\n            propertyNames: keyType,\n        };\n    }\n    else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n        return {\n            ...schema,\n            propertyNames: {\n                enum: def.keyType._def.values,\n            },\n        };\n    }\n    else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded &&\n        def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n        def.keyType._def.type._def.checks?.length) {\n        const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);\n        return {\n            ...schema,\n            propertyNames: keyType,\n        };\n    }\n    return schema;\n}\n", "import { setResponseValueAndErrors } from \"../errorMessages.js\";\nlet emojiRegex = undefined;\n/**\n * Generated from the regular expressions found here as of 2024-05-22:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Expressions with /i flag have been changed accordingly.\n */\nexport const zodPatterns = {\n    /**\n     * `c` was changed to `[cC]` to replicate /i flag\n     */\n    cuid: /^[cC][^\\s-]{8,}$/,\n    cuid2: /^[0-9a-z]+$/,\n    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n    /**\n     * `a-z` was added to replicate /i flag\n     */\n    email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n    /**\n     * Constructed a valid Unicode RegExp\n     *\n     * Lazily instantiate since this type of regex isn't supported\n     * in all envs (e.g. React Native).\n     *\n     * See:\n     * https://github.com/colinhacks/zod/issues/2433\n     * Fix in Zod:\n     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n     */\n    emoji: () => {\n        if (emojiRegex === undefined) {\n            emojiRegex = RegExp(\"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\", \"u\");\n        }\n        return emojiRegex;\n    },\n    /**\n     * Unused\n     */\n    uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n    /**\n     * Unused\n     */\n    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n    /**\n     * Unused\n     */\n    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n    nanoid: /^[a-zA-Z0-9_-]{21}$/,\n    jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/,\n};\nexport function parseStringDef(def, refs) {\n    const res = {\n        type: \"string\",\n    };\n    if (def.checks) {\n        for (const check of def.checks) {\n            switch (check.kind) {\n                case \"min\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"max\":\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"email\":\n                    switch (refs.emailStrategy) {\n                        case \"format:email\":\n                            addFormat(res, \"email\", check.message, refs);\n                            break;\n                        case \"format:idn-email\":\n                            addFormat(res, \"idn-email\", check.message, refs);\n                            break;\n                        case \"pattern:zod\":\n                            addPattern(res, zodPatterns.email, check.message, refs);\n                            break;\n                    }\n                    break;\n                case \"url\":\n                    addFormat(res, \"uri\", check.message, refs);\n                    break;\n                case \"uuid\":\n                    addFormat(res, \"uuid\", check.message, refs);\n                    break;\n                case \"regex\":\n                    addPattern(res, check.regex, check.message, refs);\n                    break;\n                case \"cuid\":\n                    addPattern(res, zodPatterns.cuid, check.message, refs);\n                    break;\n                case \"cuid2\":\n                    addPattern(res, zodPatterns.cuid2, check.message, refs);\n                    break;\n                case \"startsWith\":\n                    addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);\n                    break;\n                case \"endsWith\":\n                    addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);\n                    break;\n                case \"datetime\":\n                    addFormat(res, \"date-time\", check.message, refs);\n                    break;\n                case \"date\":\n                    addFormat(res, \"date\", check.message, refs);\n                    break;\n                case \"time\":\n                    addFormat(res, \"time\", check.message, refs);\n                    break;\n                case \"duration\":\n                    addFormat(res, \"duration\", check.message, refs);\n                    break;\n                case \"length\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"includes\": {\n                    addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);\n                    break;\n                }\n                case \"ip\": {\n                    if (check.version !== \"v6\") {\n                        addFormat(res, \"ipv4\", check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addFormat(res, \"ipv6\", check.message, refs);\n                    }\n                    break;\n                }\n                case \"base64url\":\n                    addPattern(res, zodPatterns.base64url, check.message, refs);\n                    break;\n                case \"jwt\":\n                    addPattern(res, zodPatterns.jwt, check.message, refs);\n                    break;\n                case \"cidr\": {\n                    if (check.version !== \"v6\") {\n                        addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);\n                    }\n                    break;\n                }\n                case \"emoji\":\n                    addPattern(res, zodPatterns.emoji(), check.message, refs);\n                    break;\n                case \"ulid\": {\n                    addPattern(res, zodPatterns.ulid, check.message, refs);\n                    break;\n                }\n                case \"base64\": {\n                    switch (refs.base64Strategy) {\n                        case \"format:binary\": {\n                            addFormat(res, \"binary\", check.message, refs);\n                            break;\n                        }\n                        case \"contentEncoding:base64\": {\n                            setResponseValueAndErrors(res, \"contentEncoding\", \"base64\", check.message, refs);\n                            break;\n                        }\n                        case \"pattern:zod\": {\n                            addPattern(res, zodPatterns.base64, check.message, refs);\n                            break;\n                        }\n                    }\n                    break;\n                }\n                case \"nanoid\": {\n                    addPattern(res, zodPatterns.nanoid, check.message, refs);\n                }\n                case \"toLowerCase\":\n                case \"toUpperCase\":\n                case \"trim\":\n                    break;\n                default:\n                    ((_) => { })(check);\n            }\n        }\n    }\n    return res;\n}\nfunction escapeLiteralCheckValue(literal, refs) {\n    return refs.patternStrategy === \"escape\"\n        ? escapeNonAlphaNumeric(literal)\n        : literal;\n}\nconst ALPHA_NUMERIC = new Set(\"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\");\nfunction escapeNonAlphaNumeric(source) {\n    let result = \"\";\n    for (let i = 0; i < source.length; i++) {\n        if (!ALPHA_NUMERIC.has(source[i])) {\n            result += \"\\\\\";\n        }\n        result += source[i];\n    }\n    return result;\n}\n// Adds a \"format\" keyword to the schema. If a format exists, both formats will be joined in an allOf-node, along with subsequent ones.\nfunction addFormat(schema, value, message, refs) {\n    if (schema.format || schema.anyOf?.some((x) => x.format)) {\n        if (!schema.anyOf) {\n            schema.anyOf = [];\n        }\n        if (schema.format) {\n            schema.anyOf.push({\n                format: schema.format,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { format: schema.errorMessage.format },\n                }),\n            });\n            delete schema.format;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.format;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.anyOf.push({\n            format: value,\n            ...(message &&\n                refs.errorMessages && { errorMessage: { format: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"format\", value, message, refs);\n    }\n}\n// Adds a \"pattern\" keyword to the schema. If a pattern exists, both patterns will be joined in an allOf-node, along with subsequent ones.\nfunction addPattern(schema, regex, message, refs) {\n    if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {\n        if (!schema.allOf) {\n            schema.allOf = [];\n        }\n        if (schema.pattern) {\n            schema.allOf.push({\n                pattern: schema.pattern,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { pattern: schema.errorMessage.pattern },\n                }),\n            });\n            delete schema.pattern;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.pattern;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.allOf.push({\n            pattern: stringifyRegExpWithFlags(regex, refs),\n            ...(message &&\n                refs.errorMessages && { errorMessage: { pattern: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"pattern\", stringifyRegExpWithFlags(regex, refs), message, refs);\n    }\n}\n// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\nfunction stringifyRegExpWithFlags(regex, refs) {\n    if (!refs.applyRegexFlags || !regex.flags) {\n        return regex.source;\n    }\n    // Currently handled flags\n    const flags = {\n        i: regex.flags.includes(\"i\"),\n        m: regex.flags.includes(\"m\"),\n        s: regex.flags.includes(\"s\"), // `.` matches newlines\n    };\n    // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n    const source = flags.i ? regex.source.toLowerCase() : regex.source;\n    let pattern = \"\";\n    let isEscaped = false;\n    let inCharGroup = false;\n    let inCharRange = false;\n    for (let i = 0; i < source.length; i++) {\n        if (isEscaped) {\n            pattern += source[i];\n            isEscaped = false;\n            continue;\n        }\n        if (flags.i) {\n            if (inCharGroup) {\n                if (source[i].match(/[a-z]/)) {\n                    if (inCharRange) {\n                        pattern += source[i];\n                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n                        inCharRange = false;\n                    }\n                    else if (source[i + 1] === \"-\" && source[i + 2]?.match(/[a-z]/)) {\n                        pattern += source[i];\n                        inCharRange = true;\n                    }\n                    else {\n                        pattern += `${source[i]}${source[i].toUpperCase()}`;\n                    }\n                    continue;\n                }\n            }\n            else if (source[i].match(/[a-z]/)) {\n                pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n                continue;\n            }\n        }\n        if (flags.m) {\n            if (source[i] === \"^\") {\n                pattern += `(^|(?<=[\\r\\n]))`;\n                continue;\n            }\n            else if (source[i] === \"$\") {\n                pattern += `($|(?=[\\r\\n]))`;\n                continue;\n            }\n        }\n        if (flags.s && source[i] === \".\") {\n            pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n            continue;\n        }\n        pattern += source[i];\n        if (source[i] === \"\\\\\") {\n            isEscaped = true;\n        }\n        else if (inCharGroup && source[i] === \"]\") {\n            inCharGroup = false;\n        }\n        else if (!inCharGroup && source[i] === \"[\") {\n            inCharGroup = true;\n        }\n    }\n    try {\n        new RegExp(pattern);\n    }\n    catch {\n        console.warn(`Could not convert regex pattern at ${refs.currentPath.join(\"/\")} to a flag-independent form! Falling back to the flag-ignorant source`);\n        return regex.source;\n    }\n    return pattern;\n}\n", "export function parseNativeEnumDef(def) {\n    const object = def.values;\n    const actualKeys = Object.keys(def.values).filter((key) => {\n        return typeof object[object[key]] !== \"number\";\n    });\n    const actualValues = actualKeys.map((key) => object[key]);\n    const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));\n    return {\n        type: parsedTypes.length === 1\n            ? parsedTypes[0] === \"string\"\n                ? \"string\"\n                : \"number\"\n            : [\"string\", \"number\"],\n        enum: actualValues,\n    };\n}\n", "import { parseAnyDef } from \"./any.js\";\nexport function parseNeverDef(refs) {\n    return refs.target === \"openAi\"\n        ? undefined\n        : {\n            not: parseAnyDef({\n                ...refs,\n                currentPath: [...refs.currentPath, \"not\"],\n            }),\n        };\n}\n", "export function parseNullDef(refs) {\n    return refs.target === \"openApi3\"\n        ? {\n            enum: [\"null\"],\n            nullable: true,\n        }\n        : {\n            type: \"null\",\n        };\n}\n", "import { parseDef } from \"../parseDef.js\";\nimport { primitiveMappings } from \"./union.js\";\nexport function parseNullableDef(def, refs) {\n    if ([\"ZodString\", \"ZodNumber\", \"ZodBigInt\", \"ZodBoolean\", \"ZodNull\"].includes(def.innerType._def.typeName) &&\n        (!def.innerType._def.checks || !def.innerType._def.checks.length)) {\n        if (refs.target === \"openApi3\") {\n            return {\n                type: primitiveMappings[def.innerType._def.typeName],\n                nullable: true,\n            };\n        }\n        return {\n            type: [\n                primitiveMappings[def.innerType._def.typeName],\n                \"null\",\n            ],\n        };\n    }\n    if (refs.target === \"openApi3\") {\n        const base = parseDef(def.innerType._def, {\n            ...refs,\n            currentPath: [...refs.currentPath],\n        });\n        if (base && \"$ref\" in base)\n            return { allOf: [base], nullable: true };\n        return base && { ...base, nullable: true };\n    }\n    const base = parseDef(def.innerType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", \"0\"],\n    });\n    return base && { anyOf: [base, { type: \"null\" }] };\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport const primitiveMappings = {\n    ZodString: \"string\",\n    ZodNumber: \"number\",\n    ZodBigInt: \"integer\",\n    ZodBoolean: \"boolean\",\n    ZodNull: \"null\",\n};\nexport function parseUnionDef(def, refs) {\n    if (refs.target === \"openApi3\")\n        return asAnyOf(def, refs);\n    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n    // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.\n    if (options.every((x) => x._def.typeName in primitiveMappings &&\n        (!x._def.checks || !x._def.checks.length))) {\n        // all types in union are primitive and lack checks, so might as well squash into {type: [...]}\n        const types = options.reduce((types, x) => {\n            const type = primitiveMappings[x._def.typeName]; //Can be safely casted due to row 43\n            return type && !types.includes(type) ? [...types, type] : types;\n        }, []);\n        return {\n            type: types.length > 1 ? types : types[0],\n        };\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n        // all options literals\n        const types = options.reduce((acc, x) => {\n            const type = typeof x._def.value;\n            switch (type) {\n                case \"string\":\n                case \"number\":\n                case \"boolean\":\n                    return [...acc, type];\n                case \"bigint\":\n                    return [...acc, \"integer\"];\n                case \"object\":\n                    if (x._def.value === null)\n                        return [...acc, \"null\"];\n                case \"symbol\":\n                case \"undefined\":\n                case \"function\":\n                default:\n                    return acc;\n            }\n        }, []);\n        if (types.length === options.length) {\n            // all the literals are primitive, as far as null can be considered primitive\n            const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n            return {\n                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n                enum: options.reduce((acc, x) => {\n                    return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n                }, []),\n            };\n        }\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodEnum\")) {\n        return {\n            type: \"string\",\n            enum: options.reduce((acc, x) => [\n                ...acc,\n                ...x._def.values.filter((x) => !acc.includes(x)),\n            ], []),\n        };\n    }\n    return asAnyOf(def, refs);\n}\nconst asAnyOf = (def, refs) => {\n    const anyOf = (def.options instanceof Map\n        ? Array.from(def.options.values())\n        : def.options)\n        .map((x, i) => parseDef(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", `${i}`],\n    }))\n        .filter((x) => !!x &&\n        (!refs.strictUnions ||\n            (typeof x === \"object\" && Object.keys(x).length > 0)));\n    return anyOf.length ? { anyOf } : undefined;\n};\n", "import { addErrorMessage, setResponseValueAndErrors, } from \"../errorMessages.js\";\nexport function parseNumberDef(def, refs) {\n    const res = {\n        type: \"number\",\n    };\n    if (!def.checks)\n        return res;\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"int\":\n                res.type = \"integer\";\n                addErrorMessage(res, \"type\", check.message, refs);\n                break;\n            case \"min\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMinimum = true;\n                    }\n                    setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                }\n                break;\n            case \"max\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMaximum = true;\n                    }\n                    setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                }\n                break;\n            case \"multipleOf\":\n                setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n                break;\n        }\n    }\n    return res;\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport function parseObjectDef(def, refs) {\n    const forceOptionalIntoNullable = refs.target === \"openAi\";\n    const result = {\n        type: \"object\",\n        properties: {},\n    };\n    const required = [];\n    const shape = def.shape();\n    for (const propName in shape) {\n        let propDef = shape[propName];\n        if (propDef === undefined || propDef._def === undefined) {\n            continue;\n        }\n        let propOptional = safeIsOptional(propDef);\n        if (propOptional && forceOptionalIntoNullable) {\n            if (propDef._def.typeName === \"ZodOptional\") {\n                propDef = propDef._def.innerType;\n            }\n            if (!propDef.isNullable()) {\n                propDef = propDef.nullable();\n            }\n            propOptional = false;\n        }\n        const parsedDef = parseDef(propDef._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"properties\", propName],\n            propertyPath: [...refs.currentPath, \"properties\", propName],\n        });\n        if (parsedDef === undefined) {\n            continue;\n        }\n        result.properties[propName] = parsedDef;\n        if (!propOptional) {\n            required.push(propName);\n        }\n    }\n    if (required.length) {\n        result.required = required;\n    }\n    const additionalProperties = decideAdditionalProperties(def, refs);\n    if (additionalProperties !== undefined) {\n        result.additionalProperties = additionalProperties;\n    }\n    return result;\n}\nfunction decideAdditionalProperties(def, refs) {\n    if (def.catchall._def.typeName !== \"ZodNever\") {\n        return parseDef(def.catchall._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"additionalProperties\"],\n        });\n    }\n    switch (def.unknownKeys) {\n        case \"passthrough\":\n            return refs.allowedAdditionalProperties;\n        case \"strict\":\n            return refs.rejectedAdditionalProperties;\n        case \"strip\":\n            return refs.removeAdditionalStrategy === \"strict\"\n                ? refs.allowedAdditionalProperties\n                : refs.rejectedAdditionalProperties;\n    }\n}\nfunction safeIsOptional(schema) {\n    try {\n        return schema.isOptional();\n    }\n    catch {\n        return true;\n    }\n}\n", "import { parseDef } from \"../parseDef.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport const parseOptionalDef = (def, refs) => {\n    if (refs.currentPath.toString() === refs.propertyPath?.toString()) {\n        return parseDef(def.innerType._def, refs);\n    }\n    const innerSchema = parseDef(def.innerType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", \"1\"],\n    });\n    return innerSchema\n        ? {\n            anyOf: [\n                {\n                    not: parseAnyDef(refs),\n                },\n                innerSchema,\n            ],\n        }\n        : parseAnyDef(refs);\n};\n", "import { parseDef } from \"../parseDef.js\";\nexport const parsePipelineDef = (def, refs) => {\n    if (refs.pipeStrategy === \"input\") {\n        return parseDef(def.in._def, refs);\n    }\n    else if (refs.pipeStrategy === \"output\") {\n        return parseDef(def.out._def, refs);\n    }\n    const a = parseDef(def.in._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n    });\n    const b = parseDef(def.out._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"allOf\", a ? \"1\" : \"0\"],\n    });\n    return {\n        allOf: [a, b].filter((x) => x !== undefined),\n    };\n};\n", "import { parseDef } from \"../parseDef.js\";\nexport function parsePromiseDef(def, refs) {\n    return parseDef(def.type._def, refs);\n}\n", "import { setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseSetDef(def, refs) {\n    const items = parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\"],\n    });\n    const schema = {\n        type: \"array\",\n        uniqueItems: true,\n        items,\n    };\n    if (def.minSize) {\n        setResponseValueAndErrors(schema, \"minItems\", def.minSize.value, def.minSize.message, refs);\n    }\n    if (def.maxSize) {\n        setResponseValueAndErrors(schema, \"maxItems\", def.maxSize.value, def.maxSize.message, refs);\n    }\n    return schema;\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport function parseTupleDef(def, refs) {\n    if (def.rest) {\n        return {\n            type: \"array\",\n            minItems: def.items.length,\n            items: def.items\n                .map((x, i) => parseDef(x._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"items\", `${i}`],\n            }))\n                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n            additionalItems: parseDef(def.rest._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"additionalItems\"],\n            }),\n        };\n    }\n    else {\n        return {\n            type: \"array\",\n            minItems: def.items.length,\n            maxItems: def.items.length,\n            items: def.items\n                .map((x, i) => parseDef(x._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"items\", `${i}`],\n            }))\n                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n        };\n    }\n}\n", "import { parseAnyDef } from \"./any.js\";\nexport function parseUndefinedDef(refs) {\n    return {\n        not: parseAnyDef(refs),\n    };\n}\n", "import { parseAnyDef } from \"./any.js\";\nexport function parseUnknownDef(refs) {\n    return parseAnyDef(refs);\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport const parseReadonlyDef = (def, refs) => {\n    return parseDef(def.innerType._def, refs);\n};\n", "export {};\n", "import { parseDef } from \"./parseDef.js\";\nimport { getRefs } from \"./Refs.js\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nconst zodToJsonSchema = (schema, options) => {\n    const refs = getRefs(options);\n    let definitions = typeof options === \"object\" && options.definitions\n        ? Object.entries(options.definitions).reduce((acc, [name, schema]) => ({\n            ...acc,\n            [name]: parseDef(schema._def, {\n                ...refs,\n                currentPath: [...refs.basePath, refs.definitionPath, name],\n            }, true) ?? parseAnyDef(refs),\n        }), {})\n        : undefined;\n    const name = typeof options === \"string\"\n        ? options\n        : options?.nameStrategy === \"title\"\n            ? undefined\n            : options?.name;\n    const main = parseDef(schema._def, name === undefined\n        ? refs\n        : {\n            ...refs,\n            currentPath: [...refs.basePath, refs.definitionPath, name],\n        }, false) ?? parseAnyDef(refs);\n    const title = typeof options === \"object\" &&\n        options.name !== undefined &&\n        options.nameStrategy === \"title\"\n        ? options.name\n        : undefined;\n    if (title !== undefined) {\n        main.title = title;\n    }\n    if (refs.flags.hasReferencedOpenAiAnyType) {\n        if (!definitions) {\n            definitions = {};\n        }\n        if (!definitions[refs.openAiAnyTypeName]) {\n            definitions[refs.openAiAnyTypeName] = {\n                // Skipping \"object\" as no properties can be defined and additionalProperties must be \"false\"\n                type: [\"string\", \"number\", \"integer\", \"boolean\", \"array\", \"null\"],\n                items: {\n                    $ref: refs.$refStrategy === \"relative\"\n                        ? \"1\"\n                        : [\n                            ...refs.basePath,\n                            refs.definitionPath,\n                            refs.openAiAnyTypeName,\n                        ].join(\"/\"),\n                },\n            };\n        }\n    }\n    const combined = name === undefined\n        ? definitions\n            ? {\n                ...main,\n                [refs.definitionPath]: definitions,\n            }\n            : main\n        : {\n            $ref: [\n                ...(refs.$refStrategy === \"relative\" ? [] : refs.basePath),\n                refs.definitionPath,\n                name,\n            ].join(\"/\"),\n            [refs.definitionPath]: {\n                ...definitions,\n                [name]: main,\n            },\n        };\n    if (refs.target === \"jsonSchema7\") {\n        combined.$schema = \"http://json-schema.org/draft-07/schema#\";\n    }\n    else if (refs.target === \"jsonSchema2019-09\" || refs.target === \"openAi\") {\n        combined.$schema = \"https://json-schema.org/draft/2019-09/schema#\";\n    }\n    if (refs.target === \"openAi\" &&\n        (\"anyOf\" in combined ||\n            \"oneOf\" in combined ||\n            \"allOf\" in combined ||\n            (\"type\" in combined && Array.isArray(combined.type)))) {\n        console.warn(\"Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.\");\n    }\n    return combined;\n};\nexport { zodToJsonSchema };\n", "export * from './types';\n\nexport { generateId } from '@ai-sdk/provider-utils';\n\n// Export stream data utilities for custom stream implementations,\n// both on the client and server side.\n// NOTE: this is experimental / internal and may change without notice\nexport {\n  formatAssistantStreamPart,\n  parseAssistantStreamPart,\n} from './assistant-stream-parts';\nexport type {\n  AssistantStreamPart,\n  AssistantStreamString,\n} from './assistant-stream-parts';\nexport { callChatApi } from './call-chat-api';\nexport { callCompletionApi } from './call-completion-api';\nexport { formatDataStreamPart, parseDataStreamPart } from './data-stream-parts';\nexport type { DataStreamPart, DataStreamString } from './data-stream-parts';\nexport { getTextFromDataUrl } from './data-url';\nexport type { DeepPartial } from './deep-partial';\nexport { extractMaxToolInvocationStep } from './extract-max-tool-invocation-step';\nexport { fillMessageParts } from './fill-message-parts';\nexport { getMessageParts } from './get-message-parts';\nexport { isDeepEqualData } from './is-deep-equal-data';\nexport { parsePartialJson } from './parse-partial-json';\nexport { prepareAttachmentsForRequest } from './prepare-attachments-for-request';\nexport { processAssistantStream } from './process-assistant-stream';\nexport { processDataStream } from './process-data-stream';\nexport { processTextStream } from './process-text-stream';\nexport { asSchema, jsonSchema } from './schema';\nexport type { Schema } from './schema';\nexport {\n  isAssistantMessageWithCompletedToolCalls,\n  shouldResubmitMessages,\n} from './should-resubmit-messages';\nexport { updateToolCallResult } from './update-tool-call-result';\nexport { zodSchema } from './zod-schema';\n", "import { AssistantMessage, DataMessage, JSONValue } from './types';\n\nexport type AssistantStreamString =\n  `${(typeof StreamStringPrefixes)[keyof typeof StreamStringPrefixes]}:${string}\\n`;\n\nexport interface AssistantStreamPart<\n  CODE extends string,\n  NAME extends string,\n  TYPE,\n> {\n  code: CODE;\n  name: NAME;\n  parse: (value: JSONValue) => { type: NAME; value: TYPE };\n}\n\nconst textStreamPart: AssistantStreamPart<'0', 'text', string> = {\n  code: '0',\n  name: 'text',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: 'text', value };\n  },\n};\n\nconst errorStreamPart: AssistantStreamPart<'3', 'error', string> = {\n  code: '3',\n  name: 'error',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: 'error', value };\n  },\n};\n\nconst assistantMessageStreamPart: AssistantStreamPart<\n  '4',\n  'assistant_message',\n  AssistantMessage\n> = {\n  code: '4',\n  name: 'assistant_message',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('id' in value) ||\n      !('role' in value) ||\n      !('content' in value) ||\n      typeof value.id !== 'string' ||\n      typeof value.role !== 'string' ||\n      value.role !== 'assistant' ||\n      !Array.isArray(value.content) ||\n      !value.content.every(\n        item =>\n          item != null &&\n          typeof item === 'object' &&\n          'type' in item &&\n          item.type === 'text' &&\n          'text' in item &&\n          item.text != null &&\n          typeof item.text === 'object' &&\n          'value' in item.text &&\n          typeof item.text.value === 'string',\n      )\n    ) {\n      throw new Error(\n        '\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.',\n      );\n    }\n\n    return {\n      type: 'assistant_message',\n      value: value as AssistantMessage,\n    };\n  },\n};\n\nconst assistantControlDataStreamPart: AssistantStreamPart<\n  '5',\n  'assistant_control_data',\n  {\n    threadId: string;\n    messageId: string;\n  }\n> = {\n  code: '5',\n  name: 'assistant_control_data',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('threadId' in value) ||\n      !('messageId' in value) ||\n      typeof value.threadId !== 'string' ||\n      typeof value.messageId !== 'string'\n    ) {\n      throw new Error(\n        '\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.',\n      );\n    }\n\n    return {\n      type: 'assistant_control_data',\n      value: {\n        threadId: value.threadId,\n        messageId: value.messageId,\n      },\n    };\n  },\n};\n\nconst dataMessageStreamPart: AssistantStreamPart<\n  '6',\n  'data_message',\n  DataMessage\n> = {\n  code: '6',\n  name: 'data_message',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('role' in value) ||\n      !('data' in value) ||\n      typeof value.role !== 'string' ||\n      value.role !== 'data'\n    ) {\n      throw new Error(\n        '\"data_message\" parts expect an object with a \"role\" and \"data\" property.',\n      );\n    }\n\n    return {\n      type: 'data_message',\n      value: value as DataMessage,\n    };\n  },\n};\n\nconst assistantStreamParts = [\n  textStreamPart,\n  errorStreamPart,\n  assistantMessageStreamPart,\n  assistantControlDataStreamPart,\n  dataMessageStreamPart,\n] as const;\n\ntype AssistantStreamParts =\n  | typeof textStreamPart\n  | typeof errorStreamPart\n  | typeof assistantMessageStreamPart\n  | typeof assistantControlDataStreamPart\n  | typeof dataMessageStreamPart;\n\ntype AssistantStreamPartValueType = {\n  [P in AssistantStreamParts as P['name']]: ReturnType<P['parse']>['value'];\n};\n\nexport type AssistantStreamPartType =\n  | ReturnType<typeof textStreamPart.parse>\n  | ReturnType<typeof errorStreamPart.parse>\n  | ReturnType<typeof assistantMessageStreamPart.parse>\n  | ReturnType<typeof assistantControlDataStreamPart.parse>\n  | ReturnType<typeof dataMessageStreamPart.parse>;\n\nexport const assistantStreamPartsByCode = {\n  [textStreamPart.code]: textStreamPart,\n  [errorStreamPart.code]: errorStreamPart,\n  [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n  [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n  [dataMessageStreamPart.code]: dataMessageStreamPart,\n} as const;\n\nexport const StreamStringPrefixes = {\n  [textStreamPart.name]: textStreamPart.code,\n  [errorStreamPart.name]: errorStreamPart.code,\n  [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n  [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n  [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n} as const;\n\nexport const validCodes = assistantStreamParts.map(part => part.code);\n\nexport const parseAssistantStreamPart = (\n  line: string,\n): AssistantStreamPartType => {\n  const firstSeparatorIndex = line.indexOf(':');\n\n  if (firstSeparatorIndex === -1) {\n    throw new Error('Failed to parse stream string. No separator found.');\n  }\n\n  const prefix = line.slice(0, firstSeparatorIndex);\n\n  if (!validCodes.includes(prefix as keyof typeof assistantStreamPartsByCode)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n\n  const code = prefix as keyof typeof assistantStreamPartsByCode;\n\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue: JSONValue = JSON.parse(textValue);\n\n  return assistantStreamPartsByCode[code].parse(jsonValue);\n};\n\nexport function formatAssistantStreamPart<\n  T extends keyof AssistantStreamPartValueType,\n>(type: T, value: AssistantStreamPartValueType[T]): AssistantStreamString {\n  const streamPart = assistantStreamParts.find(part => part.name === type);\n\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n\n  return `${streamPart.code}:${JSON.stringify(value)}\\n`;\n}\n", "import { LanguageModelV1FinishReason } from '@ai-sdk/provider';\nimport { generateId as generateIdFunction } from '@ai-sdk/provider-utils';\nimport {\n  calculateLanguageModelUsage,\n  LanguageModelUsage,\n} from './duplicated/usage';\nimport { parsePartialJson } from './parse-partial-json';\nimport { processDataStream } from './process-data-stream';\nimport type {\n  JSONValue,\n  ReasoningUIPart,\n  TextUIPart,\n  ToolInvocation,\n  ToolInvocationUIPart,\n  UIMessage,\n  UseChatOptions,\n} from './types';\n\nexport async function processChatResponse({\n  stream,\n  update,\n  onToolCall,\n  onFinish,\n  generateId = generateIdFunction,\n  getCurrentDate = () => new Date(),\n  lastMessage,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  update: (options: {\n    message: UIMessage;\n    data: JSONValue[] | undefined;\n    replaceLastMessage: boolean;\n  }) => void;\n  onToolCall?: UseChatOptions['onToolCall'];\n  onFinish?: (options: {\n    message: UIMessage | undefined;\n    finishReason: LanguageModelV1FinishReason;\n    usage: LanguageModelUsage;\n  }) => void;\n  generateId?: () => string;\n  getCurrentDate?: () => Date;\n  lastMessage: UIMessage | undefined;\n}) {\n  const replaceLastMessage = lastMessage?.role === 'assistant';\n  let step = replaceLastMessage\n    ? 1 +\n      // find max step in existing tool invocations:\n      (lastMessage.toolInvocations?.reduce((max, toolInvocation) => {\n        return Math.max(max, toolInvocation.step ?? 0);\n      }, 0) ?? 0)\n    : 0;\n\n  const message: UIMessage = replaceLastMessage\n    ? structuredClone(lastMessage)\n    : {\n        id: generateId(),\n        createdAt: getCurrentDate(),\n        role: 'assistant',\n        content: '',\n        parts: [],\n      };\n\n  let currentTextPart: TextUIPart | undefined = undefined;\n  let currentReasoningPart: ReasoningUIPart | undefined = undefined;\n  let currentReasoningTextDetail:\n    | { type: 'text'; text: string; signature?: string }\n    | undefined = undefined;\n\n  function updateToolInvocationPart(\n    toolCallId: string,\n    invocation: ToolInvocation,\n  ) {\n    const part = message.parts.find(\n      part =>\n        part.type === 'tool-invocation' &&\n        part.toolInvocation.toolCallId === toolCallId,\n    ) as ToolInvocationUIPart | undefined;\n\n    if (part != null) {\n      part.toolInvocation = invocation;\n    } else {\n      message.parts.push({\n        type: 'tool-invocation',\n        toolInvocation: invocation,\n      });\n    }\n  }\n\n  const data: JSONValue[] = [];\n\n  // keep list of current message annotations for message\n  let messageAnnotations: JSONValue[] | undefined = replaceLastMessage\n    ? lastMessage?.annotations\n    : undefined;\n\n  // keep track of partial tool calls\n  const partialToolCalls: Record<\n    string,\n    { text: string; step: number; index: number; toolName: string }\n  > = {};\n\n  let usage: LanguageModelUsage = {\n    completionTokens: NaN,\n    promptTokens: NaN,\n    totalTokens: NaN,\n  };\n  let finishReason: LanguageModelV1FinishReason = 'unknown';\n\n  function execUpdate() {\n    // make a copy of the data array to ensure UI is updated (SWR)\n    const copiedData = [...data];\n\n    // keeps the currentMessage up to date with the latest annotations,\n    // even if annotations preceded the message creation\n    if (messageAnnotations?.length) {\n      message.annotations = messageAnnotations;\n    }\n\n    const copiedMessage = {\n      // deep copy the message to ensure that deep changes (msg attachments) are updated\n      // with SolidJS. SolidJS uses referential integration of sub-objects to detect changes.\n      ...structuredClone(message),\n      // add a revision id to ensure that the message is updated with SWR. SWR uses a\n      // hashing approach by default to detect changes, but it only works for shallow\n      // changes. This is why we need to add a revision id to ensure that the message\n      // is updated with SWR (without it, the changes get stuck in SWR and are not\n      // forwarded to rendering):\n      revisionId: generateId(),\n    } as UIMessage;\n\n    update({\n      message: copiedMessage,\n      data: copiedData,\n      replaceLastMessage,\n    });\n  }\n\n  await processDataStream({\n    stream,\n    onTextPart(value) {\n      if (currentTextPart == null) {\n        currentTextPart = {\n          type: 'text',\n          text: value,\n        };\n        message.parts.push(currentTextPart);\n      } else {\n        currentTextPart.text += value;\n      }\n\n      message.content += value;\n      execUpdate();\n    },\n    onReasoningPart(value) {\n      if (currentReasoningTextDetail == null) {\n        currentReasoningTextDetail = { type: 'text', text: value };\n        if (currentReasoningPart != null) {\n          currentReasoningPart.details.push(currentReasoningTextDetail);\n        }\n      } else {\n        currentReasoningTextDetail.text += value;\n      }\n\n      if (currentReasoningPart == null) {\n        currentReasoningPart = {\n          type: 'reasoning',\n          reasoning: value,\n          details: [currentReasoningTextDetail],\n        };\n        message.parts.push(currentReasoningPart);\n      } else {\n        currentReasoningPart.reasoning += value;\n      }\n\n      message.reasoning = (message.reasoning ?? '') + value;\n\n      execUpdate();\n    },\n    onReasoningSignaturePart(value) {\n      if (currentReasoningTextDetail != null) {\n        currentReasoningTextDetail.signature = value.signature;\n      }\n    },\n    onRedactedReasoningPart(value) {\n      if (currentReasoningPart == null) {\n        currentReasoningPart = {\n          type: 'reasoning',\n          reasoning: '',\n          details: [],\n        };\n        message.parts.push(currentReasoningPart);\n      }\n\n      currentReasoningPart.details.push({\n        type: 'redacted',\n        data: value.data,\n      });\n\n      currentReasoningTextDetail = undefined;\n\n      execUpdate();\n    },\n    onFilePart(value) {\n      message.parts.push({\n        type: 'file',\n        mimeType: value.mimeType,\n        data: value.data,\n      });\n\n      execUpdate();\n    },\n    onSourcePart(value) {\n      message.parts.push({\n        type: 'source',\n        source: value,\n      });\n\n      execUpdate();\n    },\n    onToolCallStreamingStartPart(value) {\n      if (message.toolInvocations == null) {\n        message.toolInvocations = [];\n      }\n\n      // add the partial tool call to the map\n      partialToolCalls[value.toolCallId] = {\n        text: '',\n        step,\n        toolName: value.toolName,\n        index: message.toolInvocations.length,\n      };\n\n      const invocation = {\n        state: 'partial-call',\n        step,\n        toolCallId: value.toolCallId,\n        toolName: value.toolName,\n        args: undefined,\n      } as const;\n\n      message.toolInvocations.push(invocation);\n\n      updateToolInvocationPart(value.toolCallId, invocation);\n\n      execUpdate();\n    },\n    onToolCallDeltaPart(value) {\n      const partialToolCall = partialToolCalls[value.toolCallId];\n\n      partialToolCall.text += value.argsTextDelta;\n\n      const { value: partialArgs } = parsePartialJson(partialToolCall.text);\n\n      const invocation = {\n        state: 'partial-call',\n        step: partialToolCall.step,\n        toolCallId: value.toolCallId,\n        toolName: partialToolCall.toolName,\n        args: partialArgs,\n      } as const;\n\n      message.toolInvocations![partialToolCall.index] = invocation;\n\n      updateToolInvocationPart(value.toolCallId, invocation);\n\n      execUpdate();\n    },\n    async onToolCallPart(value) {\n      const invocation = {\n        state: 'call',\n        step,\n        ...value,\n      } as const;\n\n      if (partialToolCalls[value.toolCallId] != null) {\n        // change the partial tool call to a full tool call\n        message.toolInvocations![partialToolCalls[value.toolCallId].index] =\n          invocation;\n      } else {\n        if (message.toolInvocations == null) {\n          message.toolInvocations = [];\n        }\n\n        message.toolInvocations.push(invocation);\n      }\n\n      updateToolInvocationPart(value.toolCallId, invocation);\n\n      execUpdate();\n\n      // invoke the onToolCall callback if it exists. This is blocking.\n      // In the future we should make this non-blocking, which\n      // requires additional state management for error handling etc.\n      if (onToolCall) {\n        const result = await onToolCall({ toolCall: value });\n        if (result != null) {\n          const invocation = {\n            state: 'result',\n            step,\n            ...value,\n            result,\n          } as const;\n\n          // store the result in the tool invocation\n          message.toolInvocations![message.toolInvocations!.length - 1] =\n            invocation;\n\n          updateToolInvocationPart(value.toolCallId, invocation);\n\n          execUpdate();\n        }\n      }\n    },\n    onToolResultPart(value) {\n      const toolInvocations = message.toolInvocations;\n\n      if (toolInvocations == null) {\n        throw new Error('tool_result must be preceded by a tool_call');\n      }\n\n      // find if there is any tool invocation with the same toolCallId\n      // and replace it with the result\n      const toolInvocationIndex = toolInvocations.findIndex(\n        invocation => invocation.toolCallId === value.toolCallId,\n      );\n\n      if (toolInvocationIndex === -1) {\n        throw new Error(\n          'tool_result must be preceded by a tool_call with the same toolCallId',\n        );\n      }\n\n      const invocation = {\n        ...toolInvocations[toolInvocationIndex],\n        state: 'result' as const,\n        ...value,\n      } as const;\n\n      toolInvocations[toolInvocationIndex] = invocation;\n\n      updateToolInvocationPart(value.toolCallId, invocation);\n\n      execUpdate();\n    },\n    onDataPart(value) {\n      data.push(...value);\n      execUpdate();\n    },\n    onMessageAnnotationsPart(value) {\n      if (messageAnnotations == null) {\n        messageAnnotations = [...value];\n      } else {\n        messageAnnotations.push(...value);\n      }\n\n      execUpdate();\n    },\n    onFinishStepPart(value) {\n      step += 1;\n\n      // reset the current text and reasoning parts\n      currentTextPart = value.isContinued ? currentTextPart : undefined;\n      currentReasoningPart = undefined;\n      currentReasoningTextDetail = undefined;\n    },\n    onStartStepPart(value) {\n      // keep message id stable when we are updating an existing message:\n      if (!replaceLastMessage) {\n        message.id = value.messageId;\n      }\n\n      // add a step boundary part to the message\n      message.parts.push({ type: 'step-start' });\n      execUpdate();\n    },\n    onFinishMessagePart(value) {\n      finishReason = value.finishReason;\n      if (value.usage != null) {\n        usage = calculateLanguageModelUsage(value.usage);\n      }\n    },\n    onErrorPart(error) {\n      throw new Error(error);\n    },\n  });\n\n  onFinish?.({ message, finishReason, usage });\n}\n", "/**\nRepresents the number of tokens used in a prompt and completion.\n */\nexport type LanguageModelUsage = {\n  /**\nThe number of tokens used in the prompt.\n   */\n  promptTokens: number;\n\n  /**\nThe number of tokens used in the completion.\n */\n  completionTokens: number;\n\n  /**\nThe total number of tokens used (promptTokens + completionTokens).\n   */\n  totalTokens: number;\n};\n\n/**\nRepresents the number of tokens used in an embedding.\n */\nexport type EmbeddingModelUsage = {\n  /**\nThe number of tokens used in the embedding.\n   */\n  tokens: number;\n};\n\nexport function calculateLanguageModelUsage({\n  promptTokens,\n  completionTokens,\n}: {\n  promptTokens: number;\n  completionTokens: number;\n}): LanguageModelUsage {\n  return {\n    promptTokens,\n    completionTokens,\n    totalTokens: promptTokens + completionTokens,\n  };\n}\n", "import { JSONValue } from '@ai-sdk/provider';\nimport { safeParseJSON } from '@ai-sdk/provider-utils';\nimport { fixJson } from './fix-json';\n\nexport function parsePartialJson(jsonText: string | undefined): {\n  value: JSONValue | undefined;\n  state:\n    | 'undefined-input'\n    | 'successful-parse'\n    | 'repaired-parse'\n    | 'failed-parse';\n} {\n  if (jsonText === undefined) {\n    return { value: undefined, state: 'undefined-input' };\n  }\n\n  let result = safeParseJSON({ text: jsonText });\n\n  if (result.success) {\n    return { value: result.value, state: 'successful-parse' };\n  }\n\n  result = safeParseJSON({ text: fixJson(jsonText) });\n\n  if (result.success) {\n    return { value: result.value, state: 'repaired-parse' };\n  }\n\n  return { value: undefined, state: 'failed-parse' };\n}\n", "type State =\n  | 'ROOT'\n  | 'FINISH'\n  | 'INSIDE_STRING'\n  | 'INSIDE_STRING_ESCAPE'\n  | 'INSIDE_LITERAL'\n  | 'INSIDE_NUMBER'\n  | 'INSIDE_OBJECT_START'\n  | 'INSIDE_OBJECT_KEY'\n  | 'INSIDE_OBJECT_AFTER_KEY'\n  | 'INSIDE_OBJECT_BEFORE_VALUE'\n  | 'INSIDE_OBJECT_AFTER_VALUE'\n  | 'INSIDE_OBJECT_AFTER_COMMA'\n  | 'INSIDE_ARRAY_START'\n  | 'INSIDE_ARRAY_AFTER_VALUE'\n  | 'INSIDE_ARRAY_AFTER_COMMA';\n\n// Implemented as a scanner with additional fixing\n// that performs a single linear time scan pass over the partial JSON.\n//\n// The states should ideally match relevant states from the JSON spec:\n// https://www.json.org/json-en.html\n//\n// Please note that invalid JSON is not considered/covered, because it\n// is assumed that the resulting JSON will be processed by a standard\n// JSON parser that will detect any invalid JSON.\nexport function fixJson(input: string): string {\n  const stack: State[] = ['ROOT'];\n  let lastValidIndex = -1;\n  let literalStart: number | null = null;\n\n  function processValueStart(char: string, i: number, swapState: State) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_STRING');\n          break;\n        }\n\n        case 'f':\n        case 't':\n        case 'n': {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_LITERAL');\n          break;\n        }\n\n        case '-': {\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_NUMBER');\n          break;\n        }\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_NUMBER');\n          break;\n        }\n\n        case '{': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_OBJECT_START');\n          break;\n        }\n\n        case '[': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_ARRAY_START');\n          break;\n        }\n      }\n    }\n  }\n\n  function processAfterObjectValue(char: string, i: number) {\n    switch (char) {\n      case ',': {\n        stack.pop();\n        stack.push('INSIDE_OBJECT_AFTER_COMMA');\n        break;\n      }\n      case '}': {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n\n  function processAfterArrayValue(char: string, i: number) {\n    switch (char) {\n      case ',': {\n        stack.pop();\n        stack.push('INSIDE_ARRAY_AFTER_COMMA');\n        break;\n      }\n      case ']': {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n\n    switch (currentState) {\n      case 'ROOT':\n        processValueStart(char, i, 'FINISH');\n        break;\n\n      case 'INSIDE_OBJECT_START': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_KEY');\n            break;\n          }\n          case '}': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_COMMA': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_KEY');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_KEY': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_AFTER_KEY');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_KEY': {\n        switch (char) {\n          case ':': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_BEFORE_VALUE');\n\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_BEFORE_VALUE': {\n        processValueStart(char, i, 'INSIDE_OBJECT_AFTER_VALUE');\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_VALUE': {\n        processAfterObjectValue(char, i);\n        break;\n      }\n\n      case 'INSIDE_STRING': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n\n          case '\\\\': {\n            stack.push('INSIDE_STRING_ESCAPE');\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_ARRAY_START': {\n        switch (char) {\n          case ']': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, 'INSIDE_ARRAY_AFTER_VALUE');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_ARRAY_AFTER_VALUE': {\n        switch (char) {\n          case ',': {\n            stack.pop();\n            stack.push('INSIDE_ARRAY_AFTER_COMMA');\n            break;\n          }\n\n          case ']': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_ARRAY_AFTER_COMMA': {\n        processValueStart(char, i, 'INSIDE_ARRAY_AFTER_VALUE');\n        break;\n      }\n\n      case 'INSIDE_STRING_ESCAPE': {\n        stack.pop();\n        lastValidIndex = i;\n\n        break;\n      }\n\n      case 'INSIDE_NUMBER': {\n        switch (char) {\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9': {\n            lastValidIndex = i;\n            break;\n          }\n\n          case 'e':\n          case 'E':\n          case '-':\n          case '.': {\n            break;\n          }\n\n          case ',': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n              processAfterArrayValue(char, i);\n            }\n\n            if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n              processAfterObjectValue(char, i);\n            }\n\n            break;\n          }\n\n          case '}': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n              processAfterObjectValue(char, i);\n            }\n\n            break;\n          }\n\n          case ']': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n              processAfterArrayValue(char, i);\n            }\n\n            break;\n          }\n\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_LITERAL': {\n        const partialLiteral = input.substring(literalStart!, i + 1);\n\n        if (\n          !'false'.startsWith(partialLiteral) &&\n          !'true'.startsWith(partialLiteral) &&\n          !'null'.startsWith(partialLiteral)\n        ) {\n          stack.pop();\n\n          if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n\n        break;\n      }\n    }\n  }\n\n  let result = input.slice(0, lastValidIndex + 1);\n\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n\n    switch (state) {\n      case 'INSIDE_STRING': {\n        result += '\"';\n        break;\n      }\n\n      case 'INSIDE_OBJECT_KEY':\n      case 'INSIDE_OBJECT_AFTER_KEY':\n      case 'INSIDE_OBJECT_AFTER_COMMA':\n      case 'INSIDE_OBJECT_START':\n      case 'INSIDE_OBJECT_BEFORE_VALUE':\n      case 'INSIDE_OBJECT_AFTER_VALUE': {\n        result += '}';\n        break;\n      }\n\n      case 'INSIDE_ARRAY_START':\n      case 'INSIDE_ARRAY_AFTER_COMMA':\n      case 'INSIDE_ARRAY_AFTER_VALUE': {\n        result += ']';\n        break;\n      }\n\n      case 'INSIDE_LITERAL': {\n        const partialLiteral = input.substring(literalStart!, input.length);\n\n        if ('true'.startsWith(partialLiteral)) {\n          result += 'true'.slice(partialLiteral.length);\n        } else if ('false'.startsWith(partialLiteral)) {\n          result += 'false'.slice(partialLiteral.length);\n        } else if ('null'.startsWith(partialLiteral)) {\n          result += 'null'.slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n", "import {\n  LanguageModelV1FinishReason,\n  LanguageModelV1Source,\n} from '@ai-sdk/provider';\nimport { ToolCall, ToolResult } from '@ai-sdk/provider-utils';\nimport { JSONValue } from './types';\n\nexport type DataStreamString =\n  `${(typeof DataStreamStringPrefixes)[keyof typeof DataStreamStringPrefixes]}:${string}\\n`;\n\nexport interface DataStreamPart<\n  CODE extends string,\n  NAME extends string,\n  TYPE,\n> {\n  code: CODE;\n  name: NAME;\n  parse: (value: JSONValue) => { type: NAME; value: TYPE };\n}\n\nconst textStreamPart: DataStreamPart<'0', 'text', string> = {\n  code: '0',\n  name: 'text',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: 'text', value };\n  },\n};\n\nconst dataStreamPart: DataStreamPart<'2', 'data', Array<JSONValue>> = {\n  code: '2',\n  name: 'data',\n  parse: (value: JSONValue) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"data\" parts expect an array value.');\n    }\n\n    return { type: 'data', value };\n  },\n};\n\nconst errorStreamPart: DataStreamPart<'3', 'error', string> = {\n  code: '3',\n  name: 'error',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: 'error', value };\n  },\n};\n\nconst messageAnnotationsStreamPart: DataStreamPart<\n  '8',\n  'message_annotations',\n  Array<JSONValue>\n> = {\n  code: '8',\n  name: 'message_annotations',\n  parse: (value: JSONValue) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"message_annotations\" parts expect an array value.');\n    }\n\n    return { type: 'message_annotations', value };\n  },\n};\n\nconst toolCallStreamPart: DataStreamPart<\n  '9',\n  'tool_call',\n  ToolCall<string, any>\n> = {\n  code: '9',\n  name: 'tool_call',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('toolName' in value) ||\n      typeof value.toolName !== 'string' ||\n      !('args' in value) ||\n      typeof value.args !== 'object'\n    ) {\n      throw new Error(\n        '\"tool_call\" parts expect an object with a \"toolCallId\", \"toolName\", and \"args\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call',\n      value: value as unknown as ToolCall<string, any>,\n    };\n  },\n};\n\nconst toolResultStreamPart: DataStreamPart<\n  'a',\n  'tool_result',\n  Omit<ToolResult<string, any, any>, 'args' | 'toolName'>\n> = {\n  code: 'a',\n  name: 'tool_result',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('result' in value)\n    ) {\n      throw new Error(\n        '\"tool_result\" parts expect an object with a \"toolCallId\" and a \"result\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_result',\n      value: value as unknown as Omit<\n        ToolResult<string, any, any>,\n        'args' | 'toolName'\n      >,\n    };\n  },\n};\n\nconst toolCallStreamingStartStreamPart: DataStreamPart<\n  'b',\n  'tool_call_streaming_start',\n  { toolCallId: string; toolName: string }\n> = {\n  code: 'b',\n  name: 'tool_call_streaming_start',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('toolName' in value) ||\n      typeof value.toolName !== 'string'\n    ) {\n      throw new Error(\n        '\"tool_call_streaming_start\" parts expect an object with a \"toolCallId\" and \"toolName\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call_streaming_start',\n      value: value as unknown as { toolCallId: string; toolName: string },\n    };\n  },\n};\n\nconst toolCallDeltaStreamPart: DataStreamPart<\n  'c',\n  'tool_call_delta',\n  { toolCallId: string; argsTextDelta: string }\n> = {\n  code: 'c',\n  name: 'tool_call_delta',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('argsTextDelta' in value) ||\n      typeof value.argsTextDelta !== 'string'\n    ) {\n      throw new Error(\n        '\"tool_call_delta\" parts expect an object with a \"toolCallId\" and \"argsTextDelta\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call_delta',\n      value: value as unknown as {\n        toolCallId: string;\n        argsTextDelta: string;\n      },\n    };\n  },\n};\n\nconst finishMessageStreamPart: DataStreamPart<\n  'd',\n  'finish_message',\n  {\n    finishReason: LanguageModelV1FinishReason;\n    // TODO v5 remove usage from finish event (only on step-finish)\n    usage?: {\n      promptTokens: number;\n      completionTokens: number;\n    };\n  }\n> = {\n  code: 'd',\n  name: 'finish_message',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('finishReason' in value) ||\n      typeof value.finishReason !== 'string'\n    ) {\n      throw new Error(\n        '\"finish_message\" parts expect an object with a \"finishReason\" property.',\n      );\n    }\n\n    const result: {\n      finishReason: LanguageModelV1FinishReason;\n      usage?: {\n        promptTokens: number;\n        completionTokens: number;\n      };\n    } = {\n      finishReason: value.finishReason as LanguageModelV1FinishReason,\n    };\n\n    if (\n      'usage' in value &&\n      value.usage != null &&\n      typeof value.usage === 'object' &&\n      'promptTokens' in value.usage &&\n      'completionTokens' in value.usage\n    ) {\n      result.usage = {\n        promptTokens:\n          typeof value.usage.promptTokens === 'number'\n            ? value.usage.promptTokens\n            : Number.NaN,\n        completionTokens:\n          typeof value.usage.completionTokens === 'number'\n            ? value.usage.completionTokens\n            : Number.NaN,\n      };\n    }\n\n    return {\n      type: 'finish_message',\n      value: result,\n    };\n  },\n};\n\nconst finishStepStreamPart: DataStreamPart<\n  'e',\n  'finish_step',\n  {\n    isContinued: boolean;\n    finishReason: LanguageModelV1FinishReason;\n    usage?: {\n      promptTokens: number;\n      completionTokens: number;\n    };\n  }\n> = {\n  code: 'e',\n  name: 'finish_step',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('finishReason' in value) ||\n      typeof value.finishReason !== 'string'\n    ) {\n      throw new Error(\n        '\"finish_step\" parts expect an object with a \"finishReason\" property.',\n      );\n    }\n\n    const result: {\n      isContinued: boolean;\n      finishReason: LanguageModelV1FinishReason;\n      usage?: {\n        promptTokens: number;\n        completionTokens: number;\n      };\n    } = {\n      finishReason: value.finishReason as LanguageModelV1FinishReason,\n      isContinued: false,\n    };\n\n    if (\n      'usage' in value &&\n      value.usage != null &&\n      typeof value.usage === 'object' &&\n      'promptTokens' in value.usage &&\n      'completionTokens' in value.usage\n    ) {\n      result.usage = {\n        promptTokens:\n          typeof value.usage.promptTokens === 'number'\n            ? value.usage.promptTokens\n            : Number.NaN,\n        completionTokens:\n          typeof value.usage.completionTokens === 'number'\n            ? value.usage.completionTokens\n            : Number.NaN,\n      };\n    }\n\n    if ('isContinued' in value && typeof value.isContinued === 'boolean') {\n      result.isContinued = value.isContinued;\n    }\n\n    return {\n      type: 'finish_step',\n      value: result,\n    };\n  },\n};\n\nconst startStepStreamPart: DataStreamPart<\n  'f',\n  'start_step',\n  {\n    messageId: string;\n  }\n> = {\n  code: 'f',\n  name: 'start_step',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('messageId' in value) ||\n      typeof value.messageId !== 'string'\n    ) {\n      throw new Error(\n        '\"start_step\" parts expect an object with an \"id\" property.',\n      );\n    }\n\n    return {\n      type: 'start_step',\n      value: {\n        messageId: value.messageId,\n      },\n    };\n  },\n};\n\nconst reasoningStreamPart: DataStreamPart<'g', 'reasoning', string> = {\n  code: 'g',\n  name: 'reasoning',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"reasoning\" parts expect a string value.');\n    }\n    return { type: 'reasoning', value };\n  },\n};\n\nconst sourcePart: DataStreamPart<'h', 'source', LanguageModelV1Source> = {\n  code: 'h',\n  name: 'source',\n  parse: (value: JSONValue) => {\n    if (value == null || typeof value !== 'object') {\n      throw new Error('\"source\" parts expect a Source object.');\n    }\n\n    return {\n      type: 'source',\n      value: value as LanguageModelV1Source,\n    };\n  },\n};\n\nconst redactedReasoningStreamPart: DataStreamPart<\n  'i',\n  'redacted_reasoning',\n  { data: string }\n> = {\n  code: 'i',\n  name: 'redacted_reasoning',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('data' in value) ||\n      typeof value.data !== 'string'\n    ) {\n      throw new Error(\n        '\"redacted_reasoning\" parts expect an object with a \"data\" property.',\n      );\n    }\n    return { type: 'redacted_reasoning', value: { data: value.data } };\n  },\n};\n\nconst reasoningSignatureStreamPart: DataStreamPart<\n  'j',\n  'reasoning_signature',\n  { signature: string }\n> = {\n  code: 'j',\n  name: 'reasoning_signature',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('signature' in value) ||\n      typeof value.signature !== 'string'\n    ) {\n      throw new Error(\n        '\"reasoning_signature\" parts expect an object with a \"signature\" property.',\n      );\n    }\n    return {\n      type: 'reasoning_signature',\n      value: { signature: value.signature },\n    };\n  },\n};\n\nconst fileStreamPart: DataStreamPart<\n  'k',\n  'file',\n  {\n    data: string; // base64 encoded data\n    mimeType: string;\n  }\n> = {\n  code: 'k',\n  name: 'file',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('data' in value) ||\n      typeof value.data !== 'string' ||\n      !('mimeType' in value) ||\n      typeof value.mimeType !== 'string'\n    ) {\n      throw new Error(\n        '\"file\" parts expect an object with a \"data\" and \"mimeType\" property.',\n      );\n    }\n    return { type: 'file', value: value as { data: string; mimeType: string } };\n  },\n};\n\nconst dataStreamParts = [\n  textStreamPart,\n  dataStreamPart,\n  errorStreamPart,\n  messageAnnotationsStreamPart,\n  toolCallStreamPart,\n  toolResultStreamPart,\n  toolCallStreamingStartStreamPart,\n  toolCallDeltaStreamPart,\n  finishMessageStreamPart,\n  finishStepStreamPart,\n  startStepStreamPart,\n  reasoningStreamPart,\n  sourcePart,\n  redactedReasoningStreamPart,\n  reasoningSignatureStreamPart,\n  fileStreamPart,\n] as const;\n\nexport const dataStreamPartsByCode = Object.fromEntries(\n  dataStreamParts.map(part => [part.code, part]),\n) as {\n  [K in (typeof dataStreamParts)[number]['code']]: (typeof dataStreamParts)[number];\n};\n\ntype DataStreamParts = (typeof dataStreamParts)[number];\n\n/**\n * Maps the type of a stream part to its value type.\n */\ntype DataStreamPartValueType = {\n  [P in DataStreamParts as P['name']]: ReturnType<P['parse']>['value'];\n};\n\nexport type DataStreamPartType = ReturnType<DataStreamParts['parse']>;\n\n/**\n * The map of prefixes for data in the stream\n *\n * - 0: Text from the LLM response\n * - 1: (OpenAI) function_call responses\n * - 2: custom JSON added by the user using `Data`\n * - 6: (OpenAI) tool_call responses\n *\n * Example:\n * ```\n * 0:Vercel\n * 0:'s\n * 0: AI\n * 0: AI\n * 0: SDK\n * 0: is great\n * 0:!\n * 2: { \"someJson\": \"value\" }\n * 1: {\"function_call\": {\"name\": \"get_current_weather\", \"arguments\": \"{\\\\n\\\\\"location\\\\\": \\\\\"Charlottesville, Virginia\\\\\",\\\\n\\\\\"format\\\\\": \\\\\"celsius\\\\\"\\\\n}\"}}\n * 6: {\"tool_call\": {\"id\": \"tool_0\", \"type\": \"function\", \"function\": {\"name\": \"get_current_weather\", \"arguments\": \"{\\\\n\\\\\"location\\\\\": \\\\\"Charlottesville, Virginia\\\\\",\\\\n\\\\\"format\\\\\": \\\\\"celsius\\\\\"\\\\n}\"}}}\n *```\n */\nexport const DataStreamStringPrefixes = Object.fromEntries(\n  dataStreamParts.map(part => [part.name, part.code]),\n) as {\n  [K in DataStreamParts['name']]: (typeof dataStreamParts)[number]['code'];\n};\n\nexport const validCodes = dataStreamParts.map(part => part.code);\n\n/**\nParses a stream part from a string.\n\n@param line The string to parse.\n@returns The parsed stream part.\n@throws An error if the string cannot be parsed.\n */\nexport const parseDataStreamPart = (line: string): DataStreamPartType => {\n  const firstSeparatorIndex = line.indexOf(':');\n\n  if (firstSeparatorIndex === -1) {\n    throw new Error('Failed to parse stream string. No separator found.');\n  }\n\n  const prefix = line.slice(0, firstSeparatorIndex);\n\n  if (!validCodes.includes(prefix as keyof typeof dataStreamPartsByCode)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n\n  const code = prefix as keyof typeof dataStreamPartsByCode;\n\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue: JSONValue = JSON.parse(textValue);\n\n  return dataStreamPartsByCode[code].parse(jsonValue);\n};\n\n/**\nPrepends a string with a prefix from the `StreamChunkPrefixes`, JSON-ifies it,\nand appends a new line.\n\nIt ensures type-safety for the part type and value.\n */\nexport function formatDataStreamPart<T extends keyof DataStreamPartValueType>(\n  type: T,\n  value: DataStreamPartValueType[T],\n): DataStreamString {\n  const streamPart = dataStreamParts.find(part => part.name === type);\n\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n\n  return `${streamPart.code}:${JSON.stringify(value)}\\n`;\n}\n", "import { DataStreamPartType, parseDataStreamPart } from './data-stream-parts';\n\nconst NEWLINE = '\\n'.charCodeAt(0);\n\n// concatenates all the chunks into a single Uint8Array\nfunction concatChunks(chunks: Uint8Array[], totalLength: number) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n\n  return concatenatedChunks;\n}\n\nexport async function processDataStream({\n  stream,\n  onTextPart,\n  onReasoningPart,\n  onReasoningSignaturePart,\n  onRedactedReasoningPart,\n  onSourcePart,\n  onFilePart,\n  onDataPart,\n  onErrorPart,\n  onToolCallStreamingStartPart,\n  onToolCallDeltaPart,\n  onToolCallPart,\n  onToolResultPart,\n  onMessageAnnotationsPart,\n  onFinishMessagePart,\n  onFinishStepPart,\n  onStartStepPart,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  onTextPart?: (\n    streamPart: (DataStreamPartType & { type: 'text' })['value'],\n  ) => Promise<void> | void;\n  onReasoningPart?: (\n    streamPart: (DataStreamPartType & { type: 'reasoning' })['value'],\n  ) => Promise<void> | void;\n  onReasoningSignaturePart?: (\n    streamPart: (DataStreamPartType & { type: 'reasoning_signature' })['value'],\n  ) => Promise<void> | void;\n  onRedactedReasoningPart?: (\n    streamPart: (DataStreamPartType & { type: 'redacted_reasoning' })['value'],\n  ) => Promise<void> | void;\n  onFilePart?: (\n    streamPart: (DataStreamPartType & { type: 'file' })['value'],\n  ) => Promise<void> | void;\n  onSourcePart?: (\n    streamPart: (DataStreamPartType & { type: 'source' })['value'],\n  ) => Promise<void> | void;\n  onDataPart?: (\n    streamPart: (DataStreamPartType & { type: 'data' })['value'],\n  ) => Promise<void> | void;\n  onErrorPart?: (\n    streamPart: (DataStreamPartType & { type: 'error' })['value'],\n  ) => Promise<void> | void;\n  onToolCallStreamingStartPart?: (\n    streamPart: (DataStreamPartType & {\n      type: 'tool_call_streaming_start';\n    })['value'],\n  ) => Promise<void> | void;\n  onToolCallDeltaPart?: (\n    streamPart: (DataStreamPartType & { type: 'tool_call_delta' })['value'],\n  ) => Promise<void> | void;\n  onToolCallPart?: (\n    streamPart: (DataStreamPartType & { type: 'tool_call' })['value'],\n  ) => Promise<void> | void;\n  onToolResultPart?: (\n    streamPart: (DataStreamPartType & { type: 'tool_result' })['value'],\n  ) => Promise<void> | void;\n  onMessageAnnotationsPart?: (\n    streamPart: (DataStreamPartType & {\n      type: 'message_annotations';\n    })['value'],\n  ) => Promise<void> | void;\n  onFinishMessagePart?: (\n    streamPart: (DataStreamPartType & { type: 'finish_message' })['value'],\n  ) => Promise<void> | void;\n  onFinishStepPart?: (\n    streamPart: (DataStreamPartType & { type: 'finish_step' })['value'],\n  ) => Promise<void> | void;\n  onStartStepPart?: (\n    streamPart: (DataStreamPartType & { type: 'start_step' })['value'],\n  ) => Promise<void> | void;\n}): Promise<void> {\n  // implementation note: this slightly more complex algorithm is required\n  // to pass the tests in the edge environment.\n\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  const chunks: Uint8Array[] = [];\n  let totalLength = 0;\n\n  while (true) {\n    const { value } = await reader.read();\n\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        // if the last character is not a newline, we have not read the whole JSON value\n        continue;\n      }\n    }\n\n    if (chunks.length === 0) {\n      break; // we have reached the end of the stream\n    }\n\n    const concatenatedChunks = concatChunks(chunks, totalLength);\n    totalLength = 0;\n\n    const streamParts = decoder\n      .decode(concatenatedChunks, { stream: true })\n      .split('\\n')\n      .filter(line => line !== '') // splitting leaves an empty string at the end\n      .map(parseDataStreamPart);\n\n    for (const { type, value } of streamParts) {\n      switch (type) {\n        case 'text':\n          await onTextPart?.(value);\n          break;\n        case 'reasoning':\n          await onReasoningPart?.(value);\n          break;\n        case 'reasoning_signature':\n          await onReasoningSignaturePart?.(value);\n          break;\n        case 'redacted_reasoning':\n          await onRedactedReasoningPart?.(value);\n          break;\n        case 'file':\n          await onFilePart?.(value);\n          break;\n        case 'source':\n          await onSourcePart?.(value);\n          break;\n        case 'data':\n          await onDataPart?.(value);\n          break;\n        case 'error':\n          await onErrorPart?.(value);\n          break;\n        case 'message_annotations':\n          await onMessageAnnotationsPart?.(value);\n          break;\n        case 'tool_call_streaming_start':\n          await onToolCallStreamingStartPart?.(value);\n          break;\n        case 'tool_call_delta':\n          await onToolCallDeltaPart?.(value);\n          break;\n        case 'tool_call':\n          await onToolCallPart?.(value);\n          break;\n        case 'tool_result':\n          await onToolResultPart?.(value);\n          break;\n        case 'finish_message':\n          await onFinishMessagePart?.(value);\n          break;\n        case 'finish_step':\n          await onFinishStepPart?.(value);\n          break;\n        case 'start_step':\n          await onStartStepPart?.(value);\n          break;\n        default: {\n          const exhaustiveCheck: never = type;\n          throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);\n        }\n      }\n    }\n  }\n}\n", "import { JSONValue } from '@ai-sdk/provider';\nimport { generateId as generateIdFunction } from '@ai-sdk/provider-utils';\nimport { processTextStream } from './process-text-stream';\nimport { TextUIPart, UIMessage, UseChatOptions } from './types';\n\nexport async function processChatTextResponse({\n  stream,\n  update,\n  onFinish,\n  getCurrentDate = () => new Date(),\n  generateId = generateIdFunction,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  update: (options: {\n    message: UIMessage;\n    data: JSONValue[] | undefined;\n    replaceLastMessage: boolean;\n  }) => void;\n  onFinish: UseChatOptions['onFinish'];\n  getCurrentDate?: () => Date;\n  generateId?: () => string;\n}) {\n  const textPart: TextUIPart = { type: 'text', text: '' };\n\n  const resultMessage: UIMessage = {\n    id: generateId(),\n    createdAt: getCurrentDate(),\n    role: 'assistant' as const,\n    content: '',\n    parts: [textPart],\n  };\n\n  await processTextStream({\n    stream,\n    onTextPart: chunk => {\n      resultMessage.content += chunk;\n      textPart.text += chunk;\n\n      // note: creating a new message object is required for Solid.js streaming\n      update({\n        message: { ...resultMessage },\n        data: [],\n        replaceLastMessage: false,\n      });\n    },\n  });\n\n  // in text mode, we don't have usage information or finish reason:\n  onFinish?.(resultMessage, {\n    usage: { completionTokens: NaN, promptTokens: NaN, totalTokens: NaN },\n    finishReason: 'unknown',\n  });\n}\n", "export async function processTextStream({\n  stream,\n  onTextPart,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  onTextPart: (chunk: string) => Promise<void> | void;\n}): Promise<void> {\n  const reader = stream.pipeThrough(new TextDecoderStream()).getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    await onTextPart(value);\n  }\n}\n", "import { processChatResponse } from './process-chat-response';\nimport { processChatTextResponse } from './process-chat-text-response';\nimport { IdGenerator, JSONValue, UIMessage, UseChatOptions } from './types';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => fetch;\n\nexport async function callChatApi({\n  api,\n  body,\n  streamProtocol = 'data',\n  credentials,\n  headers,\n  abortController,\n  restoreMessagesOnFailure,\n  onResponse,\n  onUpdate,\n  onFinish,\n  onToolCall,\n  generateId,\n  fetch = getOriginalFetch(),\n  lastMessage,\n  requestType = 'generate',\n}: {\n  api: string;\n  body: Record<string, any>;\n  streamProtocol: 'data' | 'text' | undefined;\n  credentials: RequestCredentials | undefined;\n  headers: HeadersInit | undefined;\n  abortController: (() => AbortController | null) | undefined;\n  restoreMessagesOnFailure: () => void;\n  onResponse: ((response: Response) => void | Promise<void>) | undefined;\n  onUpdate: (options: {\n    message: UIMessage;\n    data: JSONValue[] | undefined;\n    replaceLastMessage: boolean;\n  }) => void;\n  onFinish: UseChatOptions['onFinish'];\n  onToolCall: UseChatOptions['onToolCall'];\n  generateId: IdGenerator;\n  fetch: ReturnType<typeof getOriginalFetch> | undefined;\n  lastMessage: UIMessage | undefined;\n  requestType?: 'generate' | 'resume';\n}) {\n  const request =\n    requestType === 'resume'\n      ? fetch(`${api}?chatId=${body.id}`, {\n          method: 'GET',\n          headers: {\n            'Content-Type': 'application/json',\n            ...headers,\n          },\n          signal: abortController?.()?.signal,\n          credentials,\n        })\n      : fetch(api, {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: {\n            'Content-Type': 'application/json',\n            ...headers,\n          },\n          signal: abortController?.()?.signal,\n          credentials,\n        });\n\n  const response = await request.catch(err => {\n    restoreMessagesOnFailure();\n    throw err;\n  });\n\n  if (onResponse) {\n    try {\n      await onResponse(response);\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  if (!response.ok) {\n    restoreMessagesOnFailure();\n    throw new Error(\n      (await response.text()) ?? 'Failed to fetch the chat response.',\n    );\n  }\n\n  if (!response.body) {\n    throw new Error('The response body is empty.');\n  }\n\n  switch (streamProtocol) {\n    case 'text': {\n      await processChatTextResponse({\n        stream: response.body,\n        update: onUpdate,\n        onFinish,\n        generateId,\n      });\n      return;\n    }\n\n    case 'data': {\n      await processChatResponse({\n        stream: response.body,\n        update: onUpdate,\n        lastMessage,\n        onToolCall,\n        onFinish({ message, finishReason, usage }) {\n          if (onFinish && message != null) {\n            onFinish(message, { usage, finishReason });\n          }\n        },\n        generateId,\n      });\n      return;\n    }\n\n    default: {\n      const exhaustiveCheck: never = streamProtocol;\n      throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n    }\n  }\n}\n", "import { processTextStream } from './process-text-stream';\nimport { processDataStream } from './process-data-stream';\nimport { JSONValue } from './types';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => fetch;\n\nexport async function callCompletionApi({\n  api,\n  prompt,\n  credentials,\n  headers,\n  body,\n  streamProtocol = 'data',\n  setCompletion,\n  setLoading,\n  setError,\n  setAbortController,\n  onResponse,\n  onFinish,\n  onError,\n  onData,\n  fetch = getOriginalFetch(),\n}: {\n  api: string;\n  prompt: string;\n  credentials: RequestCredentials | undefined;\n  headers: HeadersInit | undefined;\n  body: Record<string, any>;\n  streamProtocol: 'data' | 'text' | undefined;\n  setCompletion: (completion: string) => void;\n  setLoading: (loading: boolean) => void;\n  setError: (error: Error | undefined) => void;\n  setAbortController: (abortController: AbortController | null) => void;\n  onResponse: ((response: Response) => void | Promise<void>) | undefined;\n  onFinish: ((prompt: string, completion: string) => void) | undefined;\n  onError: ((error: Error) => void) | undefined;\n  onData: ((data: JSONValue[]) => void) | undefined;\n  fetch: ReturnType<typeof getOriginalFetch> | undefined;\n}) {\n  try {\n    setLoading(true);\n    setError(undefined);\n\n    const abortController = new AbortController();\n    setAbortController(abortController);\n\n    // Empty the completion immediately.\n    setCompletion('');\n\n    const response = await fetch(api, {\n      method: 'POST',\n      body: JSON.stringify({\n        prompt,\n        ...body,\n      }),\n      credentials,\n      headers: {\n        'Content-Type': 'application/json',\n        ...headers,\n      },\n      signal: abortController.signal,\n    }).catch(err => {\n      throw err;\n    });\n\n    if (onResponse) {\n      try {\n        await onResponse(response);\n      } catch (err) {\n        throw err;\n      }\n    }\n\n    if (!response.ok) {\n      throw new Error(\n        (await response.text()) ?? 'Failed to fetch the chat response.',\n      );\n    }\n\n    if (!response.body) {\n      throw new Error('The response body is empty.');\n    }\n\n    let result = '';\n\n    switch (streamProtocol) {\n      case 'text': {\n        await processTextStream({\n          stream: response.body,\n          onTextPart: chunk => {\n            result += chunk;\n            setCompletion(result);\n          },\n        });\n        break;\n      }\n      case 'data': {\n        await processDataStream({\n          stream: response.body,\n          onTextPart(value) {\n            result += value;\n            setCompletion(result);\n          },\n          onDataPart(value) {\n            onData?.(value);\n          },\n          onErrorPart(value) {\n            throw new Error(value);\n          },\n        });\n        break;\n      }\n      default: {\n        const exhaustiveCheck: never = streamProtocol;\n        throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n      }\n    }\n\n    if (onFinish) {\n      onFinish(prompt, result);\n    }\n\n    setAbortController(null);\n    return result;\n  } catch (err) {\n    // Ignore abort errors as they are expected.\n    if ((err as any).name === 'AbortError') {\n      setAbortController(null);\n      return null;\n    }\n\n    if (err instanceof Error) {\n      if (onError) {\n        onError(err);\n      }\n    }\n\n    setError(err as Error);\n  } finally {\n    setLoading(false);\n  }\n}\n", "/**\n * Converts a data URL of type text/* to a text string.\n */\nexport function getTextFromDataUrl(dataUrl: string): string {\n  const [header, base64Content] = dataUrl.split(',');\n  const mimeType = header.split(';')[0].split(':')[1];\n\n  if (mimeType == null || base64Content == null) {\n    throw new Error('Invalid data URL format');\n  }\n\n  try {\n    return window.atob(base64Content);\n  } catch (error) {\n    throw new Error(`Error decoding data URL`);\n  }\n}\n", "import { ToolInvocation } from './types';\n\nexport function extractMaxToolInvocationStep(\n  toolInvocations: ToolInvocation[] | undefined,\n): number | undefined {\n  return toolInvocations?.reduce((max, toolInvocation) => {\n    return Math.max(max, toolInvocation.step ?? 0);\n  }, 0);\n}\n", "import {\n  CreateMessage,\n  FileUIPart,\n  Message,\n  ReasoningUIPart,\n  SourceUIPart,\n  StepStartUIPart,\n  TextUIPart,\n  ToolInvocationUIPart,\n  UIMessage,\n} from './types';\n\nexport function getMessageParts(\n  message: Message | CreateMessage | UIMessage,\n): (\n  | TextUIPart\n  | ReasoningUIPart\n  | ToolInvocationUIPart\n  | SourceUIPart\n  | FileUIPart\n  | StepStartUIPart\n)[] {\n  return (\n    message.parts ?? [\n      ...(message.toolInvocations\n        ? message.toolInvocations.map(toolInvocation => ({\n            type: 'tool-invocation' as const,\n            toolInvocation,\n          }))\n        : []),\n      ...(message.reasoning\n        ? [\n            {\n              type: 'reasoning' as const,\n              reasoning: message.reasoning,\n              details: [{ type: 'text' as const, text: message.reasoning }],\n            },\n          ]\n        : []),\n      ...(message.content\n        ? [{ type: 'text' as const, text: message.content }]\n        : []),\n    ]\n  );\n}\n", "import { getMessageParts } from './get-message-parts';\nimport { Message, UIMessage } from './types';\n\nexport function fillMessageParts(messages: Message[]): UIMessage[] {\n  return messages.map(message => ({\n    ...message,\n    parts: getMessageParts(message),\n  }));\n}\n", "/**\n * Performs a deep-equal comparison of two parsed JSON objects.\n *\n * @param {any} obj1 - The first object to compare.\n * @param {any} obj2 - The second object to compare.\n * @returns {boolean} - Returns true if the two objects are deeply equal, false otherwise.\n */\nexport function isDeepEqualData(obj1: any, obj2: any): boolean {\n  // Check for strict equality first\n  if (obj1 === obj2) return true;\n\n  // Check if either is null or undefined\n  if (obj1 == null || obj2 == null) return false;\n\n  // Check if both are objects\n  if (typeof obj1 !== 'object' && typeof obj2 !== 'object')\n    return obj1 === obj2;\n\n  // If they are not strictly equal, they both need to be Objects\n  if (obj1.constructor !== obj2.constructor) return false;\n\n  // Special handling for Date objects\n  if (obj1 instanceof Date && obj2 instanceof Date) {\n    return obj1.getTime() === obj2.getTime();\n  }\n\n  // Handle arrays: compare length and then perform a recursive deep comparison on each item\n  if (Array.isArray(obj1)) {\n    if (obj1.length !== obj2.length) return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqualData(obj1[i], obj2[i])) return false;\n    }\n    return true; // All array elements matched\n  }\n\n  // Compare the set of keys in each object\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length) return false;\n\n  // Check each key-value pair recursively\n  for (const key of keys1) {\n    if (!keys2.includes(key)) return false;\n    if (!isDeepEqualData(obj1[key], obj2[key])) return false;\n  }\n\n  return true; // All keys and values matched\n}\n", "import { Attachment } from './types';\n\nexport async function prepareAttachmentsForRequest(\n  attachmentsFromOptions: FileList | Array<Attachment> | undefined,\n) {\n  if (!attachmentsFromOptions) {\n    return [];\n  }\n\n  // https://github.com/vercel/ai/pull/6045\n  // React-native doesn't have a FileList\n  // global variable, so we need to check for it\n  if (\n    globalThis.FileList &&\n    attachmentsFromOptions instanceof globalThis.FileList\n  ) {\n    return Promise.all(\n      Array.from(attachmentsFromOptions).map(async attachment => {\n        const { name, type } = attachment;\n\n        const dataUrl = await new Promise<string>((resolve, reject) => {\n          const reader = new FileReader();\n          reader.onload = readerEvent => {\n            resolve(readerEvent.target?.result as string);\n          };\n          reader.onerror = error => reject(error);\n          reader.readAsDataURL(attachment);\n        });\n\n        return {\n          name,\n          contentType: type,\n          url: dataUrl,\n        };\n      }),\n    );\n  }\n\n  if (Array.isArray(attachmentsFromOptions)) {\n    return attachmentsFromOptions;\n  }\n\n  throw new Error('Invalid attachments type');\n}\n", "import {\n  AssistantStreamPartType,\n  parseAssistantStreamPart,\n} from './assistant-stream-parts';\n\nconst NEWLINE = '\\n'.charCodeAt(0);\n\n// concatenates all the chunks into a single Uint8Array\nfunction concatChunks(chunks: Uint8Array[], totalLength: number) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n\n  return concatenatedChunks;\n}\n\nexport async function processAssistantStream({\n  stream,\n  onTextPart,\n  onErrorPart,\n  onAssistantMessagePart,\n  onAssistantControlDataPart,\n  onDataMessagePart,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  onTextPart?: (\n    streamPart: (AssistantStreamPartType & { type: 'text' })['value'],\n  ) => Promise<void> | void;\n  onErrorPart?: (\n    streamPart: (AssistantStreamPartType & { type: 'error' })['value'],\n  ) => Promise<void> | void;\n  onAssistantMessagePart?: (\n    streamPart: (AssistantStreamPartType & {\n      type: 'assistant_message';\n    })['value'],\n  ) => Promise<void> | void;\n  onAssistantControlDataPart?: (\n    streamPart: (AssistantStreamPartType & {\n      type: 'assistant_control_data';\n    })['value'],\n  ) => Promise<void> | void;\n  onDataMessagePart?: (\n    streamPart: (AssistantStreamPartType & { type: 'data_message' })['value'],\n  ) => Promise<void> | void;\n}): Promise<void> {\n  // implementation note: this slightly more complex algorithm is required\n  // to pass the tests in the edge environment.\n\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  const chunks: Uint8Array[] = [];\n  let totalLength = 0;\n\n  while (true) {\n    const { value } = await reader.read();\n\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        // if the last character is not a newline, we have not read the whole JSON value\n        continue;\n      }\n    }\n\n    if (chunks.length === 0) {\n      break; // we have reached the end of the stream\n    }\n\n    const concatenatedChunks = concatChunks(chunks, totalLength);\n    totalLength = 0;\n\n    const streamParts = decoder\n      .decode(concatenatedChunks, { stream: true })\n      .split('\\n')\n      .filter(line => line !== '')\n      .map(parseAssistantStreamPart);\n\n    for (const { type, value } of streamParts) {\n      switch (type) {\n        case 'text':\n          await onTextPart?.(value);\n          break;\n        case 'error':\n          await onErrorPart?.(value);\n          break;\n        case 'assistant_message':\n          await onAssistantMessagePart?.(value);\n          break;\n        case 'assistant_control_data':\n          await onAssistantControlDataPart?.(value);\n          break;\n        case 'data_message':\n          await onDataMessagePart?.(value);\n          break;\n        default: {\n          const exhaustiveCheck: never = type;\n          throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);\n        }\n      }\n    }\n  }\n}\n", "import { Validator, validatorSymbol } from '@ai-sdk/provider-utils';\nimport { JSONSchema7 } from 'json-schema';\nimport { z } from 'zod';\nimport { zodSchema } from './zod-schema';\n\n/**\n * Used to mark schemas so we can support both Zod and custom schemas.\n */\nconst schemaSymbol = Symbol.for('vercel.ai.schema');\n\nexport type Schema<OBJECT = unknown> = Validator<OBJECT> & {\n  /**\n   * Used to mark schemas so we can support both Zod and custom schemas.\n   */\n  [schemaSymbol]: true;\n\n  /**\n   * Schema type for inference.\n   */\n  _type: OBJECT;\n\n  /**\n   * The JSON Schema for the schema. It is passed to the providers.\n   */\n  readonly jsonSchema: JSONSchema7;\n};\n\n/**\n * Create a schema using a JSON Schema.\n *\n * @param jsonSchema The JSON Schema for the schema.\n * @param options.validate Optional. A validation function for the schema.\n */\nexport function jsonSchema<OBJECT = unknown>(\n  jsonSchema: JSONSchema7,\n  {\n    validate,\n  }: {\n    validate?: (\n      value: unknown,\n    ) => { success: true; value: OBJECT } | { success: false; error: Error };\n  } = {},\n): Schema<OBJECT> {\n  return {\n    [schemaSymbol]: true,\n    _type: undefined as OBJECT, // should never be used directly\n    [validatorSymbol]: true,\n    jsonSchema,\n    validate,\n  };\n}\n\nfunction isSchema(value: unknown): value is Schema {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    schemaSymbol in value &&\n    value[schemaSymbol] === true &&\n    'jsonSchema' in value &&\n    'validate' in value\n  );\n}\n\nexport function asSchema<OBJECT>(\n  schema: z.Schema<OBJECT, z.ZodTypeDef, any> | Schema<OBJECT>,\n): Schema<OBJECT> {\n  return isSchema(schema) ? schema : zodSchema(schema);\n}\n", "import { JSONSchema7 } from 'json-schema';\nimport { z } from 'zod';\nimport zodToJsonSchema from 'zod-to-json-schema';\nimport { jsonSchema, Schema } from './schema';\n\nexport function zodSchema<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n  options?: {\n    /**\n     * Enables support for references in the schema.\n     * This is required for recursive schemas, e.g. with `z.lazy`.\n     * However, not all language models and providers support such references.\n     * Defaults to `false`.\n     */\n    useReferences?: boolean;\n  },\n): Schema<OBJECT> {\n  // default to no references (to support openapi conversion for google)\n  const useReferences = options?.useReferences ?? false;\n\n  return jsonSchema(\n    zodToJsonSchema(zodSchema, {\n      $refStrategy: useReferences ? 'root' : 'none',\n      target: 'jsonSchema7', // note: openai mode breaks various gemini conversions\n    }) as JSONSchema7,\n    {\n      validate: value => {\n        const result = zodSchema.safeParse(value);\n        return result.success\n          ? { success: true, value: result.data }\n          : { success: false, error: result.error };\n      },\n    },\n  );\n}\n", "import { extractMaxToolInvocationStep } from './extract-max-tool-invocation-step';\nimport { UIMessage } from './types';\n\nexport function shouldResubmitMessages({\n  originalMaxToolInvocationStep,\n  originalMessageCount,\n  maxSteps,\n  messages,\n}: {\n  originalMaxToolInvocationStep: number | undefined;\n  originalMessageCount: number;\n  maxSteps: number;\n  messages: UIMessage[];\n}) {\n  const lastMessage = messages[messages.length - 1];\n  return (\n    // check if the feature is enabled:\n    maxSteps > 1 &&\n    // ensure there is a last message:\n    lastMessage != null &&\n    // ensure we actually have new steps (to prevent infinite loops in case of errors):\n    (messages.length > originalMessageCount ||\n      extractMaxToolInvocationStep(lastMessage.toolInvocations) !==\n        originalMaxToolInvocationStep) &&\n    // check that next step is possible:\n    isAssistantMessageWithCompletedToolCalls(lastMessage) &&\n    // limit the number of automatic steps:\n    (extractMaxToolInvocationStep(lastMessage.toolInvocations) ?? 0) < maxSteps\n  );\n}\n\n/**\nCheck if the message is an assistant message with completed tool calls.\nThe last step of the message must have at least one tool invocation and\nall tool invocations must have a result.\n */\nexport function isAssistantMessageWithCompletedToolCalls(\n  message: UIMessage,\n): message is UIMessage & {\n  role: 'assistant';\n} {\n  if (message.role !== 'assistant') {\n    return false;\n  }\n\n  const lastStepStartIndex = message.parts.reduce((lastIndex, part, index) => {\n    return part.type === 'step-start' ? index : lastIndex;\n  }, -1);\n\n  const lastStepToolInvocations = message.parts\n    .slice(lastStepStartIndex + 1)\n    .filter(part => part.type === 'tool-invocation');\n\n  return (\n    lastStepToolInvocations.length > 0 &&\n    lastStepToolInvocations.every(part => 'result' in part.toolInvocation)\n  );\n}\n", "import { ToolInvocationUIPart, UIMessage } from './types';\n\n/**\n * Updates the result of a specific tool invocation in the last message of the given messages array.\n *\n * @param {object} params - The parameters object.\n * @param {UIMessage[]} params.messages - An array of messages, from which the last one is updated.\n * @param {string} params.toolCallId - The unique identifier for the tool invocation to update.\n * @param {unknown} params.toolResult - The result object to attach to the tool invocation.\n * @returns {void} This function does not return anything.\n */\nexport function updateToolCallResult({\n  messages,\n  toolCallId,\n  toolResult: result,\n}: {\n  messages: UIMessage[];\n  toolCallId: string;\n  toolResult: unknown;\n}) {\n  const lastMessage = messages[messages.length - 1];\n\n  const invocationPart = lastMessage.parts.find(\n    (part): part is ToolInvocationUIPart =>\n      part.type === 'tool-invocation' &&\n      part.toolInvocation.toolCallId === toolCallId,\n  );\n\n  if (invocationPart == null) {\n    return;\n  }\n\n  const toolResult = {\n    ...invocationPart.toolInvocation,\n    state: 'result' as const,\n    result,\n  };\n\n  invocationPart.toolInvocation = toolResult;\n\n  lastMessage.toolInvocations = lastMessage.toolInvocations?.map(\n    toolInvocation =>\n      toolInvocation.toolCallId === toolCallId ? toolResult : toolInvocation,\n  );\n}\n", "// re-exports:\nexport { createIdGenerator, generateId } from '@ai-sdk/provider-utils';\nexport type { IDGenerator } from '@ai-sdk/provider-utils';\nexport {\n  formatAssistantStreamPart,\n  formatDataStreamPart,\n  jsonSchema,\n  parseAssistantStreamPart,\n  parseDataStreamPart,\n  processDataStream,\n  processTextStream,\n  zodSchema,\n} from '@ai-sdk/ui-utils';\nexport type {\n  AssistantMessage,\n  AssistantStatus,\n  Attachment,\n  ChatRequest,\n  ChatRequestOptions,\n  CreateMessage,\n  DataMessage,\n  DataStreamPart,\n  DeepPartial,\n  IdGenerator,\n  JSONValue,\n  Message,\n  UIMessage,\n  RequestOptions,\n  Schema,\n  ToolInvocation,\n  UseAssistantOptions,\n} from '@ai-sdk/ui-utils';\n\n// directory exports:\nexport * from './data-stream';\nexport * from './embed';\nexport * from './generate-image';\nexport * from './generate-object';\nexport * from './generate-text';\nexport * from './generate-speech';\nexport * from './transcribe';\nexport * from './middleware';\nexport * from './prompt';\nexport * from './registry';\nexport * from './tool';\nexport * from './types';\n\n// telemetry types:\nexport type { TelemetrySettings } from './telemetry/telemetry-settings';\n\n// util exports:\nexport { cosineSimilarity } from './util/cosine-similarity';\nexport { simulateReadableStream } from './util/simulate-readable-stream';\n", "import { DataStreamString, formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { DataStreamWriter } from './data-stream-writer';\n\nexport function createDataStream({\n  execute,\n  onError = () => 'An error occurred.', // mask error messages for safety by default\n}: {\n  execute: (dataStream: DataStreamWriter) => Promise<void> | void;\n  onError?: (error: unknown) => string;\n}): ReadableStream<DataStreamString> {\n  let controller!: ReadableStreamDefaultController<string>;\n\n  const ongoingStreamPromises: Promise<void>[] = [];\n\n  const stream = new ReadableStream({\n    start(controllerArg) {\n      controller = controllerArg;\n    },\n  });\n\n  function safeEnqueue(data: DataStreamString) {\n    try {\n      controller.enqueue(data);\n    } catch (error) {\n      // suppress errors when the stream has been closed\n    }\n  }\n\n  try {\n    const result = execute({\n      write(data: DataStreamString) {\n        safeEnqueue(data);\n      },\n      writeData(data) {\n        safeEnqueue(formatDataStreamPart('data', [data]));\n      },\n      writeMessageAnnotation(annotation) {\n        safeEnqueue(formatDataStreamPart('message_annotations', [annotation]));\n      },\n      writeSource(source) {\n        safeEnqueue(formatDataStreamPart('source', source));\n      },\n      merge(streamArg) {\n        ongoingStreamPromises.push(\n          (async () => {\n            const reader = streamArg.getReader();\n            while (true) {\n              const { done, value } = await reader.read();\n              if (done) break;\n              safeEnqueue(value);\n            }\n          })().catch(error => {\n            safeEnqueue(formatDataStreamPart('error', onError(error)));\n          }),\n        );\n      },\n      onError,\n    });\n\n    if (result) {\n      ongoingStreamPromises.push(\n        result.catch(error => {\n          safeEnqueue(formatDataStreamPart('error', onError(error)));\n        }),\n      );\n    }\n  } catch (error) {\n    safeEnqueue(formatDataStreamPart('error', onError(error)));\n  }\n\n  // Wait until all ongoing streams are done. This approach enables merging\n  // streams even after execute has returned, as long as there is still an\n  // open merged stream. This is important to e.g. forward new streams and\n  // from callbacks.\n  const waitForStreams: Promise<void> = new Promise(async resolve => {\n    while (ongoingStreamPromises.length > 0) {\n      await ongoingStreamPromises.shift();\n    }\n    resolve();\n  });\n\n  waitForStreams.finally(() => {\n    try {\n      controller.close();\n    } catch (error) {\n      // suppress errors when the stream has been closed\n    }\n  });\n\n  return stream;\n}\n", "export function prepareResponseHeaders(\n  headers: HeadersInit | undefined,\n  {\n    contentType,\n    dataStreamVersion,\n  }: { contentType: string; dataStreamVersion?: 'v1' | undefined },\n) {\n  const responseHeaders = new Headers(headers ?? {});\n\n  if (!responseHeaders.has('Content-Type')) {\n    responseHeaders.set('Content-Type', contentType);\n  }\n\n  if (dataStreamVersion !== undefined) {\n    responseHeaders.set('X-Vercel-AI-Data-Stream', dataStreamVersion);\n  }\n\n  return responseHeaders;\n}\n", "import { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { createDataStream } from './create-data-stream';\nimport { DataStreamWriter } from './data-stream-writer';\n\nexport function createDataStreamResponse({\n  status,\n  statusText,\n  headers,\n  execute,\n  onError,\n}: ResponseInit & {\n  execute: (dataStream: DataStreamWriter) => Promise<void> | void;\n  onError?: (error: unknown) => string;\n}): Response {\n  return new Response(\n    createDataStream({ execute, onError }).pipeThrough(new TextEncoderStream()),\n    {\n      status,\n      statusText,\n      headers: prepareResponseHeaders(headers, {\n        contentType: 'text/plain; charset=utf-8',\n        dataStreamVersion: 'v1',\n      }),\n    },\n  );\n}\n", "export function prepareOutgoingHttpHeaders(\n  headers: HeadersInit | undefined,\n  {\n    contentType,\n    dataStreamVersion,\n  }: { contentType: string; dataStreamVersion?: 'v1' | undefined },\n) {\n  const outgoingHeaders: Record<string, string | number | string[]> = {};\n\n  if (headers != null) {\n    for (const [key, value] of Object.entries(headers)) {\n      outgoingHeaders[key] = value;\n    }\n  }\n\n  if (outgoingHeaders['Content-Type'] == null) {\n    outgoingHeaders['Content-Type'] = contentType;\n  }\n\n  if (dataStreamVersion !== undefined) {\n    outgoingHeaders['X-Vercel-AI-Data-Stream'] = dataStreamVersion;\n  }\n\n  return outgoingHeaders;\n}\n", "import { ServerResponse } from 'node:http';\n\n/**\n * Writes the content of a stream to a server response.\n */\nexport function writeToServerResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream,\n}: {\n  response: ServerResponse;\n  status?: number;\n  statusText?: string;\n  headers?: Record<string, string | number | string[]>;\n  stream: ReadableStream<Uint8Array>;\n}): void {\n  response.writeHead(status ?? 200, statusText, headers);\n\n  const reader = stream.getReader();\n  const read = async () => {\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        response.write(value);\n      }\n    } catch (error) {\n      throw error;\n    } finally {\n      response.end();\n    }\n  };\n\n  read();\n}\n", "import { ServerResponse } from 'node:http';\nimport { prepareOutgoingHttpHeaders } from '../util/prepare-outgoing-http-headers';\nimport { writeToServerResponse } from '../util/write-to-server-response';\nimport { createDataStream } from './create-data-stream';\nimport { DataStreamWriter } from './data-stream-writer';\n\nexport function pipeDataStreamToResponse(\n  response: ServerResponse,\n  {\n    status,\n    statusText,\n    headers,\n    execute,\n    onError,\n  }: ResponseInit & {\n    execute: (writer: DataStreamWriter) => Promise<void> | void;\n    onError?: (error: unknown) => string;\n  },\n): void {\n  writeToServerResponse({\n    response,\n    status,\n    statusText,\n    headers: prepareOutgoingHttpHeaders(headers, {\n      contentType: 'text/plain; charset=utf-8',\n      dataStreamVersion: 'v1',\n    }),\n    stream: createDataStream({ execute, onError }).pipeThrough(\n      new TextEncoderStream(),\n    ),\n  });\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\n/**\nError that is thrown when a model with an unsupported version is used.\n */\nexport class UnsupportedModelVersionError extends AISDKError {\n  constructor() {\n    super({\n      name: 'AI_UnsupportedModelVersionError',\n      message:\n        `Unsupported model version. ` +\n        `AI SDK 4 only supports models that implement specification version \"v1\". ` +\n        `Please upgrade to AI SDK 5 to use this model.`,\n    });\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidArgumentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidArgumentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly parameter: string;\n  readonly value: unknown;\n\n  constructor({\n    parameter,\n    value,\n    message,\n  }: {\n    parameter: string;\n    value: unknown;\n    message: string;\n  }) {\n    super({\n      name,\n      message: `Invalid argument for parameter ${parameter}: ${message}`,\n    });\n\n    this.parameter = parameter;\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is InvalidArgumentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { APICallError } from '@ai-sdk/provider';\nimport { delay, getErrorMessage, isAbortError } from '@ai-sdk/provider-utils';\nimport { RetryError } from './retry-error';\n\nexport type RetryFunction = <OUTPUT>(\n  fn: () => PromiseLike<OUTPUT>,\n) => PromiseLike<OUTPUT>;\n\n/**\nThe `retryWithExponentialBackoff` strategy retries a failed API call with an exponential backoff.\nYou can configure the maximum number of retries, the initial delay, and the backoff factor.\n */\nexport const retryWithExponentialBackoff =\n  ({\n    maxRetries = 2,\n    initialDelayInMs = 2000,\n    backoffFactor = 2,\n  } = {}): RetryFunction =>\n  async <OUTPUT>(f: () => PromiseLike<OUTPUT>) =>\n    _retryWithExponentialBackoff(f, {\n      maxRetries,\n      delayInMs: initialDelayInMs,\n      backoffFactor,\n    });\n\nasync function _retryWithExponentialBackoff<OUTPUT>(\n  f: () => PromiseLike<OUTPUT>,\n  {\n    maxRetries,\n    delayInMs,\n    backoffFactor,\n  }: { maxRetries: number; delayInMs: number; backoffFactor: number },\n  errors: unknown[] = [],\n): Promise<OUTPUT> {\n  try {\n    return await f();\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error; // don't retry when the request was aborted\n    }\n\n    if (maxRetries === 0) {\n      throw error; // don't wrap the error when retries are disabled\n    }\n\n    const errorMessage = getErrorMessage(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n\n    if (tryNumber > maxRetries) {\n      throw new RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: 'maxRetriesExceeded',\n        errors: newErrors,\n      });\n    }\n\n    if (\n      error instanceof Error &&\n      APICallError.isInstance(error) &&\n      error.isRetryable === true &&\n      tryNumber <= maxRetries\n    ) {\n      await delay(delayInMs);\n      return _retryWithExponentialBackoff(\n        f,\n        { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },\n        newErrors,\n      );\n    }\n\n    if (tryNumber === 1) {\n      throw error; // don't wrap the error when a non-retryable error occurs on the first try\n    }\n\n    throw new RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: 'errorNotRetryable',\n      errors: newErrors,\n    });\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_RetryError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport type RetryErrorReason =\n  | 'maxRetriesExceeded'\n  | 'errorNotRetryable'\n  | 'abort';\n\nexport class RetryError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  // note: property order determines debugging output\n  readonly reason: RetryErrorReason;\n  readonly lastError: unknown;\n  readonly errors: Array<unknown>;\n\n  constructor({\n    message,\n    reason,\n    errors,\n  }: {\n    message: string;\n    reason: RetryErrorReason;\n    errors: Array<unknown>;\n  }) {\n    super({ name, message });\n\n    this.reason = reason;\n    this.errors = errors;\n\n    // separate our last error to make debugging via log easier:\n    this.lastError = errors[errors.length - 1];\n  }\n\n  static isInstance(error: unknown): error is RetryError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport {\n  RetryFunction,\n  retryWithExponentialBackoff,\n} from '../../util/retry-with-exponential-backoff';\n\n/**\n * Validate and prepare retries.\n */\nexport function prepareRetries({\n  maxRetries,\n}: {\n  maxRetries: number | undefined;\n}): {\n  maxRetries: number;\n  retry: RetryFunction;\n} {\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new InvalidArgumentError({\n        parameter: 'maxRetries',\n        value: maxRetries,\n        message: 'maxRetries must be an integer',\n      });\n    }\n\n    if (maxRetries < 0) {\n      throw new InvalidArgumentError({\n        parameter: 'maxRetries',\n        value: maxRetries,\n        message: 'maxRetries must be >= 0',\n      });\n    }\n  }\n\n  const maxRetriesResult = maxRetries ?? 2;\n\n  return {\n    maxRetries: maxRetriesResult,\n    retry: retryWithExponentialBackoff({ maxRetries: maxRetriesResult }),\n  };\n}\n", "import { TelemetrySettings } from './telemetry-settings';\n\nexport function assembleOperationName({\n  operationId,\n  telemetry,\n}: {\n  operationId: string;\n  telemetry?: TelemetrySettings;\n}) {\n  return {\n    // standardized operation and resource name:\n    'operation.name': `${operationId}${\n      telemetry?.functionId != null ? ` ${telemetry.functionId}` : ''\n    }`,\n    'resource.name': telemetry?.functionId,\n\n    // detailed, AI SDK specific data:\n    'ai.operationId': operationId,\n    'ai.telemetry.functionId': telemetry?.functionId,\n  };\n}\n", "import { Attributes } from '@opentelemetry/api';\nimport { CallSettings } from '../prompt/call-settings';\nimport { TelemetrySettings } from './telemetry-settings';\n\nexport function getBaseTelemetryAttributes({\n  model,\n  settings,\n  telemetry,\n  headers,\n}: {\n  model: { modelId: string; provider: string };\n  settings: Omit<CallSettings, 'abortSignal' | 'headers'>;\n  telemetry: TelemetrySettings | undefined;\n  headers: Record<string, string | undefined> | undefined;\n}): Attributes {\n  return {\n    'ai.model.provider': model.provider,\n    'ai.model.id': model.modelId,\n\n    // settings:\n    ...Object.entries(settings).reduce((attributes, [key, value]) => {\n      attributes[`ai.settings.${key}`] = value;\n      return attributes;\n    }, {} as Attributes),\n\n    // add metadata as attributes:\n    ...Object.entries(telemetry?.metadata ?? {}).reduce(\n      (attributes, [key, value]) => {\n        attributes[`ai.telemetry.metadata.${key}`] = value;\n        return attributes;\n      },\n      {} as Attributes,\n    ),\n\n    // request headers\n    ...Object.entries(headers ?? {}).reduce((attributes, [key, value]) => {\n      if (value !== undefined) {\n        attributes[`ai.request.headers.${key}`] = value;\n      }\n      return attributes;\n    }, {} as Attributes),\n  };\n}\n", "import { Tracer, trace } from '@opentelemetry/api';\nimport { noopTracer } from './noop-tracer';\n\nexport function getTracer({\n  isEnabled = false,\n  tracer,\n}: {\n  isEnabled?: boolean;\n  tracer?: Tracer;\n} = {}): Tracer {\n  if (!isEnabled) {\n    return noopTracer;\n  }\n\n  if (tracer) {\n    return tracer;\n  }\n\n  return trace.getTracer('ai');\n}\n", "import { Span, SpanContext, Tracer } from '@opentelemetry/api';\n\n/**\n * Tracer implementation that does nothing (null object).\n */\nexport const noopTracer: Tracer = {\n  startSpan(): Span {\n    return noopSpan;\n  },\n\n  startActiveSpan<F extends (span: Span) => unknown>(\n    name: unknown,\n    arg1: unknown,\n    arg2?: unknown,\n    arg3?: F,\n  ): ReturnType<any> {\n    if (typeof arg1 === 'function') {\n      return arg1(noopSpan);\n    }\n    if (typeof arg2 === 'function') {\n      return arg2(noopSpan);\n    }\n    if (typeof arg3 === 'function') {\n      return arg3(noopSpan);\n    }\n  },\n};\n\nconst noopSpan: Span = {\n  spanContext() {\n    return noopSpanContext;\n  },\n  setAttribute() {\n    return this;\n  },\n  setAttributes() {\n    return this;\n  },\n  addEvent() {\n    return this;\n  },\n  addLink() {\n    return this;\n  },\n  addLinks() {\n    return this;\n  },\n  setStatus() {\n    return this;\n  },\n  updateName() {\n    return this;\n  },\n  end() {\n    return this;\n  },\n  isRecording() {\n    return false;\n  },\n  recordException() {\n    return this;\n  },\n};\n\nconst noopSpanContext: SpanContext = {\n  traceId: '',\n  spanId: '',\n  traceFlags: 0,\n};\n", "import { Attributes, Span, Tracer, SpanStatusCode } from '@opentelemetry/api';\n\nexport function recordSpan<T>({\n  name,\n  tracer,\n  attributes,\n  fn,\n  endWhenDone = true,\n}: {\n  name: string;\n  tracer: Tracer;\n  attributes: Attributes;\n  fn: (span: Span) => Promise<T>;\n  endWhenDone?: boolean;\n}) {\n  return tracer.startActiveSpan(name, { attributes }, async span => {\n    try {\n      const result = await fn(span);\n\n      if (endWhenDone) {\n        span.end();\n      }\n\n      return result;\n    } catch (error) {\n      try {\n        recordErrorOnSpan(span, error);\n      } finally {\n        // always stop the span when there is an error:\n        span.end();\n      }\n\n      throw error;\n    }\n  });\n}\n\n/**\n * Record an error on a span. If the error is an instance of Error, an exception event will be recorded on the span, otherwise\n * the span will be set to an error status.\n *\n * @param span - The span to record the error on.\n * @param error - The error to record on the span.\n */\nexport function recordErrorOnSpan(span: Span, error: unknown) {\n  if (error instanceof Error) {\n    span.recordException({\n      name: error.name,\n      message: error.message,\n      stack: error.stack,\n    });\n    span.setStatus({\n      code: SpanStatusCode.ERROR,\n      message: error.message,\n    });\n  } else {\n    span.setStatus({ code: SpanStatusCode.ERROR });\n  }\n}\n", "import type { Attributes, AttributeValue } from '@opentelemetry/api';\nimport type { TelemetrySettings } from './telemetry-settings';\n\nexport function selectTelemetryAttributes({\n  telemetry,\n  attributes,\n}: {\n  telemetry?: TelemetrySettings;\n  attributes: {\n    [attributeKey: string]:\n      | AttributeValue\n      | { input: () => AttributeValue | undefined }\n      | { output: () => AttributeValue | undefined }\n      | undefined;\n  };\n}): Attributes {\n  // when telemetry is disabled, return an empty object to avoid serialization overhead:\n  if (telemetry?.isEnabled !== true) {\n    return {};\n  }\n\n  return Object.entries(attributes).reduce((attributes, [key, value]) => {\n    if (value === undefined) {\n      return attributes;\n    }\n\n    // input value, check if it should be recorded:\n    if (\n      typeof value === 'object' &&\n      'input' in value &&\n      typeof value.input === 'function'\n    ) {\n      // default to true:\n      if (telemetry?.recordInputs === false) {\n        return attributes;\n      }\n\n      const result = value.input();\n\n      return result === undefined\n        ? attributes\n        : { ...attributes, [key]: result };\n    }\n\n    // output value, check if it should be recorded:\n    if (\n      typeof value === 'object' &&\n      'output' in value &&\n      typeof value.output === 'function'\n    ) {\n      // default to true:\n      if (telemetry?.recordOutputs === false) {\n        return attributes;\n      }\n\n      const result = value.output();\n\n      return result === undefined\n        ? attributes\n        : { ...attributes, [key]: result };\n    }\n\n    // value is an attribute value already:\n    return { ...attributes, [key]: value };\n  }, {});\n}\n", "import { UnsupportedModelVersionError } from '../../errors/unsupported-model-version-error';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { EmbeddingModel } from '../types';\nimport { EmbedResult } from './embed-result';\n\n/**\nEmbed a value using an embedding model. The type of the value is defined by the embedding model.\n\n@param model - The embedding model to use.\n@param value - The value that should be embedded.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the embedding, the value, and additional information.\n */\nexport async function embed<VALUE>({\n  model,\n  value,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n}: {\n  /**\nThe embedding model to use.\n     */\n  model: EmbeddingModel<VALUE>;\n\n  /**\nThe value that should be embedded.\n   */\n  value: VALUE;\n\n  /**\nMaximum number of retries per embedding model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n\n  /**\n   * Optional telemetry configuration (experimental).\n   */\n  experimental_telemetry?: TelemetrySettings;\n}): Promise<EmbedResult<VALUE>> {\n  if (typeof model === 'string' || model.specificationVersion !== 'v1') {\n    throw new UnsupportedModelVersionError();\n  }\n\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.embed',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: 'ai.embed', telemetry }),\n        ...baseTelemetryAttributes,\n        'ai.value': { input: () => JSON.stringify(value) },\n      },\n    }),\n    tracer,\n    fn: async span => {\n      const { embedding, usage, rawResponse } = await retry(() =>\n        // nested spans to align with the embedMany telemetry data:\n        recordSpan({\n          name: 'ai.embed.doEmbed',\n          attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              ...assembleOperationName({\n                operationId: 'ai.embed.doEmbed',\n                telemetry,\n              }),\n              ...baseTelemetryAttributes,\n              // specific settings that only make sense on the outer level:\n              'ai.values': { input: () => [JSON.stringify(value)] },\n            },\n          }),\n          tracer,\n          fn: async doEmbedSpan => {\n            const modelResponse = await model.doEmbed({\n              values: [value],\n              abortSignal,\n              headers,\n            });\n\n            const embedding = modelResponse.embeddings[0];\n            const usage = modelResponse.usage ?? { tokens: NaN };\n\n            doEmbedSpan.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  'ai.embeddings': {\n                    output: () =>\n                      modelResponse.embeddings.map(embedding =>\n                        JSON.stringify(embedding),\n                      ),\n                  },\n                  'ai.usage.tokens': usage.tokens,\n                },\n              }),\n            );\n\n            return {\n              embedding,\n              usage,\n              rawResponse: modelResponse.rawResponse,\n            };\n          },\n        }),\n      );\n\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.embedding': { output: () => JSON.stringify(embedding) },\n            'ai.usage.tokens': usage.tokens,\n          },\n        }),\n      );\n\n      return new DefaultEmbedResult({ value, embedding, usage, rawResponse });\n    },\n  });\n}\n\nclass DefaultEmbedResult<VALUE> implements EmbedResult<VALUE> {\n  readonly value: EmbedResult<VALUE>['value'];\n  readonly embedding: EmbedResult<VALUE>['embedding'];\n  readonly usage: EmbedResult<VALUE>['usage'];\n  readonly rawResponse: EmbedResult<VALUE>['rawResponse'];\n\n  constructor(options: {\n    value: EmbedResult<VALUE>['value'];\n    embedding: EmbedResult<VALUE>['embedding'];\n    usage: EmbedResult<VALUE>['usage'];\n    rawResponse?: EmbedResult<VALUE>['rawResponse'];\n  }) {\n    this.value = options.value;\n    this.embedding = options.embedding;\n    this.usage = options.usage;\n    this.rawResponse = options.rawResponse;\n  }\n}\n", "/**\n * Splits an array into chunks of a specified size.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} array - The array to split.\n * @param {number} chunkSize - The size of each chunk.\n * @returns {T[][]} - A new array containing the chunks.\n */\nexport function splitArray<T>(array: T[], chunkSize: number): T[][] {\n  if (chunkSize <= 0) {\n    throw new Error('chunkSize must be greater than 0');\n  }\n\n  const result = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.slice(i, i + chunkSize));\n  }\n\n  return result;\n}\n", "import { prepareRetries } from '../prompt/prepare-retries';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { Embedding, EmbeddingModel } from '../types';\nimport { splitArray } from '../util/split-array';\nimport { EmbedManyResult } from './embed-many-result';\nimport { UnsupportedModelVersionError } from '../../errors/unsupported-model-version-error';\n\n/**\nEmbed several values using an embedding model. The type of the value is defined\nby the embedding model.\n\n`embedMany` automatically splits large requests into smaller chunks if the model\nhas a limit on how many embeddings can be generated in a single call.\n\n@param model - The embedding model to use.\n@param values - The values that should be embedded.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the embeddings, the value, and additional information.\n */\nexport async function embedMany<VALUE>({\n  model,\n  values,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n}: {\n  /**\nThe embedding model to use.\n     */\n  model: EmbeddingModel<VALUE>;\n\n  /**\nThe values that should be embedded.\n   */\n  values: Array<VALUE>;\n\n  /**\nMaximum number of retries per embedding model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n\n  /**\n   * Optional telemetry configuration (experimental).\n   */\n  experimental_telemetry?: TelemetrySettings;\n}): Promise<EmbedManyResult<VALUE>> {\n  if (typeof model === 'string' || model.specificationVersion !== 'v1') {\n    throw new UnsupportedModelVersionError();\n  }\n\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.embedMany',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: 'ai.embedMany', telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        'ai.values': {\n          input: () => values.map(value => JSON.stringify(value)),\n        },\n      },\n    }),\n    tracer,\n    fn: async span => {\n      const maxEmbeddingsPerCall = model.maxEmbeddingsPerCall;\n\n      // the model has not specified limits on\n      // how many embeddings can be generated in a single call\n      if (maxEmbeddingsPerCall == null) {\n        const { embeddings, usage } = await retry(() => {\n          // nested spans to align with the embedMany telemetry data:\n          return recordSpan({\n            name: 'ai.embedMany.doEmbed',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.embedMany.doEmbed',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                'ai.values': {\n                  input: () => values.map(value => JSON.stringify(value)),\n                },\n              },\n            }),\n            tracer,\n            fn: async doEmbedSpan => {\n              const modelResponse = await model.doEmbed({\n                values,\n                abortSignal,\n                headers,\n              });\n\n              const embeddings = modelResponse.embeddings;\n              const usage = modelResponse.usage ?? { tokens: NaN };\n\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.embeddings': {\n                      output: () =>\n                        embeddings.map(embedding => JSON.stringify(embedding)),\n                    },\n                    'ai.usage.tokens': usage.tokens,\n                  },\n                }),\n              );\n\n              return { embeddings, usage };\n            },\n          });\n        });\n\n        span.setAttributes(\n          selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              'ai.embeddings': {\n                output: () =>\n                  embeddings.map(embedding => JSON.stringify(embedding)),\n              },\n              'ai.usage.tokens': usage.tokens,\n            },\n          }),\n        );\n\n        return new DefaultEmbedManyResult({ values, embeddings, usage });\n      }\n\n      // split the values into chunks that are small enough for the model:\n      const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n\n      // serially embed the chunks:\n      const embeddings: Array<Embedding> = [];\n      let tokens = 0;\n\n      for (const chunk of valueChunks) {\n        const { embeddings: responseEmbeddings, usage } = await retry(() => {\n          // nested spans to align with the embedMany telemetry data:\n          return recordSpan({\n            name: 'ai.embedMany.doEmbed',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.embedMany.doEmbed',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                'ai.values': {\n                  input: () => chunk.map(value => JSON.stringify(value)),\n                },\n              },\n            }),\n            tracer,\n            fn: async doEmbedSpan => {\n              const modelResponse = await model.doEmbed({\n                values: chunk,\n                abortSignal,\n                headers,\n              });\n\n              const embeddings = modelResponse.embeddings;\n              const usage = modelResponse.usage ?? { tokens: NaN };\n\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.embeddings': {\n                      output: () =>\n                        embeddings.map(embedding => JSON.stringify(embedding)),\n                    },\n                    'ai.usage.tokens': usage.tokens,\n                  },\n                }),\n              );\n\n              return { embeddings, usage };\n            },\n          });\n        });\n\n        embeddings.push(...responseEmbeddings);\n        tokens += usage.tokens;\n      }\n\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.embeddings': {\n              output: () =>\n                embeddings.map(embedding => JSON.stringify(embedding)),\n            },\n            'ai.usage.tokens': tokens,\n          },\n        }),\n      );\n\n      return new DefaultEmbedManyResult({\n        values,\n        embeddings,\n        usage: { tokens },\n      });\n    },\n  });\n}\n\nclass DefaultEmbedManyResult<VALUE> implements EmbedManyResult<VALUE> {\n  readonly values: EmbedManyResult<VALUE>['values'];\n  readonly embeddings: EmbedManyResult<VALUE>['embeddings'];\n  readonly usage: EmbedManyResult<VALUE>['usage'];\n\n  constructor(options: {\n    values: EmbedManyResult<VALUE>['values'];\n    embeddings: EmbedManyResult<VALUE>['embeddings'];\n    usage: EmbedManyResult<VALUE>['usage'];\n  }) {\n    this.values = options.values;\n    this.embeddings = options.embeddings;\n    this.usage = options.usage;\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\nimport { ImageModelResponseMetadata } from '../core/types/image-model-response-metadata';\n\nconst name = 'AI_NoImageGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when no image could be generated. This can have multiple causes:\n\n- The model failed to generate a response.\n- The model generated a response that could not be parsed.\n */\nexport class NoImageGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\nThe response metadata for each call.\n   */\n  readonly responses: Array<ImageModelResponseMetadata> | undefined;\n\n  constructor({\n    message = 'No image generated.',\n    cause,\n    responses,\n  }: {\n    message?: string;\n    cause?: Error;\n    responses?: Array<ImageModelResponseMetadata>;\n  }) {\n    super({ name, message, cause });\n\n    this.responses = responses;\n  }\n\n  static isInstance(error: unknown): error is NoImageGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import {\n  convertBase64ToUint8Array,\n  convertUint8ArrayToBase64,\n} from '@ai-sdk/provider-utils';\n\n/**\n * A generated file.\n */\nexport interface GeneratedFile {\n  /**\nFile as a base64 encoded string.\n     */\n  readonly base64: string;\n\n  /**\nFile as a Uint8Array.\n     */\n  readonly uint8Array: Uint8Array;\n\n  /**\nMIME type of the file\n   */\n  readonly mimeType: string;\n}\n\nexport class DefaultGeneratedFile implements GeneratedFile {\n  private base64Data: string | undefined;\n  private uint8ArrayData: Uint8Array | undefined;\n\n  readonly mimeType: string;\n\n  constructor({\n    data,\n    mimeType,\n  }: {\n    data: string | Uint8Array;\n    mimeType: string;\n  }) {\n    const isUint8Array = data instanceof Uint8Array;\n    this.base64Data = isUint8Array ? undefined : data;\n    this.uint8ArrayData = isUint8Array ? data : undefined;\n    this.mimeType = mimeType;\n  }\n\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get base64() {\n    if (this.base64Data == null) {\n      this.base64Data = convertUint8ArrayToBase64(this.uint8ArrayData!);\n    }\n    return this.base64Data;\n  }\n\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get uint8Array() {\n    if (this.uint8ArrayData == null) {\n      this.uint8ArrayData = convertBase64ToUint8Array(this.base64Data!);\n    }\n    return this.uint8ArrayData;\n  }\n}\n\nexport class DefaultGeneratedFileWithType extends DefaultGeneratedFile {\n  readonly type = 'file';\n\n  constructor(options: { data: string | Uint8Array; mimeType: string }) {\n    super(options);\n  }\n}\n", "import { convertBase64ToUint8Array } from '@ai-sdk/provider-utils';\n\nexport const imageMimeTypeSignatures = [\n  {\n    mimeType: 'image/gif' as const,\n    bytesPrefix: [0x47, 0x49, 0x46],\n    base64Prefix: 'R0lG',\n  },\n  {\n    mimeType: 'image/png' as const,\n    bytesPrefix: [0x89, 0x50, 0x4e, 0x47],\n    base64Prefix: 'iVBORw',\n  },\n  {\n    mimeType: 'image/jpeg' as const,\n    bytesPrefix: [0xff, 0xd8],\n    base64Prefix: '/9j/',\n  },\n  {\n    mimeType: 'image/webp' as const,\n    bytesPrefix: [0x52, 0x49, 0x46, 0x46],\n    base64Prefix: 'UklGRg',\n  },\n  {\n    mimeType: 'image/bmp' as const,\n    bytesPrefix: [0x42, 0x4d],\n    base64Prefix: 'Qk',\n  },\n  {\n    mimeType: 'image/tiff' as const,\n    bytesPrefix: [0x49, 0x49, 0x2a, 0x00],\n    base64Prefix: 'SUkqAA',\n  },\n  {\n    mimeType: 'image/tiff' as const,\n    bytesPrefix: [0x4d, 0x4d, 0x00, 0x2a],\n    base64Prefix: 'TU0AKg',\n  },\n  {\n    mimeType: 'image/avif' as const,\n    bytesPrefix: [\n      0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70, 0x61, 0x76, 0x69, 0x66,\n    ],\n    base64Prefix: 'AAAAIGZ0eXBhdmlm',\n  },\n  {\n    mimeType: 'image/heic' as const,\n    bytesPrefix: [\n      0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70, 0x68, 0x65, 0x69, 0x63,\n    ],\n    base64Prefix: 'AAAAIGZ0eXBoZWlj',\n  },\n] as const;\n\nexport const audioMimeTypeSignatures = [\n  {\n    mimeType: 'audio/mpeg' as const,\n    bytesPrefix: [0xff, 0xfb],\n    base64Prefix: '//s=',\n  },\n  {\n    mimeType: 'audio/wav' as const,\n    bytesPrefix: [0x52, 0x49, 0x46, 0x46],\n    base64Prefix: 'UklGR',\n  },\n  {\n    mimeType: 'audio/ogg' as const,\n    bytesPrefix: [0x4f, 0x67, 0x67, 0x53],\n    base64Prefix: 'T2dnUw',\n  },\n  {\n    mimeType: 'audio/flac' as const,\n    bytesPrefix: [0x66, 0x4c, 0x61, 0x43],\n    base64Prefix: 'ZkxhQw',\n  },\n  {\n    mimeType: 'audio/aac' as const,\n    bytesPrefix: [0x40, 0x15, 0x00, 0x00],\n    base64Prefix: 'QBUA',\n  },\n  {\n    mimeType: 'audio/mp4' as const,\n    bytesPrefix: [0x66, 0x74, 0x79, 0x70],\n    base64Prefix: 'ZnR5cA',\n  },\n] as const;\n\nconst stripID3 = (data: Uint8Array | string) => {\n  const bytes =\n    typeof data === 'string' ? convertBase64ToUint8Array(data) : data;\n  const id3Size =\n    ((bytes[6] & 0x7f) << 21) |\n    ((bytes[7] & 0x7f) << 14) |\n    ((bytes[8] & 0x7f) << 7) |\n    (bytes[9] & 0x7f);\n\n  // The raw MP3 starts here\n  return bytes.slice(id3Size + 10);\n};\n\nfunction stripID3TagsIfPresent(data: Uint8Array | string): Uint8Array | string {\n  const hasId3 =\n    (typeof data === 'string' && data.startsWith('SUQz')) ||\n    (typeof data !== 'string' &&\n      data.length > 10 &&\n      data[0] === 0x49 && // 'I'\n      data[1] === 0x44 && // 'D'\n      data[2] === 0x33); // '3'\n\n  return hasId3 ? stripID3(data) : data;\n}\n\nexport function detectMimeType({\n  data,\n  signatures,\n}: {\n  data: Uint8Array | string;\n  signatures: typeof audioMimeTypeSignatures | typeof imageMimeTypeSignatures;\n}): (typeof signatures)[number]['mimeType'] | undefined {\n  const processedData = stripID3TagsIfPresent(data);\n\n  for (const signature of signatures) {\n    if (\n      typeof processedData === 'string'\n        ? processedData.startsWith(signature.base64Prefix)\n        : processedData.length >= signature.bytesPrefix.length &&\n          signature.bytesPrefix.every(\n            (byte, index) => processedData[index] === byte,\n          )\n    ) {\n      return signature.mimeType;\n    }\n  }\n\n  return undefined;\n}\n", "import { AISDKError, ImageModelV1, JSONValue } from '@ai-sdk/provider';\nimport { NoImageGeneratedError } from '../../errors/no-image-generated-error';\nimport {\n  DefaultGeneratedFile,\n  GeneratedFile,\n} from '../generate-text/generated-file';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { ImageGenerationWarning } from '../types/image-model';\nimport { ImageModelResponseMetadata } from '../types/image-model-response-metadata';\nimport { GenerateImageResult } from './generate-image-result';\nimport {\n  detectMimeType,\n  imageMimeTypeSignatures,\n} from '../util/detect-mimetype';\nimport { UnsupportedModelVersionError } from '../../errors/unsupported-model-version-error';\n\n/**\nGenerates images using an image model.\n\n@param model - The image model to use.\n@param prompt - The prompt that should be used to generate the image.\n@param n - Number of images to generate. Default: 1.\n@param size - Size of the images to generate. Must have the format `{width}x{height}`.\n@param aspectRatio - Aspect ratio of the images to generate. Must have the format `{width}:{height}`.\n@param seed - Seed for the image generation.\n@param providerOptions - Additional provider-specific options that are passed through to the provider\nas body parameters.\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the generated images.\n */\nexport async function generateImage({\n  model,\n  prompt,\n  n = 1,\n  size,\n  aspectRatio,\n  seed,\n  providerOptions,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n}: {\n  /**\nThe image model to use.\n     */\n  model: ImageModelV1;\n\n  /**\nThe prompt that should be used to generate the image.\n   */\n  prompt: string;\n\n  /**\nNumber of images to generate.\n   */\n  n?: number;\n\n  /**\nSize of the images to generate. Must have the format `{width}x{height}`. If not provided, the default size will be used.\n   */\n  size?: `${number}x${number}`;\n\n  /**\nAspect ratio of the images to generate. Must have the format `{width}:{height}`. If not provided, the default aspect ratio will be used.\n   */\n  aspectRatio?: `${number}:${number}`;\n\n  /**\nSeed for the image generation. If not provided, the default seed will be used.\n   */\n  seed?: number;\n\n  /**\nAdditional provider-specific options that are passed through to the provider\nas body parameters.\n\nThe outer record is keyed by the provider name, and the inner\nrecord is keyed by the provider-specific metadata key.\n```ts\n{\n  \"openai\": {\n    \"style\": \"vivid\"\n  }\n}\n```\n     */\n  providerOptions?: Record<string, Record<string, JSONValue>>;\n\n  /**\nMaximum number of retries per embedding model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n}): Promise<GenerateImageResult> {\n  if (typeof model === 'string' || model.specificationVersion !== 'v1') {\n    throw new UnsupportedModelVersionError();\n  }\n\n  const { retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  // default to 1 if the model has not specified limits on\n  // how many images can be generated in a single call\n  const maxImagesPerCall = model.maxImagesPerCall ?? 1;\n\n  // parallelize calls to the model:\n  const callCount = Math.ceil(n / maxImagesPerCall);\n  const callImageCounts = Array.from({ length: callCount }, (_, i) => {\n    if (i < callCount - 1) {\n      return maxImagesPerCall;\n    }\n\n    const remainder = n % maxImagesPerCall;\n    return remainder === 0 ? maxImagesPerCall : remainder;\n  });\n  const results = await Promise.all(\n    callImageCounts.map(async callImageCount =>\n      retry(() =>\n        model.doGenerate({\n          prompt,\n          n: callImageCount,\n          abortSignal,\n          headers,\n          size,\n          aspectRatio,\n          seed,\n          providerOptions: providerOptions ?? {},\n        }),\n      ),\n    ),\n  );\n\n  // collect result images, warnings, and response metadata\n  const images: Array<DefaultGeneratedFile> = [];\n  const warnings: Array<ImageGenerationWarning> = [];\n  const responses: Array<ImageModelResponseMetadata> = [];\n  for (const result of results) {\n    images.push(\n      ...result.images.map(\n        image =>\n          new DefaultGeneratedFile({\n            data: image,\n            mimeType:\n              detectMimeType({\n                data: image,\n                signatures: imageMimeTypeSignatures,\n              }) ?? 'image/png',\n          }),\n      ),\n    );\n    warnings.push(...result.warnings);\n    responses.push(result.response);\n  }\n\n  if (!images.length) {\n    throw new NoImageGeneratedError({ responses });\n  }\n\n  return new DefaultGenerateImageResult({ images, warnings, responses });\n}\n\nclass DefaultGenerateImageResult implements GenerateImageResult {\n  readonly images: Array<GeneratedFile>;\n  readonly warnings: Array<ImageGenerationWarning>;\n  readonly responses: Array<ImageModelResponseMetadata>;\n\n  constructor(options: {\n    images: Array<GeneratedFile>;\n    warnings: Array<ImageGenerationWarning>;\n    responses: Array<ImageModelResponseMetadata>;\n  }) {\n    this.images = options.images;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n  }\n\n  get image() {\n    return this.images[0];\n  }\n}\n", "import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport { createIdGenerator, safeParseJSON } from '@ai-sdk/provider-utils';\nimport { Schema } from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { NoObjectGeneratedError } from '../../errors/no-object-generated-error';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  CallWarning,\n  FinishReason,\n  LanguageModel,\n  LogProbs,\n  ProviderMetadata,\n} from '../types';\nimport { LanguageModelRequestMetadata } from '../types/language-model-request-metadata';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { ProviderOptions } from '../types/provider-metadata';\nimport { calculateLanguageModelUsage } from '../types/usage';\nimport { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { GenerateObjectResult } from './generate-object-result';\nimport { injectJsonInstruction } from './inject-json-instruction';\nimport { getOutputStrategy } from './output-strategy';\nimport { validateObjectGenerationInput } from './validate-object-generation-input';\nimport { stringifyForTelemetry } from '../prompt/stringify-for-telemetry';\nimport { UnsupportedModelVersionError } from '../../errors/unsupported-model-version-error';\n\nconst originalGenerateId = createIdGenerator({ prefix: 'aiobj', size: 24 });\n\n/**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n\nShould return the repaired text or null if the text cannot be repaired.\n     */\nexport type RepairTextFunction = (options: {\n  text: string;\n  error: JSONParseError | TypeValidationError;\n}) => Promise<string | null>;\n\n/**\nGenerate a structured, typed object for a given prompt and schema using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamObject` instead.\n\n@returns\nA result object that contains the generated object, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject<OBJECT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output?: 'object' | undefined;\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe schema of the object that the model should generate.\n     */\n      schema: z.Schema<OBJECT, z.ZodTypeDef, any> | Schema<OBJECT>;\n\n      /**\nOptional name of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n     */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n     */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\nOptional telemetry configuration (experimental).\n       */\n\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<OBJECT>>;\n/**\nGenerate an array with structured, typed elements for a given prompt and element schema using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamObject` instead.\n\n@return\nA result object that contains the generated object, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject<ELEMENT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'array';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe element schema of the array that the model should generate.\n */\n      schema: z.Schema<ELEMENT, z.ZodTypeDef, any> | Schema<ELEMENT>;\n\n      /**\nOptional name of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n     */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<Array<ELEMENT>>>;\n/**\nGenerate a value from an enum (limited list of string values) using a language model.\n\nThis function does not stream the output.\n\n@return\nA result object that contains the generated value, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject<ENUM extends string>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'enum';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe enum values that the model should use.\n     */\n      enum: Array<ENUM>;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n     */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<ENUM>>;\n/**\nGenerate JSON with any schema for a given prompt using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamObject` instead.\n\n@returns\nA result object that contains the generated object, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'no-schema';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe mode to use for object generation. Must be \"json\" for no-schema output.\n     */\n      mode?: 'json';\n\n      /**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n     */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\nOptional telemetry configuration (experimental).\n       */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<JSONValue>>;\nexport async function generateObject<SCHEMA, RESULT>({\n  model,\n  enum: enumValues, // rename bc enum is reserved by typescript\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  output = 'object',\n  system,\n  prompt,\n  messages,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_repairText: repairText,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  _internal: {\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n  } = {},\n  ...settings\n}: Omit<CallSettings, 'stopSequences'> &\n  Prompt & {\n    /**\n     * The expected structure of the output.\n     *\n     * - 'object': Generate a single object that conforms to the schema.\n     * - 'array': Generate an array of objects that conform to the schema.\n     * - 'no-schema': Generate any JSON object. No schema is specified.\n     *\n     * Default is 'object' if not specified.\n     */\n    output?: 'object' | 'array' | 'enum' | 'no-schema';\n\n    model: LanguageModel;\n    enum?: Array<SCHEMA>;\n    schema?: z.Schema<SCHEMA, z.ZodTypeDef, any> | Schema<SCHEMA>;\n    schemaName?: string;\n    schemaDescription?: string;\n    mode?: 'auto' | 'json' | 'tool';\n    experimental_repairText?: RepairTextFunction;\n    experimental_telemetry?: TelemetrySettings;\n    experimental_providerMetadata?: ProviderMetadata;\n    providerOptions?: ProviderOptions;\n\n    /**\n     * Internal. For test use only. May change without notice.\n     */\n    _internal?: {\n      generateId?: () => string;\n      currentDate?: () => Date;\n    };\n  }): Promise<GenerateObjectResult<RESULT>> {\n  if (typeof model === 'string' || model.specificationVersion !== 'v1') {\n    throw new UnsupportedModelVersionError();\n  }\n\n  validateObjectGenerationInput({\n    output,\n    mode,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues,\n  });\n\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues,\n  });\n\n  // automatically set mode to 'json' for no-schema output\n  if (outputStrategy.type === 'no-schema' && mode === undefined) {\n    mode = 'json';\n  }\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.generateObject',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: 'ai.generateObject',\n          telemetry,\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        'ai.prompt': {\n          input: () => JSON.stringify({ system, prompt, messages }),\n        },\n        'ai.schema':\n          outputStrategy.jsonSchema != null\n            ? { input: () => JSON.stringify(outputStrategy.jsonSchema) }\n            : undefined,\n        'ai.schema.name': schemaName,\n        'ai.schema.description': schemaDescription,\n        'ai.settings.output': outputStrategy.type,\n        'ai.settings.mode': mode,\n      },\n    }),\n    tracer,\n    fn: async span => {\n      // use the default provider mode when the mode is set to 'auto' or unspecified\n      if (mode === 'auto' || mode == null) {\n        mode = model.defaultObjectGenerationMode;\n      }\n\n      let result: string;\n      let finishReason: FinishReason;\n      let usage: Parameters<typeof calculateLanguageModelUsage>[0];\n      let warnings: CallWarning[] | undefined;\n      let rawResponse:\n        | { headers?: Record<string, string>; body?: unknown }\n        | undefined;\n      let response: LanguageModelResponseMetadata;\n      let request: LanguageModelRequestMetadata;\n      let logprobs: LogProbs | undefined;\n      let resultProviderMetadata: ProviderMetadata | undefined;\n\n      switch (mode) {\n        case 'json': {\n          const standardizedPrompt = standardizePrompt({\n            prompt: {\n              system:\n                outputStrategy.jsonSchema == null\n                  ? injectJsonInstruction({ prompt: system })\n                  : model.supportsStructuredOutputs\n                    ? system\n                    : injectJsonInstruction({\n                        prompt: system,\n                        schema: outputStrategy.jsonSchema,\n                      }),\n              prompt,\n              messages,\n            },\n            tools: undefined,\n          });\n\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: standardizedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls,\n            modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context\n          });\n\n          const generateResult = await retry(() =>\n            recordSpan({\n              name: 'ai.generateObject.doGenerate',\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: 'ai.generateObject.doGenerate',\n                    telemetry,\n                  }),\n                  ...baseTelemetryAttributes,\n                  'ai.prompt.format': {\n                    input: () => standardizedPrompt.type,\n                  },\n                  'ai.prompt.messages': {\n                    input: () => JSON.stringify(promptMessages),\n                  },\n                  'ai.settings.mode': mode,\n\n                  // standardized gen-ai llm span attributes:\n                  'gen_ai.system': model.provider,\n                  'gen_ai.request.model': model.modelId,\n                  'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                  'gen_ai.request.max_tokens': settings.maxTokens,\n                  'gen_ai.request.presence_penalty': settings.presencePenalty,\n                  'gen_ai.request.temperature': settings.temperature,\n                  'gen_ai.request.top_k': settings.topK,\n                  'gen_ai.request.top_p': settings.topP,\n                },\n              }),\n              tracer,\n              fn: async span => {\n                const result = await model.doGenerate({\n                  mode: {\n                    type: 'object-json',\n                    schema: outputStrategy.jsonSchema,\n                    name: schemaName,\n                    description: schemaDescription,\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat: standardizedPrompt.type,\n                  prompt: promptMessages,\n                  providerMetadata: providerOptions,\n                  abortSignal,\n                  headers,\n                });\n\n                const responseData = {\n                  id: result.response?.id ?? generateId(),\n                  timestamp: result.response?.timestamp ?? currentDate(),\n                  modelId: result.response?.modelId ?? model.modelId,\n                };\n\n                if (result.text === undefined) {\n                  throw new NoObjectGeneratedError({\n                    message:\n                      'No object generated: the model did not return a response.',\n                    response: responseData,\n                    usage: calculateLanguageModelUsage(result.usage),\n                    finishReason: result.finishReason,\n                  });\n                }\n\n                // Add response information to the span:\n                span.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      'ai.response.finishReason': result.finishReason,\n                      'ai.response.object': { output: () => result.text },\n                      'ai.response.id': responseData.id,\n                      'ai.response.model': responseData.modelId,\n                      'ai.response.timestamp':\n                        responseData.timestamp.toISOString(),\n                      'ai.response.providerMetadata': JSON.stringify(\n                        result.providerMetadata,\n                      ),\n                      'ai.usage.promptTokens': result.usage.promptTokens,\n                      'ai.usage.completionTokens':\n                        result.usage.completionTokens,\n\n                      // standardized gen-ai llm span attributes:\n                      'gen_ai.response.finish_reasons': [result.finishReason],\n                      'gen_ai.response.id': responseData.id,\n                      'gen_ai.response.model': responseData.modelId,\n                      'gen_ai.usage.prompt_tokens': result.usage.promptTokens,\n                      'gen_ai.usage.completion_tokens':\n                        result.usage.completionTokens,\n                    },\n                  }),\n                );\n\n                return { ...result, objectText: result.text, responseData };\n              },\n            }),\n          );\n\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          resultProviderMetadata = generateResult.providerMetadata;\n          request = generateResult.request ?? {};\n          response = generateResult.responseData;\n\n          break;\n        }\n\n        case 'tool': {\n          const standardizedPrompt = standardizePrompt({\n            prompt: { system, prompt, messages },\n            tools: undefined,\n          });\n\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: standardizedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls,\n            modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context,\n          });\n          const inputFormat = standardizedPrompt.type;\n\n          const generateResult = await retry(() =>\n            recordSpan({\n              name: 'ai.generateObject.doGenerate',\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: 'ai.generateObject.doGenerate',\n                    telemetry,\n                  }),\n                  ...baseTelemetryAttributes,\n                  'ai.prompt.format': {\n                    input: () => inputFormat,\n                  },\n                  'ai.prompt.messages': {\n                    input: () => stringifyForTelemetry(promptMessages),\n                  },\n                  'ai.settings.mode': mode,\n\n                  // standardized gen-ai llm span attributes:\n                  'gen_ai.system': model.provider,\n                  'gen_ai.request.model': model.modelId,\n                  'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                  'gen_ai.request.max_tokens': settings.maxTokens,\n                  'gen_ai.request.presence_penalty': settings.presencePenalty,\n                  'gen_ai.request.temperature': settings.temperature,\n                  'gen_ai.request.top_k': settings.topK,\n                  'gen_ai.request.top_p': settings.topP,\n                },\n              }),\n              tracer,\n              fn: async span => {\n                const result = await model.doGenerate({\n                  mode: {\n                    type: 'object-tool',\n                    tool: {\n                      type: 'function',\n                      name: schemaName ?? 'json',\n                      description:\n                        schemaDescription ?? 'Respond with a JSON object.',\n                      parameters: outputStrategy.jsonSchema!,\n                    },\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat,\n                  prompt: promptMessages,\n                  providerMetadata: providerOptions,\n                  abortSignal,\n                  headers,\n                });\n\n                const objectText = result.toolCalls?.[0]?.args;\n\n                const responseData = {\n                  id: result.response?.id ?? generateId(),\n                  timestamp: result.response?.timestamp ?? currentDate(),\n                  modelId: result.response?.modelId ?? model.modelId,\n                };\n\n                if (objectText === undefined) {\n                  throw new NoObjectGeneratedError({\n                    message: 'No object generated: the tool was not called.',\n                    response: responseData,\n                    usage: calculateLanguageModelUsage(result.usage),\n                    finishReason: result.finishReason,\n                  });\n                }\n\n                // Add response information to the span:\n                span.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      'ai.response.finishReason': result.finishReason,\n                      'ai.response.object': { output: () => objectText },\n                      'ai.response.id': responseData.id,\n                      'ai.response.model': responseData.modelId,\n                      'ai.response.timestamp':\n                        responseData.timestamp.toISOString(),\n                      'ai.response.providerMetadata': JSON.stringify(\n                        result.providerMetadata,\n                      ),\n                      'ai.usage.promptTokens': result.usage.promptTokens,\n                      'ai.usage.completionTokens':\n                        result.usage.completionTokens,\n\n                      // standardized gen-ai llm span attributes:\n                      'gen_ai.response.finish_reasons': [result.finishReason],\n                      'gen_ai.response.id': responseData.id,\n                      'gen_ai.response.model': responseData.modelId,\n                      'gen_ai.usage.input_tokens': result.usage.promptTokens,\n                      'gen_ai.usage.output_tokens':\n                        result.usage.completionTokens,\n                    },\n                  }),\n                );\n\n                return { ...result, objectText, responseData };\n              },\n            }),\n          );\n\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          resultProviderMetadata = generateResult.providerMetadata;\n          request = generateResult.request ?? {};\n          response = generateResult.responseData;\n\n          break;\n        }\n\n        case undefined: {\n          throw new Error(\n            'Model does not have a default object generation mode.',\n          );\n        }\n\n        default: {\n          const _exhaustiveCheck: never = mode;\n          throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n        }\n      }\n\n      function processResult(result: string): RESULT {\n        const parseResult = safeParseJSON({ text: result });\n\n        if (!parseResult.success) {\n          throw new NoObjectGeneratedError({\n            message: 'No object generated: could not parse the response.',\n            cause: parseResult.error,\n            text: result,\n            response,\n            usage: calculateLanguageModelUsage(usage),\n            finishReason: finishReason,\n          });\n        }\n\n        const validationResult = outputStrategy.validateFinalResult(\n          parseResult.value,\n          {\n            text: result,\n            response,\n            usage: calculateLanguageModelUsage(usage),\n          },\n        );\n\n        if (!validationResult.success) {\n          throw new NoObjectGeneratedError({\n            message: 'No object generated: response did not match schema.',\n            cause: validationResult.error,\n            text: result,\n            response,\n            usage: calculateLanguageModelUsage(usage),\n            finishReason: finishReason,\n          });\n        }\n\n        return validationResult.value;\n      }\n\n      let object: RESULT;\n      try {\n        object = processResult(result);\n      } catch (error) {\n        if (\n          repairText != null &&\n          NoObjectGeneratedError.isInstance(error) &&\n          (JSONParseError.isInstance(error.cause) ||\n            TypeValidationError.isInstance(error.cause))\n        ) {\n          const repairedText = await repairText({\n            text: result,\n            error: error.cause,\n          });\n\n          if (repairedText === null) {\n            throw error;\n          }\n\n          object = processResult(repairedText);\n        } else {\n          throw error;\n        }\n      }\n\n      // Add response information to the span:\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.response.finishReason': finishReason,\n            'ai.response.object': {\n              output: () => JSON.stringify(object),\n            },\n\n            'ai.usage.promptTokens': usage.promptTokens,\n            'ai.usage.completionTokens': usage.completionTokens,\n          },\n        }),\n      );\n\n      return new DefaultGenerateObjectResult({\n        object,\n        finishReason,\n        usage: calculateLanguageModelUsage(usage),\n        warnings,\n        request,\n        response: {\n          ...response,\n          headers: rawResponse?.headers,\n          body: rawResponse?.body,\n        },\n        logprobs,\n        providerMetadata: resultProviderMetadata,\n      });\n    },\n  });\n}\n\nclass DefaultGenerateObjectResult<T> implements GenerateObjectResult<T> {\n  readonly object: GenerateObjectResult<T>['object'];\n  readonly finishReason: GenerateObjectResult<T>['finishReason'];\n  readonly usage: GenerateObjectResult<T>['usage'];\n  readonly warnings: GenerateObjectResult<T>['warnings'];\n  readonly logprobs: GenerateObjectResult<T>['logprobs'];\n  readonly experimental_providerMetadata: GenerateObjectResult<T>['experimental_providerMetadata'];\n  readonly providerMetadata: GenerateObjectResult<T>['providerMetadata'];\n  readonly response: GenerateObjectResult<T>['response'];\n  readonly request: GenerateObjectResult<T>['request'];\n\n  constructor(options: {\n    object: GenerateObjectResult<T>['object'];\n    finishReason: GenerateObjectResult<T>['finishReason'];\n    usage: GenerateObjectResult<T>['usage'];\n    warnings: GenerateObjectResult<T>['warnings'];\n    logprobs: GenerateObjectResult<T>['logprobs'];\n    providerMetadata: GenerateObjectResult<T>['providerMetadata'];\n    response: GenerateObjectResult<T>['response'];\n    request: GenerateObjectResult<T>['request'];\n  }) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.providerMetadata = options.providerMetadata;\n    this.experimental_providerMetadata = options.providerMetadata;\n    this.response = options.response;\n    this.request = options.request;\n    this.logprobs = options.logprobs;\n  }\n\n  toJsonResponse(init?: ResponseInit): Response {\n    return new Response(JSON.stringify(this.object), {\n      status: init?.status ?? 200,\n      headers: prepareResponseHeaders(init?.headers, {\n        contentType: 'application/json; charset=utf-8',\n      }),\n    });\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\nimport { LanguageModelResponseMetadata } from '../core/types/language-model-response-metadata';\nimport { LanguageModelUsage } from '../core/types/usage';\nimport { FinishReason } from '../core';\n\nconst name = 'AI_NoObjectGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when no object could be generated. This can have several causes:\n\n- The model failed to generate a response.\n- The model generated a response that could not be parsed.\n- The model generated a response that could not be validated against the schema.\n\nThe error contains the following properties:\n\n- `text`: The text that was generated by the model. This can be the raw text or the tool call text, depending on the model.\n */\nexport class NoObjectGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n  The text that was generated by the model. This can be the raw text or the tool call text, depending on the model.\n   */\n  readonly text: string | undefined;\n\n  /**\n  The response metadata.\n   */\n  readonly response: LanguageModelResponseMetadata | undefined;\n\n  /**\n  The usage of the model.\n   */\n  readonly usage: LanguageModelUsage | undefined;\n\n  /**\n  Reason why the model finished generating a response.\n   */\n  readonly finishReason: FinishReason | undefined;\n\n  constructor({\n    message = 'No object generated.',\n    cause,\n    text,\n    response,\n    usage,\n    finishReason,\n  }: {\n    message?: string;\n    cause?: Error;\n    text?: string;\n    response: LanguageModelResponseMetadata;\n    usage: LanguageModelUsage;\n    finishReason: FinishReason;\n  }) {\n    super({ name, message, cause });\n\n    this.text = text;\n    this.response = response;\n    this.usage = usage;\n    this.finishReason = finishReason;\n  }\n\n  static isInstance(error: unknown): error is NoObjectGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n\nexport function verifyNoObjectGeneratedError(\n  error: unknown,\n  expected: {\n    message: string;\n    response: LanguageModelResponseMetadata;\n    usage: LanguageModelUsage;\n    finishReason: FinishReason;\n  },\n) {\n  expect(NoObjectGeneratedError.isInstance(error)).toBeTruthy();\n  const noObjectGeneratedError = error as NoObjectGeneratedError;\n  expect(noObjectGeneratedError.message).toStrictEqual(expected.message);\n  expect(noObjectGeneratedError.response).toStrictEqual(expected.response);\n  expect(noObjectGeneratedError.usage).toStrictEqual(expected.usage);\n  expect(noObjectGeneratedError.finishReason).toStrictEqual(\n    expected.finishReason,\n  );\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_DownloadError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class DownloadError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly url: string;\n  readonly statusCode?: number;\n  readonly statusText?: string;\n\n  constructor({\n    url,\n    statusCode,\n    statusText,\n    cause,\n    message = cause == null\n      ? `Failed to download ${url}: ${statusCode} ${statusText}`\n      : `Failed to download ${url}: ${cause}`,\n  }: {\n    url: string;\n    statusCode?: number;\n    statusText?: string;\n    message?: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.url = url;\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n  }\n\n  static isInstance(error: unknown): error is DownloadError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { DownloadError } from './download-error';\n\nexport async function download({ url }: { url: URL }): Promise<{\n  data: Uint8Array;\n  mimeType: string | undefined;\n}> {\n  const urlText = url.toString();\n  try {\n    const response = await fetch(urlText);\n\n    if (!response.ok) {\n      throw new DownloadError({\n        url: urlText,\n        statusCode: response.status,\n        statusText: response.statusText,\n      });\n    }\n\n    return {\n      data: new Uint8Array(await response.arrayBuffer()),\n      mimeType: response.headers.get('content-type') ?? undefined,\n    };\n  } catch (error) {\n    if (DownloadError.isInstance(error)) {\n      throw error;\n    }\n\n    throw new DownloadError({ url: urlText, cause: error });\n  }\n}\n", "import {\n  convertBase64ToUint8Array,\n  convertUint8ArrayToBase64,\n} from '@ai-sdk/provider-utils';\nimport { InvalidDataContentError } from './invalid-data-content-error';\nimport { z } from 'zod';\n\n/**\nData content. Can either be a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer.\n */\nexport type DataContent = string | Uint8Array | ArrayBuffer | Buffer;\n\n/**\n@internal\n */\nexport const dataContentSchema: z.ZodType<DataContent> = z.union([\n  z.string(),\n  z.instanceof(Uint8Array),\n  z.instanceof(ArrayBuffer),\n  z.custom(\n    // Buffer might not be available in some environments such as CloudFlare:\n    (value: unknown): value is Buffer =>\n      globalThis.Buffer?.isBuffer(value) ?? false,\n    { message: 'Must be a Buffer' },\n  ),\n]);\n\n/**\nConverts data content to a base64-encoded string.\n\n@param content - Data content to convert.\n@returns Base64-encoded string.\n*/\nexport function convertDataContentToBase64String(content: DataContent): string {\n  if (typeof content === 'string') {\n    return content;\n  }\n\n  if (content instanceof ArrayBuffer) {\n    return convertUint8ArrayToBase64(new Uint8Array(content));\n  }\n\n  return convertUint8ArrayToBase64(content);\n}\n\n/**\nConverts data content to a Uint8Array.\n\n@param content - Data content to convert.\n@returns Uint8Array.\n */\nexport function convertDataContentToUint8Array(\n  content: DataContent,\n): Uint8Array {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n\n  if (typeof content === 'string') {\n    try {\n      return convertBase64ToUint8Array(content);\n    } catch (error) {\n      throw new InvalidDataContentError({\n        message:\n          'Invalid data content. Content string is not a base64-encoded media.',\n        content,\n        cause: error,\n      });\n    }\n  }\n\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n\n  throw new InvalidDataContentError({ content });\n}\n\n/**\n * Converts a Uint8Array to a string of text.\n *\n * @param uint8Array - The Uint8Array to convert.\n * @returns The converted string.\n */\nexport function convertUint8ArrayToText(uint8Array: Uint8Array): string {\n  try {\n    return new TextDecoder().decode(uint8Array);\n  } catch (error) {\n    throw new Error('Error decoding Uint8Array to text');\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidDataContentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidDataContentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly content: unknown;\n\n  constructor({\n    content,\n    cause,\n    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`,\n  }: {\n    content: unknown;\n    cause?: unknown;\n    message?: string;\n  }) {\n    super({ name, message, cause });\n\n    this.content = content;\n  }\n\n  static isInstance(error: unknown): error is InvalidDataContentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidMessageRoleError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidMessageRoleError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly role: string;\n\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`,\n  }: {\n    role: string;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.role = role;\n  }\n\n  static isInstance(error: unknown): error is InvalidMessageRoleError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "export function splitDataUrl(dataUrl: string): {\n  mimeType: string | undefined;\n  base64Content: string | undefined;\n} {\n  try {\n    const [header, base64Content] = dataUrl.split(',');\n    return {\n      mimeType: header.split(';')[0].split(':')[1],\n      base64Content,\n    };\n  } catch (error) {\n    return {\n      mimeType: undefined,\n      base64Content: undefined,\n    };\n  }\n}\n", "import {\n  LanguageModelV1FilePart,\n  LanguageModelV1ImagePart,\n  LanguageModelV1Message,\n  LanguageModelV1Prompt,\n  LanguageModelV1TextPart,\n} from '@ai-sdk/provider';\nimport { download } from '../../util/download';\nimport { CoreMessage } from '../prompt/message';\nimport {\n  detectMimeType,\n  imageMimeTypeSignatures,\n} from '../util/detect-mimetype';\nimport { FilePart, ImagePart, TextPart } from './content-part';\nimport {\n  convertDataContentToBase64String,\n  convertDataContentToUint8Array,\n  DataContent,\n} from './data-content';\nimport { InvalidMessageRoleError } from './invalid-message-role-error';\nimport { splitDataUrl } from './split-data-url';\nimport { StandardizedPrompt } from './standardize-prompt';\n\nexport async function convertToLanguageModelPrompt({\n  prompt,\n  modelSupportsImageUrls = true,\n  modelSupportsUrl = () => false,\n  downloadImplementation = download,\n}: {\n  prompt: StandardizedPrompt;\n  modelSupportsImageUrls: boolean | undefined;\n  modelSupportsUrl: undefined | ((url: URL) => boolean);\n  downloadImplementation?: typeof download;\n}): Promise<LanguageModelV1Prompt> {\n  const downloadedAssets = await downloadAssets(\n    prompt.messages,\n    downloadImplementation,\n    modelSupportsImageUrls,\n    modelSupportsUrl,\n  );\n\n  return [\n    ...(prompt.system != null\n      ? [{ role: 'system' as const, content: prompt.system }]\n      : []),\n    ...prompt.messages.map(message =>\n      convertToLanguageModelMessage(message, downloadedAssets),\n    ),\n  ];\n}\n\n/**\n * Convert a CoreMessage to a LanguageModelV1Message.\n *\n * @param message The CoreMessage to convert.\n * @param downloadedAssets A map of URLs to their downloaded data. Only\n *   available if the model does not support URLs, null otherwise.\n */\nexport function convertToLanguageModelMessage(\n  message: CoreMessage,\n  downloadedAssets: Record<\n    string,\n    { mimeType: string | undefined; data: Uint8Array }\n  >,\n): LanguageModelV1Message {\n  const role = message.role;\n  switch (role) {\n    case 'system': {\n      return {\n        role: 'system',\n        content: message.content,\n        providerMetadata:\n          message.providerOptions ?? message.experimental_providerMetadata,\n      };\n    }\n\n    case 'user': {\n      if (typeof message.content === 'string') {\n        return {\n          role: 'user',\n          content: [{ type: 'text', text: message.content }],\n          providerMetadata:\n            message.providerOptions ?? message.experimental_providerMetadata,\n        };\n      }\n\n      return {\n        role: 'user',\n        content: message.content\n          .map(part => convertPartToLanguageModelPart(part, downloadedAssets))\n          // remove empty text parts:\n          .filter(part => part.type !== 'text' || part.text !== ''),\n        providerMetadata:\n          message.providerOptions ?? message.experimental_providerMetadata,\n      };\n    }\n\n    case 'assistant': {\n      if (typeof message.content === 'string') {\n        return {\n          role: 'assistant',\n          content: [{ type: 'text', text: message.content }],\n          providerMetadata:\n            message.providerOptions ?? message.experimental_providerMetadata,\n        };\n      }\n\n      return {\n        role: 'assistant',\n        content: message.content\n          .filter(\n            // remove empty text parts:\n            part => part.type !== 'text' || part.text !== '',\n          )\n          .map(part => {\n            const providerOptions =\n              part.providerOptions ?? part.experimental_providerMetadata;\n\n            switch (part.type) {\n              case 'file': {\n                return {\n                  type: 'file',\n                  data:\n                    part.data instanceof URL\n                      ? part.data\n                      : convertDataContentToBase64String(part.data),\n                  filename: part.filename,\n                  mimeType: part.mimeType,\n                  providerMetadata: providerOptions,\n                };\n              }\n              case 'reasoning': {\n                return {\n                  type: 'reasoning',\n                  text: part.text,\n                  signature: part.signature,\n                  providerMetadata: providerOptions,\n                };\n              }\n              case 'redacted-reasoning': {\n                return {\n                  type: 'redacted-reasoning',\n                  data: part.data,\n                  providerMetadata: providerOptions,\n                };\n              }\n              case 'text': {\n                return {\n                  type: 'text' as const,\n                  text: part.text,\n                  providerMetadata: providerOptions,\n                };\n              }\n              case 'tool-call': {\n                return {\n                  type: 'tool-call' as const,\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  args: part.args,\n                  providerMetadata: providerOptions,\n                };\n              }\n            }\n          }),\n        providerMetadata:\n          message.providerOptions ?? message.experimental_providerMetadata,\n      };\n    }\n\n    case 'tool': {\n      return {\n        role: 'tool',\n        content: message.content.map(part => ({\n          type: 'tool-result',\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          result: part.result,\n          content: part.experimental_content,\n          isError: part.isError,\n          providerMetadata:\n            part.providerOptions ?? part.experimental_providerMetadata,\n        })),\n        providerMetadata:\n          message.providerOptions ?? message.experimental_providerMetadata,\n      };\n    }\n\n    default: {\n      const _exhaustiveCheck: never = role;\n      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });\n    }\n  }\n}\n\n/**\n * Downloads images and files from URLs in the messages.\n */\nasync function downloadAssets(\n  messages: CoreMessage[],\n  downloadImplementation: typeof download,\n  modelSupportsImageUrls: boolean | undefined,\n  modelSupportsUrl: (url: URL) => boolean,\n): Promise<Record<string, { mimeType: string | undefined; data: Uint8Array }>> {\n  const urls = messages\n    .filter(message => message.role === 'user')\n    .map(message => message.content)\n    .filter((content): content is Array<TextPart | ImagePart | FilePart> =>\n      Array.isArray(content),\n    )\n    .flat()\n    .filter(\n      (part): part is ImagePart | FilePart =>\n        part.type === 'image' || part.type === 'file',\n    )\n    /**\n     * Filter out image parts if the model supports image URLs, before letting it\n     * decide if it supports a particular URL.\n     */\n    .filter(\n      (part): part is ImagePart | FilePart =>\n        !(part.type === 'image' && modelSupportsImageUrls === true),\n    )\n    .map(part => (part.type === 'image' ? part.image : part.data))\n    .map(part =>\n      // support string urls:\n      typeof part === 'string' &&\n      (part.startsWith('http:') || part.startsWith('https:'))\n        ? new URL(part)\n        : part,\n    )\n    .filter((image): image is URL => image instanceof URL)\n    /**\n     * Filter out URLs that the model supports natively, so we don't download them.\n     */\n    .filter(url => !modelSupportsUrl(url));\n\n  // download in parallel:\n  const downloadedImages = await Promise.all(\n    urls.map(async url => ({\n      url,\n      data: await downloadImplementation({ url }),\n    })),\n  );\n\n  return Object.fromEntries(\n    downloadedImages.map(({ url, data }) => [url.toString(), data]),\n  );\n}\n\n/**\n * Convert part of a message to a LanguageModelV1Part.\n * @param part The part to convert.\n * @param downloadedAssets A map of URLs to their downloaded data. Only\n *  available if the model does not support URLs, null otherwise.\n *\n * @returns The converted part.\n */\nfunction convertPartToLanguageModelPart(\n  part: TextPart | ImagePart | FilePart,\n  downloadedAssets: Record<\n    string,\n    { mimeType: string | undefined; data: Uint8Array }\n  >,\n):\n  | LanguageModelV1TextPart\n  | LanguageModelV1ImagePart\n  | LanguageModelV1FilePart {\n  if (part.type === 'text') {\n    return {\n      type: 'text',\n      text: part.text,\n      providerMetadata:\n        part.providerOptions ?? part.experimental_providerMetadata,\n    };\n  }\n\n  let mimeType: string | undefined = part.mimeType;\n  let data: DataContent | URL;\n  let content: URL | ArrayBuffer | string;\n  let normalizedData: Uint8Array | URL;\n\n  const type = part.type;\n  switch (type) {\n    case 'image':\n      data = part.image;\n      break;\n    case 'file':\n      data = part.data;\n      break;\n    default:\n      throw new Error(`Unsupported part type: ${type}`);\n  }\n\n  // Attempt to create a URL from the data. If it fails, we can assume the data\n  // is not a URL and likely some other sort of data.\n  try {\n    content = typeof data === 'string' ? new URL(data) : data;\n  } catch (error) {\n    content = data;\n  }\n\n  // If we successfully created a URL, we can use that to normalize the data\n  // either by passing it through or converting normalizing the base64 content\n  // to a Uint8Array.\n  if (content instanceof URL) {\n    // If the content is a data URL, we want to convert that to a Uint8Array\n    if (content.protocol === 'data:') {\n      const { mimeType: dataUrlMimeType, base64Content } = splitDataUrl(\n        content.toString(),\n      );\n\n      if (dataUrlMimeType == null || base64Content == null) {\n        throw new Error(`Invalid data URL format in part ${type}`);\n      }\n\n      mimeType = dataUrlMimeType;\n      normalizedData = convertDataContentToUint8Array(base64Content);\n    } else {\n      /**\n       * If the content is a URL, we should first see if it was downloaded. And if not,\n       * we can let the model decide if it wants to support the URL. This also allows\n       * for non-HTTP URLs to be passed through (e.g. gs://).\n       */\n      const downloadedFile = downloadedAssets[content.toString()];\n      if (downloadedFile) {\n        normalizedData = downloadedFile.data;\n        mimeType ??= downloadedFile.mimeType;\n      } else {\n        normalizedData = content;\n      }\n    }\n  } else {\n    // Since we know now the content is not a URL, we can attempt to normalize\n    // the data assuming it is some sort of data.\n    normalizedData = convertDataContentToUint8Array(content);\n  }\n\n  // Now that we have the normalized data either as a URL or a Uint8Array,\n  // we can create the LanguageModelV1Part.\n  switch (type) {\n    case 'image': {\n      // When possible, try to detect the mimetype automatically\n      // to deal with incorrect mimetype inputs.\n      // When detection fails, use provided mimetype.\n\n      if (normalizedData instanceof Uint8Array) {\n        mimeType =\n          detectMimeType({\n            data: normalizedData,\n            signatures: imageMimeTypeSignatures,\n          }) ?? mimeType;\n      }\n      return {\n        type: 'image',\n        image: normalizedData,\n        mimeType,\n        providerMetadata:\n          part.providerOptions ?? part.experimental_providerMetadata,\n      };\n    }\n\n    case 'file': {\n      // We should have a mimeType at this point, if not, throw an error.\n      if (mimeType == null) {\n        throw new Error(`Mime type is missing for file part`);\n      }\n\n      return {\n        type: 'file',\n        data:\n          normalizedData instanceof Uint8Array\n            ? convertDataContentToBase64String(normalizedData)\n            : normalizedData,\n        filename: part.filename,\n        mimeType,\n        providerMetadata:\n          part.providerOptions ?? part.experimental_providerMetadata,\n      };\n    }\n  }\n}\n", "import { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport { CallSettings } from './call-settings';\n\n/**\n * Validates call settings and sets default values.\n */\nexport function prepareCallSettings({\n  maxTokens,\n  temperature,\n  topP,\n  topK,\n  presencePenalty,\n  frequencyPenalty,\n  stopSequences,\n  seed,\n}: Omit<CallSettings, 'abortSignal' | 'headers' | 'maxRetries'>): Omit<\n  CallSettings,\n  'abortSignal' | 'headers' | 'maxRetries'\n> {\n  if (maxTokens != null) {\n    if (!Number.isInteger(maxTokens)) {\n      throw new InvalidArgumentError({\n        parameter: 'maxTokens',\n        value: maxTokens,\n        message: 'maxTokens must be an integer',\n      });\n    }\n\n    if (maxTokens < 1) {\n      throw new InvalidArgumentError({\n        parameter: 'maxTokens',\n        value: maxTokens,\n        message: 'maxTokens must be >= 1',\n      });\n    }\n  }\n\n  if (temperature != null) {\n    if (typeof temperature !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'temperature',\n        value: temperature,\n        message: 'temperature must be a number',\n      });\n    }\n  }\n\n  if (topP != null) {\n    if (typeof topP !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'topP',\n        value: topP,\n        message: 'topP must be a number',\n      });\n    }\n  }\n\n  if (topK != null) {\n    if (typeof topK !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'topK',\n        value: topK,\n        message: 'topK must be a number',\n      });\n    }\n  }\n\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'presencePenalty',\n        value: presencePenalty,\n        message: 'presencePenalty must be a number',\n      });\n    }\n  }\n\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'frequencyPenalty',\n        value: frequencyPenalty,\n        message: 'frequencyPenalty must be a number',\n      });\n    }\n  }\n\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new InvalidArgumentError({\n        parameter: 'seed',\n        value: seed,\n        message: 'seed must be an integer',\n      });\n    }\n  }\n\n  return {\n    maxTokens,\n    // TODO v5 remove default 0 for temperature\n    temperature: temperature ?? 0,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    stopSequences:\n      stopSequences != null && stopSequences.length > 0\n        ? stopSequences\n        : undefined,\n    seed,\n  };\n}\n", "import { InvalidPromptError } from '@ai-sdk/provider';\nimport { safeValidateTypes } from '@ai-sdk/provider-utils';\nimport { Message } from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { ToolSet } from '../generate-text/tool-set';\nimport { convertToCoreMessages } from './convert-to-core-messages';\nimport { CoreMessage, coreMessageSchema } from './message';\nimport { Prompt } from './prompt';\n\nexport type StandardizedPrompt = {\n  /**\n   * Original prompt type. This is forwarded to the providers and can be used\n   * to write send raw text to providers that support it.\n   */\n  type: 'prompt' | 'messages';\n\n  /**\n   * System message.\n   */\n  system?: string;\n\n  /**\n   * Messages.\n   */\n  messages: CoreMessage[];\n};\n\nexport function standardizePrompt<TOOLS extends ToolSet>({\n  prompt,\n  tools,\n}: {\n  prompt: Prompt;\n  tools: undefined | TOOLS;\n}): StandardizedPrompt {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'prompt or messages must be defined',\n    });\n  }\n\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'prompt and messages cannot be defined at the same time',\n    });\n  }\n\n  // validate that system is a string\n  if (prompt.system != null && typeof prompt.system !== 'string') {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'system must be a string',\n    });\n  }\n\n  // type: prompt\n  if (prompt.prompt != null) {\n    // validate that prompt is a string\n    if (typeof prompt.prompt !== 'string') {\n      throw new InvalidPromptError({\n        prompt,\n        message: 'prompt must be a string',\n      });\n    }\n\n    return {\n      type: 'prompt',\n      system: prompt.system,\n      messages: [\n        {\n          role: 'user',\n          content: prompt.prompt,\n        },\n      ],\n    };\n  }\n\n  // type: messages\n  if (prompt.messages != null) {\n    const promptType = detectPromptType(prompt.messages);\n\n    const messages: CoreMessage[] =\n      promptType === 'ui-messages'\n        ? convertToCoreMessages(prompt.messages as Omit<Message, 'id'>[], {\n            tools,\n          })\n        : (prompt.messages as CoreMessage[]);\n\n    if (messages.length === 0) {\n      throw new InvalidPromptError({\n        prompt,\n        message: 'messages must not be empty',\n      });\n    }\n\n    const validationResult = safeValidateTypes({\n      value: messages,\n      schema: z.array(coreMessageSchema),\n    });\n\n    if (!validationResult.success) {\n      throw new InvalidPromptError({\n        prompt,\n        message: [\n          'message must be a CoreMessage or a UI message',\n          `Validation error: ${validationResult.error.message}`,\n        ].join('\\n'),\n        cause: validationResult.error,\n      });\n    }\n\n    return {\n      type: 'messages',\n      messages,\n      system: prompt.system,\n    };\n  }\n\n  throw new Error('unreachable');\n}\n\nfunction detectPromptType(\n  prompt: Array<any>,\n): 'ui-messages' | 'messages' | 'other' {\n  if (!Array.isArray(prompt)) {\n    throw new InvalidPromptError({\n      prompt,\n      message: [\n        'messages must be an array of CoreMessage or UIMessage',\n        `Received non-array value: ${JSON.stringify(prompt)}`,\n      ].join('\\n'),\n      cause: prompt,\n    });\n  }\n\n  if (prompt.length === 0) {\n    return 'messages';\n  }\n\n  const characteristics = prompt.map(detectSingleMessageCharacteristics);\n\n  if (characteristics.some(c => c === 'has-ui-specific-parts')) {\n    return 'ui-messages';\n  }\n\n  const nonMessageIndex = characteristics.findIndex(\n    c => c !== 'has-core-specific-parts' && c !== 'message',\n  );\n\n  if (nonMessageIndex === -1) {\n    return 'messages';\n  }\n\n  throw new InvalidPromptError({\n    prompt,\n    message: [\n      'messages must be an array of CoreMessage or UIMessage',\n      `Received message of type: \"${characteristics[nonMessageIndex]}\" at index ${nonMessageIndex}`,\n      `messages[${nonMessageIndex}]: ${JSON.stringify(prompt[nonMessageIndex])}`,\n    ].join('\\n'),\n    cause: prompt,\n  });\n}\n\nfunction detectSingleMessageCharacteristics(\n  message: any,\n): 'has-ui-specific-parts' | 'has-core-specific-parts' | 'message' | 'other' {\n  if (\n    typeof message === 'object' &&\n    message !== null &&\n    (message.role === 'function' || // UI-only role\n      message.role === 'data' || // UI-only role\n      'toolInvocations' in message || // UI-specific field\n      'parts' in message || // UI-specific field\n      'experimental_attachments' in message)\n  ) {\n    return 'has-ui-specific-parts';\n  } else if (\n    typeof message === 'object' &&\n    message !== null &&\n    'content' in message &&\n    (Array.isArray(message.content) || // Core messages can have array content\n      'experimental_providerMetadata' in message ||\n      'providerOptions' in message)\n  ) {\n    return 'has-core-specific-parts';\n  } else if (\n    typeof message === 'object' &&\n    message !== null &&\n    'role' in message &&\n    'content' in message &&\n    typeof message.content === 'string' &&\n    ['system', 'user', 'assistant', 'tool'].includes(message.role)\n  ) {\n    return 'message';\n  } else {\n    return 'other';\n  }\n}\n", "import { Attachment } from '@ai-sdk/ui-utils';\nimport { FilePart, ImagePart, TextPart } from './content-part';\nimport {\n  convertDataContentToUint8Array,\n  convertUint8ArrayToText,\n} from './data-content';\n\ntype ContentPart = TextPart | ImagePart | FilePart;\n\n/**\n * Converts a list of attachments to a list of content parts\n * for consumption by `ai/core` functions.\n * Currently only supports images and text attachments.\n */\nexport function attachmentsToParts(attachments: Attachment[]): ContentPart[] {\n  const parts: ContentPart[] = [];\n\n  for (const attachment of attachments) {\n    let url;\n\n    try {\n      url = new URL(attachment.url);\n    } catch (error) {\n      throw new Error(`Invalid URL: ${attachment.url}`);\n    }\n\n    switch (url.protocol) {\n      case 'http:':\n      case 'https:': {\n        if (attachment.contentType?.startsWith('image/')) {\n          parts.push({ type: 'image', image: url });\n        } else {\n          if (!attachment.contentType) {\n            throw new Error(\n              'If the attachment is not an image, it must specify a content type',\n            );\n          }\n\n          parts.push({\n            type: 'file',\n            data: url,\n            mimeType: attachment.contentType,\n          });\n        }\n        break;\n      }\n\n      case 'data:': {\n        let header;\n        let base64Content;\n        let mimeType;\n\n        try {\n          [header, base64Content] = attachment.url.split(',');\n          mimeType = header.split(';')[0].split(':')[1];\n        } catch (error) {\n          throw new Error(`Error processing data URL: ${attachment.url}`);\n        }\n\n        if (mimeType == null || base64Content == null) {\n          throw new Error(`Invalid data URL format: ${attachment.url}`);\n        }\n\n        if (attachment.contentType?.startsWith('image/')) {\n          parts.push({\n            type: 'image',\n            image: convertDataContentToUint8Array(base64Content),\n          });\n        } else if (attachment.contentType?.startsWith('text/')) {\n          parts.push({\n            type: 'text',\n            text: convertUint8ArrayToText(\n              convertDataContentToUint8Array(base64Content),\n            ),\n          });\n        } else {\n          if (!attachment.contentType) {\n            throw new Error(\n              'If the attachment is not an image or text, it must specify a content type',\n            );\n          }\n\n          parts.push({\n            type: 'file',\n            data: base64Content,\n            mimeType: attachment.contentType,\n          });\n        }\n\n        break;\n      }\n\n      default: {\n        throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n      }\n    }\n  }\n\n  return parts;\n}\n", "import { AISDKError } from '@ai-sdk/provider';\nimport { Message } from '@ai-sdk/ui-utils';\n\nconst name = 'AI_MessageConversionError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class MessageConversionError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly originalMessage: Omit<Message, 'id'>;\n\n  constructor({\n    originalMessage,\n    message,\n  }: {\n    originalMessage: Omit<Message, 'id'>;\n    message: string;\n  }) {\n    super({ name, message });\n\n    this.originalMessage = originalMessage;\n  }\n\n  static isInstance(error: unknown): error is MessageConversionError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import {\n  FileUIPart,\n  Message,\n  ReasoningUIPart,\n  TextUIPart,\n  ToolInvocationUIPart,\n} from '@ai-sdk/ui-utils';\nimport { ToolSet } from '../generate-text/tool-set';\nimport {\n  AssistantContent,\n  CoreMessage,\n  ToolCallPart,\n  ToolResultPart,\n} from '../prompt';\nimport { attachmentsToParts } from './attachments-to-parts';\nimport { MessageConversionError } from './message-conversion-error';\n\n/**\nConverts an array of messages from useChat into an array of CoreMessages that can be used\nwith the AI core functions (e.g. `streamText`).\n */\nexport function convertToCoreMessages<TOOLS extends ToolSet = never>(\n  messages: Array<Omit<Message, 'id'>>,\n  options?: { tools?: TOOLS },\n) {\n  const tools = options?.tools ?? ({} as TOOLS);\n  const coreMessages: CoreMessage[] = [];\n\n  for (let i = 0; i < messages.length; i++) {\n    const message = messages[i];\n    const isLastMessage = i === messages.length - 1;\n    const { role, content, experimental_attachments } = message;\n\n    switch (role) {\n      case 'system': {\n        coreMessages.push({\n          role: 'system',\n          content,\n        });\n        break;\n      }\n\n      case 'user': {\n        if (message.parts == null) {\n          coreMessages.push({\n            role: 'user',\n            content: experimental_attachments\n              ? [\n                  { type: 'text', text: content },\n                  ...attachmentsToParts(experimental_attachments),\n                ]\n              : content,\n          });\n        } else {\n          const textParts = message.parts\n            .filter(part => part.type === 'text')\n            .map(part => ({\n              type: 'text' as const,\n              text: part.text,\n            }));\n\n          coreMessages.push({\n            role: 'user',\n            content: experimental_attachments\n              ? [...textParts, ...attachmentsToParts(experimental_attachments)]\n              : textParts,\n          });\n        }\n        break;\n      }\n\n      case 'assistant': {\n        if (message.parts != null) {\n          let currentStep = 0;\n          let blockHasToolInvocations = false;\n          let block: Array<\n            TextUIPart | ToolInvocationUIPart | ReasoningUIPart | FileUIPart\n          > = [];\n\n          function processBlock() {\n            const content: AssistantContent = [];\n\n            for (const part of block) {\n              switch (part.type) {\n                case 'file':\n                case 'text': {\n                  content.push(part);\n                  break;\n                }\n                case 'reasoning': {\n                  for (const detail of part.details) {\n                    switch (detail.type) {\n                      case 'text':\n                        content.push({\n                          type: 'reasoning' as const,\n                          text: detail.text,\n                          signature: detail.signature,\n                        });\n                        break;\n                      case 'redacted':\n                        content.push({\n                          type: 'redacted-reasoning' as const,\n                          data: detail.data,\n                        });\n                        break;\n                    }\n                  }\n                  break;\n                }\n                case 'tool-invocation':\n                  content.push({\n                    type: 'tool-call' as const,\n                    toolCallId: part.toolInvocation.toolCallId,\n                    toolName: part.toolInvocation.toolName,\n                    args: part.toolInvocation.args,\n                  });\n                  break;\n                default: {\n                  const _exhaustiveCheck: never = part;\n                  throw new Error(`Unsupported part: ${_exhaustiveCheck}`);\n                }\n              }\n            }\n\n            coreMessages.push({\n              role: 'assistant',\n              content,\n            });\n\n            // check if there are tool invocations with results in the block\n            const stepInvocations = block\n              .filter(\n                (\n                  part:\n                    | TextUIPart\n                    | ToolInvocationUIPart\n                    | ReasoningUIPart\n                    | FileUIPart,\n                ): part is ToolInvocationUIPart =>\n                  part.type === 'tool-invocation',\n              )\n              .map(part => part.toolInvocation);\n\n            // tool message with tool results\n            if (stepInvocations.length > 0) {\n              coreMessages.push({\n                role: 'tool',\n                content: stepInvocations.map(\n                  (toolInvocation): ToolResultPart => {\n                    if (!('result' in toolInvocation)) {\n                      throw new MessageConversionError({\n                        originalMessage: message,\n                        message:\n                          'ToolInvocation must have a result: ' +\n                          JSON.stringify(toolInvocation),\n                      });\n                    }\n\n                    const { toolCallId, toolName, result } = toolInvocation;\n\n                    const tool = tools[toolName];\n                    return tool?.experimental_toToolResultContent != null\n                      ? {\n                          type: 'tool-result',\n                          toolCallId,\n                          toolName,\n                          result: tool.experimental_toToolResultContent(result),\n                          experimental_content:\n                            tool.experimental_toToolResultContent(result),\n                        }\n                      : {\n                          type: 'tool-result',\n                          toolCallId,\n                          toolName,\n                          result,\n                        };\n                  },\n                ),\n              });\n            }\n\n            // updates for next block\n            block = [];\n            blockHasToolInvocations = false;\n            currentStep++;\n          }\n\n          for (const part of message.parts) {\n            switch (part.type) {\n              case 'text': {\n                if (blockHasToolInvocations) {\n                  processBlock(); // text must come before tool invocations\n                }\n                block.push(part);\n                break;\n              }\n              case 'file':\n              case 'reasoning': {\n                block.push(part);\n                break;\n              }\n              case 'tool-invocation': {\n                if ((part.toolInvocation.step ?? 0) !== currentStep) {\n                  processBlock();\n                }\n                block.push(part);\n                blockHasToolInvocations = true;\n                break;\n              }\n            }\n          }\n\n          processBlock();\n\n          break;\n        }\n\n        const toolInvocations = message.toolInvocations;\n\n        if (toolInvocations == null || toolInvocations.length === 0) {\n          coreMessages.push({ role: 'assistant', content });\n          break;\n        }\n\n        const maxStep = toolInvocations.reduce((max, toolInvocation) => {\n          return Math.max(max, toolInvocation.step ?? 0);\n        }, 0);\n\n        for (let i = 0; i <= maxStep; i++) {\n          const stepInvocations = toolInvocations.filter(\n            toolInvocation => (toolInvocation.step ?? 0) === i,\n          );\n\n          if (stepInvocations.length === 0) {\n            continue;\n          }\n\n          // assistant message with tool calls\n          coreMessages.push({\n            role: 'assistant',\n            content: [\n              ...(isLastMessage && content && i === 0\n                ? [{ type: 'text' as const, text: content }]\n                : []),\n              ...stepInvocations.map(\n                ({ toolCallId, toolName, args }): ToolCallPart => ({\n                  type: 'tool-call' as const,\n                  toolCallId,\n                  toolName,\n                  args,\n                }),\n              ),\n            ],\n          });\n\n          // tool message with tool results\n          coreMessages.push({\n            role: 'tool',\n            content: stepInvocations.map((toolInvocation): ToolResultPart => {\n              if (!('result' in toolInvocation)) {\n                throw new MessageConversionError({\n                  originalMessage: message,\n                  message:\n                    'ToolInvocation must have a result: ' +\n                    JSON.stringify(toolInvocation),\n                });\n              }\n\n              const { toolCallId, toolName, result } = toolInvocation;\n\n              const tool = tools[toolName];\n              return tool?.experimental_toToolResultContent != null\n                ? {\n                    type: 'tool-result',\n                    toolCallId,\n                    toolName,\n                    result: tool.experimental_toToolResultContent(result),\n                    experimental_content:\n                      tool.experimental_toToolResultContent(result),\n                  }\n                : {\n                    type: 'tool-result',\n                    toolCallId,\n                    toolName,\n                    result,\n                  };\n            }),\n          });\n        }\n\n        if (content && !isLastMessage) {\n          coreMessages.push({ role: 'assistant', content });\n        }\n\n        break;\n      }\n\n      case 'data': {\n        // ignore\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new MessageConversionError({\n          originalMessage: message,\n          message: `Unsupported role: ${_exhaustiveCheck}`,\n        });\n      }\n    }\n  }\n\n  return coreMessages;\n}\n", "import { z } from 'zod';\nimport { ProviderMetadata } from '../types';\nimport {\n  providerMetadataSchema,\n  ProviderOptions,\n} from '../types/provider-metadata';\nimport {\n  FilePart,\n  filePartSchema,\n  ImagePart,\n  imagePartSchema,\n  ReasoningPart,\n  reasoningPartSchema,\n  RedactedReasoningPart,\n  redactedReasoningPartSchema,\n  TextPart,\n  textPartSchema,\n  ToolCallPart,\n  toolCallPartSchema,\n  ToolResultPart,\n  toolResultPartSchema,\n} from './content-part';\n\n/**\n A system message. It can contain system information.\n\n Note: using the \"system\" part of the prompt is strongly preferred\n to increase the resilience against prompt injection attacks,\n and because not all providers support several system messages.\n */\nexport type CoreSystemMessage = {\n  role: 'system';\n  content: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreSystemMessageSchema: z.ZodType<CoreSystemMessage> = z.object({\n  role: z.literal('system'),\n  content: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nA user message. It can contain text or a combination of text and images.\n */\nexport type CoreUserMessage = {\n  role: 'user';\n  content: UserContent;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n*/\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreUserMessageSchema: z.ZodType<CoreUserMessage> = z.object({\n  role: z.literal('user'),\n  content: z.union([\n    z.string(),\n    z.array(z.union([textPartSchema, imagePartSchema, filePartSchema])),\n  ]),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nContent of a user message. It can be a string or an array of text and image parts.\n */\nexport type UserContent = string | Array<TextPart | ImagePart | FilePart>;\n\n/**\nAn assistant message. It can contain text, tool calls, or a combination of text and tool calls.\n */\nexport type CoreAssistantMessage = {\n  role: 'assistant';\n  content: AssistantContent;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n*/\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreAssistantMessageSchema: z.ZodType<CoreAssistantMessage> =\n  z.object({\n    role: z.literal('assistant'),\n    content: z.union([\n      z.string(),\n      z.array(\n        z.union([\n          textPartSchema,\n          filePartSchema,\n          reasoningPartSchema,\n          redactedReasoningPartSchema,\n          toolCallPartSchema,\n        ]),\n      ),\n    ]),\n    providerOptions: providerMetadataSchema.optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional(),\n  });\n\n/**\nContent of an assistant message.\nIt can be a string or an array of text, image, reasoning, redacted reasoning, and tool call parts.\n */\nexport type AssistantContent =\n  | string\n  | Array<\n      TextPart | FilePart | ReasoningPart | RedactedReasoningPart | ToolCallPart\n    >;\n\n/**\nA tool message. It contains the result of one or more tool calls.\n */\nexport type CoreToolMessage = {\n  role: 'tool';\n  content: ToolContent;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n*/\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreToolMessageSchema: z.ZodType<CoreToolMessage> = z.object({\n  role: z.literal('tool'),\n  content: z.array(toolResultPartSchema),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nContent of a tool message. It is an array of tool result parts.\n */\nexport type ToolContent = Array<ToolResultPart>;\n\n/**\nA message that can be used in the `messages` field of a prompt.\nIt can be a user message, an assistant message, or a tool message.\n */\nexport type CoreMessage =\n  | CoreSystemMessage\n  | CoreUserMessage\n  | CoreAssistantMessage\n  | CoreToolMessage;\n\nexport const coreMessageSchema: z.ZodType<CoreMessage> = z.union([\n  coreSystemMessageSchema,\n  coreUserMessageSchema,\n  coreAssistantMessageSchema,\n  coreToolMessageSchema,\n]);\n", "import { LanguageModelV1ProviderMetadata } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { jsonValueSchema } from './json-value';\n\n/**\nAdditional provider-specific metadata that is returned from the provider.\n\nThis is needed to enable provider-specific functionality that can be\nfully encapsulated in the provider.\n */\nexport type ProviderMetadata = LanguageModelV1ProviderMetadata;\n\n/**\nAdditional provider-specific options.\n\nThey are passed through to the provider from the AI SDK and enable\nprovider-specific functionality that can be fully encapsulated in the provider.\n */\n// TODO change to LanguageModelV2ProviderOptions in language model v2\nexport type ProviderOptions = LanguageModelV1ProviderMetadata;\n\nexport const providerMetadataSchema: z.ZodType<ProviderMetadata> = z.record(\n  z.string(),\n  z.record(z.string(), jsonValueSchema),\n);\n", "import { JSONValue } from '@ai-sdk/provider';\nimport { z } from 'zod';\n\nexport const jsonValueSchema: z.ZodType<JSONValue> = z.lazy(() =>\n  z.union([\n    z.null(),\n    z.string(),\n    z.number(),\n    z.boolean(),\n    z.record(z.string(), jsonValueSchema),\n    z.array(jsonValueSchema),\n  ]),\n);\n", "import { z } from 'zod';\nimport {\n  ProviderMetadata,\n  providerMetadataSchema,\n  ProviderOptions,\n} from '../types/provider-metadata';\nimport { DataContent, dataContentSchema } from './data-content';\nimport {\n  ToolResultContent,\n  toolResultContentSchema,\n} from './tool-result-content';\n\n/**\nText content part of a prompt. It contains a string of text.\n */\nexport interface TextPart {\n  type: 'text';\n\n  /**\nThe text content.\n   */\n  text: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const textPartSchema: z.ZodType<TextPart> = z.object({\n  type: z.literal('text'),\n  text: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nImage content part of a prompt. It contains an image.\n */\nexport interface ImagePart {\n  type: 'image';\n\n  /**\nImage data. Can either be:\n\n- data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer\n- URL: a URL that points to the image\n   */\n  image: DataContent | URL;\n\n  /**\nOptional mime type of the image.\n   */\n  mimeType?: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const imagePartSchema: z.ZodType<ImagePart> = z.object({\n  type: z.literal('image'),\n  image: z.union([dataContentSchema, z.instanceof(URL)]),\n  mimeType: z.string().optional(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nFile content part of a prompt. It contains a file.\n */\nexport interface FilePart {\n  type: 'file';\n\n  /**\nFile data. Can either be:\n\n- data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer\n- URL: a URL that points to the image\n   */\n  data: DataContent | URL;\n\n  /**\nOptional filename of the file.\n   */\n  filename?: string;\n\n  /**\nMime type of the file.\n   */\n  mimeType: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const filePartSchema: z.ZodType<FilePart> = z.object({\n  type: z.literal('file'),\n  data: z.union([dataContentSchema, z.instanceof(URL)]),\n  filename: z.string().optional(),\n  mimeType: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\n * Reasoning content part of a prompt. It contains a reasoning.\n */\nexport interface ReasoningPart {\n  type: 'reasoning';\n\n  /**\nThe reasoning text.\n   */\n  text: string;\n\n  /**\nAn optional signature for verifying that the reasoning originated from the model.\n   */\n  signature?: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const reasoningPartSchema: z.ZodType<ReasoningPart> = z.object({\n  type: z.literal('reasoning'),\n  text: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nRedacted reasoning content part of a prompt.\n */\nexport interface RedactedReasoningPart {\n  type: 'redacted-reasoning';\n\n  /**\nRedacted reasoning data.\n   */\n  data: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const redactedReasoningPartSchema: z.ZodType<RedactedReasoningPart> =\n  z.object({\n    type: z.literal('redacted-reasoning'),\n    data: z.string(),\n    providerOptions: providerMetadataSchema.optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional(),\n  });\n\n/**\nTool call content part of a prompt. It contains a tool call (usually generated by the AI model).\n */\nexport interface ToolCallPart {\n  type: 'tool-call';\n\n  /**\nID of the tool call. This ID is used to match the tool call with the tool result.\n */\n  toolCallId: string;\n\n  /**\nName of the tool that is being called.\n */\n  toolName: string;\n\n  /**\nArguments of the tool call. This is a JSON-serializable object that matches the tool's input schema.\n   */\n  args: unknown;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const toolCallPartSchema: z.ZodType<ToolCallPart> = z.object({\n  type: z.literal('tool-call'),\n  toolCallId: z.string(),\n  toolName: z.string(),\n  args: z.unknown(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n}) as z.ZodType<ToolCallPart>; // necessary bc args is optional on Zod type\n\n/**\nTool result content part of a prompt. It contains the result of the tool call with the matching ID.\n */\nexport interface ToolResultPart {\n  type: 'tool-result';\n\n  /**\nID of the tool call that this result is associated with.\n */\n  toolCallId: string;\n\n  /**\nName of the tool that generated this result.\n  */\n  toolName: string;\n\n  /**\nResult of the tool call. This is a JSON-serializable object.\n   */\n  result: unknown;\n\n  /**\nMulti-part content of the tool result. Only for tools that support multipart results.\n   */\n  experimental_content?: ToolResultContent;\n\n  /**\nOptional flag if the result is an error or an error message.\n   */\n  isError?: boolean;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const toolResultPartSchema: z.ZodType<ToolResultPart> = z.object({\n  type: z.literal('tool-result'),\n  toolCallId: z.string(),\n  toolName: z.string(),\n  result: z.unknown(),\n  content: toolResultContentSchema.optional(),\n  isError: z.boolean().optional(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n}) as z.ZodType<ToolResultPart>; // necessary bc result is optional on Zod type\n", "import { z } from 'zod';\n\nexport type ToolResultContent = Array<\n  | {\n      type: 'text';\n      text: string;\n    }\n  | {\n      type: 'image';\n      data: string; // base64 encoded png image, e.g. screenshot\n      mimeType?: string; // e.g. 'image/png';\n    }\n>;\n\nexport const toolResultContentSchema: z.ZodType<ToolResultContent> = z.array(\n  z.union([\n    z.object({ type: z.literal('text'), text: z.string() }),\n    z.object({\n      type: z.literal('image'),\n      data: z.string(),\n      mimeType: z.string().optional(),\n    }),\n  ]),\n);\n\nexport function isToolResultContent(\n  value: unknown,\n): value is ToolResultContent {\n  if (!Array.isArray(value) || value.length === 0) {\n    return false;\n  }\n\n  return value.every(part => {\n    if (typeof part !== 'object' || part === null) {\n      return false;\n    }\n\n    if (part.type === 'text') {\n      return typeof part.text === 'string';\n    }\n\n    if (part.type === 'image') {\n      return (\n        typeof part.data === 'string' &&\n        (part.mimeType === undefined || typeof part.mimeType === 'string')\n      );\n    }\n\n    return false;\n  });\n}\n", "/**\nRepresents the number of tokens used in a prompt and completion.\n */\nexport type LanguageModelUsage = {\n  /**\nThe number of tokens used in the prompt.\n   */\n  promptTokens: number;\n\n  /**\nThe number of tokens used in the completion.\n */\n  completionTokens: number;\n\n  /**\nThe total number of tokens used (promptTokens + completionTokens).\n   */\n  totalTokens: number;\n};\n\n/**\nRepresents the number of tokens used in an embedding.\n */\nexport type EmbeddingModelUsage = {\n  /**\nThe number of tokens used in the embedding.\n   */\n  tokens: number;\n};\n\nexport function calculateLanguageModelUsage({\n  promptTokens,\n  completionTokens,\n}: {\n  promptTokens: number;\n  completionTokens: number;\n}): LanguageModelUsage {\n  return {\n    promptTokens,\n    completionTokens,\n    totalTokens: promptTokens + completionTokens,\n  };\n}\n\nexport function addLanguageModelUsage(\n  usage1: LanguageModelUsage,\n  usage2: LanguageModelUsage,\n): LanguageModelUsage {\n  return {\n    promptTokens: usage1.promptTokens + usage2.promptTokens,\n    completionTokens: usage1.completionTokens + usage2.completionTokens,\n    totalTokens: usage1.totalTokens + usage2.totalTokens,\n  };\n}\n", "import { JSONSchema7 } from '@ai-sdk/provider';\n\nconst DEFAULT_SCHEMA_PREFIX = 'JSON schema:';\nconst DEFAULT_SCHEMA_SUFFIX =\n  'You MUST answer with a JSON object that matches the JSON schema above.';\nconst DEFAULT_GENERIC_SUFFIX = 'You MUST answer with JSON.';\n\nexport function injectJsonInstruction({\n  prompt,\n  schema,\n  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : undefined,\n  schemaSuffix = schema != null\n    ? DEFAULT_SCHEMA_SUFFIX\n    : DEFAULT_GENERIC_SUFFIX,\n}: {\n  prompt?: string;\n  schema?: JSONSchema7;\n  schemaPrefix?: string;\n  schemaSuffix?: string;\n}): string {\n  return [\n    prompt != null && prompt.length > 0 ? prompt : undefined,\n    prompt != null && prompt.length > 0 ? '' : undefined, // add a newline if prompt is not null\n    schemaPrefix,\n    schema != null ? JSON.stringify(schema) : undefined,\n    schemaSuffix,\n  ]\n    .filter(line => line != null)\n    .join('\\n');\n}\n", "import {\n  isJSONArray,\n  isJSONObject,\n  JSONObject,\n  JSONSchema7,\n  JSONValue,\n  TypeValidationError,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { safeValidateTypes, ValidationResult } from '@ai-sdk/provider-utils';\nimport { asSchema, DeepPartial, Schema } from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { NoObjectGeneratedError } from '../../errors/no-object-generated-error';\nimport {\n  AsyncIterableStream,\n  createAsyncIterableStream,\n} from '../util/async-iterable-stream';\nimport { ObjectStreamPart } from './stream-object-result';\nimport {\n  FinishReason,\n  LanguageModelResponseMetadata,\n  LanguageModelUsage,\n} from '../types';\n\nexport interface OutputStrategy<PARTIAL, RESULT, ELEMENT_STREAM> {\n  readonly type: 'object' | 'array' | 'enum' | 'no-schema';\n  readonly jsonSchema: JSONSchema7 | undefined;\n\n  validatePartialResult({\n    value,\n    textDelta,\n    isFinalDelta,\n  }: {\n    value: JSONValue;\n    textDelta: string;\n    isFirstDelta: boolean;\n    isFinalDelta: boolean;\n    latestObject: PARTIAL | undefined;\n  }): ValidationResult<{\n    partial: PARTIAL;\n    textDelta: string;\n  }>;\n  validateFinalResult(\n    value: JSONValue | undefined,\n    context: {\n      text: string;\n      response: LanguageModelResponseMetadata;\n      usage: LanguageModelUsage;\n    },\n  ): ValidationResult<RESULT>;\n\n  createElementStream(\n    originalStream: ReadableStream<ObjectStreamPart<PARTIAL>>,\n  ): ELEMENT_STREAM;\n}\n\nconst noSchemaOutputStrategy: OutputStrategy<JSONValue, JSONValue, never> = {\n  type: 'no-schema',\n  jsonSchema: undefined,\n\n  validatePartialResult({ value, textDelta }) {\n    return { success: true, value: { partial: value, textDelta } };\n  },\n\n  validateFinalResult(\n    value: JSONValue | undefined,\n    context: {\n      text: string;\n      response: LanguageModelResponseMetadata;\n      usage: LanguageModelUsage;\n      finishReason: FinishReason;\n    },\n  ): ValidationResult<JSONValue> {\n    return value === undefined\n      ? {\n          success: false,\n          error: new NoObjectGeneratedError({\n            message: 'No object generated: response did not match schema.',\n            text: context.text,\n            response: context.response,\n            usage: context.usage,\n            finishReason: context.finishReason,\n          }),\n        }\n      : { success: true, value };\n  },\n\n  createElementStream() {\n    throw new UnsupportedFunctionalityError({\n      functionality: 'element streams in no-schema mode',\n    });\n  },\n};\n\nconst objectOutputStrategy = <OBJECT>(\n  schema: Schema<OBJECT>,\n): OutputStrategy<DeepPartial<OBJECT>, OBJECT, never> => ({\n  type: 'object',\n  jsonSchema: schema.jsonSchema,\n\n  validatePartialResult({ value, textDelta }) {\n    return {\n      success: true,\n      value: {\n        // Note: currently no validation of partial results:\n        partial: value as DeepPartial<OBJECT>,\n        textDelta,\n      },\n    };\n  },\n\n  validateFinalResult(value: JSONValue | undefined): ValidationResult<OBJECT> {\n    return safeValidateTypes({ value, schema });\n  },\n\n  createElementStream() {\n    throw new UnsupportedFunctionalityError({\n      functionality: 'element streams in object mode',\n    });\n  },\n});\n\nconst arrayOutputStrategy = <ELEMENT>(\n  schema: Schema<ELEMENT>,\n): OutputStrategy<ELEMENT[], ELEMENT[], AsyncIterableStream<ELEMENT>> => {\n  // remove $schema from schema.jsonSchema:\n  const { $schema, ...itemSchema } = schema.jsonSchema;\n\n  return {\n    type: 'enum',\n\n    // wrap in object that contains array of elements, since most LLMs will not\n    // be able to generate an array directly:\n    // possible future optimization: use arrays directly when model supports grammar-guided generation\n    jsonSchema: {\n      $schema: 'http://json-schema.org/draft-07/schema#',\n      type: 'object',\n      properties: {\n        elements: { type: 'array', items: itemSchema },\n      },\n      required: ['elements'],\n      additionalProperties: false,\n    },\n\n    validatePartialResult({ value, latestObject, isFirstDelta, isFinalDelta }) {\n      // check that the value is an object that contains an array of elements:\n      if (!isJSONObject(value) || !isJSONArray(value.elements)) {\n        return {\n          success: false,\n          error: new TypeValidationError({\n            value,\n            cause: 'value must be an object that contains an array of elements',\n          }),\n        };\n      }\n\n      const inputArray = value.elements as Array<JSONObject>;\n      const resultArray: Array<ELEMENT> = [];\n\n      for (let i = 0; i < inputArray.length; i++) {\n        const element = inputArray[i];\n        const result = safeValidateTypes({ value: element, schema });\n\n        // special treatment for last processed element:\n        // ignore parse or validation failures, since they indicate that the\n        // last element is incomplete and should not be included in the result,\n        // unless it is the final delta\n        if (i === inputArray.length - 1 && !isFinalDelta) {\n          continue;\n        }\n\n        if (!result.success) {\n          return result;\n        }\n\n        resultArray.push(result.value);\n      }\n\n      // calculate delta:\n      const publishedElementCount = latestObject?.length ?? 0;\n\n      let textDelta = '';\n\n      if (isFirstDelta) {\n        textDelta += '[';\n      }\n\n      if (publishedElementCount > 0) {\n        textDelta += ',';\n      }\n\n      textDelta += resultArray\n        .slice(publishedElementCount) // only new elements\n        .map(element => JSON.stringify(element))\n        .join(',');\n\n      if (isFinalDelta) {\n        textDelta += ']';\n      }\n\n      return {\n        success: true,\n        value: {\n          partial: resultArray,\n          textDelta,\n        },\n      };\n    },\n\n    validateFinalResult(\n      value: JSONValue | undefined,\n    ): ValidationResult<Array<ELEMENT>> {\n      // check that the value is an object that contains an array of elements:\n      if (!isJSONObject(value) || !isJSONArray(value.elements)) {\n        return {\n          success: false,\n          error: new TypeValidationError({\n            value,\n            cause: 'value must be an object that contains an array of elements',\n          }),\n        };\n      }\n\n      const inputArray = value.elements as Array<JSONObject>;\n\n      // check that each element in the array is of the correct type:\n      for (const element of inputArray) {\n        const result = safeValidateTypes({ value: element, schema });\n        if (!result.success) {\n          return result;\n        }\n      }\n\n      return { success: true, value: inputArray as Array<ELEMENT> };\n    },\n\n    createElementStream(\n      originalStream: ReadableStream<ObjectStreamPart<ELEMENT[]>>,\n    ) {\n      let publishedElements = 0;\n\n      return createAsyncIterableStream(\n        originalStream.pipeThrough(\n          new TransformStream<ObjectStreamPart<ELEMENT[]>, ELEMENT>({\n            transform(chunk, controller) {\n              switch (chunk.type) {\n                case 'object': {\n                  const array = chunk.object;\n\n                  // publish new elements one by one:\n                  for (\n                    ;\n                    publishedElements < array.length;\n                    publishedElements++\n                  ) {\n                    controller.enqueue(array[publishedElements]);\n                  }\n\n                  break;\n                }\n\n                case 'text-delta':\n                case 'finish':\n                case 'error': // suppress error (use onError instead)\n                  break;\n\n                default: {\n                  const _exhaustiveCheck: never = chunk;\n                  throw new Error(\n                    `Unsupported chunk type: ${_exhaustiveCheck}`,\n                  );\n                }\n              }\n            },\n          }),\n        ),\n      );\n    },\n  };\n};\n\nconst enumOutputStrategy = <ENUM extends string>(\n  enumValues: Array<ENUM>,\n): OutputStrategy<ENUM, ENUM, never> => {\n  return {\n    type: 'enum',\n\n    // wrap in object that contains result, since most LLMs will not\n    // be able to generate an enum value directly:\n    // possible future optimization: use enums directly when model supports top-level enums\n    jsonSchema: {\n      $schema: 'http://json-schema.org/draft-07/schema#',\n      type: 'object',\n      properties: {\n        result: { type: 'string', enum: enumValues },\n      },\n      required: ['result'],\n      additionalProperties: false,\n    },\n\n    validateFinalResult(value: JSONValue | undefined): ValidationResult<ENUM> {\n      // check that the value is an object that contains an array of elements:\n      if (!isJSONObject(value) || typeof value.result !== 'string') {\n        return {\n          success: false,\n          error: new TypeValidationError({\n            value,\n            cause:\n              'value must be an object that contains a string in the \"result\" property.',\n          }),\n        };\n      }\n\n      const result = value.result as string;\n\n      return enumValues.includes(result as ENUM)\n        ? { success: true, value: result as ENUM }\n        : {\n            success: false,\n            error: new TypeValidationError({\n              value,\n              cause: 'value must be a string in the enum',\n            }),\n          };\n    },\n\n    validatePartialResult() {\n      // no streaming in enum mode\n      throw new UnsupportedFunctionalityError({\n        functionality: 'partial results in enum mode',\n      });\n    },\n\n    createElementStream() {\n      // no streaming in enum mode\n      throw new UnsupportedFunctionalityError({\n        functionality: 'element streams in enum mode',\n      });\n    },\n  };\n};\n\nexport function getOutputStrategy<SCHEMA>({\n  output,\n  schema,\n  enumValues,\n}: {\n  output: 'object' | 'array' | 'enum' | 'no-schema';\n  schema?: z.Schema<SCHEMA, z.ZodTypeDef, any> | Schema<SCHEMA>;\n  enumValues?: Array<SCHEMA>;\n}): OutputStrategy<any, any, any> {\n  switch (output) {\n    case 'object':\n      return objectOutputStrategy(asSchema(schema!));\n    case 'array':\n      return arrayOutputStrategy(asSchema(schema!));\n    case 'enum':\n      return enumOutputStrategy(enumValues! as Array<string>);\n    case 'no-schema':\n      return noSchemaOutputStrategy;\n    default: {\n      const _exhaustiveCheck: never = output;\n      throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n    }\n  }\n}\n", "export type AsyncIterableStream<T> = AsyncIterable<T> & ReadableStream<T>;\n\nexport function createAsyncIterableStream<T>(\n  source: ReadableStream<T>,\n): AsyncIterableStream<T> {\n  const stream = source.pipeThrough(new TransformStream<T, T>());\n\n  (stream as AsyncIterableStream<T>)[Symbol.asyncIterator] = () => {\n    const reader = stream.getReader();\n    return {\n      async next(): Promise<IteratorResult<T>> {\n        const { done, value } = await reader.read();\n        return done ? { done: true, value: undefined } : { done: false, value };\n      },\n    };\n  };\n\n  return stream as AsyncIterableStream<T>;\n}\n", "import { z } from 'zod';\nimport { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport { Schema } from '@ai-sdk/ui-utils';\n\nexport function validateObjectGenerationInput({\n  output,\n  mode,\n  schema,\n  schemaName,\n  schemaDescription,\n  enumValues,\n}: {\n  output?: 'object' | 'array' | 'enum' | 'no-schema';\n  schema?: z.Schema<any, z.ZodTypeDef, any> | Schema<any>;\n  schemaName?: string;\n  schemaDescription?: string;\n  enumValues?: Array<unknown>;\n  mode?: 'auto' | 'json' | 'tool';\n}) {\n  if (\n    output != null &&\n    output !== 'object' &&\n    output !== 'array' &&\n    output !== 'enum' &&\n    output !== 'no-schema'\n  ) {\n    throw new InvalidArgumentError({\n      parameter: 'output',\n      value: output,\n      message: 'Invalid output type.',\n    });\n  }\n\n  if (output === 'no-schema') {\n    if (mode === 'auto' || mode === 'tool') {\n      throw new InvalidArgumentError({\n        parameter: 'mode',\n        value: mode,\n        message: 'Mode must be \"json\" for no-schema output.',\n      });\n    }\n\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Schema is not supported for no-schema output.',\n      });\n    }\n\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaDescription',\n        value: schemaDescription,\n        message: 'Schema description is not supported for no-schema output.',\n      });\n    }\n\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaName',\n        value: schemaName,\n        message: 'Schema name is not supported for no-schema output.',\n      });\n    }\n\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are not supported for no-schema output.',\n      });\n    }\n  }\n\n  if (output === 'object') {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Schema is required for object output.',\n      });\n    }\n\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are not supported for object output.',\n      });\n    }\n  }\n\n  if (output === 'array') {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Element schema is required for array output.',\n      });\n    }\n\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are not supported for array output.',\n      });\n    }\n  }\n\n  if (output === 'enum') {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Schema is not supported for enum output.',\n      });\n    }\n\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaDescription',\n        value: schemaDescription,\n        message: 'Schema description is not supported for enum output.',\n      });\n    }\n\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaName',\n        value: schemaName,\n        message: 'Schema name is not supported for enum output.',\n      });\n    }\n\n    if (enumValues == null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are required for enum output.',\n      });\n    }\n\n    for (const value of enumValues) {\n      if (typeof value !== 'string') {\n        throw new InvalidArgumentError({\n          parameter: 'enumValues',\n          value,\n          message: 'Enum values must be strings.',\n        });\n      }\n    }\n  }\n}\n", "/**\n * Helper utility to serialize prompt content for OpenTelemetry tracing.\n * It is initially created because normalized LanguageModelV1Prompt carries\n * images as Uint8Arrays, on which JSON.stringify acts weirdly, converting\n * them to objects with stringified indices as keys, e.g. {\"0\": 42, \"1\": 69 }.\n */\n\nimport {\n  LanguageModelV1ImagePart,\n  LanguageModelV1Message,\n  LanguageModelV1Prompt,\n  LanguageModelV1ProviderMetadata,\n} from '@ai-sdk/provider';\nimport { convertDataContentToBase64String } from './data-content';\n\nexport function stringifyForTelemetry(prompt: LanguageModelV1Prompt): string {\n  const processedPrompt = prompt.map((message: LanguageModelV1Message) => {\n    return {\n      ...message,\n      content:\n        typeof message.content === 'string'\n          ? message.content\n          : message.content.map(processPart),\n    };\n  });\n\n  return JSON.stringify(processedPrompt);\n}\n\ntype MessageContentPart = Exclude<\n  LanguageModelV1Message['content'],\n  string\n>[number];\ntype ProcessedMessageContentPart =\n  | Exclude<MessageContentPart, LanguageModelV1ImagePart>\n  | {\n      type: 'image';\n      image: string | URL;\n      mimeType?: string;\n      providerMetadata?: LanguageModelV1ProviderMetadata;\n    };\n\nfunction processPart(part: MessageContentPart): ProcessedMessageContentPart {\n  if (part.type === 'image') {\n    return {\n      ...part,\n      image:\n        part.image instanceof Uint8Array\n          ? convertDataContentToBase64String(part.image)\n          : part.image,\n    };\n  }\n  return part;\n}\n", "import {\n  JSONValue,\n  LanguageModelV1CallOptions,\n  LanguageModelV1FinishReason,\n  LanguageModelV1StreamPart,\n} from '@ai-sdk/provider';\nimport { createIdGenerator } from '@ai-sdk/provider-utils';\nimport {\n  DeepPartial,\n  Schema,\n  isDeepEqualData,\n  parsePartialJson,\n} from '@ai-sdk/ui-utils';\nimport { ServerResponse } from 'http';\nimport { z } from 'zod';\nimport { NoObjectGeneratedError } from '../../errors/no-object-generated-error';\nimport { DelayedPromise } from '../../util/delayed-promise';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  CallWarning,\n  FinishReason,\n  LanguageModel,\n  LogProbs,\n} from '../types/language-model';\nimport { LanguageModelRequestMetadata } from '../types/language-model-request-metadata';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { ProviderMetadata, ProviderOptions } from '../types/provider-metadata';\nimport {\n  LanguageModelUsage,\n  calculateLanguageModelUsage,\n} from '../types/usage';\nimport {\n  AsyncIterableStream,\n  createAsyncIterableStream,\n} from '../util/async-iterable-stream';\nimport { createStitchableStream } from '../util/create-stitchable-stream';\nimport { now as originalNow } from '../util/now';\nimport { prepareOutgoingHttpHeaders } from '../util/prepare-outgoing-http-headers';\nimport { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { writeToServerResponse } from '../util/write-to-server-response';\nimport { injectJsonInstruction } from './inject-json-instruction';\nimport { OutputStrategy, getOutputStrategy } from './output-strategy';\nimport { ObjectStreamPart, StreamObjectResult } from './stream-object-result';\nimport { validateObjectGenerationInput } from './validate-object-generation-input';\nimport { stringifyForTelemetry } from '../prompt/stringify-for-telemetry';\nimport { UnsupportedModelVersionError } from '../../errors/unsupported-model-version-error';\n\nconst originalGenerateId = createIdGenerator({ prefix: 'aiobj', size: 24 });\n\n/**\nCallback that is set using the `onError` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamObjectOnErrorCallback = (event: {\n  error: unknown;\n}) => Promise<void> | void;\n\n/**\nCallback that is set using the `onFinish` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamObjectOnFinishCallback<RESULT> = (event: {\n  /**\nThe token usage of the generated response.\n*/\n  usage: LanguageModelUsage;\n\n  /**\nThe generated object. Can be undefined if the final object does not match the schema.\n*/\n  object: RESULT | undefined;\n\n  /**\nOptional error object. This is e.g. a TypeValidationError when the final object does not match the schema.\n*/\n  error: unknown | undefined;\n\n  /**\nResponse metadata.\n */\n  response: LanguageModelResponseMetadata;\n\n  /**\nWarnings from the model provider (e.g. unsupported settings).\n*/\n  warnings?: CallWarning[];\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n*/\n  providerMetadata: ProviderMetadata | undefined;\n\n  /**\n@deprecated Use `providerMetadata` instead.\n*/\n  experimental_providerMetadata?: ProviderMetadata;\n}) => Promise<void> | void;\n\n/**\nGenerate a structured, typed object for a given prompt and schema using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateObject` instead.\n\n@return\nA result object for accessing the partial object stream and additional information.\n */\nexport function streamObject<OBJECT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output?: 'object' | undefined;\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe schema of the object that the model should generate.\n */\n      schema: z.Schema<OBJECT, z.ZodTypeDef, any> | Schema<OBJECT>;\n\n      /**\nOptional name of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n      onError?: StreamObjectOnErrorCallback;\n\n      /**\nCallback that is called when the LLM response and the final object validation are finished.\n     */\n      onFinish?: StreamObjectOnFinishCallback<OBJECT>;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n        now?: () => number;\n      };\n    },\n): StreamObjectResult<DeepPartial<OBJECT>, OBJECT, never>;\n/**\nGenerate an array with structured, typed elements for a given prompt and element schema using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateObject` instead.\n\n@return\nA result object for accessing the partial object stream and additional information.\n */\nexport function streamObject<ELEMENT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'array';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe element schema of the array that the model should generate.\n */\n      schema: z.Schema<ELEMENT, z.ZodTypeDef, any> | Schema<ELEMENT>;\n\n      /**\nOptional name of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n      onError?: StreamObjectOnErrorCallback;\n\n      /**\nCallback that is called when the LLM response and the final object validation are finished.\n     */\n      onFinish?: StreamObjectOnFinishCallback<Array<ELEMENT>>;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n        now?: () => number;\n      };\n    },\n): StreamObjectResult<\n  Array<ELEMENT>,\n  Array<ELEMENT>,\n  AsyncIterableStream<ELEMENT>\n>;\n/**\nGenerate JSON with any schema for a given prompt using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateObject` instead.\n\n@return\nA result object for accessing the partial object stream and additional information.\n */\nexport function streamObject(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'no-schema';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe mode to use for object generation. Must be \"json\" for no-schema output.\n     */\n      mode?: 'json';\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n      onError?: StreamObjectOnErrorCallback;\n\n      /**\nCallback that is called when the LLM response and the final object validation are finished.\n     */\n      onFinish?: StreamObjectOnFinishCallback<JSONValue>;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n        now?: () => number;\n      };\n    },\n): StreamObjectResult<JSONValue, JSONValue, never>;\nexport function streamObject<SCHEMA, PARTIAL, RESULT, ELEMENT_STREAM>({\n  model,\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  output = 'object',\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  onError,\n  onFinish,\n  _internal: {\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n    now = originalNow,\n  } = {},\n  ...settings\n}: Omit<CallSettings, 'stopSequences'> &\n  Prompt & {\n    /**\n     * The expected structure of the output.\n     *\n     * - 'object': Generate a single object that conforms to the schema.\n     * - 'array': Generate an array of objects that conform to the schema.\n     * - 'no-schema': Generate any JSON object. No schema is specified.\n     *\n     * Default is 'object' if not specified.\n     */\n    output?: 'object' | 'array' | 'no-schema';\n\n    model: LanguageModel;\n    schema?: z.Schema<SCHEMA, z.ZodTypeDef, any> | Schema<SCHEMA>;\n    schemaName?: string;\n    schemaDescription?: string;\n    mode?: 'auto' | 'json' | 'tool';\n    experimental_telemetry?: TelemetrySettings;\n    providerOptions?: ProviderOptions;\n    experimental_providerMetadata?: ProviderMetadata;\n    onError?: StreamObjectOnErrorCallback;\n    onFinish?: StreamObjectOnFinishCallback<RESULT>;\n    _internal?: {\n      generateId?: () => string;\n      currentDate?: () => Date;\n      now?: () => number;\n    };\n  }): StreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM> {\n  if (typeof model === 'string' || model.specificationVersion !== 'v1') {\n    throw new UnsupportedModelVersionError();\n  }\n\n  validateObjectGenerationInput({\n    output,\n    mode,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n  });\n\n  const outputStrategy = getOutputStrategy({ output, schema: inputSchema });\n\n  // automatically set mode to 'json' for no-schema output\n  if (outputStrategy.type === 'no-schema' && mode === undefined) {\n    mode = 'json';\n  }\n\n  return new DefaultStreamObjectResult({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    mode,\n    onError,\n    onFinish,\n    generateId,\n    currentDate,\n    now,\n  });\n}\n\nclass DefaultStreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM>\n  implements StreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM>\n{\n  private readonly objectPromise = new DelayedPromise<RESULT>();\n  private readonly usagePromise = new DelayedPromise<LanguageModelUsage>();\n  private readonly providerMetadataPromise = new DelayedPromise<\n    ProviderMetadata | undefined\n  >();\n  private readonly warningsPromise = new DelayedPromise<\n    CallWarning[] | undefined\n  >();\n  private readonly requestPromise =\n    new DelayedPromise<LanguageModelRequestMetadata>();\n  private readonly responsePromise =\n    new DelayedPromise<LanguageModelResponseMetadata>();\n\n  private readonly baseStream: ReadableStream<ObjectStreamPart<PARTIAL>>;\n\n  private readonly outputStrategy: OutputStrategy<\n    PARTIAL,\n    RESULT,\n    ELEMENT_STREAM\n  >;\n\n  constructor({\n    model,\n    headers,\n    telemetry,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    mode,\n    onError,\n    onFinish,\n    generateId,\n    currentDate,\n    now,\n  }: {\n    model: LanguageModel;\n    telemetry: TelemetrySettings | undefined;\n    headers: Record<string, string | undefined> | undefined;\n    settings: Omit<CallSettings, 'abortSignal' | 'headers'>;\n    maxRetries: number | undefined;\n    abortSignal: AbortSignal | undefined;\n    outputStrategy: OutputStrategy<PARTIAL, RESULT, ELEMENT_STREAM>;\n    system: Prompt['system'];\n    prompt: Prompt['prompt'];\n    messages: Prompt['messages'];\n    schemaName: string | undefined;\n    schemaDescription: string | undefined;\n    providerOptions: ProviderOptions | undefined;\n    mode: 'auto' | 'json' | 'tool' | undefined;\n    onError: StreamObjectOnErrorCallback | undefined;\n    onFinish: StreamObjectOnFinishCallback<RESULT> | undefined;\n    generateId: () => string;\n    currentDate: () => Date;\n    now: () => number;\n  }) {\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n    });\n\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...settings, maxRetries },\n    });\n\n    const tracer = getTracer(telemetry);\n    const self = this;\n\n    const stitchableStream =\n      createStitchableStream<ObjectStreamPart<PARTIAL>>();\n\n    const eventProcessor = new TransformStream<\n      ObjectStreamPart<PARTIAL>,\n      ObjectStreamPart<PARTIAL>\n    >({\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n\n        if (chunk.type === 'error') {\n          onError?.({ error: chunk.error });\n        }\n      },\n    });\n\n    this.baseStream = stitchableStream.stream.pipeThrough(eventProcessor);\n\n    recordSpan({\n      name: 'ai.streamObject',\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: 'ai.streamObject',\n            telemetry,\n          }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          'ai.prompt': {\n            input: () => JSON.stringify({ system, prompt, messages }),\n          },\n          'ai.schema':\n            outputStrategy.jsonSchema != null\n              ? { input: () => JSON.stringify(outputStrategy.jsonSchema) }\n              : undefined,\n          'ai.schema.name': schemaName,\n          'ai.schema.description': schemaDescription,\n          'ai.settings.output': outputStrategy.type,\n          'ai.settings.mode': mode,\n        },\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async rootSpan => {\n        // use the default provider mode when the mode is set to 'auto' or unspecified\n        if (mode === 'auto' || mode == null) {\n          mode = model.defaultObjectGenerationMode;\n        }\n\n        let callOptions: LanguageModelV1CallOptions;\n        let transformer: Transformer<\n          LanguageModelV1StreamPart,\n          string | Omit<LanguageModelV1StreamPart, 'text-delta'>\n        >;\n\n        switch (mode) {\n          case 'json': {\n            const standardizedPrompt = standardizePrompt({\n              prompt: {\n                system:\n                  outputStrategy.jsonSchema == null\n                    ? injectJsonInstruction({ prompt: system })\n                    : model.supportsStructuredOutputs\n                      ? system\n                      : injectJsonInstruction({\n                          prompt: system,\n                          schema: outputStrategy.jsonSchema,\n                        }),\n                prompt,\n                messages,\n              },\n              tools: undefined,\n            });\n\n            callOptions = {\n              mode: {\n                type: 'object-json',\n                schema: outputStrategy.jsonSchema,\n                name: schemaName,\n                description: schemaDescription,\n              },\n              ...prepareCallSettings(settings),\n              inputFormat: standardizedPrompt.type,\n              prompt: await convertToLanguageModelPrompt({\n                prompt: standardizedPrompt,\n                modelSupportsImageUrls: model.supportsImageUrls,\n                modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context\n              }),\n              providerMetadata: providerOptions,\n              abortSignal,\n              headers,\n            };\n\n            transformer = {\n              transform: (chunk, controller) => {\n                switch (chunk.type) {\n                  case 'text-delta':\n                    controller.enqueue(chunk.textDelta);\n                    break;\n                  case 'response-metadata':\n                  case 'finish':\n                  case 'error':\n                    controller.enqueue(chunk);\n                    break;\n                }\n              },\n            };\n\n            break;\n          }\n\n          case 'tool': {\n            const standardizedPrompt = standardizePrompt({\n              prompt: { system, prompt, messages },\n              tools: undefined,\n            });\n\n            callOptions = {\n              mode: {\n                type: 'object-tool',\n                tool: {\n                  type: 'function',\n                  name: schemaName ?? 'json',\n                  description:\n                    schemaDescription ?? 'Respond with a JSON object.',\n                  parameters: outputStrategy.jsonSchema!,\n                },\n              },\n              ...prepareCallSettings(settings),\n              inputFormat: standardizedPrompt.type,\n              prompt: await convertToLanguageModelPrompt({\n                prompt: standardizedPrompt,\n                modelSupportsImageUrls: model.supportsImageUrls,\n                modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context,\n              }),\n              providerMetadata: providerOptions,\n              abortSignal,\n              headers,\n            };\n\n            transformer = {\n              transform(chunk, controller) {\n                switch (chunk.type) {\n                  case 'tool-call-delta':\n                    controller.enqueue(chunk.argsTextDelta);\n                    break;\n                  case 'response-metadata':\n                  case 'finish':\n                  case 'error':\n                    controller.enqueue(chunk);\n                    break;\n                }\n              },\n            };\n\n            break;\n          }\n\n          case undefined: {\n            throw new Error(\n              'Model does not have a default object generation mode.',\n            );\n          }\n\n          default: {\n            const _exhaustiveCheck: never = mode;\n            throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n          }\n        }\n\n        const {\n          result: { stream, warnings, rawResponse, request },\n          doStreamSpan,\n          startTimestampMs,\n        } = await retry(() =>\n          recordSpan({\n            name: 'ai.streamObject.doStream',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.streamObject.doStream',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                'ai.prompt.format': {\n                  input: () => callOptions.inputFormat,\n                },\n                'ai.prompt.messages': {\n                  input: () => stringifyForTelemetry(callOptions.prompt),\n                },\n                'ai.settings.mode': mode,\n\n                // standardized gen-ai llm span attributes:\n                'gen_ai.system': model.provider,\n                'gen_ai.request.model': model.modelId,\n                'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                'gen_ai.request.max_tokens': settings.maxTokens,\n                'gen_ai.request.presence_penalty': settings.presencePenalty,\n                'gen_ai.request.temperature': settings.temperature,\n                'gen_ai.request.top_k': settings.topK,\n                'gen_ai.request.top_p': settings.topP,\n              },\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async doStreamSpan => ({\n              startTimestampMs: now(),\n              doStreamSpan,\n              result: await model.doStream(callOptions),\n            }),\n          }),\n        );\n\n        self.requestPromise.resolve(request ?? {});\n\n        // store information for onFinish callback:\n        let usage: LanguageModelUsage | undefined;\n        let finishReason: LanguageModelV1FinishReason | undefined;\n        let providerMetadata: ProviderMetadata | undefined;\n        let object: RESULT | undefined;\n        let error: unknown | undefined;\n\n        // pipe chunks through a transformation stream that extracts metadata:\n        let accumulatedText = '';\n        let textDelta = '';\n        let response: {\n          id: string;\n          timestamp: Date;\n          modelId: string;\n        } = {\n          id: generateId(),\n          timestamp: currentDate(),\n          modelId: model.modelId,\n        };\n\n        // Keep track of raw parse result before type validation, since e.g. Zod might\n        // change the object by mapping properties.\n        let latestObjectJson: JSONValue | undefined = undefined;\n        let latestObject: PARTIAL | undefined = undefined;\n        let isFirstChunk = true;\n        let isFirstDelta = true;\n\n        const transformedStream = stream\n          .pipeThrough(new TransformStream(transformer))\n          .pipeThrough(\n            new TransformStream<\n              string | ObjectStreamInputPart,\n              ObjectStreamPart<PARTIAL>\n            >({\n              async transform(chunk, controller): Promise<void> {\n                // Telemetry event for first chunk:\n                if (isFirstChunk) {\n                  const msToFirstChunk = now() - startTimestampMs;\n\n                  isFirstChunk = false;\n\n                  doStreamSpan.addEvent('ai.stream.firstChunk', {\n                    'ai.stream.msToFirstChunk': msToFirstChunk,\n                  });\n\n                  doStreamSpan.setAttributes({\n                    'ai.stream.msToFirstChunk': msToFirstChunk,\n                  });\n                }\n\n                // process partial text chunks\n                if (typeof chunk === 'string') {\n                  accumulatedText += chunk;\n                  textDelta += chunk;\n\n                  const { value: currentObjectJson, state: parseState } =\n                    parsePartialJson(accumulatedText);\n\n                  if (\n                    currentObjectJson !== undefined &&\n                    !isDeepEqualData(latestObjectJson, currentObjectJson)\n                  ) {\n                    const validationResult =\n                      outputStrategy.validatePartialResult({\n                        value: currentObjectJson,\n                        textDelta,\n                        latestObject,\n                        isFirstDelta,\n                        isFinalDelta: parseState === 'successful-parse',\n                      });\n\n                    if (\n                      validationResult.success &&\n                      !isDeepEqualData(\n                        latestObject,\n                        validationResult.value.partial,\n                      )\n                    ) {\n                      // inside inner check to correctly parse the final element in array mode:\n                      latestObjectJson = currentObjectJson;\n                      latestObject = validationResult.value.partial;\n\n                      controller.enqueue({\n                        type: 'object',\n                        object: latestObject,\n                      });\n\n                      controller.enqueue({\n                        type: 'text-delta',\n                        textDelta: validationResult.value.textDelta,\n                      });\n\n                      textDelta = '';\n                      isFirstDelta = false;\n                    }\n                  }\n\n                  return;\n                }\n\n                switch (chunk.type) {\n                  case 'response-metadata': {\n                    response = {\n                      id: chunk.id ?? response.id,\n                      timestamp: chunk.timestamp ?? response.timestamp,\n                      modelId: chunk.modelId ?? response.modelId,\n                    };\n                    break;\n                  }\n\n                  case 'finish': {\n                    // send final text delta:\n                    if (textDelta !== '') {\n                      controller.enqueue({ type: 'text-delta', textDelta });\n                    }\n\n                    // store finish reason for telemetry:\n                    finishReason = chunk.finishReason;\n\n                    // store usage and metadata for promises and onFinish callback:\n                    usage = calculateLanguageModelUsage(chunk.usage);\n                    providerMetadata = chunk.providerMetadata;\n\n                    controller.enqueue({ ...chunk, usage, response });\n\n                    // resolve promises that can be resolved now:\n                    self.usagePromise.resolve(usage);\n                    self.providerMetadataPromise.resolve(providerMetadata);\n                    self.responsePromise.resolve({\n                      ...response,\n                      headers: rawResponse?.headers,\n                    });\n\n                    // resolve the object promise with the latest object:\n                    const validationResult = outputStrategy.validateFinalResult(\n                      latestObjectJson,\n                      {\n                        text: accumulatedText,\n                        response,\n                        usage,\n                      },\n                    );\n\n                    if (validationResult.success) {\n                      object = validationResult.value;\n                      self.objectPromise.resolve(object);\n                    } else {\n                      error = new NoObjectGeneratedError({\n                        message:\n                          'No object generated: response did not match schema.',\n                        cause: validationResult.error,\n                        text: accumulatedText,\n                        response,\n                        usage,\n                        finishReason: finishReason,\n                      });\n                      self.objectPromise.reject(error);\n                    }\n\n                    break;\n                  }\n\n                  default: {\n                    controller.enqueue(chunk);\n                    break;\n                  }\n                }\n              },\n\n              // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n              async flush(controller) {\n                try {\n                  const finalUsage = usage ?? {\n                    promptTokens: NaN,\n                    completionTokens: NaN,\n                    totalTokens: NaN,\n                  };\n\n                  doStreamSpan.setAttributes(\n                    selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        'ai.response.finishReason': finishReason,\n                        'ai.response.object': {\n                          output: () => JSON.stringify(object),\n                        },\n                        'ai.response.id': response.id,\n                        'ai.response.model': response.modelId,\n                        'ai.response.timestamp':\n                          response.timestamp.toISOString(),\n                        'ai.response.providerMetadata':\n                          JSON.stringify(providerMetadata),\n\n                        'ai.usage.promptTokens': finalUsage.promptTokens,\n                        'ai.usage.completionTokens':\n                          finalUsage.completionTokens,\n\n                        // standardized gen-ai llm span attributes:\n                        'gen_ai.response.finish_reasons': [finishReason],\n                        'gen_ai.response.id': response.id,\n                        'gen_ai.response.model': response.modelId,\n                        'gen_ai.usage.input_tokens': finalUsage.promptTokens,\n                        'gen_ai.usage.output_tokens':\n                          finalUsage.completionTokens,\n                      },\n                    }),\n                  );\n\n                  // finish doStreamSpan before other operations for correct timing:\n                  doStreamSpan.end();\n\n                  // Add response information to the root span:\n                  rootSpan.setAttributes(\n                    selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        'ai.usage.promptTokens': finalUsage.promptTokens,\n                        'ai.usage.completionTokens':\n                          finalUsage.completionTokens,\n                        'ai.response.object': {\n                          output: () => JSON.stringify(object),\n                        },\n                        'ai.response.providerMetadata':\n                          JSON.stringify(providerMetadata),\n                      },\n                    }),\n                  );\n\n                  // call onFinish callback:\n                  await onFinish?.({\n                    usage: finalUsage,\n                    object,\n                    error,\n                    response: {\n                      ...response,\n                      headers: rawResponse?.headers,\n                    },\n                    warnings,\n                    providerMetadata,\n                    experimental_providerMetadata: providerMetadata,\n                  });\n                } catch (error) {\n                  controller.enqueue({ type: 'error', error });\n                } finally {\n                  rootSpan.end();\n                }\n              },\n            }),\n          );\n\n        stitchableStream.addStream(transformedStream);\n      },\n    })\n      .catch(error => {\n        // add an empty stream with an error to break the stream:\n        stitchableStream.addStream(\n          new ReadableStream({\n            start(controller) {\n              controller.enqueue({ type: 'error', error });\n              controller.close();\n            },\n          }),\n        );\n      })\n      .finally(() => {\n        stitchableStream.close();\n      });\n\n    this.outputStrategy = outputStrategy;\n  }\n\n  get object() {\n    return this.objectPromise.value;\n  }\n\n  get usage() {\n    return this.usagePromise.value;\n  }\n\n  get experimental_providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n\n  get providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n\n  get warnings() {\n    return this.warningsPromise.value;\n  }\n\n  get request() {\n    return this.requestPromise.value;\n  }\n\n  get response() {\n    return this.responsePromise.value;\n  }\n\n  get partialObjectStream(): AsyncIterableStream<PARTIAL> {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream<ObjectStreamPart<PARTIAL>, PARTIAL>({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case 'object':\n                controller.enqueue(chunk.object);\n                break;\n\n              case 'text-delta':\n              case 'finish':\n              case 'error': // suppress error (use onError instead)\n                break;\n\n              default: {\n                const _exhaustiveCheck: never = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  get elementStream(): ELEMENT_STREAM {\n    return this.outputStrategy.createElementStream(this.baseStream);\n  }\n\n  get textStream(): AsyncIterableStream<string> {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream<ObjectStreamPart<PARTIAL>, string>({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case 'text-delta':\n                controller.enqueue(chunk.textDelta);\n                break;\n\n              case 'object':\n              case 'finish':\n              case 'error': // suppress error (use onError instead)\n                break;\n\n              default: {\n                const _exhaustiveCheck: never = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  get fullStream(): AsyncIterableStream<ObjectStreamPart<PARTIAL>> {\n    return createAsyncIterableStream(this.baseStream);\n  }\n\n  pipeTextStreamToResponse(response: ServerResponse, init?: ResponseInit) {\n    writeToServerResponse({\n      response,\n      status: init?.status,\n      statusText: init?.statusText,\n      headers: prepareOutgoingHttpHeaders(init?.headers, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n      stream: this.textStream.pipeThrough(new TextEncoderStream()),\n    });\n  }\n\n  toTextStreamResponse(init?: ResponseInit): Response {\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: init?.status ?? 200,\n      headers: prepareResponseHeaders(init?.headers, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n    });\n  }\n}\n\nexport type ObjectStreamInputPart =\n  | {\n      type: 'error';\n      error: unknown;\n    }\n  | {\n      type: 'response-metadata';\n      id?: string;\n      timestamp?: Date;\n      modelId?: string;\n    }\n  | {\n      type: 'finish';\n      finishReason: FinishReason;\n      logprobs?: LogProbs;\n      usage: LanguageModelUsage;\n      providerMetadata?: ProviderMetadata;\n    };\n", "/**\n * Delayed promise. It is only constructed once the value is accessed.\n * This is useful to avoid unhandled promise rejections when the promise is created\n * but not accessed.\n */\nexport class DelayedPromise<T> {\n  private status:\n    | { type: 'pending' }\n    | { type: 'resolved'; value: T }\n    | { type: 'rejected'; error: unknown } = { type: 'pending' };\n  private promise: Promise<T> | undefined;\n  private _resolve: undefined | ((value: T) => void) = undefined;\n  private _reject: undefined | ((error: unknown) => void) = undefined;\n\n  get value(): Promise<T> {\n    if (this.promise) {\n      return this.promise;\n    }\n\n    this.promise = new Promise<T>((resolve, reject) => {\n      if (this.status.type === 'resolved') {\n        resolve(this.status.value);\n      } else if (this.status.type === 'rejected') {\n        reject(this.status.error);\n      }\n\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n\n    return this.promise;\n  }\n\n  resolve(value: T): void {\n    this.status = { type: 'resolved', value };\n\n    if (this.promise) {\n      this._resolve?.(value);\n    }\n  }\n\n  reject(error: unknown): void {\n    this.status = { type: 'rejected', error };\n\n    if (this.promise) {\n      this._reject?.(error);\n    }\n  }\n}\n", "/**\n * Creates a Promise with externally accessible resolve and reject functions.\n *\n * @template T - The type of the value that the Promise will resolve to.\n * @returns An object containing:\n *   - promise: A Promise that can be resolved or rejected externally.\n *   - resolve: A function to resolve the Promise with a value of type T.\n *   - reject: A function to reject the Promise with an error.\n */\nexport function createResolvablePromise<T = any>(): {\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (error: unknown) => void;\n} {\n  let resolve: (value: T) => void;\n  let reject: (error: unknown) => void;\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return {\n    promise,\n    resolve: resolve!,\n    reject: reject!,\n  };\n}\n", "import { createResolvablePromise } from '../../util/create-resolvable-promise';\n\n/**\n * Creates a stitchable stream that can pipe one stream at a time.\n *\n * @template T - The type of values emitted by the streams.\n * @returns {Object} An object containing the stitchable stream and control methods.\n */\nexport function createStitchableStream<T>(): {\n  stream: ReadableStream<T>;\n  addStream: (innerStream: ReadableStream<T>) => void;\n  close: () => void;\n  terminate: () => void;\n} {\n  let innerStreamReaders: ReadableStreamDefaultReader<T>[] = [];\n  let controller: ReadableStreamDefaultController<T> | null = null;\n  let isClosed = false;\n  let waitForNewStream = createResolvablePromise<void>();\n\n  const processPull = async () => {\n    // Case 1: Outer stream is closed and no more inner streams\n    if (isClosed && innerStreamReaders.length === 0) {\n      controller?.close();\n      return;\n    }\n\n    // Case 2: No inner streams available, but outer stream is open\n    // wait for a new inner stream to be added or the outer stream to close\n    if (innerStreamReaders.length === 0) {\n      waitForNewStream = createResolvablePromise<void>();\n      await waitForNewStream.promise;\n      return processPull();\n    }\n\n    try {\n      const { value, done } = await innerStreamReaders[0].read();\n\n      if (done) {\n        // Case 3: Current inner stream is done\n        innerStreamReaders.shift(); // Remove the finished stream\n\n        // Continue pulling from the next stream if available\n        if (innerStreamReaders.length > 0) {\n          await processPull();\n        } else if (isClosed) {\n          controller?.close();\n        }\n      } else {\n        // Case 4: Current inner stream returns an item\n        controller?.enqueue(value);\n      }\n    } catch (error) {\n      // Case 5: Current inner stream throws an error\n      controller?.error(error);\n      innerStreamReaders.shift(); // Remove the errored stream\n\n      if (isClosed && innerStreamReaders.length === 0) {\n        controller?.close();\n      }\n    }\n  };\n\n  return {\n    stream: new ReadableStream<T>({\n      start(controllerParam) {\n        controller = controllerParam;\n      },\n      pull: processPull,\n      async cancel() {\n        for (const reader of innerStreamReaders) {\n          await reader.cancel();\n        }\n        innerStreamReaders = [];\n        isClosed = true;\n      },\n    }),\n    addStream: (innerStream: ReadableStream<T>) => {\n      if (isClosed) {\n        throw new Error('Cannot add inner stream: outer stream is closed');\n      }\n\n      innerStreamReaders.push(innerStream.getReader());\n      waitForNewStream.resolve();\n    },\n\n    /**\n     * Gracefully close the outer stream. This will let the inner streams\n     * finish processing and then close the outer stream.\n     */\n    close: () => {\n      isClosed = true;\n      waitForNewStream.resolve();\n\n      if (innerStreamReaders.length === 0) {\n        controller?.close();\n      }\n    },\n\n    /**\n     * Immediately close the outer stream. This will cancel all inner streams\n     * and close the outer stream.\n     */\n    terminate: () => {\n      isClosed = true;\n      waitForNewStream.resolve();\n\n      innerStreamReaders.forEach(reader => reader.cancel());\n      innerStreamReaders = [];\n      controller?.close();\n    },\n  };\n}\n", "// Shim for performance.now() to support environments that don't have it:\nexport function now(): number {\n  return globalThis?.performance?.now() ?? Date.now();\n}\n", "import { createIdGenerator, IDGenerator } from '@ai-sdk/provider-utils';\nimport { Tracer } from '@opentelemetry/api';\nimport { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport { NoOutputSpecifiedError } from '../../errors/no-output-specified-error';\nimport { ToolExecutionError } from '../../errors/tool-execution-error';\nimport { UnsupportedModelVersionError } from '../../errors/unsupported-model-version-error';\nimport { CoreAssistantMessage, CoreMessage } from '../prompt';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { prepareToolsAndToolChoice } from '../prompt/prepare-tools-and-tool-choice';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { stringifyForTelemetry } from '../prompt/stringify-for-telemetry';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordErrorOnSpan, recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { LanguageModel, ToolChoice } from '../types';\nimport { ProviderMetadata, ProviderOptions } from '../types/provider-metadata';\nimport {\n  addLanguageModelUsage,\n  calculateLanguageModelUsage,\n  LanguageModelUsage,\n} from '../types/usage';\nimport { removeTextAfterLastWhitespace } from '../util/remove-text-after-last-whitespace';\nimport { GenerateTextResult } from './generate-text-result';\nimport { DefaultGeneratedFile, GeneratedFile } from './generated-file';\nimport { Output } from './output';\nimport { parseToolCall } from './parse-tool-call';\nimport { asReasoningText, ReasoningDetail } from './reasoning-detail';\nimport { ResponseMessage, StepResult } from './step-result';\nimport { toResponseMessages } from './to-response-messages';\nimport { ToolCallArray } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair';\nimport { ToolResultArray } from './tool-result';\nimport { ToolSet } from './tool-set';\n\nconst originalGenerateId = createIdGenerator({\n  prefix: 'aitxt',\n  size: 24,\n});\n\nconst originalGenerateMessageId = createIdGenerator({\n  prefix: 'msg',\n  size: 24,\n});\n\n/**\nCallback that is set using the `onStepFinish` option.\n\n@param stepResult - The result of the step.\n */\nexport type GenerateTextOnStepFinishCallback<TOOLS extends ToolSet> = (\n  stepResult: StepResult<TOOLS>,\n) => Promise<void> | void;\n\n/**\nGenerate a text and call tools for a given prompt using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamText` instead.\n\n@param model - The language model to use.\n\n@param tools - Tools that are accessible to and can be called by the model. The model needs to support calling tools.\n@param toolChoice - The tool choice strategy. Default: 'auto'.\n\n@param system - A system message that will be part of the prompt.\n@param prompt - A simple text prompt. You can either use `prompt` or `messages` but not both.\n@param messages - A list of messages. You can either use `prompt` or `messages` but not both.\n\n@param maxTokens - Maximum number of tokens to generate.\n@param temperature - Temperature setting.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topP - Nucleus sampling.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topK - Only sample from the top K options for each subsequent token.\nUsed to remove \"long tail\" low probability responses.\nRecommended for advanced use cases only. You usually only need to use temperature.\n@param presencePenalty - Presence penalty setting.\nIt affects the likelihood of the model to repeat information that is already in the prompt.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param frequencyPenalty - Frequency penalty setting.\nIt affects the likelihood of the model to repeatedly use the same words or phrases.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param stopSequences - Stop sequences.\nIf set, the model will stop generating text when one of the stop sequences is generated.\n@param seed - The seed (integer) to use for random sampling.\nIf set and supported by the model, calls will generate deterministic results.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@param maxSteps - Maximum number of sequential LLM calls (steps), e.g. when you use tool calls.\n@param experimental_generateMessageId - Generate a unique ID for each message.\n\n@param onStepFinish - Callback that is called when each step (LLM call) is finished, including intermediate steps.\n\n@returns\nA result object that contains the generated text, the results of the tool calls, and additional information.\n */\nexport async function generateText<\n  TOOLS extends ToolSet,\n  OUTPUT = never,\n  OUTPUT_PARTIAL = never,\n>({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  maxSteps = 1,\n  experimental_generateMessageId: generateMessageId = originalGenerateMessageId,\n  experimental_output: output,\n  experimental_continueSteps: continueSteps = false,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  experimental_activeTools: activeTools,\n  experimental_prepareStep: prepareStep,\n  experimental_repairToolCall: repairToolCall,\n  _internal: {\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n  } = {},\n  onStepFinish,\n  ...settings\n}: CallSettings &\n  Prompt & {\n    /**\nThe language model to use.\n     */\n    model: LanguageModel;\n\n    /**\nThe tools that the model can call. The model needs to support calling tools.\n*/\n    tools?: TOOLS;\n\n    /**\nThe tool choice strategy. Default: 'auto'.\n     */\n    toolChoice?: ToolChoice<TOOLS>;\n\n    /**\nMaximum number of sequential LLM calls (steps), e.g. when you use tool calls. Must be at least 1.\n\nA maximum number is required to prevent infinite loops in the case of misconfigured tools.\n\nBy default, it's set to 1, which means that only a single LLM call is made.\n     */\n    maxSteps?: number;\n\n    /**\nGenerate a unique ID for each message.\n     */\n    experimental_generateMessageId?: IDGenerator;\n\n    /**\nWhen enabled, the model will perform additional steps if the finish reason is \"length\" (experimental).\n\nBy default, it's set to false.\n     */\n    experimental_continueSteps?: boolean;\n\n    /**\nOptional telemetry configuration (experimental).\n     */\n    experimental_telemetry?: TelemetrySettings;\n\n    /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n    providerOptions?: ProviderOptions;\n\n    /**\n@deprecated Use `providerOptions` instead.\n     */\n    experimental_providerMetadata?: ProviderMetadata;\n\n    /**\nLimits the tools that are available for the model to call without\nchanging the tool call and result types in the result.\n     */\n    experimental_activeTools?: Array<keyof TOOLS>;\n\n    /**\nOptional specification for parsing structured outputs from the LLM response.\n     */\n    experimental_output?: Output<OUTPUT, OUTPUT_PARTIAL>;\n\n    /**\nOptional function that you can use to provide different settings for a step.\n\n@param options - The options for the step.\n@param options.steps - The steps that have been executed so far.\n@param options.stepNumber - The number of the step that is being executed.\n@param options.maxSteps - The maximum number of steps.\n@param options.model - The model that is being used.\n\n@returns An object that contains the settings for the step.\nIf you return undefined (or for undefined settings), the settings from the outer level will be used.\n    */\n    experimental_prepareStep?: (options: {\n      steps: Array<StepResult<TOOLS>>;\n      stepNumber: number;\n      maxSteps: number;\n      model: LanguageModel;\n    }) => PromiseLike<\n      | {\n          model?: LanguageModel;\n          toolChoice?: ToolChoice<TOOLS>;\n          experimental_activeTools?: Array<keyof TOOLS>;\n        }\n      | undefined\n    >;\n\n    /**\nA function that attempts to repair a tool call that failed to parse.\n     */\n    experimental_repairToolCall?: ToolCallRepairFunction<TOOLS>;\n\n    /**\n    Callback that is called when each step (LLM call) is finished, including intermediate steps.\n    */\n    onStepFinish?: GenerateTextOnStepFinishCallback<TOOLS>;\n\n    /**\n     * Internal. For test use only. May change without notice.\n     */\n    _internal?: {\n      generateId?: IDGenerator;\n      currentDate?: () => Date;\n    };\n  }): Promise<GenerateTextResult<TOOLS, OUTPUT>> {\n  if (typeof model === 'string' || model.specificationVersion !== 'v1') {\n    throw new UnsupportedModelVersionError();\n  }\n\n  if (maxSteps < 1) {\n    throw new InvalidArgumentError({\n      parameter: 'maxSteps',\n      value: maxSteps,\n      message: 'maxSteps must be at least 1',\n    });\n  }\n\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries },\n  });\n\n  const initialPrompt = standardizePrompt({\n    prompt: {\n      system: output?.injectIntoSystemPrompt({ system, model }) ?? system,\n      prompt,\n      messages,\n    },\n    tools,\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.generateText',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: 'ai.generateText',\n          telemetry,\n        }),\n        ...baseTelemetryAttributes,\n        // model:\n        'ai.model.provider': model.provider,\n        'ai.model.id': model.modelId,\n        // specific settings that only make sense on the outer level:\n        'ai.prompt': {\n          input: () => JSON.stringify({ system, prompt, messages }),\n        },\n        'ai.settings.maxSteps': maxSteps,\n      },\n    }),\n    tracer,\n    fn: async span => {\n      const callSettings = prepareCallSettings(settings);\n\n      let currentModelResponse: Awaited<\n        ReturnType<LanguageModel['doGenerate']>\n      > & { response: { id: string; timestamp: Date; modelId: string } };\n      let currentToolCalls: ToolCallArray<TOOLS> = [];\n      let currentToolResults: ToolResultArray<TOOLS> = [];\n      let currentReasoningDetails: Array<ReasoningDetail> = [];\n      let stepCount = 0;\n      const responseMessages: Array<ResponseMessage> = [];\n      let text = '';\n      const sources: GenerateTextResult<TOOLS, OUTPUT>['sources'] = [];\n      const steps: GenerateTextResult<TOOLS, OUTPUT>['steps'] = [];\n      let usage: LanguageModelUsage = {\n        completionTokens: 0,\n        promptTokens: 0,\n        totalTokens: 0,\n      };\n\n      let stepType: 'initial' | 'tool-result' | 'continue' | 'done' = 'initial';\n\n      do {\n        // after the 1st step, we need to switch to messages format:\n        const promptFormat = stepCount === 0 ? initialPrompt.type : 'messages';\n\n        const stepInputMessages = [\n          ...initialPrompt.messages,\n          ...responseMessages,\n        ];\n\n        const prepareStepResult = await prepareStep?.({\n          model,\n          steps,\n          maxSteps,\n          stepNumber: stepCount,\n        });\n\n        const stepToolChoice = prepareStepResult?.toolChoice ?? toolChoice;\n        const stepActiveTools =\n          prepareStepResult?.experimental_activeTools ?? activeTools;\n        const stepModel = prepareStepResult?.model ?? model;\n\n        const promptMessages = await convertToLanguageModelPrompt({\n          prompt: {\n            type: promptFormat,\n            system: initialPrompt.system,\n            messages: stepInputMessages,\n          },\n          modelSupportsImageUrls: stepModel.supportsImageUrls,\n          modelSupportsUrl: stepModel.supportsUrl?.bind(stepModel), // support 'this' context\n        });\n\n        const mode = {\n          type: 'regular' as const,\n          ...prepareToolsAndToolChoice({\n            tools,\n            toolChoice: stepToolChoice,\n            activeTools: stepActiveTools,\n          }),\n        };\n\n        currentModelResponse = await retry(() =>\n          recordSpan({\n            name: 'ai.generateText.doGenerate',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.generateText.doGenerate',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                // model:\n                'ai.model.provider': stepModel.provider,\n                'ai.model.id': stepModel.modelId,\n                // prompt:\n                'ai.prompt.format': { input: () => promptFormat },\n                'ai.prompt.messages': {\n                  input: () => stringifyForTelemetry(promptMessages),\n                },\n                'ai.prompt.tools': {\n                  // convert the language model level tools:\n                  input: () => mode.tools?.map(tool => JSON.stringify(tool)),\n                },\n                'ai.prompt.toolChoice': {\n                  input: () =>\n                    mode.toolChoice != null\n                      ? JSON.stringify(mode.toolChoice)\n                      : undefined,\n                },\n\n                // standardized gen-ai llm span attributes:\n                'gen_ai.system': stepModel.provider,\n                'gen_ai.request.model': stepModel.modelId,\n                'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                'gen_ai.request.max_tokens': settings.maxTokens,\n                'gen_ai.request.presence_penalty': settings.presencePenalty,\n                'gen_ai.request.stop_sequences': settings.stopSequences,\n                'gen_ai.request.temperature': settings.temperature,\n                'gen_ai.request.top_k': settings.topK,\n                'gen_ai.request.top_p': settings.topP,\n              },\n            }),\n            tracer,\n            fn: async span => {\n              const result = await stepModel.doGenerate({\n                mode,\n                ...callSettings,\n                inputFormat: promptFormat,\n                responseFormat: output?.responseFormat({ model }),\n                prompt: promptMessages,\n                providerMetadata: providerOptions,\n                abortSignal,\n                headers,\n              });\n\n              // Fill in default values:\n              const responseData = {\n                id: result.response?.id ?? generateId(),\n                timestamp: result.response?.timestamp ?? currentDate(),\n                modelId: result.response?.modelId ?? stepModel.modelId,\n              };\n\n              // Add response information to the span:\n              span.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.response.finishReason': result.finishReason,\n                    'ai.response.text': {\n                      output: () => result.text,\n                    },\n                    'ai.response.toolCalls': {\n                      output: () => JSON.stringify(result.toolCalls),\n                    },\n                    'ai.response.id': responseData.id,\n                    'ai.response.model': responseData.modelId,\n                    'ai.response.timestamp':\n                      responseData.timestamp.toISOString(),\n                    'ai.response.providerMetadata': JSON.stringify(\n                      result.providerMetadata,\n                    ),\n\n                    'ai.usage.promptTokens': result.usage.promptTokens,\n                    'ai.usage.completionTokens': result.usage.completionTokens,\n\n                    // standardized gen-ai llm span attributes:\n                    'gen_ai.response.finish_reasons': [result.finishReason],\n                    'gen_ai.response.id': responseData.id,\n                    'gen_ai.response.model': responseData.modelId,\n                    'gen_ai.usage.input_tokens': result.usage.promptTokens,\n                    'gen_ai.usage.output_tokens': result.usage.completionTokens,\n                  },\n                }),\n              );\n\n              return { ...result, response: responseData };\n            },\n          }),\n        );\n\n        // parse tool calls:\n        currentToolCalls = await Promise.all(\n          (currentModelResponse.toolCalls ?? []).map(toolCall =>\n            parseToolCall({\n              toolCall,\n              tools,\n              repairToolCall,\n              system,\n              messages: stepInputMessages,\n            }),\n          ),\n        );\n\n        // execute tools:\n        currentToolResults =\n          tools == null\n            ? []\n            : await executeTools({\n                toolCalls: currentToolCalls,\n                tools,\n                tracer,\n                telemetry,\n                messages: stepInputMessages,\n                abortSignal,\n              });\n\n        // token usage:\n        const currentUsage = calculateLanguageModelUsage(\n          currentModelResponse.usage,\n        );\n        usage = addLanguageModelUsage(usage, currentUsage);\n\n        // check if another step is needed:\n        let nextStepType: 'done' | 'continue' | 'tool-result' = 'done';\n        if (++stepCount < maxSteps) {\n          if (\n            continueSteps &&\n            currentModelResponse.finishReason === 'length' &&\n            // only use continue when there are no tool calls:\n            currentToolCalls.length === 0\n          ) {\n            nextStepType = 'continue';\n          } else if (\n            // there are tool calls:\n            currentToolCalls.length > 0 &&\n            // all current tool calls have results:\n            currentToolResults.length === currentToolCalls.length\n          ) {\n            nextStepType = 'tool-result';\n          }\n        }\n\n        // text:\n        const originalText = currentModelResponse.text ?? '';\n        const stepTextLeadingWhitespaceTrimmed =\n          stepType === 'continue' && // only for continue steps\n          text.trimEnd() !== text // only trim when there is preceding whitespace\n            ? originalText.trimStart()\n            : originalText;\n        const stepText =\n          nextStepType === 'continue'\n            ? removeTextAfterLastWhitespace(stepTextLeadingWhitespaceTrimmed)\n            : stepTextLeadingWhitespaceTrimmed;\n\n        text =\n          nextStepType === 'continue' || stepType === 'continue'\n            ? text + stepText\n            : stepText;\n\n        currentReasoningDetails = asReasoningDetails(\n          currentModelResponse.reasoning,\n        );\n\n        // sources:\n        sources.push(...(currentModelResponse.sources ?? []));\n\n        // append to messages for potential next step:\n        if (stepType === 'continue') {\n          // continue step: update the last assistant message\n          // continue is only possible when there are no tool calls,\n          // so we can assume that there is a single last assistant message:\n          const lastMessage = responseMessages[\n            responseMessages.length - 1\n          ] as CoreAssistantMessage;\n\n          if (typeof lastMessage.content === 'string') {\n            lastMessage.content += stepText;\n          } else {\n            lastMessage.content.push({\n              text: stepText,\n              type: 'text',\n            });\n          }\n        } else {\n          responseMessages.push(\n            ...toResponseMessages({\n              text,\n              files: asFiles(currentModelResponse.files),\n              reasoning: asReasoningDetails(currentModelResponse.reasoning),\n              tools: tools ?? ({} as TOOLS),\n              toolCalls: currentToolCalls,\n              toolResults: currentToolResults,\n              messageId: generateMessageId(),\n              generateMessageId,\n            }),\n          );\n        }\n\n        // Add step information (after response messages are updated):\n        const currentStepResult: StepResult<TOOLS> = {\n          stepType,\n          text: stepText,\n          // TODO v5: rename reasoning to reasoningText (and use reasoning for composite array)\n          reasoning: asReasoningText(currentReasoningDetails),\n          reasoningDetails: currentReasoningDetails,\n          files: asFiles(currentModelResponse.files),\n          sources: currentModelResponse.sources ?? [],\n          toolCalls: currentToolCalls,\n          toolResults: currentToolResults,\n          finishReason: currentModelResponse.finishReason,\n          usage: currentUsage,\n          warnings: currentModelResponse.warnings,\n          logprobs: currentModelResponse.logprobs,\n          request: currentModelResponse.request ?? {},\n          response: {\n            ...currentModelResponse.response,\n            headers: currentModelResponse.rawResponse?.headers,\n            body: currentModelResponse.rawResponse?.body,\n\n            // deep clone msgs to avoid mutating past messages in multi-step:\n            messages: structuredClone(responseMessages),\n          },\n          providerMetadata: currentModelResponse.providerMetadata,\n          experimental_providerMetadata: currentModelResponse.providerMetadata,\n          isContinued: nextStepType === 'continue',\n        };\n        steps.push(currentStepResult);\n        await onStepFinish?.(currentStepResult);\n\n        stepType = nextStepType;\n      } while (stepType !== 'done');\n\n      // Add response information to the span:\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.response.finishReason': currentModelResponse.finishReason,\n            'ai.response.text': {\n              output: () => currentModelResponse.text,\n            },\n            'ai.response.toolCalls': {\n              output: () => JSON.stringify(currentModelResponse.toolCalls),\n            },\n\n            'ai.usage.promptTokens': currentModelResponse.usage.promptTokens,\n            'ai.usage.completionTokens':\n              currentModelResponse.usage.completionTokens,\n            'ai.response.providerMetadata': JSON.stringify(\n              currentModelResponse.providerMetadata,\n            ),\n          },\n        }),\n      );\n\n      return new DefaultGenerateTextResult({\n        text,\n        files: asFiles(currentModelResponse.files),\n        reasoning: asReasoningText(currentReasoningDetails),\n        reasoningDetails: currentReasoningDetails,\n        sources,\n        outputResolver: () => {\n          if (output == null) {\n            throw new NoOutputSpecifiedError();\n          }\n\n          return output.parseOutput(\n            { text },\n            {\n              response: currentModelResponse.response,\n              usage,\n              finishReason: currentModelResponse.finishReason,\n            },\n          );\n        },\n        toolCalls: currentToolCalls,\n        toolResults: currentToolResults,\n        finishReason: currentModelResponse.finishReason,\n        usage,\n        warnings: currentModelResponse.warnings,\n        request: currentModelResponse.request ?? {},\n        response: {\n          ...currentModelResponse.response,\n          headers: currentModelResponse.rawResponse?.headers,\n          body: currentModelResponse.rawResponse?.body,\n          messages: responseMessages,\n        },\n        logprobs: currentModelResponse.logprobs,\n        steps,\n        providerMetadata: currentModelResponse.providerMetadata,\n      });\n    },\n  });\n}\n\nasync function executeTools<TOOLS extends ToolSet>({\n  toolCalls,\n  tools,\n  tracer,\n  telemetry,\n  messages,\n  abortSignal,\n}: {\n  toolCalls: ToolCallArray<TOOLS>;\n  tools: TOOLS;\n  tracer: Tracer;\n  telemetry: TelemetrySettings | undefined;\n  messages: CoreMessage[];\n  abortSignal: AbortSignal | undefined;\n}): Promise<ToolResultArray<TOOLS>> {\n  const toolResults = await Promise.all(\n    toolCalls.map(async ({ toolCallId, toolName, args }) => {\n      const tool = tools[toolName];\n\n      if (tool?.execute == null) {\n        return undefined;\n      }\n\n      const result = await recordSpan({\n        name: 'ai.toolCall',\n        attributes: selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            ...assembleOperationName({\n              operationId: 'ai.toolCall',\n              telemetry,\n            }),\n            'ai.toolCall.name': toolName,\n            'ai.toolCall.id': toolCallId,\n            'ai.toolCall.args': {\n              output: () => JSON.stringify(args),\n            },\n          },\n        }),\n        tracer,\n        fn: async span => {\n          try {\n            const result = await tool.execute!(args, {\n              toolCallId,\n              messages,\n              abortSignal,\n            });\n\n            try {\n              span.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.toolCall.result': {\n                      output: () => JSON.stringify(result),\n                    },\n                  },\n                }),\n              );\n            } catch (ignored) {\n              // JSON stringify might fail if the result is not serializable,\n              // in which case we just ignore it. In the future we might want to\n              // add an optional serialize method to the tool interface and warn\n              // if the result is not serializable.\n            }\n\n            return result;\n          } catch (error) {\n            recordErrorOnSpan(span, error);\n            throw new ToolExecutionError({\n              toolCallId,\n              toolName,\n              toolArgs: args,\n              cause: error,\n            });\n          }\n        },\n      });\n\n      return {\n        type: 'tool-result',\n        toolCallId,\n        toolName,\n        args,\n        result,\n      } as ToolResultArray<TOOLS>[number];\n    }),\n  );\n\n  return toolResults.filter(\n    (result): result is NonNullable<typeof result> => result != null,\n  );\n}\n\nclass DefaultGenerateTextResult<TOOLS extends ToolSet, OUTPUT>\n  implements GenerateTextResult<TOOLS, OUTPUT>\n{\n  readonly text: GenerateTextResult<TOOLS, OUTPUT>['text'];\n  readonly files: GenerateTextResult<TOOLS, OUTPUT>['files'];\n  readonly reasoning: GenerateTextResult<TOOLS, OUTPUT>['reasoning'];\n  readonly reasoningDetails: GenerateTextResult<\n    TOOLS,\n    OUTPUT\n  >['reasoningDetails'];\n  readonly toolCalls: GenerateTextResult<TOOLS, OUTPUT>['toolCalls'];\n  readonly toolResults: GenerateTextResult<TOOLS, OUTPUT>['toolResults'];\n  readonly finishReason: GenerateTextResult<TOOLS, OUTPUT>['finishReason'];\n  readonly usage: GenerateTextResult<TOOLS, OUTPUT>['usage'];\n  readonly warnings: GenerateTextResult<TOOLS, OUTPUT>['warnings'];\n  readonly steps: GenerateTextResult<TOOLS, OUTPUT>['steps'];\n  readonly logprobs: GenerateTextResult<TOOLS, OUTPUT>['logprobs'];\n  readonly experimental_providerMetadata: GenerateTextResult<\n    TOOLS,\n    OUTPUT\n  >['experimental_providerMetadata'];\n  readonly providerMetadata: GenerateTextResult<\n    TOOLS,\n    OUTPUT\n  >['providerMetadata'];\n  readonly response: GenerateTextResult<TOOLS, OUTPUT>['response'];\n  readonly request: GenerateTextResult<TOOLS, OUTPUT>['request'];\n  readonly sources: GenerateTextResult<TOOLS, OUTPUT>['sources'];\n\n  private readonly outputResolver: () => GenerateTextResult<\n    TOOLS,\n    OUTPUT\n  >['experimental_output'];\n\n  constructor(options: {\n    text: GenerateTextResult<TOOLS, OUTPUT>['text'];\n    files: GenerateTextResult<TOOLS, OUTPUT>['files'];\n    reasoning: GenerateTextResult<TOOLS, OUTPUT>['reasoning'];\n    reasoningDetails: GenerateTextResult<TOOLS, OUTPUT>['reasoningDetails'];\n    toolCalls: GenerateTextResult<TOOLS, OUTPUT>['toolCalls'];\n    toolResults: GenerateTextResult<TOOLS, OUTPUT>['toolResults'];\n    finishReason: GenerateTextResult<TOOLS, OUTPUT>['finishReason'];\n    usage: GenerateTextResult<TOOLS, OUTPUT>['usage'];\n    warnings: GenerateTextResult<TOOLS, OUTPUT>['warnings'];\n    logprobs: GenerateTextResult<TOOLS, OUTPUT>['logprobs'];\n    steps: GenerateTextResult<TOOLS, OUTPUT>['steps'];\n    providerMetadata: GenerateTextResult<TOOLS, OUTPUT>['providerMetadata'];\n    response: GenerateTextResult<TOOLS, OUTPUT>['response'];\n    request: GenerateTextResult<TOOLS, OUTPUT>['request'];\n    outputResolver: () => GenerateTextResult<\n      TOOLS,\n      OUTPUT\n    >['experimental_output'];\n    sources: GenerateTextResult<TOOLS, OUTPUT>['sources'];\n  }) {\n    this.text = options.text;\n    this.files = options.files;\n    this.reasoning = options.reasoning;\n    this.reasoningDetails = options.reasoningDetails;\n    this.toolCalls = options.toolCalls;\n    this.toolResults = options.toolResults;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.request = options.request;\n    this.response = options.response;\n    this.steps = options.steps;\n    this.experimental_providerMetadata = options.providerMetadata;\n    this.providerMetadata = options.providerMetadata;\n    this.logprobs = options.logprobs;\n    this.outputResolver = options.outputResolver;\n    this.sources = options.sources;\n  }\n\n  get experimental_output() {\n    return this.outputResolver();\n  }\n}\n\nfunction asReasoningDetails(\n  reasoning:\n    | string\n    | Array<\n        | { type: 'text'; text: string; signature?: string }\n        | { type: 'redacted'; data: string }\n      >\n    | undefined,\n): Array<\n  | { type: 'text'; text: string; signature?: string }\n  | { type: 'redacted'; data: string }\n> {\n  if (reasoning == null) {\n    return [];\n  }\n\n  if (typeof reasoning === 'string') {\n    return [{ type: 'text', text: reasoning }];\n  }\n\n  return reasoning;\n}\n\nfunction asFiles(\n  files:\n    | Array<{\n        data: string | Uint8Array;\n        mimeType: string;\n      }>\n    | undefined,\n): Array<GeneratedFile> {\n  return files?.map(file => new DefaultGeneratedFile(file)) ?? [];\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_NoOutputSpecifiedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when no output type is specified and output-related methods are called.\n */\nexport class NoOutputSpecifiedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message = 'No output specified.' }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is NoOutputSpecifiedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError, getErrorMessage, JSONValue } from '@ai-sdk/provider';\n\nconst name = 'AI_ToolExecutionError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class ToolExecutionError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly toolName: string;\n  readonly toolArgs: JSONValue;\n  readonly toolCallId: string;\n\n  constructor({\n    toolArgs,\n    toolName,\n    toolCallId,\n    cause,\n    message = `Error executing tool ${toolName}: ${getErrorMessage(cause)}`,\n  }: {\n    message?: string;\n    toolArgs: JSONValue;\n    toolName: string;\n    toolCallId: string;\n    cause: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.toolArgs = toolArgs;\n    this.toolName = toolName;\n    this.toolCallId = toolCallId;\n  }\n\n  static isInstance(error: unknown): error is ToolExecutionError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import {\n  LanguageModelV1FunctionTool,\n  LanguageModelV1ProviderDefinedTool,\n  LanguageModelV1ToolChoice,\n} from '@ai-sdk/provider';\nimport { asSchema } from '@ai-sdk/ui-utils';\nimport { ToolSet } from '../generate-text';\nimport { ToolChoice } from '../types/language-model';\nimport { isNonEmptyObject } from '../util/is-non-empty-object';\n\nexport function prepareToolsAndToolChoice<TOOLS extends ToolSet>({\n  tools,\n  toolChoice,\n  activeTools,\n}: {\n  tools: TOOLS | undefined;\n  toolChoice: ToolChoice<TOOLS> | undefined;\n  activeTools: Array<keyof TOOLS> | undefined;\n}): {\n  tools:\n    | Array<LanguageModelV1FunctionTool | LanguageModelV1ProviderDefinedTool>\n    | undefined;\n  toolChoice: LanguageModelV1ToolChoice | undefined;\n} {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: undefined,\n      toolChoice: undefined,\n    };\n  }\n\n  // when activeTools is provided, we only include the tools that are in the list:\n  const filteredTools =\n    activeTools != null\n      ? Object.entries(tools).filter(([name]) =>\n          activeTools.includes(name as keyof TOOLS),\n        )\n      : Object.entries(tools);\n\n  return {\n    tools: filteredTools.map(([name, tool]) => {\n      const toolType = tool.type;\n      switch (toolType) {\n        case undefined:\n        case 'function':\n          return {\n            type: 'function' as const,\n            name,\n            description: tool.description,\n            parameters: asSchema(tool.parameters).jsonSchema,\n          };\n        case 'provider-defined':\n          return {\n            type: 'provider-defined' as const,\n            name,\n            id: tool.id,\n            args: tool.args,\n          };\n        default: {\n          const exhaustiveCheck: never = toolType;\n          throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n        }\n      }\n    }),\n    toolChoice:\n      toolChoice == null\n        ? { type: 'auto' }\n        : typeof toolChoice === 'string'\n          ? { type: toolChoice }\n          : { type: 'tool' as const, toolName: toolChoice.toolName as string },\n  };\n}\n", "export function isNonEmptyObject(\n  object: Record<string, unknown> | undefined | null,\n): object is Record<string, unknown> {\n  return object != null && Object.keys(object).length > 0;\n}\n", "const lastWhitespaceRegexp = /^([\\s\\S]*?)(\\s+)(\\S*)$/;\n\n/**\n * Splits the text on the last whitespace.\n *\n * Whitespace is defined as one or more whitespace characters,\n * e.g. space, tab, newline, etc.\n *\n * @param text - The text to split.\n * @returns The prefix, whitespace, and suffix. Undefined if there is no whitespace.\n */\nexport function splitOnLastWhitespace(text: string):\n  | {\n      prefix: string;\n      whitespace: string;\n      suffix: string;\n    }\n  | undefined {\n  const match = text.match(lastWhitespaceRegexp);\n  return match\n    ? { prefix: match[1], whitespace: match[2], suffix: match[3] }\n    : undefined;\n}\n", "import { splitOnLastWhitespace } from './split-on-last-whitespace';\n\nexport function removeTextAfterLastWhitespace(text: string): string {\n  const match = splitOnLastWhitespace(text);\n  return match ? match.prefix + match.whitespace : text;\n}\n", "import { LanguageModelV1FunctionToolCall } from '@ai-sdk/provider';\nimport { safeParseJSON, safeValidateTypes } from '@ai-sdk/provider-utils';\nimport { Schema, asSchema } from '@ai-sdk/ui-utils';\nimport { InvalidToolArgumentsError } from '../../errors/invalid-tool-arguments-error';\nimport { NoSuchToolError } from '../../errors/no-such-tool-error';\nimport { ToolCallRepairError } from '../../errors/tool-call-repair-error';\nimport { CoreMessage } from '../prompt';\nimport { inferParameters } from '../tool/tool';\nimport { ToolCallUnion } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair';\nimport { ToolSet } from './tool-set';\n\nexport async function parseToolCall<TOOLS extends ToolSet>({\n  toolCall,\n  tools,\n  repairToolCall,\n  system,\n  messages,\n}: {\n  toolCall: LanguageModelV1FunctionToolCall;\n  tools: TOOLS | undefined;\n  repairToolCall: ToolCallRepairFunction<TOOLS> | undefined;\n  system: string | undefined;\n  messages: CoreMessage[];\n}): Promise<ToolCallUnion<TOOLS>> {\n  if (tools == null) {\n    throw new NoSuchToolError({ toolName: toolCall.toolName });\n  }\n\n  try {\n    return await doParseToolCall({ toolCall, tools });\n  } catch (error) {\n    if (\n      repairToolCall == null ||\n      !(\n        NoSuchToolError.isInstance(error) ||\n        InvalidToolArgumentsError.isInstance(error)\n      )\n    ) {\n      throw error;\n    }\n\n    let repairedToolCall: LanguageModelV1FunctionToolCall | null = null;\n\n    try {\n      repairedToolCall = await repairToolCall({\n        toolCall,\n        tools,\n        parameterSchema: ({ toolName }) =>\n          asSchema(tools[toolName].parameters).jsonSchema,\n        system,\n        messages,\n        error,\n      });\n    } catch (repairError) {\n      throw new ToolCallRepairError({\n        cause: repairError,\n        originalError: error,\n      });\n    }\n\n    // no repaired tool call returned\n    if (repairedToolCall == null) {\n      throw error;\n    }\n\n    return await doParseToolCall({ toolCall: repairedToolCall, tools });\n  }\n}\n\nasync function doParseToolCall<TOOLS extends ToolSet>({\n  toolCall,\n  tools,\n}: {\n  toolCall: LanguageModelV1FunctionToolCall;\n  tools: TOOLS;\n}): Promise<ToolCallUnion<TOOLS>> {\n  const toolName = toolCall.toolName as keyof TOOLS & string;\n\n  const tool = tools[toolName];\n\n  if (tool == null) {\n    throw new NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools),\n    });\n  }\n\n  const schema = asSchema(tool.parameters) as Schema<\n    inferParameters<TOOLS[keyof TOOLS]['parameters']>\n  >;\n\n  // when the tool call has no arguments, we try passing an empty object to the schema\n  // (many LLMs generate empty strings for tool calls with no arguments)\n  const parseResult =\n    toolCall.args.trim() === ''\n      ? safeValidateTypes({ value: {}, schema })\n      : safeParseJSON({ text: toolCall.args, schema });\n\n  if (parseResult.success === false) {\n    throw new InvalidToolArgumentsError({\n      toolName,\n      toolArgs: toolCall.args,\n      cause: parseResult.error,\n    });\n  }\n\n  return {\n    type: 'tool-call',\n    toolCallId: toolCall.toolCallId,\n    toolName,\n    args: parseResult.value,\n  };\n}\n", "import { AISDKError, getErrorMessage } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidToolArgumentsError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidToolArgumentsError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly toolName: string;\n  readonly toolArgs: string;\n\n  constructor({\n    toolArgs,\n    toolName,\n    cause,\n    message = `Invalid arguments for tool ${toolName}: ${getErrorMessage(\n      cause,\n    )}`,\n  }: {\n    message?: string;\n    toolArgs: string;\n    toolName: string;\n    cause: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.toolArgs = toolArgs;\n    this.toolName = toolName;\n  }\n\n  static isInstance(error: unknown): error is InvalidToolArgumentsError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_NoSuchToolError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchToolError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly toolName: string;\n  readonly availableTools: string[] | undefined;\n\n  constructor({\n    toolName,\n    availableTools = undefined,\n    message = `Model tried to call unavailable tool '${toolName}'. ${\n      availableTools === undefined\n        ? 'No tools are available.'\n        : `Available tools: ${availableTools.join(', ')}.`\n    }`,\n  }: {\n    toolName: string;\n    availableTools?: string[] | undefined;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.toolName = toolName;\n    this.availableTools = availableTools;\n  }\n\n  static isInstance(error: unknown): error is NoSuchToolError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError, getErrorMessage } from '@ai-sdk/provider';\nimport { InvalidToolArgumentsError } from './invalid-tool-arguments-error';\nimport { NoSuchToolError } from './no-such-tool-error';\n\nconst name = 'AI_ToolCallRepairError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class ToolCallRepairError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly originalError: NoSuchToolError | InvalidToolArgumentsError;\n\n  constructor({\n    cause,\n    originalError,\n    message = `Error repairing tool call: ${getErrorMessage(cause)}`,\n  }: {\n    message?: string;\n    cause: unknown;\n    originalError: NoSuchToolError | InvalidToolArgumentsError;\n  }) {\n    super({ name, message, cause });\n    this.originalError = originalError;\n  }\n\n  static isInstance(error: unknown): error is ToolCallRepairError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "export type ReasoningDetail =\n  | { type: 'text'; text: string; signature?: string }\n  | { type: 'redacted'; data: string };\n\nexport function asReasoningText(\n  reasoning: Array<ReasoningDetail>,\n): string | undefined {\n  const reasoningText = reasoning\n    .filter(part => part.type === 'text')\n    .map(part => part.text)\n    .join('');\n\n  return reasoningText.length > 0 ? reasoningText : undefined;\n}\n", "import { ToolResultPart } from '../prompt';\nimport { GeneratedFile } from './generated-file';\nimport { ReasoningDetail } from './reasoning-detail';\nimport { ResponseMessage } from './step-result';\nimport { ToolCallArray } from './tool-call';\nimport { ToolResultArray } from './tool-result';\nimport { ToolSet } from './tool-set';\n\n/**\nConverts the result of a `generateText` or `streamText` call to a list of response messages.\n */\nexport function toResponseMessages<TOOLS extends ToolSet>({\n  text = '',\n  files,\n  reasoning,\n  tools,\n  toolCalls,\n  toolResults,\n  messageId,\n  generateMessageId,\n}: {\n  text: string | undefined;\n  files: Array<GeneratedFile>;\n  reasoning: Array<ReasoningDetail>;\n  tools: TOOLS;\n  toolCalls: ToolCallArray<TOOLS>;\n  toolResults: ToolResultArray<TOOLS>;\n  messageId: string;\n  generateMessageId: () => string;\n}): Array<ResponseMessage> {\n  const responseMessages: Array<ResponseMessage> = [];\n\n  const content = [];\n\n  // TODO language model v2: switch to order response content (instead of type-based ordering)\n\n  if (reasoning.length > 0) {\n    content.push(\n      ...reasoning.map(part =>\n        part.type === 'text'\n          ? { ...part, type: 'reasoning' as const }\n          : { ...part, type: 'redacted-reasoning' as const },\n      ),\n    );\n  }\n\n  if (files.length > 0) {\n    content.push(\n      ...files.map(file => ({\n        type: 'file' as const,\n        data: file.base64,\n        mimeType: file.mimeType,\n      })),\n    );\n  }\n\n  if (text.length > 0) {\n    content.push({ type: 'text' as const, text });\n  }\n\n  if (toolCalls.length > 0) {\n    content.push(...toolCalls);\n  }\n\n  if (content.length > 0) {\n    responseMessages.push({\n      role: 'assistant',\n      content,\n      id: messageId,\n    });\n  }\n\n  if (toolResults.length > 0) {\n    responseMessages.push({\n      role: 'tool',\n      id: generateMessageId(),\n      content: toolResults.map((toolResult): ToolResultPart => {\n        const tool = tools[toolResult.toolName];\n        return tool?.experimental_toToolResultContent != null\n          ? {\n              type: 'tool-result',\n              toolCallId: toolResult.toolCallId,\n              toolName: toolResult.toolName,\n              result: tool.experimental_toToolResultContent(toolResult.result),\n              experimental_content: tool.experimental_toToolResultContent(\n                toolResult.result,\n              ),\n            }\n          : {\n              type: 'tool-result',\n              toolCallId: toolResult.toolCallId,\n              toolName: toolResult.toolName,\n              result: toolResult.result,\n            };\n      }),\n    });\n  }\n\n  return responseMessages;\n}\n", "import { safeParseJSON, safeValidateTypes } from '@ai-sdk/provider-utils';\nimport {\n  asSchema,\n  DeepPartial,\n  parsePartialJson,\n  Schema,\n} from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { NoObjectGeneratedError } from '../../errors';\nimport { injectJsonInstruction } from '../generate-object/inject-json-instruction';\nimport {\n  FinishReason,\n  LanguageModel,\n  LanguageModelV1CallOptions,\n} from '../types/language-model';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { LanguageModelUsage } from '../types/usage';\n\nexport interface Output<OUTPUT, PARTIAL> {\n  readonly type: 'object' | 'text';\n  injectIntoSystemPrompt(options: {\n    system: string | undefined;\n    model: LanguageModel;\n  }): string | undefined;\n\n  responseFormat: (options: {\n    model: LanguageModel;\n  }) => LanguageModelV1CallOptions['responseFormat'];\n\n  parsePartial(options: { text: string }): { partial: PARTIAL } | undefined;\n\n  parseOutput(\n    options: { text: string },\n    context: {\n      response: LanguageModelResponseMetadata;\n      usage: LanguageModelUsage;\n      finishReason: FinishReason;\n    },\n  ): OUTPUT;\n}\n\nexport const text = (): Output<string, string> => ({\n  type: 'text',\n\n  responseFormat: () => ({ type: 'text' }),\n\n  injectIntoSystemPrompt({ system }: { system: string | undefined }) {\n    return system;\n  },\n\n  parsePartial({ text }: { text: string }) {\n    return { partial: text };\n  },\n\n  parseOutput({ text }: { text: string }) {\n    return text;\n  },\n});\n\nexport const object = <OUTPUT>({\n  schema: inputSchema,\n}: {\n  schema: z.Schema<OUTPUT, z.ZodTypeDef, any> | Schema<OUTPUT>;\n}): Output<OUTPUT, DeepPartial<OUTPUT>> => {\n  const schema = asSchema(inputSchema);\n\n  return {\n    type: 'object',\n\n    responseFormat: ({ model }) => ({\n      type: 'json',\n      schema: model.supportsStructuredOutputs ? schema.jsonSchema : undefined,\n    }),\n\n    injectIntoSystemPrompt({ system, model }) {\n      // when the model supports structured outputs,\n      // we can use the system prompt as is:\n      return model.supportsStructuredOutputs\n        ? system\n        : injectJsonInstruction({\n            prompt: system,\n            schema: schema.jsonSchema,\n          });\n    },\n\n    parsePartial({ text }: { text: string }) {\n      const result = parsePartialJson(text);\n\n      switch (result.state) {\n        case 'failed-parse':\n        case 'undefined-input':\n          return undefined;\n\n        case 'repaired-parse':\n        case 'successful-parse':\n          return {\n            // Note: currently no validation of partial results:\n            partial: result.value as DeepPartial<OUTPUT>,\n          };\n\n        default: {\n          const _exhaustiveCheck: never = result.state;\n          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n\n    parseOutput(\n      { text }: { text: string },\n      context: {\n        response: LanguageModelResponseMetadata;\n        usage: LanguageModelUsage;\n        finishReason: FinishReason;\n      },\n    ) {\n      const parseResult = safeParseJSON({ text });\n\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: 'No object generated: could not parse the response.',\n          cause: parseResult.error,\n          text,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason,\n        });\n      }\n\n      const validationResult = safeValidateTypes({\n        value: parseResult.value,\n        schema,\n      });\n\n      if (!validationResult.success) {\n        throw new NoObjectGeneratedError({\n          message: 'No object generated: response did not match schema.',\n          cause: validationResult.error,\n          text,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason,\n        });\n      }\n\n      return validationResult.value;\n    },\n  };\n};\n", "export {\n  AISDKError,\n  APICallError,\n  EmptyResponseBodyError,\n  InvalidPromptError,\n  InvalidResponseDataError,\n  JSONParseError,\n  LoadAPIKeyError,\n  NoContentGeneratedError,\n  NoSuchModelError,\n  TypeValidationError,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\n\nexport { InvalidArgumentError } from './invalid-argument-error';\nexport { InvalidStreamPartError } from './invalid-stream-part-error';\nexport { InvalidToolArgumentsError } from './invalid-tool-arguments-error';\nexport { NoImageGeneratedError } from './no-image-generated-error';\nexport { NoObjectGeneratedError } from './no-object-generated-error';\nexport { NoOutputSpecifiedError } from './no-output-specified-error';\nexport { NoSuchToolError } from './no-such-tool-error';\nexport { ToolCallRepairError } from './tool-call-repair-error';\nexport { ToolExecutionError } from './tool-execution-error';\nexport { MCPClientError } from './mcp-client-error';\nexport { UnsupportedModelVersionError } from './unsupported-model-version-error';\n\nexport { InvalidDataContentError } from '../core/prompt/invalid-data-content-error';\nexport { InvalidMessageRoleError } from '../core/prompt/invalid-message-role-error';\nexport { MessageConversionError } from '../core/prompt/message-conversion-error';\nexport { DownloadError } from '../util/download-error';\nexport { RetryError } from '../util/retry-error';\n", "import { AISDKError } from '@ai-sdk/provider';\nimport { SingleRequestTextStreamPart } from '../core/generate-text/run-tools-transformation';\n\nconst name = 'AI_InvalidStreamPartError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidStreamPartError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly chunk: SingleRequestTextStreamPart<any>;\n\n  constructor({\n    chunk,\n    message,\n  }: {\n    chunk: SingleRequestTextStreamPart<any>;\n    message: string;\n  }) {\n    super({ name, message });\n\n    this.chunk = chunk;\n  }\n\n  static isInstance(error: unknown): error is InvalidStreamPartError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_MCPClientError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * An error occurred with the MCP client.\n */\nexport class MCPClientError extends AISDKError {\n  private readonly [symbol] = true;\n\n  constructor({\n    name = 'MCPClientError',\n    message,\n    cause,\n  }: {\n    name?: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n  }\n\n  static isInstance(error: unknown): error is MCPClientError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { delay as originalDelay } from '@ai-sdk/provider-utils';\nimport { TextStreamPart } from './stream-text-result';\nimport { ToolSet } from './tool-set';\nimport { InvalidArgumentError } from '@ai-sdk/provider';\n\nconst CHUNKING_REGEXPS = {\n  word: /\\S+\\s+/m,\n  line: /\\n+/m,\n};\n\n/**\n * Detects the first chunk in a buffer.\n *\n * @param buffer - The buffer to detect the first chunk in.\n *\n * @returns The first detected chunk, or `undefined` if no chunk was detected.\n */\nexport type ChunkDetector = (buffer: string) => string | undefined | null;\n\n/**\n * Smooths text streaming output.\n *\n * @param delayInMs - The delay in milliseconds between each chunk. Defaults to 10ms. Can be set to `null` to skip the delay.\n * @param chunking - Controls how the text is chunked for streaming. Use \"word\" to stream word by word (default), \"line\" to stream line by line, or provide a custom RegExp pattern for custom chunking.\n *\n * @returns A transform stream that smooths text streaming output.\n */\nexport function smoothStream<TOOLS extends ToolSet>({\n  delayInMs = 10,\n  chunking = 'word',\n  _internal: { delay = originalDelay } = {},\n}: {\n  delayInMs?: number | null;\n  chunking?: 'word' | 'line' | RegExp | ChunkDetector;\n  /**\n   * Internal. For test use only. May change without notice.\n   */\n  _internal?: {\n    delay?: (delayInMs: number | null) => Promise<void>;\n  };\n} = {}): (options: {\n  tools: TOOLS;\n}) => TransformStream<TextStreamPart<TOOLS>, TextStreamPart<TOOLS>> {\n  let detectChunk: ChunkDetector;\n\n  if (typeof chunking === 'function') {\n    detectChunk = buffer => {\n      const match = chunking(buffer);\n\n      if (match == null) {\n        return null;\n      }\n\n      if (!match.length) {\n        throw new Error(`Chunking function must return a non-empty string.`);\n      }\n\n      if (!buffer.startsWith(match)) {\n        throw new Error(\n          `Chunking function must return a match that is a prefix of the buffer. Received: \"${match}\" expected to start with \"${buffer}\"`,\n        );\n      }\n\n      return match;\n    };\n  } else {\n    const chunkingRegex =\n      typeof chunking === 'string' ? CHUNKING_REGEXPS[chunking] : chunking;\n\n    if (chunkingRegex == null) {\n      throw new InvalidArgumentError({\n        argument: 'chunking',\n        message: `Chunking must be \"word\" or \"line\" or a RegExp. Received: ${chunking}`,\n      });\n    }\n\n    detectChunk = buffer => {\n      const match = chunkingRegex.exec(buffer);\n\n      if (!match) {\n        return null;\n      }\n\n      return buffer.slice(0, match.index) + match?.[0];\n    };\n  }\n\n  return () => {\n    let buffer = '';\n\n    return new TransformStream<TextStreamPart<TOOLS>, TextStreamPart<TOOLS>>({\n      async transform(chunk, controller) {\n        if (chunk.type !== 'text-delta') {\n          if (buffer.length > 0) {\n            controller.enqueue({ type: 'text-delta', textDelta: buffer });\n            buffer = '';\n          }\n\n          controller.enqueue(chunk);\n          return;\n        }\n\n        buffer += chunk.textDelta;\n\n        let match;\n\n        while ((match = detectChunk(buffer)) != null) {\n          controller.enqueue({ type: 'text-delta', textDelta: match });\n          buffer = buffer.slice(match.length);\n\n          await delay(delayInMs);\n        }\n      },\n    });\n  };\n}\n", "import { AISDKError, LanguageModelV1Source } from '@ai-sdk/provider';\nimport { createIdGenerator, IDGenerator } from '@ai-sdk/provider-utils';\nimport { DataStreamString, formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { Span } from '@opentelemetry/api';\nimport { ServerResponse } from 'node:http';\nimport { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport { InvalidStreamPartError } from '../../errors/invalid-stream-part-error';\nimport { NoOutputSpecifiedError } from '../../errors/no-output-specified-error';\nimport { UnsupportedModelVersionError } from '../../errors/unsupported-model-version-error';\nimport { StreamData } from '../../streams/stream-data';\nimport { asArray } from '../../util/as-array';\nimport { consumeStream } from '../../util/consume-stream';\nimport { DelayedPromise } from '../../util/delayed-promise';\nimport { DataStreamWriter } from '../data-stream/data-stream-writer';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { CoreAssistantMessage } from '../prompt/message';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { prepareToolsAndToolChoice } from '../prompt/prepare-tools-and-tool-choice';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { stringifyForTelemetry } from '../prompt/stringify-for-telemetry';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  FinishReason,\n  LanguageModel,\n  LogProbs,\n  ToolChoice,\n} from '../types/language-model';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { ProviderMetadata, ProviderOptions } from '../types/provider-metadata';\nimport { addLanguageModelUsage, LanguageModelUsage } from '../types/usage';\nimport {\n  AsyncIterableStream,\n  createAsyncIterableStream,\n} from '../util/async-iterable-stream';\nimport { createStitchableStream } from '../util/create-stitchable-stream';\nimport { mergeStreams } from '../util/merge-streams';\nimport { now as originalNow } from '../util/now';\nimport { prepareOutgoingHttpHeaders } from '../util/prepare-outgoing-http-headers';\nimport { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { splitOnLastWhitespace } from '../util/split-on-last-whitespace';\nimport { writeToServerResponse } from '../util/write-to-server-response';\nimport { GeneratedFile } from './generated-file';\nimport { Output } from './output';\nimport { asReasoningText, ReasoningDetail } from './reasoning-detail';\nimport {\n  runToolsTransformation,\n  SingleRequestTextStreamPart,\n} from './run-tools-transformation';\nimport { ResponseMessage, StepResult } from './step-result';\nimport {\n  ConsumeStreamOptions,\n  DataStreamOptions,\n  StreamTextResult,\n  TextStreamPart,\n} from './stream-text-result';\nimport { toResponseMessages } from './to-response-messages';\nimport { ToolCallUnion } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair';\nimport { ToolResultUnion } from './tool-result';\nimport { ToolSet } from './tool-set';\n\nconst originalGenerateId = createIdGenerator({\n  prefix: 'aitxt',\n  size: 24,\n});\n\nconst originalGenerateMessageId = createIdGenerator({\n  prefix: 'msg',\n  size: 24,\n});\n\n/**\nA transformation that is applied to the stream.\n\n@param stopStream - A function that stops the source stream.\n@param tools - The tools that are accessible to and can be called by the model. The model needs to support calling tools.\n */\nexport type StreamTextTransform<TOOLS extends ToolSet> = (options: {\n  tools: TOOLS; // for type inference\n  stopStream: () => void;\n}) => TransformStream<TextStreamPart<TOOLS>, TextStreamPart<TOOLS>>;\n\n/**\nCallback that is set using the `onError` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamTextOnErrorCallback = (event: {\n  error: unknown;\n}) => Promise<void> | void;\n\n/**\nCallback that is set using the `onStepFinish` option.\n\n@param stepResult - The result of the step.\n */\nexport type StreamTextOnStepFinishCallback<TOOLS extends ToolSet> = (\n  stepResult: StepResult<TOOLS>,\n) => Promise<void> | void;\n\n/**\nCallback that is set using the `onChunk` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamTextOnChunkCallback<TOOLS extends ToolSet> = (event: {\n  chunk: Extract<\n    TextStreamPart<TOOLS>,\n    {\n      type:\n        | 'text-delta'\n        | 'reasoning'\n        | 'source'\n        | 'tool-call'\n        | 'tool-call-streaming-start'\n        | 'tool-call-delta'\n        | 'tool-result';\n    }\n  >;\n}) => Promise<void> | void;\n\n/**\nCallback that is set using the `onFinish` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamTextOnFinishCallback<TOOLS extends ToolSet> = (\n  event: Omit<StepResult<TOOLS>, 'stepType' | 'isContinued'> & {\n    /**\nDetails for all steps.\n   */\n    readonly steps: StepResult<TOOLS>[];\n  },\n) => Promise<void> | void;\n\n/**\nGenerate a text and call tools for a given prompt using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateText` instead.\n\n@param model - The language model to use.\n@param tools - Tools that are accessible to and can be called by the model. The model needs to support calling tools.\n\n@param system - A system message that will be part of the prompt.\n@param prompt - A simple text prompt. You can either use `prompt` or `messages` but not both.\n@param messages - A list of messages. You can either use `prompt` or `messages` but not both.\n\n@param maxTokens - Maximum number of tokens to generate.\n@param temperature - Temperature setting.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topP - Nucleus sampling.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topK - Only sample from the top K options for each subsequent token.\nUsed to remove \"long tail\" low probability responses.\nRecommended for advanced use cases only. You usually only need to use temperature.\n@param presencePenalty - Presence penalty setting.\nIt affects the likelihood of the model to repeat information that is already in the prompt.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param frequencyPenalty - Frequency penalty setting.\nIt affects the likelihood of the model to repeatedly use the same words or phrases.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param stopSequences - Stop sequences.\nIf set, the model will stop generating text when one of the stop sequences is generated.\n@param seed - The seed (integer) to use for random sampling.\nIf set and supported by the model, calls will generate deterministic results.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@param maxSteps - Maximum number of sequential LLM calls (steps), e.g. when you use tool calls.\n@param experimental_generateMessageId - Generate a unique ID for each message.\n\n@param onChunk - Callback that is called for each chunk of the stream. The stream processing will pause until the callback promise is resolved.\n@param onError - Callback that is called when an error occurs during streaming. You can use it to log errors.\n@param onStepFinish - Callback that is called when each step (LLM call) is finished, including intermediate steps.\n@param onFinish - Callback that is called when the LLM response and all request tool executions\n(for tools that have an `execute` function) are finished.\n\n@return\nA result object for accessing different stream types and additional information.\n */\nexport function streamText<\n  TOOLS extends ToolSet,\n  OUTPUT = never,\n  PARTIAL_OUTPUT = never,\n>({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  maxSteps = 1,\n  experimental_generateMessageId: generateMessageId = originalGenerateMessageId,\n  experimental_output: output,\n  experimental_continueSteps: continueSteps = false,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  experimental_toolCallStreaming = false,\n  toolCallStreaming = experimental_toolCallStreaming,\n  experimental_activeTools: activeTools,\n  experimental_repairToolCall: repairToolCall,\n  experimental_transform: transform,\n  onChunk,\n  onError,\n  onFinish,\n  onStepFinish,\n  _internal: {\n    now = originalNow,\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n  } = {},\n  ...settings\n}: CallSettings &\n  Prompt & {\n    /**\nThe language model to use.\n     */\n    model: LanguageModel;\n\n    /**\nThe tools that the model can call. The model needs to support calling tools.\n    */\n    tools?: TOOLS;\n\n    /**\nThe tool choice strategy. Default: 'auto'.\n     */\n    toolChoice?: ToolChoice<TOOLS>;\n\n    /**\nMaximum number of sequential LLM calls (steps), e.g. when you use tool calls. Must be at least 1.\n\nA maximum number is required to prevent infinite loops in the case of misconfigured tools.\n\nBy default, it's set to 1, which means that only a single LLM call is made.\n */\n    maxSteps?: number;\n\n    /**\nGenerate a unique ID for each message.\n     */\n    experimental_generateMessageId?: IDGenerator;\n\n    /**\nWhen enabled, the model will perform additional steps if the finish reason is \"length\" (experimental).\n\nBy default, it's set to false.\n     */\n    experimental_continueSteps?: boolean;\n\n    /**\nOptional telemetry configuration (experimental).\n     */\n    experimental_telemetry?: TelemetrySettings;\n\n    /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n    providerOptions?: ProviderOptions;\n\n    /**\n@deprecated Use `providerOptions` instead.\n */\n    experimental_providerMetadata?: ProviderMetadata;\n\n    /**\nLimits the tools that are available for the model to call without\nchanging the tool call and result types in the result.\n     */\n    experimental_activeTools?: Array<keyof TOOLS>;\n\n    /**\nOptional specification for parsing structured outputs from the LLM response.\n     */\n    experimental_output?: Output<OUTPUT, PARTIAL_OUTPUT>;\n\n    /**\nA function that attempts to repair a tool call that failed to parse.\n     */\n    experimental_repairToolCall?: ToolCallRepairFunction<TOOLS>;\n\n    /**\nEnable streaming of tool call deltas as they are generated. Disabled by default.\n     */\n    toolCallStreaming?: boolean;\n\n    /**\n@deprecated Use `toolCallStreaming` instead.\n     */\n    experimental_toolCallStreaming?: boolean;\n\n    /**\nOptional stream transformations.\nThey are applied in the order they are provided.\nThe stream transformations must maintain the stream structure for streamText to work correctly.\n     */\n    experimental_transform?:\n      | StreamTextTransform<TOOLS>\n      | Array<StreamTextTransform<TOOLS>>;\n\n    /**\nCallback that is called for each chunk of the stream.\nThe stream processing will pause until the callback promise is resolved.\n     */\n    onChunk?: StreamTextOnChunkCallback<TOOLS>;\n\n    /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n    onError?: StreamTextOnErrorCallback;\n\n    /**\nCallback that is called when the LLM response and all request tool executions\n(for tools that have an `execute` function) are finished.\n\nThe usage is the combined usage of all steps.\n     */\n    onFinish?: StreamTextOnFinishCallback<TOOLS>;\n\n    /**\nCallback that is called when each step (LLM call) is finished, including intermediate steps.\n    */\n    onStepFinish?: StreamTextOnStepFinishCallback<TOOLS>;\n\n    /**\nInternal. For test use only. May change without notice.\n     */\n    _internal?: {\n      now?: () => number;\n      generateId?: IDGenerator;\n      currentDate?: () => Date;\n    };\n  }): StreamTextResult<TOOLS, PARTIAL_OUTPUT> {\n  if (typeof model === 'string' || model.specificationVersion !== 'v1') {\n    throw new UnsupportedModelVersionError();\n  }\n\n  return new DefaultStreamTextResult<TOOLS, OUTPUT, PARTIAL_OUTPUT>({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    toolCallStreaming,\n    transforms: asArray(transform),\n    activeTools,\n    repairToolCall,\n    maxSteps,\n    output,\n    continueSteps,\n    providerOptions,\n    onChunk,\n    onError,\n    onFinish,\n    onStepFinish,\n    now,\n    currentDate,\n    generateId,\n    generateMessageId,\n  });\n}\n\ntype EnrichedStreamPart<TOOLS extends ToolSet, PARTIAL_OUTPUT> = {\n  part: TextStreamPart<TOOLS>;\n  partialOutput: PARTIAL_OUTPUT | undefined;\n};\n\nfunction createOutputTransformStream<\n  TOOLS extends ToolSet,\n  OUTPUT,\n  PARTIAL_OUTPUT,\n>(\n  output: Output<OUTPUT, PARTIAL_OUTPUT> | undefined,\n): TransformStream<\n  TextStreamPart<TOOLS>,\n  EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n> {\n  if (!output) {\n    return new TransformStream<\n      TextStreamPart<TOOLS>,\n      EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n    >({\n      transform(chunk, controller) {\n        controller.enqueue({ part: chunk, partialOutput: undefined });\n      },\n    });\n  }\n\n  let text = '';\n  let textChunk = '';\n  let lastPublishedJson = '';\n\n  function publishTextChunk({\n    controller,\n    partialOutput = undefined,\n  }: {\n    controller: TransformStreamDefaultController<\n      EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n    >;\n    partialOutput?: PARTIAL_OUTPUT;\n  }) {\n    controller.enqueue({\n      part: { type: 'text-delta', textDelta: textChunk },\n      partialOutput,\n    });\n    textChunk = '';\n  }\n\n  return new TransformStream<\n    TextStreamPart<TOOLS>,\n    EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n  >({\n    transform(chunk, controller) {\n      // ensure that we publish the last text chunk before the step finish:\n      if (chunk.type === 'step-finish') {\n        publishTextChunk({ controller });\n      }\n\n      if (chunk.type !== 'text-delta') {\n        controller.enqueue({ part: chunk, partialOutput: undefined });\n        return;\n      }\n\n      text += chunk.textDelta;\n      textChunk += chunk.textDelta;\n\n      // only publish if partial json can be parsed:\n      const result = output.parsePartial({ text });\n      if (result != null) {\n        // only send new json if it has changed:\n        const currentJson = JSON.stringify(result.partial);\n        if (currentJson !== lastPublishedJson) {\n          publishTextChunk({ controller, partialOutput: result.partial });\n          lastPublishedJson = currentJson;\n        }\n      }\n    },\n\n    flush(controller) {\n      // publish remaining text (there should be none if the content was correctly formatted):\n      if (textChunk.length > 0) {\n        publishTextChunk({ controller });\n      }\n    },\n  });\n}\n\nclass DefaultStreamTextResult<TOOLS extends ToolSet, OUTPUT, PARTIAL_OUTPUT>\n  implements StreamTextResult<TOOLS, PARTIAL_OUTPUT>\n{\n  private readonly warningsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['warnings']>\n  >();\n  private readonly usagePromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['usage']>\n  >();\n  private readonly finishReasonPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['finishReason']>\n  >();\n  private readonly providerMetadataPromise = new DelayedPromise<\n    Awaited<\n      StreamTextResult<TOOLS, PARTIAL_OUTPUT>['experimental_providerMetadata']\n    >\n  >();\n  private readonly textPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['text']>\n  >();\n  private readonly reasoningPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['reasoning']>\n  >();\n  private readonly reasoningDetailsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['reasoningDetails']>\n  >();\n  private readonly sourcesPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['sources']>\n  >();\n  private readonly filesPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['files']>\n  >();\n  private readonly toolCallsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['toolCalls']>\n  >();\n  private readonly toolResultsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['toolResults']>\n  >();\n  private readonly requestPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['request']>\n  >();\n  private readonly responsePromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['response']>\n  >();\n  private readonly stepsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['steps']>\n  >();\n\n  private readonly addStream: (\n    stream: ReadableStream<TextStreamPart<TOOLS>>,\n  ) => void;\n\n  private readonly closeStream: () => void;\n\n  private baseStream: ReadableStream<EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>>;\n\n  private output: Output<OUTPUT, PARTIAL_OUTPUT> | undefined;\n\n  constructor({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    toolCallStreaming,\n    transforms,\n    activeTools,\n    repairToolCall,\n    maxSteps,\n    output,\n    continueSteps,\n    providerOptions,\n    now,\n    currentDate,\n    generateId,\n    generateMessageId,\n    onChunk,\n    onError,\n    onFinish,\n    onStepFinish,\n  }: {\n    model: LanguageModel;\n    telemetry: TelemetrySettings | undefined;\n    headers: Record<string, string | undefined> | undefined;\n    settings: Omit<CallSettings, 'abortSignal' | 'headers'>;\n    maxRetries: number | undefined;\n    abortSignal: AbortSignal | undefined;\n    system: Prompt['system'];\n    prompt: Prompt['prompt'];\n    messages: Prompt['messages'];\n    tools: TOOLS | undefined;\n    toolChoice: ToolChoice<TOOLS> | undefined;\n    toolCallStreaming: boolean;\n    transforms: Array<StreamTextTransform<TOOLS>>;\n    activeTools: Array<keyof TOOLS> | undefined;\n    repairToolCall: ToolCallRepairFunction<TOOLS> | undefined;\n    maxSteps: number;\n    output: Output<OUTPUT, PARTIAL_OUTPUT> | undefined;\n    continueSteps: boolean;\n    providerOptions: ProviderOptions | undefined;\n    now: () => number;\n    currentDate: () => Date;\n    generateId: () => string;\n    generateMessageId: () => string;\n\n    // callbacks:\n    onChunk: undefined | StreamTextOnChunkCallback<TOOLS>;\n    onError: undefined | StreamTextOnErrorCallback;\n    onFinish: undefined | StreamTextOnFinishCallback<TOOLS>;\n    onStepFinish: undefined | StreamTextOnStepFinishCallback<TOOLS>;\n  }) {\n    if (maxSteps < 1) {\n      throw new InvalidArgumentError({\n        parameter: 'maxSteps',\n        value: maxSteps,\n        message: 'maxSteps must be at least 1',\n      });\n    }\n\n    this.output = output;\n\n    // event processor for telemetry, invoking callbacks, etc.\n    // The event processor reads the transformed stream to enable correct\n    // recording of the final transformed outputs.\n    let recordedStepText = '';\n    let recordedContinuationText = '';\n    let recordedFullText = '';\n\n    let stepReasoning: Array<ReasoningDetail> = [];\n    let stepFiles: Array<GeneratedFile> = [];\n    let activeReasoningText: undefined | (ReasoningDetail & { type: 'text' }) =\n      undefined;\n\n    let recordedStepSources: LanguageModelV1Source[] = [];\n    const recordedSources: LanguageModelV1Source[] = [];\n\n    const recordedResponse: LanguageModelResponseMetadata & {\n      messages: Array<ResponseMessage>;\n    } = {\n      id: generateId(),\n      timestamp: currentDate(),\n      modelId: model.modelId,\n      messages: [],\n    };\n    let recordedToolCalls: ToolCallUnion<TOOLS>[] = [];\n    let recordedToolResults: ToolResultUnion<TOOLS>[] = [];\n    let recordedFinishReason: FinishReason | undefined = undefined;\n    let recordedUsage: LanguageModelUsage | undefined = undefined;\n    let stepType: 'initial' | 'continue' | 'tool-result' = 'initial';\n    const recordedSteps: StepResult<TOOLS>[] = [];\n    let rootSpan!: Span;\n\n    const eventProcessor = new TransformStream<\n      EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>,\n      EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n    >({\n      async transform(chunk, controller) {\n        controller.enqueue(chunk); // forward the chunk to the next stream\n\n        const { part } = chunk;\n\n        if (\n          part.type === 'text-delta' ||\n          part.type === 'reasoning' ||\n          part.type === 'source' ||\n          part.type === 'tool-call' ||\n          part.type === 'tool-result' ||\n          part.type === 'tool-call-streaming-start' ||\n          part.type === 'tool-call-delta'\n        ) {\n          await onChunk?.({ chunk: part });\n        }\n\n        if (part.type === 'error') {\n          await onError?.({ error: part.error });\n        }\n\n        if (part.type === 'text-delta') {\n          recordedStepText += part.textDelta;\n          recordedContinuationText += part.textDelta;\n          recordedFullText += part.textDelta;\n        }\n\n        if (part.type === 'reasoning') {\n          if (activeReasoningText == null) {\n            activeReasoningText = { type: 'text', text: part.textDelta };\n            stepReasoning.push(activeReasoningText);\n          } else {\n            activeReasoningText.text += part.textDelta;\n          }\n        }\n\n        if (part.type === 'reasoning-signature') {\n          if (activeReasoningText == null) {\n            throw new AISDKError({\n              name: 'InvalidStreamPart',\n              message: 'reasoning-signature without reasoning',\n            });\n          }\n\n          activeReasoningText.signature = part.signature;\n          activeReasoningText = undefined; // signature concludes reasoning part\n        }\n\n        if (part.type === 'redacted-reasoning') {\n          stepReasoning.push({ type: 'redacted', data: part.data });\n        }\n\n        if (part.type === 'file') {\n          stepFiles.push(part);\n        }\n\n        if (part.type === 'source') {\n          recordedSources.push(part.source);\n          recordedStepSources.push(part.source);\n        }\n\n        if (part.type === 'tool-call') {\n          recordedToolCalls.push(part);\n        }\n\n        if (part.type === 'tool-result') {\n          recordedToolResults.push(part);\n        }\n\n        if (part.type === 'step-finish') {\n          const stepMessages = toResponseMessages({\n            text: recordedContinuationText,\n            files: stepFiles,\n            reasoning: stepReasoning,\n            tools: tools ?? ({} as TOOLS),\n            toolCalls: recordedToolCalls,\n            toolResults: recordedToolResults,\n            messageId: part.messageId,\n            generateMessageId,\n          });\n\n          // determine the next step type\n          const currentStep = recordedSteps.length;\n          let nextStepType: 'done' | 'continue' | 'tool-result' = 'done';\n          if (currentStep + 1 < maxSteps) {\n            if (\n              continueSteps &&\n              part.finishReason === 'length' &&\n              // only use continue when there are no tool calls:\n              recordedToolCalls.length === 0\n            ) {\n              nextStepType = 'continue';\n            } else if (\n              // there are tool calls:\n              recordedToolCalls.length > 0 &&\n              // all current tool calls have results:\n              recordedToolResults.length === recordedToolCalls.length\n            ) {\n              nextStepType = 'tool-result';\n            }\n          }\n\n          // Add step information (after response messages are updated):\n          const currentStepResult: StepResult<TOOLS> = {\n            stepType,\n            text: recordedStepText,\n            reasoning: asReasoningText(stepReasoning),\n            reasoningDetails: stepReasoning,\n            files: stepFiles,\n            sources: recordedStepSources,\n            toolCalls: recordedToolCalls,\n            toolResults: recordedToolResults,\n            finishReason: part.finishReason,\n            usage: part.usage,\n            warnings: part.warnings,\n            logprobs: part.logprobs,\n            request: part.request,\n            response: {\n              ...part.response,\n              messages: [...recordedResponse.messages, ...stepMessages],\n            },\n            providerMetadata: part.experimental_providerMetadata,\n            experimental_providerMetadata: part.experimental_providerMetadata,\n            isContinued: part.isContinued,\n          };\n\n          await onStepFinish?.(currentStepResult);\n\n          recordedSteps.push(currentStepResult);\n\n          recordedToolCalls = [];\n          recordedToolResults = [];\n          recordedStepText = '';\n          recordedStepSources = [];\n          stepReasoning = [];\n          stepFiles = [];\n          activeReasoningText = undefined;\n\n          if (nextStepType !== 'done') {\n            stepType = nextStepType;\n          }\n\n          if (nextStepType !== 'continue') {\n            recordedResponse.messages.push(...stepMessages);\n            recordedContinuationText = '';\n          }\n        }\n\n        if (part.type === 'finish') {\n          recordedResponse.id = part.response.id;\n          recordedResponse.timestamp = part.response.timestamp;\n          recordedResponse.modelId = part.response.modelId;\n          recordedResponse.headers = part.response.headers;\n          recordedUsage = part.usage;\n          recordedFinishReason = part.finishReason;\n        }\n      },\n\n      async flush(controller) {\n        try {\n          if (recordedSteps.length === 0) {\n            return; // no steps recorded (e.g. in error scenario)\n          }\n\n          // from last step (when there are errors there may be no last step)\n          const lastStep = recordedSteps[recordedSteps.length - 1];\n\n          self.warningsPromise.resolve(lastStep.warnings);\n          self.requestPromise.resolve(lastStep.request);\n          self.responsePromise.resolve(lastStep.response);\n          self.toolCallsPromise.resolve(lastStep.toolCalls);\n          self.toolResultsPromise.resolve(lastStep.toolResults);\n          self.providerMetadataPromise.resolve(\n            lastStep.experimental_providerMetadata,\n          );\n          self.reasoningPromise.resolve(lastStep.reasoning);\n          self.reasoningDetailsPromise.resolve(lastStep.reasoningDetails);\n\n          // derived:\n          const finishReason = recordedFinishReason ?? 'unknown';\n          const usage = recordedUsage ?? {\n            completionTokens: NaN,\n            promptTokens: NaN,\n            totalTokens: NaN,\n          };\n\n          // from finish:\n          self.finishReasonPromise.resolve(finishReason);\n          self.usagePromise.resolve(usage);\n\n          // aggregate results:\n          self.textPromise.resolve(recordedFullText);\n          self.sourcesPromise.resolve(recordedSources);\n          self.filesPromise.resolve(lastStep.files);\n          self.stepsPromise.resolve(recordedSteps);\n\n          // call onFinish callback:\n          await onFinish?.({\n            finishReason,\n            logprobs: undefined,\n            usage,\n            text: recordedFullText,\n            reasoning: lastStep.reasoning,\n            reasoningDetails: lastStep.reasoningDetails,\n            files: lastStep.files,\n            sources: lastStep.sources,\n            toolCalls: lastStep.toolCalls,\n            toolResults: lastStep.toolResults,\n            request: lastStep.request ?? {},\n            response: lastStep.response,\n            warnings: lastStep.warnings,\n            providerMetadata: lastStep.providerMetadata,\n            experimental_providerMetadata:\n              lastStep.experimental_providerMetadata,\n            steps: recordedSteps,\n          });\n\n          // Add response information to the root span:\n          rootSpan.setAttributes(\n            selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                'ai.response.finishReason': finishReason,\n                'ai.response.text': { output: () => recordedFullText },\n                'ai.response.toolCalls': {\n                  output: () =>\n                    lastStep.toolCalls?.length\n                      ? JSON.stringify(lastStep.toolCalls)\n                      : undefined,\n                },\n\n                'ai.usage.promptTokens': usage.promptTokens,\n                'ai.usage.completionTokens': usage.completionTokens,\n                'ai.response.providerMetadata': JSON.stringify(\n                  lastStep.providerMetadata,\n                ),\n              },\n            }),\n          );\n        } catch (error) {\n          controller.error(error);\n        } finally {\n          rootSpan.end();\n        }\n      },\n    });\n\n    // initialize the stitchable stream and the transformed stream:\n    const stitchableStream = createStitchableStream<TextStreamPart<TOOLS>>();\n    this.addStream = stitchableStream.addStream;\n    this.closeStream = stitchableStream.close;\n\n    let stream = stitchableStream.stream;\n\n    // transform the stream before output parsing\n    // to enable replacement of stream segments:\n    for (const transform of transforms) {\n      stream = stream.pipeThrough(\n        transform({\n          tools: tools as TOOLS,\n          stopStream() {\n            stitchableStream.terminate();\n          },\n        }),\n      );\n    }\n\n    this.baseStream = stream\n      .pipeThrough(createOutputTransformStream(output))\n      .pipeThrough(eventProcessor);\n\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n    });\n\n    const tracer = getTracer(telemetry);\n\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...settings, maxRetries },\n    });\n\n    const initialPrompt = standardizePrompt({\n      prompt: {\n        system: output?.injectIntoSystemPrompt({ system, model }) ?? system,\n        prompt,\n        messages,\n      },\n      tools,\n    });\n\n    const self = this;\n\n    recordSpan({\n      name: 'ai.streamText',\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({ operationId: 'ai.streamText', telemetry }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          'ai.prompt': {\n            input: () => JSON.stringify({ system, prompt, messages }),\n          },\n          'ai.settings.maxSteps': maxSteps,\n        },\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async rootSpanArg => {\n        rootSpan = rootSpanArg;\n\n        async function streamStep({\n          currentStep,\n          responseMessages,\n          usage,\n          stepType,\n          previousStepText,\n          hasLeadingWhitespace,\n          messageId,\n        }: {\n          currentStep: number;\n          responseMessages: Array<ResponseMessage>;\n          usage: LanguageModelUsage;\n          stepType: 'initial' | 'continue' | 'tool-result';\n          previousStepText: string;\n          hasLeadingWhitespace: boolean;\n          messageId: string;\n        }) {\n          // after the 1st step, we need to switch to messages format:\n          const promptFormat =\n            responseMessages.length === 0 ? initialPrompt.type : 'messages';\n\n          const stepInputMessages = [\n            ...initialPrompt.messages,\n            ...responseMessages,\n          ];\n\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: {\n              type: promptFormat,\n              system: initialPrompt.system,\n              messages: stepInputMessages,\n            },\n            modelSupportsImageUrls: model.supportsImageUrls,\n            modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context\n          });\n\n          const mode = {\n            type: 'regular' as const,\n            ...prepareToolsAndToolChoice({ tools, toolChoice, activeTools }),\n          };\n\n          const {\n            result: { stream, warnings, rawResponse, request },\n            doStreamSpan,\n            startTimestampMs,\n          } = await retry(() =>\n            recordSpan({\n              name: 'ai.streamText.doStream',\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: 'ai.streamText.doStream',\n                    telemetry,\n                  }),\n                  ...baseTelemetryAttributes,\n                  'ai.prompt.format': {\n                    input: () => promptFormat,\n                  },\n                  'ai.prompt.messages': {\n                    input: () => stringifyForTelemetry(promptMessages),\n                  },\n                  'ai.prompt.tools': {\n                    // convert the language model level tools:\n                    input: () => mode.tools?.map(tool => JSON.stringify(tool)),\n                  },\n                  'ai.prompt.toolChoice': {\n                    input: () =>\n                      mode.toolChoice != null\n                        ? JSON.stringify(mode.toolChoice)\n                        : undefined,\n                  },\n\n                  // standardized gen-ai llm span attributes:\n                  'gen_ai.system': model.provider,\n                  'gen_ai.request.model': model.modelId,\n                  'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                  'gen_ai.request.max_tokens': settings.maxTokens,\n                  'gen_ai.request.presence_penalty': settings.presencePenalty,\n                  'gen_ai.request.stop_sequences': settings.stopSequences,\n                  'gen_ai.request.temperature': settings.temperature,\n                  'gen_ai.request.top_k': settings.topK,\n                  'gen_ai.request.top_p': settings.topP,\n                },\n              }),\n              tracer,\n              endWhenDone: false,\n              fn: async doStreamSpan => ({\n                startTimestampMs: now(), // get before the call\n                doStreamSpan,\n                result: await model.doStream({\n                  mode,\n                  ...prepareCallSettings(settings),\n                  inputFormat: promptFormat,\n                  responseFormat: output?.responseFormat({ model }),\n                  prompt: promptMessages,\n                  providerMetadata: providerOptions,\n                  abortSignal,\n                  headers,\n                }),\n              }),\n            }),\n          );\n\n          const transformedStream = runToolsTransformation({\n            tools,\n            generatorStream: stream,\n            toolCallStreaming,\n            tracer,\n            telemetry,\n            system,\n            messages: stepInputMessages,\n            repairToolCall,\n            abortSignal,\n          });\n\n          const stepRequest = request ?? {};\n          const stepToolCalls: ToolCallUnion<TOOLS>[] = [];\n          const stepToolResults: ToolResultUnion<TOOLS>[] = [];\n\n          const stepReasoning: Array<ReasoningDetail> = [];\n          const stepFiles: Array<GeneratedFile> = [];\n          let activeReasoningText:\n            | undefined\n            | (ReasoningDetail & { type: 'text' }) = undefined;\n\n          let stepFinishReason: FinishReason = 'unknown';\n          let stepUsage: LanguageModelUsage = {\n            promptTokens: 0,\n            completionTokens: 0,\n            totalTokens: 0,\n          };\n          let stepProviderMetadata: ProviderMetadata | undefined;\n          let stepFirstChunk = true;\n          let stepText = '';\n          let fullStepText = stepType === 'continue' ? previousStepText : '';\n          let stepLogProbs: LogProbs | undefined;\n          let stepResponse: { id: string; timestamp: Date; modelId: string } = {\n            id: generateId(),\n            timestamp: currentDate(),\n            modelId: model.modelId,\n          };\n\n          // chunk buffer when using continue:\n          let chunkBuffer = '';\n          let chunkTextPublished = false;\n          let inWhitespacePrefix = true;\n          let hasWhitespaceSuffix = false; // for next step. when true, step ended with whitespace\n\n          async function publishTextChunk({\n            controller,\n            chunk,\n          }: {\n            controller: TransformStreamDefaultController<TextStreamPart<TOOLS>>;\n            chunk: TextStreamPart<TOOLS> & { type: 'text-delta' };\n          }) {\n            controller.enqueue(chunk);\n\n            stepText += chunk.textDelta;\n            fullStepText += chunk.textDelta;\n            chunkTextPublished = true;\n            hasWhitespaceSuffix = chunk.textDelta.trimEnd() !== chunk.textDelta;\n          }\n\n          self.addStream(\n            transformedStream.pipeThrough(\n              new TransformStream<\n                SingleRequestTextStreamPart<TOOLS>,\n                TextStreamPart<TOOLS>\n              >({\n                async transform(chunk, controller): Promise<void> {\n                  if (stepFirstChunk) {\n                    // Telemetry for first chunk:\n                    const msToFirstChunk = now() - startTimestampMs;\n\n                    stepFirstChunk = false;\n\n                    doStreamSpan.addEvent('ai.stream.firstChunk', {\n                      'ai.response.msToFirstChunk': msToFirstChunk,\n                    });\n\n                    doStreamSpan.setAttributes({\n                      'ai.response.msToFirstChunk': msToFirstChunk,\n                    });\n\n                    // Step start:\n                    controller.enqueue({\n                      type: 'step-start',\n                      messageId,\n                      request: stepRequest,\n                      warnings: warnings ?? [],\n                    });\n                  }\n\n                  // Filter out empty text deltas\n                  if (\n                    chunk.type === 'text-delta' &&\n                    chunk.textDelta.length === 0\n                  ) {\n                    return;\n                  }\n\n                  const chunkType = chunk.type;\n                  switch (chunkType) {\n                    case 'text-delta': {\n                      if (continueSteps) {\n                        // when a new step starts, leading whitespace is to be discarded\n                        // when there is already preceding whitespace in the chunk buffer\n                        const trimmedChunkText =\n                          inWhitespacePrefix && hasLeadingWhitespace\n                            ? chunk.textDelta.trimStart()\n                            : chunk.textDelta;\n\n                        if (trimmedChunkText.length === 0) {\n                          break;\n                        }\n\n                        inWhitespacePrefix = false;\n                        chunkBuffer += trimmedChunkText;\n\n                        const split = splitOnLastWhitespace(chunkBuffer);\n\n                        // publish the text until the last whitespace:\n                        if (split != null) {\n                          chunkBuffer = split.suffix;\n\n                          await publishTextChunk({\n                            controller,\n                            chunk: {\n                              type: 'text-delta',\n                              textDelta: split.prefix + split.whitespace,\n                            },\n                          });\n                        }\n                      } else {\n                        await publishTextChunk({ controller, chunk });\n                      }\n                      break;\n                    }\n\n                    case 'reasoning': {\n                      controller.enqueue(chunk);\n\n                      if (activeReasoningText == null) {\n                        activeReasoningText = {\n                          type: 'text',\n                          text: chunk.textDelta,\n                        };\n                        stepReasoning.push(activeReasoningText);\n                      } else {\n                        activeReasoningText.text += chunk.textDelta;\n                      }\n\n                      break;\n                    }\n\n                    case 'reasoning-signature': {\n                      controller.enqueue(chunk);\n\n                      if (activeReasoningText == null) {\n                        throw new InvalidStreamPartError({\n                          chunk,\n                          message: 'reasoning-signature without reasoning',\n                        });\n                      }\n\n                      activeReasoningText.signature = chunk.signature;\n                      activeReasoningText = undefined; // signature concludes reasoning part\n                      break;\n                    }\n\n                    case 'redacted-reasoning': {\n                      controller.enqueue(chunk);\n                      stepReasoning.push({\n                        type: 'redacted',\n                        data: chunk.data,\n                      });\n\n                      break;\n                    }\n\n                    case 'tool-call': {\n                      controller.enqueue(chunk);\n                      // store tool calls for onFinish callback and toolCalls promise:\n                      stepToolCalls.push(chunk);\n                      break;\n                    }\n\n                    case 'tool-result': {\n                      controller.enqueue(chunk);\n                      // store tool results for onFinish callback and toolResults promise:\n                      stepToolResults.push(chunk);\n                      break;\n                    }\n\n                    case 'response-metadata': {\n                      stepResponse = {\n                        id: chunk.id ?? stepResponse.id,\n                        timestamp: chunk.timestamp ?? stepResponse.timestamp,\n                        modelId: chunk.modelId ?? stepResponse.modelId,\n                      };\n                      break;\n                    }\n\n                    case 'finish': {\n                      // Note: tool executions might not be finished yet when the finish event is emitted.\n                      // store usage and finish reason for promises and onFinish callback:\n                      stepUsage = chunk.usage;\n                      stepFinishReason = chunk.finishReason;\n                      stepProviderMetadata =\n                        chunk.experimental_providerMetadata;\n                      stepLogProbs = chunk.logprobs;\n\n                      // Telemetry for finish event timing\n                      // (since tool executions can take longer and distort calculations)\n                      const msToFinish = now() - startTimestampMs;\n                      doStreamSpan.addEvent('ai.stream.finish');\n                      doStreamSpan.setAttributes({\n                        'ai.response.msToFinish': msToFinish,\n                        'ai.response.avgCompletionTokensPerSecond':\n                          (1000 * stepUsage.completionTokens) / msToFinish,\n                      });\n\n                      break;\n                    }\n\n                    case 'file': {\n                      stepFiles.push(chunk);\n                      controller.enqueue(chunk);\n                      break;\n                    }\n\n                    // forward:\n                    case 'source':\n                    case 'tool-call-streaming-start':\n                    case 'tool-call-delta': {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n\n                    case 'error': {\n                      controller.enqueue(chunk);\n                      stepFinishReason = 'error';\n                      break;\n                    }\n\n                    default: {\n                      const exhaustiveCheck: never = chunkType;\n                      throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                    }\n                  }\n                },\n\n                // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                async flush(controller) {\n                  const stepToolCallsJson =\n                    stepToolCalls.length > 0\n                      ? JSON.stringify(stepToolCalls)\n                      : undefined;\n\n                  // determine the next step type\n                  let nextStepType: 'done' | 'continue' | 'tool-result' =\n                    'done';\n                  if (currentStep + 1 < maxSteps) {\n                    if (\n                      continueSteps &&\n                      stepFinishReason === 'length' &&\n                      // only use continue when there are no tool calls:\n                      stepToolCalls.length === 0\n                    ) {\n                      nextStepType = 'continue';\n                    } else if (\n                      // there are tool calls:\n                      stepToolCalls.length > 0 &&\n                      // all current tool calls have results:\n                      stepToolResults.length === stepToolCalls.length\n                    ) {\n                      nextStepType = 'tool-result';\n                    }\n                  }\n\n                  // when using continuation, publish buffer on final step or if there\n                  // was no whitespace in the step:\n                  if (\n                    continueSteps &&\n                    chunkBuffer.length > 0 &&\n                    (nextStepType !== 'continue' || // when the next step is a regular step, publish the buffer\n                      (stepType === 'continue' && !chunkTextPublished)) // when the next step is a continue step, publish the buffer if no text was published in the step\n                  ) {\n                    await publishTextChunk({\n                      controller,\n                      chunk: {\n                        type: 'text-delta',\n                        textDelta: chunkBuffer,\n                      },\n                    });\n                    chunkBuffer = '';\n                  }\n\n                  // record telemetry information first to ensure best effort timing\n                  try {\n                    doStreamSpan.setAttributes(\n                      selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                          'ai.response.finishReason': stepFinishReason,\n                          'ai.response.text': { output: () => stepText },\n                          'ai.response.toolCalls': {\n                            output: () => stepToolCallsJson,\n                          },\n                          'ai.response.id': stepResponse.id,\n                          'ai.response.model': stepResponse.modelId,\n                          'ai.response.timestamp':\n                            stepResponse.timestamp.toISOString(),\n                          'ai.response.providerMetadata':\n                            JSON.stringify(stepProviderMetadata),\n\n                          'ai.usage.promptTokens': stepUsage.promptTokens,\n                          'ai.usage.completionTokens':\n                            stepUsage.completionTokens,\n\n                          // standardized gen-ai llm span attributes:\n                          'gen_ai.response.finish_reasons': [stepFinishReason],\n                          'gen_ai.response.id': stepResponse.id,\n                          'gen_ai.response.model': stepResponse.modelId,\n                          'gen_ai.usage.input_tokens': stepUsage.promptTokens,\n                          'gen_ai.usage.output_tokens':\n                            stepUsage.completionTokens,\n                        },\n                      }),\n                    );\n                  } catch (error) {\n                    // ignore error setting telemetry attributes\n                  } finally {\n                    // finish doStreamSpan before other operations for correct timing:\n                    doStreamSpan.end();\n                  }\n\n                  controller.enqueue({\n                    type: 'step-finish',\n                    finishReason: stepFinishReason,\n                    usage: stepUsage,\n                    providerMetadata: stepProviderMetadata,\n                    experimental_providerMetadata: stepProviderMetadata,\n                    logprobs: stepLogProbs,\n                    request: stepRequest,\n                    response: {\n                      ...stepResponse,\n                      headers: rawResponse?.headers,\n                    },\n                    warnings,\n                    isContinued: nextStepType === 'continue',\n                    messageId,\n                  });\n\n                  const combinedUsage = addLanguageModelUsage(usage, stepUsage);\n\n                  if (nextStepType === 'done') {\n                    controller.enqueue({\n                      type: 'finish',\n                      finishReason: stepFinishReason,\n                      usage: combinedUsage,\n                      providerMetadata: stepProviderMetadata,\n                      experimental_providerMetadata: stepProviderMetadata,\n                      logprobs: stepLogProbs,\n                      response: {\n                        ...stepResponse,\n                        headers: rawResponse?.headers,\n                      },\n                    });\n\n                    self.closeStream(); // close the stitchable stream\n                  } else {\n                    // append to messages for the next step:\n                    if (stepType === 'continue') {\n                      // continue step: update the last assistant message\n                      // continue is only possible when there are no tool calls,\n                      // so we can assume that there is a single last assistant message:\n                      const lastMessage = responseMessages[\n                        responseMessages.length - 1\n                      ] as CoreAssistantMessage;\n\n                      if (typeof lastMessage.content === 'string') {\n                        lastMessage.content += stepText;\n                      } else {\n                        lastMessage.content.push({\n                          text: stepText,\n                          type: 'text',\n                        });\n                      }\n                    } else {\n                      responseMessages.push(\n                        ...toResponseMessages({\n                          text: stepText,\n                          files: stepFiles,\n                          reasoning: stepReasoning,\n                          tools: tools ?? ({} as TOOLS),\n                          toolCalls: stepToolCalls,\n                          toolResults: stepToolResults,\n                          messageId,\n                          generateMessageId,\n                        }),\n                      );\n                    }\n\n                    await streamStep({\n                      currentStep: currentStep + 1,\n                      responseMessages,\n                      usage: combinedUsage,\n                      stepType: nextStepType,\n                      previousStepText: fullStepText,\n                      hasLeadingWhitespace: hasWhitespaceSuffix,\n                      messageId:\n                        // keep the same id when continuing a step:\n                        nextStepType === 'continue'\n                          ? messageId\n                          : generateMessageId(),\n                    });\n                  }\n                },\n              }),\n            ),\n          );\n        }\n\n        // add the initial stream to the stitchable stream\n        await streamStep({\n          currentStep: 0,\n          responseMessages: [],\n          usage: {\n            promptTokens: 0,\n            completionTokens: 0,\n            totalTokens: 0,\n          },\n          previousStepText: '',\n          stepType: 'initial',\n          hasLeadingWhitespace: false,\n          messageId: generateMessageId(),\n        });\n      },\n    }).catch(error => {\n      // add an error stream part and close the streams:\n      self.addStream(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue({ type: 'error', error });\n            controller.close();\n          },\n        }),\n      );\n      self.closeStream();\n    });\n  }\n\n  get warnings() {\n    return this.warningsPromise.value;\n  }\n\n  get usage() {\n    return this.usagePromise.value;\n  }\n\n  get finishReason() {\n    return this.finishReasonPromise.value;\n  }\n\n  get experimental_providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n\n  get providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n\n  get text() {\n    return this.textPromise.value;\n  }\n\n  get reasoning() {\n    return this.reasoningPromise.value;\n  }\n\n  get reasoningDetails() {\n    return this.reasoningDetailsPromise.value;\n  }\n\n  get sources() {\n    return this.sourcesPromise.value;\n  }\n\n  get files() {\n    return this.filesPromise.value;\n  }\n\n  get toolCalls() {\n    return this.toolCallsPromise.value;\n  }\n\n  get toolResults() {\n    return this.toolResultsPromise.value;\n  }\n\n  get request() {\n    return this.requestPromise.value;\n  }\n\n  get response() {\n    return this.responsePromise.value;\n  }\n\n  get steps() {\n    return this.stepsPromise.value;\n  }\n\n  /**\nSplit out a new stream from the original stream.\nThe original stream is replaced to allow for further splitting,\nsince we do not know how many times the stream will be split.\n\nNote: this leads to buffering the stream content on the server.\nHowever, the LLM results are expected to be small enough to not cause issues.\n   */\n  private teeStream() {\n    const [stream1, stream2] = this.baseStream.tee();\n    this.baseStream = stream2;\n    return stream1;\n  }\n\n  get textStream(): AsyncIterableStream<string> {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream<EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>, string>({\n          transform({ part }, controller) {\n            if (part.type === 'text-delta') {\n              controller.enqueue(part.textDelta);\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  get fullStream(): AsyncIterableStream<TextStreamPart<TOOLS>> {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream<\n          EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>,\n          TextStreamPart<TOOLS>\n        >({\n          transform({ part }, controller) {\n            controller.enqueue(part);\n          },\n        }),\n      ),\n    );\n  }\n\n  async consumeStream(options?: ConsumeStreamOptions): Promise<void> {\n    try {\n      await consumeStream({\n        stream: this.fullStream,\n        onError: options?.onError,\n      });\n    } catch (error) {\n      options?.onError?.(error);\n    }\n  }\n\n  get experimental_partialOutputStream(): AsyncIterableStream<PARTIAL_OUTPUT> {\n    if (this.output == null) {\n      throw new NoOutputSpecifiedError();\n    }\n\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream<\n          EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>,\n          PARTIAL_OUTPUT\n        >({\n          transform({ partialOutput }, controller) {\n            if (partialOutput != null) {\n              controller.enqueue(partialOutput);\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  private toDataStreamInternal({\n    getErrorMessage = () => 'An error occurred.', // mask error messages for safety by default\n    sendUsage = true,\n    sendReasoning = false,\n    sendSources = false,\n    experimental_sendFinish = true,\n  }: {\n    getErrorMessage: ((error: unknown) => string) | undefined;\n    sendUsage: boolean | undefined;\n    sendReasoning: boolean | undefined;\n    sendSources: boolean | undefined;\n    experimental_sendFinish: boolean | undefined;\n  }): ReadableStream<DataStreamString> {\n    return this.fullStream.pipeThrough(\n      new TransformStream<TextStreamPart<TOOLS>, DataStreamString>({\n        transform: async (chunk, controller) => {\n          const chunkType = chunk.type;\n          switch (chunkType) {\n            case 'text-delta': {\n              controller.enqueue(formatDataStreamPart('text', chunk.textDelta));\n              break;\n            }\n\n            case 'reasoning': {\n              if (sendReasoning) {\n                controller.enqueue(\n                  formatDataStreamPart('reasoning', chunk.textDelta),\n                );\n              }\n              break;\n            }\n\n            case 'redacted-reasoning': {\n              if (sendReasoning) {\n                controller.enqueue(\n                  formatDataStreamPart('redacted_reasoning', {\n                    data: chunk.data,\n                  }),\n                );\n              }\n              break;\n            }\n\n            case 'reasoning-signature': {\n              if (sendReasoning) {\n                controller.enqueue(\n                  formatDataStreamPart('reasoning_signature', {\n                    signature: chunk.signature,\n                  }),\n                );\n              }\n              break;\n            }\n\n            case 'file': {\n              controller.enqueue(\n                formatDataStreamPart('file', {\n                  mimeType: chunk.mimeType,\n                  data: chunk.base64,\n                }),\n              );\n              break;\n            }\n\n            case 'source': {\n              if (sendSources) {\n                controller.enqueue(\n                  formatDataStreamPart('source', chunk.source),\n                );\n              }\n              break;\n            }\n\n            case 'tool-call-streaming-start': {\n              controller.enqueue(\n                formatDataStreamPart('tool_call_streaming_start', {\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                }),\n              );\n              break;\n            }\n\n            case 'tool-call-delta': {\n              controller.enqueue(\n                formatDataStreamPart('tool_call_delta', {\n                  toolCallId: chunk.toolCallId,\n                  argsTextDelta: chunk.argsTextDelta,\n                }),\n              );\n              break;\n            }\n\n            case 'tool-call': {\n              controller.enqueue(\n                formatDataStreamPart('tool_call', {\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  args: chunk.args,\n                }),\n              );\n              break;\n            }\n\n            case 'tool-result': {\n              controller.enqueue(\n                formatDataStreamPart('tool_result', {\n                  toolCallId: chunk.toolCallId,\n                  result: chunk.result,\n                }),\n              );\n              break;\n            }\n\n            case 'error': {\n              controller.enqueue(\n                formatDataStreamPart('error', getErrorMessage(chunk.error)),\n              );\n              break;\n            }\n\n            case 'step-start': {\n              controller.enqueue(\n                formatDataStreamPart('start_step', {\n                  messageId: chunk.messageId,\n                }),\n              );\n              break;\n            }\n\n            case 'step-finish': {\n              controller.enqueue(\n                formatDataStreamPart('finish_step', {\n                  finishReason: chunk.finishReason,\n                  usage: sendUsage\n                    ? {\n                        promptTokens: chunk.usage.promptTokens,\n                        completionTokens: chunk.usage.completionTokens,\n                      }\n                    : undefined,\n                  isContinued: chunk.isContinued,\n                }),\n              );\n              break;\n            }\n\n            case 'finish': {\n              if (experimental_sendFinish) {\n                controller.enqueue(\n                  formatDataStreamPart('finish_message', {\n                    finishReason: chunk.finishReason,\n                    usage: sendUsage\n                      ? {\n                          promptTokens: chunk.usage.promptTokens,\n                          completionTokens: chunk.usage.completionTokens,\n                        }\n                      : undefined,\n                  }),\n                );\n              }\n              break;\n            }\n\n            default: {\n              const exhaustiveCheck: never = chunkType;\n              throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n            }\n          }\n        },\n      }),\n    );\n  }\n\n  pipeDataStreamToResponse(\n    response: ServerResponse,\n    {\n      status,\n      statusText,\n      headers,\n      data,\n      getErrorMessage,\n      sendUsage,\n      sendReasoning,\n      sendSources,\n      experimental_sendFinish,\n    }: ResponseInit &\n      DataStreamOptions & {\n        data?: StreamData;\n        getErrorMessage?: (error: unknown) => string;\n      } = {},\n  ) {\n    writeToServerResponse({\n      response,\n      status,\n      statusText,\n      headers: prepareOutgoingHttpHeaders(headers, {\n        contentType: 'text/plain; charset=utf-8',\n        dataStreamVersion: 'v1',\n      }),\n      stream: this.toDataStream({\n        data,\n        getErrorMessage,\n        sendUsage,\n        sendReasoning,\n        sendSources,\n        experimental_sendFinish,\n      }),\n    });\n  }\n\n  pipeTextStreamToResponse(response: ServerResponse, init?: ResponseInit) {\n    writeToServerResponse({\n      response,\n      status: init?.status,\n      statusText: init?.statusText,\n      headers: prepareOutgoingHttpHeaders(init?.headers, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n      stream: this.textStream.pipeThrough(new TextEncoderStream()),\n    });\n  }\n\n  // TODO breaking change 5.0: remove pipeThrough(new TextEncoderStream())\n  toDataStream(\n    options?: DataStreamOptions & {\n      data?: StreamData;\n      getErrorMessage?: (error: unknown) => string;\n    },\n  ) {\n    const stream = this.toDataStreamInternal({\n      getErrorMessage: options?.getErrorMessage,\n      sendUsage: options?.sendUsage,\n      sendReasoning: options?.sendReasoning,\n      sendSources: options?.sendSources,\n      experimental_sendFinish: options?.experimental_sendFinish,\n    }).pipeThrough(new TextEncoderStream());\n\n    return options?.data ? mergeStreams(options?.data.stream, stream) : stream;\n  }\n\n  mergeIntoDataStream(writer: DataStreamWriter, options?: DataStreamOptions) {\n    writer.merge(\n      this.toDataStreamInternal({\n        getErrorMessage: writer.onError,\n        sendUsage: options?.sendUsage,\n        sendReasoning: options?.sendReasoning,\n        sendSources: options?.sendSources,\n        experimental_sendFinish: options?.experimental_sendFinish,\n      }),\n    );\n  }\n\n  toDataStreamResponse({\n    headers,\n    status,\n    statusText,\n    data,\n    getErrorMessage,\n    sendUsage,\n    sendReasoning,\n    sendSources,\n    experimental_sendFinish,\n  }: ResponseInit &\n    DataStreamOptions & {\n      data?: StreamData;\n      getErrorMessage?: (error: unknown) => string;\n    } = {}): Response {\n    return new Response(\n      this.toDataStream({\n        data,\n        getErrorMessage,\n        sendUsage,\n        sendReasoning,\n        sendSources,\n        experimental_sendFinish,\n      }),\n      {\n        status,\n        statusText,\n        headers: prepareResponseHeaders(headers, {\n          contentType: 'text/plain; charset=utf-8',\n          dataStreamVersion: 'v1',\n        }),\n      },\n    );\n  }\n\n  toTextStreamResponse(init?: ResponseInit): Response {\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: init?.status ?? 200,\n      headers: prepareResponseHeaders(init?.headers, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n    });\n  }\n}\n", "export function asArray<T>(value: T | T[] | undefined): T[] {\n  return value === undefined ? [] : Array.isArray(value) ? value : [value];\n}\n", "/**\n * Consumes a ReadableStream until it's fully read.\n *\n * This function reads the stream chunk by chunk until the stream is exhausted.\n * It doesn't process or return the data from the stream; it simply ensures\n * that the entire stream is read.\n *\n * @param {ReadableStream} stream - The ReadableStream to be consumed.\n * @returns {Promise<void>} A promise that resolves when the stream is fully consumed.\n */\nexport async function consumeStream({\n  stream,\n  onError,\n}: {\n  stream: ReadableStream;\n  onError?: (error: unknown) => void;\n}): Promise<void> {\n  const reader = stream.getReader();\n  try {\n    while (true) {\n      const { done } = await reader.read();\n      if (done) break;\n    }\n  } catch (error) {\n    onError?.(error);\n  } finally {\n    reader.releaseLock();\n  }\n}\n", "/**\n * Merges two readable streams into a single readable stream, emitting values\n * from each stream as they become available.\n *\n * The first stream is prioritized over the second stream. If both streams have\n * values available, the first stream's value is emitted first.\n *\n * @template VALUE1 - The type of values emitted by the first stream.\n * @template VALUE2 - The type of values emitted by the second stream.\n * @param {ReadableStream<VALUE1>} stream1 - The first readable stream.\n * @param {ReadableStream<VALUE2>} stream2 - The second readable stream.\n * @returns {ReadableStream<VALUE1 | VALUE2>} A new readable stream that emits values from both input streams.\n */\nexport function mergeStreams<VALUE1, VALUE2>(\n  stream1: ReadableStream<VALUE1>,\n  stream2: ReadableStream<VALUE2>,\n): ReadableStream<VALUE1 | VALUE2> {\n  const reader1 = stream1.getReader();\n  const reader2 = stream2.getReader();\n\n  let lastRead1: Promise<ReadableStreamReadResult<VALUE1>> | undefined =\n    undefined;\n  let lastRead2: Promise<ReadableStreamReadResult<VALUE2>> | undefined =\n    undefined;\n\n  let stream1Done = false;\n  let stream2Done = false;\n\n  // only use when stream 2 is done:\n  async function readStream1(\n    controller: ReadableStreamDefaultController<VALUE1 | VALUE2>,\n  ) {\n    try {\n      if (lastRead1 == null) {\n        lastRead1 = reader1.read();\n      }\n\n      const result = await lastRead1;\n      lastRead1 = undefined;\n\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n\n  // only use when stream 1 is done:\n  async function readStream2(\n    controller: ReadableStreamDefaultController<VALUE1 | VALUE2>,\n  ) {\n    try {\n      if (lastRead2 == null) {\n        lastRead2 = reader2.read();\n      }\n\n      const result = await lastRead2;\n      lastRead2 = undefined;\n\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n\n  return new ReadableStream<VALUE1 | VALUE2>({\n    async pull(controller) {\n      try {\n        // stream 1 is done, we can only read from stream 2:\n        if (stream1Done) {\n          await readStream2(controller);\n          return;\n        }\n\n        // stream 2 is done, we can only read from stream 1:\n        if (stream2Done) {\n          await readStream1(controller);\n          return;\n        }\n\n        // pull the next value from the stream that was read last:\n        if (lastRead1 == null) {\n          lastRead1 = reader1.read();\n        }\n        if (lastRead2 == null) {\n          lastRead2 = reader2.read();\n        }\n\n        // Note on Promise.race (prioritizing stream 1 over stream 2):\n        // If the iterable contains one or more non-promise values and/or an already settled promise,\n        // then Promise.race() will settle to the first of these values found in the iterable.\n        const { result, reader } = await Promise.race([\n          lastRead1.then(result => ({ result, reader: reader1 })),\n          lastRead2.then(result => ({ result, reader: reader2 })),\n        ]);\n\n        if (!result.done) {\n          controller.enqueue(result.value);\n        }\n\n        if (reader === reader1) {\n          lastRead1 = undefined;\n          if (result.done) {\n            // stream 1 is done, we can only read from stream 2:\n            await readStream2(controller);\n            stream1Done = true;\n          }\n        } else {\n          lastRead2 = undefined;\n          // stream 2 is done, we can only read from stream 1:\n          if (result.done) {\n            stream2Done = true;\n            await readStream1(controller);\n          }\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    cancel() {\n      reader1.cancel();\n      reader2.cancel();\n    },\n  });\n}\n", "import { LanguageModelV1StreamPart } from '@ai-sdk/provider';\nimport { generateId } from '@ai-sdk/ui-utils';\nimport { Tracer } from '@opentelemetry/api';\nimport { ToolExecutionError } from '../../errors';\nimport { CoreMessage } from '../prompt/message';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { recordErrorOnSpan, recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  FinishReason,\n  LanguageModelUsage,\n  LogProbs,\n  ProviderMetadata,\n} from '../types';\nimport { Source } from '../types/language-model';\nimport { calculateLanguageModelUsage } from '../types/usage';\nimport { DefaultGeneratedFileWithType, GeneratedFile } from './generated-file';\nimport { parseToolCall } from './parse-tool-call';\nimport { ToolCallUnion } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair';\nimport { ToolResultUnion } from './tool-result';\nimport { ToolSet } from './tool-set';\n\nexport type SingleRequestTextStreamPart<TOOLS extends ToolSet> =\n  | {\n      type: 'text-delta';\n      textDelta: string;\n    }\n  | {\n      type: 'reasoning';\n      textDelta: string;\n    }\n  | {\n      type: 'reasoning-signature';\n      signature: string;\n    }\n  | {\n      type: 'redacted-reasoning';\n      data: string;\n    }\n  | ({\n      type: 'file';\n    } & GeneratedFile)\n  | {\n      type: 'source';\n      source: Source;\n    }\n  | ({\n      type: 'tool-call';\n    } & ToolCallUnion<TOOLS>)\n  | {\n      type: 'tool-call-streaming-start';\n      toolCallId: string;\n      toolName: string;\n    }\n  | {\n      type: 'tool-call-delta';\n      toolCallId: string;\n      toolName: string;\n      argsTextDelta: string;\n    }\n  | ({\n      type: 'tool-result';\n    } & ToolResultUnion<TOOLS>)\n  | {\n      type: 'response-metadata';\n      id?: string;\n      timestamp?: Date;\n      modelId?: string;\n    }\n  | {\n      type: 'finish';\n      finishReason: FinishReason;\n      logprobs?: LogProbs;\n      usage: LanguageModelUsage;\n      experimental_providerMetadata?: ProviderMetadata;\n    }\n  | {\n      type: 'error';\n      error: unknown;\n    };\n\nexport function runToolsTransformation<TOOLS extends ToolSet>({\n  tools,\n  generatorStream,\n  toolCallStreaming,\n  tracer,\n  telemetry,\n  system,\n  messages,\n  abortSignal,\n  repairToolCall,\n}: {\n  tools: TOOLS | undefined;\n  generatorStream: ReadableStream<LanguageModelV1StreamPart>;\n  toolCallStreaming: boolean;\n  tracer: Tracer;\n  telemetry: TelemetrySettings | undefined;\n  system: string | undefined;\n  messages: CoreMessage[];\n  abortSignal: AbortSignal | undefined;\n  repairToolCall: ToolCallRepairFunction<TOOLS> | undefined;\n}): ReadableStream<SingleRequestTextStreamPart<TOOLS>> {\n  // tool results stream\n  let toolResultsStreamController: ReadableStreamDefaultController<\n    SingleRequestTextStreamPart<TOOLS>\n  > | null = null;\n  const toolResultsStream = new ReadableStream<\n    SingleRequestTextStreamPart<TOOLS>\n  >({\n    start(controller) {\n      toolResultsStreamController = controller;\n    },\n  });\n\n  // keep track of active tool calls for tool call streaming:\n  const activeToolCalls: Record<string, boolean> = {};\n\n  // keep track of outstanding tool results for stream closing:\n  const outstandingToolResults = new Set<string>();\n\n  let canClose = false;\n  let finishChunk:\n    | (SingleRequestTextStreamPart<TOOLS> & { type: 'finish' })\n    | undefined = undefined;\n\n  function attemptClose() {\n    // close the tool results controller if no more outstanding tool calls\n    if (canClose && outstandingToolResults.size === 0) {\n      // we delay sending the finish chunk until all tool results (incl. delayed ones)\n      // are received to ensure that the frontend receives tool results before a message\n      // finish event arrives.\n      if (finishChunk != null) {\n        toolResultsStreamController!.enqueue(finishChunk);\n      }\n\n      toolResultsStreamController!.close();\n    }\n  }\n\n  // forward stream\n  const forwardStream = new TransformStream<\n    LanguageModelV1StreamPart,\n    SingleRequestTextStreamPart<TOOLS>\n  >({\n    async transform(\n      chunk: LanguageModelV1StreamPart,\n      controller: TransformStreamDefaultController<\n        SingleRequestTextStreamPart<TOOLS>\n      >,\n    ) {\n      const chunkType = chunk.type;\n\n      switch (chunkType) {\n        // forward:\n        case 'text-delta':\n        case 'reasoning':\n        case 'reasoning-signature':\n        case 'redacted-reasoning':\n        case 'source':\n        case 'response-metadata':\n        case 'error': {\n          controller.enqueue(chunk);\n          break;\n        }\n\n        case 'file': {\n          controller.enqueue(\n            new DefaultGeneratedFileWithType({\n              data: chunk.data,\n              mimeType: chunk.mimeType,\n            }),\n          );\n          break;\n        }\n\n        // forward with less information:\n        case 'tool-call-delta': {\n          if (toolCallStreaming) {\n            if (!activeToolCalls[chunk.toolCallId]) {\n              controller.enqueue({\n                type: 'tool-call-streaming-start',\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n              });\n\n              activeToolCalls[chunk.toolCallId] = true;\n            }\n\n            controller.enqueue({\n              type: 'tool-call-delta',\n              toolCallId: chunk.toolCallId,\n              toolName: chunk.toolName,\n              argsTextDelta: chunk.argsTextDelta,\n            });\n          }\n          break;\n        }\n\n        // process tool call:\n        case 'tool-call': {\n          try {\n            const toolCall = await parseToolCall({\n              toolCall: chunk,\n              tools,\n              repairToolCall,\n              system,\n              messages,\n            });\n\n            controller.enqueue(toolCall);\n\n            const tool = tools![toolCall.toolName];\n\n            if (tool.execute != null) {\n              const toolExecutionId = generateId(); // use our own id to guarantee uniqueness\n              outstandingToolResults.add(toolExecutionId);\n\n              // Note: we don't await the tool execution here (by leaving out 'await' on recordSpan),\n              // because we want to process the next chunk as soon as possible.\n              // This is important for the case where the tool execution takes a long time.\n              recordSpan({\n                name: 'ai.toolCall',\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: 'ai.toolCall',\n                      telemetry,\n                    }),\n                    'ai.toolCall.name': toolCall.toolName,\n                    'ai.toolCall.id': toolCall.toolCallId,\n                    'ai.toolCall.args': {\n                      output: () => JSON.stringify(toolCall.args),\n                    },\n                  },\n                }),\n                tracer,\n                fn: async span =>\n                  tool.execute!(toolCall.args, {\n                    toolCallId: toolCall.toolCallId,\n                    messages,\n                    abortSignal,\n                  }).then(\n                    (result: any) => {\n                      toolResultsStreamController!.enqueue({\n                        ...toolCall,\n                        type: 'tool-result',\n                        result,\n                      } as any);\n\n                      outstandingToolResults.delete(toolExecutionId);\n\n                      attemptClose();\n\n                      // record telemetry\n                      try {\n                        span.setAttributes(\n                          selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                              'ai.toolCall.result': {\n                                output: () => JSON.stringify(result),\n                              },\n                            },\n                          }),\n                        );\n                      } catch (ignored) {\n                        // JSON stringify might fail if the result is not serializable,\n                        // in which case we just ignore it. In the future we might want to\n                        // add an optional serialize method to the tool interface and warn\n                        // if the result is not serializable.\n                      }\n                    },\n                    (error: any) => {\n                      recordErrorOnSpan(span, error);\n                      toolResultsStreamController!.enqueue({\n                        type: 'error',\n                        error: new ToolExecutionError({\n                          toolCallId: toolCall.toolCallId,\n                          toolName: toolCall.toolName,\n                          toolArgs: toolCall.args,\n                          cause: error,\n                        }),\n                      });\n\n                      outstandingToolResults.delete(toolExecutionId);\n                      attemptClose();\n                    },\n                  ),\n              });\n            }\n          } catch (error) {\n            toolResultsStreamController!.enqueue({\n              type: 'error',\n              error,\n            });\n          }\n\n          break;\n        }\n\n        case 'finish': {\n          finishChunk = {\n            type: 'finish',\n            finishReason: chunk.finishReason,\n            logprobs: chunk.logprobs,\n            usage: calculateLanguageModelUsage(chunk.usage),\n            experimental_providerMetadata: chunk.providerMetadata,\n          };\n          break;\n        }\n\n        default: {\n          const _exhaustiveCheck: never = chunkType;\n          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n\n    flush() {\n      canClose = true;\n      attemptClose();\n    },\n  });\n\n  // combine the generator stream and the tool results stream\n  return new ReadableStream<SingleRequestTextStreamPart<TOOLS>>({\n    async start(controller) {\n      // need to wait for both pipes so there are no dangling promises that\n      // can cause uncaught promise rejections when the stream is aborted\n      return Promise.all([\n        generatorStream.pipeThrough(forwardStream).pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              // the generator stream controller is automatically closed when it's consumed\n            },\n          }),\n        ),\n        toolResultsStream.pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              controller.close();\n            },\n          }),\n        ),\n      ]);\n    },\n  });\n}\n", "import { AISDKError } from '@ai-sdk/provider';\nimport { SpeechModelResponseMetadata } from '../core/types/speech-model-response-metadata';\n\n/**\nError that is thrown when no speech audio was generated.\n */\nexport class NoSpeechGeneratedError extends AISDKError {\n  readonly responses: Array<SpeechModelResponseMetadata>;\n\n  constructor(options: { responses: Array<SpeechModelResponseMetadata> }) {\n    super({\n      name: 'AI_NoSpeechGeneratedError',\n      message: 'No speech audio generated.',\n    });\n\n    this.responses = options.responses;\n  }\n}\n", "import {\n  GeneratedFile,\n  DefaultGeneratedFile,\n} from '../generate-text/generated-file';\n\n/**\n * A generated audio file.\n */\nexport interface GeneratedAudioFile extends GeneratedFile {\n  /**\n   * Audio format of the file (e.g., 'mp3', 'wav', etc.)\n   */\n  readonly format: string;\n}\n\nexport class DefaultGeneratedAudioFile\n  extends DefaultGeneratedFile\n  implements GeneratedAudioFile\n{\n  readonly format: string;\n\n  constructor({\n    data,\n    mimeType,\n  }: {\n    data: string | Uint8Array;\n    mimeType: string;\n  }) {\n    super({ data, mimeType });\n    let format = 'mp3';\n\n    // If format is not provided, try to determine it from the mimeType\n    if (mimeType) {\n      const mimeTypeParts = mimeType.split('/');\n\n      if (mimeTypeParts.length === 2) {\n        // Handle special cases for audio formats\n        if (mimeType !== 'audio/mpeg') {\n          format = mimeTypeParts[1];\n        }\n      }\n    }\n\n    if (!format) {\n      throw new Error(\n        'Audio format must be provided or determinable from mimeType',\n      );\n    }\n\n    this.format = format;\n  }\n}\n\nexport class DefaultGeneratedAudioFileWithType extends DefaultGeneratedAudioFile {\n  readonly type = 'audio';\n\n  constructor(options: {\n    data: string | Uint8Array;\n    mimeType: string;\n    format: string;\n  }) {\n    super(options);\n  }\n}\n", "import { JSONValue, SpeechModelV1 } from '@ai-sdk/provider';\nimport { NoSpeechGeneratedError } from '../../errors/no-speech-generated-error';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { ProviderOptions } from '../types/provider-metadata';\nimport { SpeechWarning } from '../types/speech-model';\nimport { SpeechModelResponseMetadata } from '../types/speech-model-response-metadata';\nimport { SpeechResult } from './generate-speech-result';\nimport {\n  audioMimeTypeSignatures,\n  detectMimeType,\n} from '../util/detect-mimetype';\nimport {\n  DefaultGeneratedAudioFile,\n  GeneratedAudioFile,\n} from './generated-audio-file';\nimport { UnsupportedModelVersionError } from '../../errors/unsupported-model-version-error';\n\n/**\nGenerates speech audio using a speech model.\n\n@param model - The speech model to use.\n@param text - The text to convert to speech.\n@param voice - The voice to use for speech generation.\n@param outputFormat - The output format to use for speech generation e.g. \"mp3\", \"wav\", etc.\n@param instructions - Instructions for the speech generation e.g. \"Speak in a slow and steady tone\".\n@param speed - The speed of the speech generation.\n@param providerOptions - Additional provider-specific options that are passed through to the provider\nas body parameters.\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the generated audio data.\n */\nexport async function generateSpeech({\n  model,\n  text,\n  voice,\n  outputFormat,\n  instructions,\n  speed,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n}: {\n  /**\nThe speech model to use.\n     */\n  model: SpeechModelV1;\n\n  /**\nThe text to convert to speech.\n   */\n  text: string;\n\n  /**\nThe voice to use for speech generation.\n   */\n  voice?: string;\n\n  /**\n   * The desired output format for the audio e.g. \"mp3\", \"wav\", etc.\n   */\n  outputFormat?: 'mp3' | 'wav' | (string & {});\n\n  /**\n    Instructions for the speech generation e.g. \"Speak in a slow and steady tone\".\n  */\n  instructions?: string;\n\n  /**\n  The speed of the speech generation.\n   */\n  speed?: number;\n\n  /**\nAdditional provider-specific options that are passed through to the provider\nas body parameters.\n\nThe outer record is keyed by the provider name, and the inner\nrecord is keyed by the provider-specific metadata key.\n```ts\n{\n  \"openai\": {}\n}\n```\n     */\n  providerOptions?: ProviderOptions;\n\n  /**\nMaximum number of retries per speech model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n}): Promise<SpeechResult> {\n  if (typeof model === 'string' || model.specificationVersion !== 'v1') {\n    throw new UnsupportedModelVersionError();\n  }\n\n  const { retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const result = await retry(() =>\n    model.doGenerate({\n      text,\n      voice,\n      outputFormat,\n      instructions,\n      speed,\n      abortSignal,\n      headers,\n      providerOptions,\n    }),\n  );\n\n  if (!result.audio || result.audio.length === 0) {\n    throw new NoSpeechGeneratedError({ responses: [result.response] });\n  }\n\n  return new DefaultSpeechResult({\n    audio: new DefaultGeneratedAudioFile({\n      data: result.audio,\n      mimeType:\n        detectMimeType({\n          data: result.audio,\n          signatures: audioMimeTypeSignatures,\n        }) ?? 'audio/mp3',\n    }),\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata,\n  });\n}\n\nclass DefaultSpeechResult implements SpeechResult {\n  readonly audio: GeneratedAudioFile;\n  readonly warnings: Array<SpeechWarning>;\n  readonly responses: Array<SpeechModelResponseMetadata>;\n  readonly providerMetadata: Record<string, Record<string, JSONValue>>;\n\n  constructor(options: {\n    audio: GeneratedAudioFile;\n    warnings: Array<SpeechWarning>;\n    responses: Array<SpeechModelResponseMetadata>;\n    providerMetadata: Record<string, Record<string, JSONValue>> | undefined;\n  }) {\n    this.audio = options.audio;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = options.providerMetadata ?? {};\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\nimport { TranscriptionModelResponseMetadata } from '../core/types/transcription-model-response-metadata';\n\n/**\nError that is thrown when no transcript was generated.\n */\nexport class NoTranscriptGeneratedError extends AISDKError {\n  readonly responses: Array<TranscriptionModelResponseMetadata>;\n\n  constructor(options: {\n    responses: Array<TranscriptionModelResponseMetadata>;\n  }) {\n    super({\n      name: 'AI_NoTranscriptGeneratedError',\n      message: 'No transcript generated.',\n    });\n\n    this.responses = options.responses;\n  }\n}\n", "import { JSONValue, TranscriptionModelV1 } from '@ai-sdk/provider';\nimport { NoTranscriptGeneratedError } from '../../errors/no-transcript-generated-error';\nimport { download } from '../../util/download';\nimport { DataContent } from '../prompt';\nimport { convertDataContentToUint8Array } from '../prompt/data-content';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { ProviderOptions } from '../types/provider-metadata';\nimport { TranscriptionWarning } from '../types/transcription-model';\nimport { TranscriptionModelResponseMetadata } from '../types/transcription-model-response-metadata';\nimport {\n  audioMimeTypeSignatures,\n  detectMimeType,\n} from '../util/detect-mimetype';\nimport { TranscriptionResult } from './transcribe-result';\nimport { UnsupportedModelVersionError } from '../../errors/unsupported-model-version-error';\n\n/**\nGenerates transcripts using a transcription model.\n\n@param model - The transcription model to use.\n@param audio - The audio data to transcribe as DataContent (string | Uint8Array | ArrayBuffer | Buffer) or a URL.\n@param providerOptions - Additional provider-specific options that are passed through to the provider\nas body parameters.\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the generated transcript.\n */\nexport async function transcribe({\n  model,\n  audio,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n}: {\n  /**\nThe transcription model to use.\n     */\n  model: TranscriptionModelV1;\n\n  /**\nThe audio data to transcribe.\n   */\n  audio: DataContent | URL;\n\n  /**\nAdditional provider-specific options that are passed through to the provider\nas body parameters.\n\nThe outer record is keyed by the provider name, and the inner\nrecord is keyed by the provider-specific metadata key.\n```ts\n{\n  \"openai\": {\n    \"temperature\": 0\n  }\n}\n```\n     */\n  providerOptions?: ProviderOptions;\n\n  /**\nMaximum number of retries per transcript model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n}): Promise<TranscriptionResult> {\n  if (typeof model === 'string' || model.specificationVersion !== 'v1') {\n    throw new UnsupportedModelVersionError();\n  }\n\n  const { retry } = prepareRetries({ maxRetries: maxRetriesArg });\n  const audioData =\n    audio instanceof URL\n      ? (await download({ url: audio })).data\n      : convertDataContentToUint8Array(audio);\n\n  const result = await retry(() =>\n    model.doGenerate({\n      audio: audioData,\n      abortSignal,\n      headers,\n      providerOptions,\n      mediaType:\n        detectMimeType({\n          data: audioData,\n          signatures: audioMimeTypeSignatures,\n        }) ?? 'audio/wav',\n    }),\n  );\n\n  if (!result.text) {\n    throw new NoTranscriptGeneratedError({ responses: [result.response] });\n  }\n\n  return new DefaultTranscriptionResult({\n    text: result.text,\n    segments: result.segments,\n    language: result.language,\n    durationInSeconds: result.durationInSeconds,\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata,\n  });\n}\n\nclass DefaultTranscriptionResult implements TranscriptionResult {\n  readonly text: string;\n  readonly segments: Array<{\n    text: string;\n    startSecond: number;\n    endSecond: number;\n  }>;\n  readonly language: string | undefined;\n  readonly durationInSeconds: number | undefined;\n  readonly warnings: Array<TranscriptionWarning>;\n  readonly responses: Array<TranscriptionModelResponseMetadata>;\n  readonly providerMetadata: Record<string, Record<string, JSONValue>>;\n\n  constructor(options: {\n    text: string;\n    segments: Array<{\n      text: string;\n      startSecond: number;\n      endSecond: number;\n    }>;\n    language: string | undefined;\n    durationInSeconds: number | undefined;\n    warnings: Array<TranscriptionWarning>;\n    responses: Array<TranscriptionModelResponseMetadata>;\n    providerMetadata: Record<string, Record<string, JSONValue>> | undefined;\n  }) {\n    this.text = options.text;\n    this.segments = options.segments;\n    this.language = options.language;\n    this.durationInSeconds = options.durationInSeconds;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = options.providerMetadata ?? {};\n  }\n}\n", "/**\n * Deeply merges two objects together.\n * - Properties from the second object override those in the first object with the same key\n * - For nested objects, the merge is performed recursively (deep merge)\n * - Arrays are replaced, not merged\n * - Primitive values are replaced\n * - If both inputs are undefined, returns undefined\n * - If one input is undefined, returns the other\n *\n * @param target The target object to merge into\n * @param source The source object to merge from\n * @returns A new object with the merged properties, or undefined if both inputs are undefined\n */\nexport function mergeObjects<T extends object, U extends object>(\n  target: T | undefined,\n  source: U | undefined,\n): (T & U) | T | U | undefined {\n  // If both inputs are undefined, return undefined\n  if (target === undefined && source === undefined) {\n    return undefined;\n  }\n\n  // If target is undefined, return source\n  if (target === undefined) {\n    return source;\n  }\n\n  // If source is undefined, return target\n  if (source === undefined) {\n    return target;\n  }\n\n  // Create a new object to avoid mutating the inputs\n  const result = { ...target } as T & U;\n\n  // Iterate through all keys in the source object\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      const sourceValue = source[key];\n\n      // Skip if the source value is undefined\n      if (sourceValue === undefined) continue;\n\n      // Get the target value if it exists\n      const targetValue =\n        key in target ? target[key as unknown as keyof T] : undefined;\n\n      // Check if both values are objects that can be deeply merged\n      const isSourceObject =\n        sourceValue !== null &&\n        typeof sourceValue === 'object' &&\n        !Array.isArray(sourceValue) &&\n        !(sourceValue instanceof Date) &&\n        !(sourceValue instanceof RegExp);\n\n      const isTargetObject =\n        targetValue !== null &&\n        targetValue !== undefined &&\n        typeof targetValue === 'object' &&\n        !Array.isArray(targetValue) &&\n        !(targetValue instanceof Date) &&\n        !(targetValue instanceof RegExp);\n\n      // If both values are mergeable objects, merge them recursively\n      if (isSourceObject && isTargetObject) {\n        result[key as keyof (T & U)] = mergeObjects(\n          targetValue as object,\n          sourceValue as object,\n        ) as any;\n      } else {\n        // For primitives, arrays, or when one value is not a mergeable object,\n        // simply override with the source value\n        result[key as keyof (T & U)] = sourceValue as any;\n      }\n    }\n  }\n\n  return result;\n}\n", "import {\n  LanguageModelV1CallOptions,\n  LanguageModelV1ProviderMetadata,\n} from '@ai-sdk/provider';\nimport type { LanguageModelV1Middleware } from './language-model-v1-middleware';\nimport { mergeObjects } from '../util/merge-objects';\n\n/**\n * Applies default settings for a language model.\n */\nexport function defaultSettingsMiddleware({\n  settings,\n}: {\n  settings: Partial<\n    LanguageModelV1CallOptions & {\n      providerMetadata?: LanguageModelV1ProviderMetadata;\n    }\n  >;\n}): LanguageModelV1Middleware {\n  return {\n    middlewareVersion: 'v1',\n    transformParams: async ({ params }) => {\n      return {\n        ...settings,\n        ...params,\n        providerMetadata: mergeObjects(\n          settings.providerMetadata,\n          params.providerMetadata,\n        ),\n\n        // special case for temperature 0\n        // TODO remove when temperature defaults to undefined\n        temperature:\n          params.temperature === 0 || params.temperature == null\n            ? (settings.temperature ?? 0)\n            : params.temperature,\n      };\n    },\n  };\n}\n", "/**\n * Returns the index of the start of the searchedText in the text, or null if it\n * is not found.\n */\nexport function getPotentialStartIndex(\n  text: string,\n  searchedText: string,\n): number | null {\n  // Return null immediately if searchedText is empty.\n  if (searchedText.length === 0) {\n    return null;\n  }\n\n  // Check if the searchedText exists as a direct substring of text.\n  const directIndex = text.indexOf(searchedText);\n  if (directIndex !== -1) {\n    return directIndex;\n  }\n\n  // Otherwise, look for the largest suffix of \"text\" that matches\n  // a prefix of \"searchedText\". We go from the end of text inward.\n  for (let i = text.length - 1; i >= 0; i--) {\n    const suffix = text.substring(i);\n    if (searchedText.startsWith(suffix)) {\n      return i;\n    }\n  }\n\n  return null;\n}\n", "import type { LanguageModelV1StreamPart } from '@ai-sdk/provider';\nimport { getPotentialStartIndex } from '../util/get-potential-start-index';\nimport type { LanguageModelV1Middleware } from './language-model-v1-middleware';\n\n/**\n * Extract an XML-tagged reasoning section from the generated text and exposes it\n * as a `reasoning` property on the result.\n *\n * @param tagName - The name of the XML tag to extract reasoning from.\n * @param separator - The separator to use between reasoning and text sections.\n * @param startWithReasoning - Whether to start with reasoning tokens.\n */\nexport function extractReasoningMiddleware({\n  tagName,\n  separator = '\\n',\n  startWithReasoning = false,\n}: {\n  tagName: string;\n  separator?: string;\n  startWithReasoning?: boolean;\n}): LanguageModelV1Middleware {\n  const openingTag = `<${tagName}>`;\n  const closingTag = `<\\/${tagName}>`;\n\n  return {\n    middlewareVersion: 'v1',\n    wrapGenerate: async ({ doGenerate }) => {\n      const { text: rawText, ...rest } = await doGenerate();\n\n      if (rawText == null) {\n        return { text: rawText, ...rest };\n      }\n\n      const text = startWithReasoning ? openingTag + rawText : rawText;\n\n      const regexp = new RegExp(`${openingTag}(.*?)${closingTag}`, 'gs');\n      const matches = Array.from(text.matchAll(regexp));\n\n      if (!matches.length) {\n        return { text, ...rest };\n      }\n\n      const reasoning = matches.map(match => match[1]).join(separator);\n\n      let textWithoutReasoning = text;\n      for (let i = matches.length - 1; i >= 0; i--) {\n        const match = matches[i];\n\n        const beforeMatch = textWithoutReasoning.slice(0, match.index);\n        const afterMatch = textWithoutReasoning.slice(\n          match.index! + match[0].length,\n        );\n\n        textWithoutReasoning =\n          beforeMatch +\n          (beforeMatch.length > 0 && afterMatch.length > 0 ? separator : '') +\n          afterMatch;\n      }\n\n      return { ...rest, text: textWithoutReasoning, reasoning };\n    },\n\n    wrapStream: async ({ doStream }) => {\n      const { stream, ...rest } = await doStream();\n\n      let isFirstReasoning = true;\n      let isFirstText = true;\n      let afterSwitch = false;\n      let isReasoning = startWithReasoning;\n      let buffer = '';\n\n      return {\n        stream: stream.pipeThrough(\n          new TransformStream<\n            LanguageModelV1StreamPart,\n            LanguageModelV1StreamPart\n          >({\n            transform: (chunk, controller) => {\n              if (chunk.type !== 'text-delta') {\n                controller.enqueue(chunk);\n                return;\n              }\n\n              buffer += chunk.textDelta;\n\n              function publish(text: string) {\n                if (text.length > 0) {\n                  const prefix =\n                    afterSwitch &&\n                    (isReasoning ? !isFirstReasoning : !isFirstText)\n                      ? separator\n                      : '';\n\n                  controller.enqueue({\n                    type: isReasoning ? 'reasoning' : 'text-delta',\n                    textDelta: prefix + text,\n                  });\n                  afterSwitch = false;\n\n                  if (isReasoning) {\n                    isFirstReasoning = false;\n                  } else {\n                    isFirstText = false;\n                  }\n                }\n              }\n\n              do {\n                const nextTag = isReasoning ? closingTag : openingTag;\n                const startIndex = getPotentialStartIndex(buffer, nextTag);\n\n                // no opening or closing tag found, publish the buffer\n                if (startIndex == null) {\n                  publish(buffer);\n                  buffer = '';\n                  break;\n                }\n\n                // publish text before the tag\n                publish(buffer.slice(0, startIndex));\n\n                const foundFullMatch =\n                  startIndex + nextTag.length <= buffer.length;\n\n                if (foundFullMatch) {\n                  buffer = buffer.slice(startIndex + nextTag.length);\n                  isReasoning = !isReasoning;\n                  afterSwitch = true;\n                } else {\n                  buffer = buffer.slice(startIndex);\n                  break;\n                }\n              } while (true);\n            },\n          }),\n        ),\n        ...rest,\n      };\n    },\n  };\n}\n", "import type { LanguageModelV1StreamPart } from '@ai-sdk/provider';\nimport type { LanguageModelV1Middleware } from './language-model-v1-middleware';\n\n/**\n * Simulates streaming chunks with the response from a generate call.\n */\nexport function simulateStreamingMiddleware(): LanguageModelV1Middleware {\n  return {\n    middlewareVersion: 'v1',\n    wrapStream: async ({ doGenerate }) => {\n      const result = await doGenerate();\n\n      const simulatedStream = new ReadableStream<LanguageModelV1StreamPart>({\n        start(controller) {\n          controller.enqueue({ type: 'response-metadata', ...result.response });\n\n          if (result.reasoning) {\n            if (typeof result.reasoning === 'string') {\n              controller.enqueue({\n                type: 'reasoning',\n                textDelta: result.reasoning,\n              });\n            } else {\n              for (const reasoning of result.reasoning) {\n                switch (reasoning.type) {\n                  case 'text': {\n                    controller.enqueue({\n                      type: 'reasoning',\n                      textDelta: reasoning.text,\n                    });\n                    if (reasoning.signature != null) {\n                      controller.enqueue({\n                        type: 'reasoning-signature',\n                        signature: reasoning.signature,\n                      });\n                    }\n                    break;\n                  }\n                  case 'redacted': {\n                    controller.enqueue({\n                      type: 'redacted-reasoning',\n                      data: reasoning.data,\n                    });\n                    break;\n                  }\n                }\n              }\n            }\n          }\n\n          if (result.text) {\n            controller.enqueue({\n              type: 'text-delta',\n              textDelta: result.text,\n            });\n          }\n\n          if (result.toolCalls) {\n            for (const toolCall of result.toolCalls) {\n              controller.enqueue({\n                type: 'tool-call-delta',\n                toolCallType: 'function',\n                toolCallId: toolCall.toolCallId,\n                toolName: toolCall.toolName,\n                argsTextDelta: toolCall.args,\n              });\n\n              controller.enqueue({\n                type: 'tool-call',\n                ...toolCall,\n              });\n            }\n          }\n\n          controller.enqueue({\n            type: 'finish',\n            finishReason: result.finishReason,\n            usage: result.usage,\n            logprobs: result.logprobs,\n            providerMetadata: result.providerMetadata,\n          });\n\n          controller.close();\n        },\n      });\n\n      return {\n        stream: simulatedStream,\n        rawCall: result.rawCall,\n        rawResponse: result.rawResponse,\n        warnings: result.warnings,\n      };\n    },\n  };\n}\n", "import { LanguageModelV1, LanguageModelV1CallOptions } from '@ai-sdk/provider';\nimport { LanguageModelV1Middleware } from './language-model-v1-middleware';\nimport { asArray } from '../../util/as-array';\n\n/**\n * Wraps a LanguageModelV1 instance with middleware functionality.\n * This function allows you to apply middleware to transform parameters,\n * wrap generate operations, and wrap stream operations of a language model.\n *\n * @param options - Configuration options for wrapping the language model.\n * @param options.model - The original LanguageModelV1 instance to be wrapped.\n * @param options.middleware - The middleware to be applied to the language model. When multiple middlewares are provided, the first middleware will transform the input first, and the last middleware will be wrapped directly around the model.\n * @param options.modelId - Optional custom model ID to override the original model's ID.\n * @param options.providerId - Optional custom provider ID to override the original model's provider.\n * @returns A new LanguageModelV1 instance with middleware applied.\n */\nexport const wrapLanguageModel = ({\n  model,\n  middleware: middlewareArg,\n  modelId,\n  providerId,\n}: {\n  model: LanguageModelV1;\n  middleware: LanguageModelV1Middleware | LanguageModelV1Middleware[];\n  modelId?: string;\n  providerId?: string;\n}): LanguageModelV1 => {\n  return asArray(middlewareArg)\n    .reverse()\n    .reduce((wrappedModel, middleware) => {\n      return doWrap({ model: wrappedModel, middleware, modelId, providerId });\n    }, model);\n};\n\nconst doWrap = ({\n  model,\n  middleware: { transformParams, wrapGenerate, wrapStream },\n  modelId,\n  providerId,\n}: {\n  model: LanguageModelV1;\n  middleware: LanguageModelV1Middleware;\n  modelId?: string;\n  providerId?: string;\n}): LanguageModelV1 => {\n  async function doTransform({\n    params,\n    type,\n  }: {\n    params: LanguageModelV1CallOptions;\n    type: 'generate' | 'stream';\n  }) {\n    return transformParams ? await transformParams({ params, type }) : params;\n  }\n\n  return {\n    specificationVersion: 'v1',\n\n    provider: providerId ?? model.provider,\n    modelId: modelId ?? model.modelId,\n\n    defaultObjectGenerationMode: model.defaultObjectGenerationMode,\n    supportsImageUrls: model.supportsImageUrls,\n    supportsUrl: model.supportsUrl?.bind(model),\n    supportsStructuredOutputs: model.supportsStructuredOutputs,\n\n    async doGenerate(\n      params: LanguageModelV1CallOptions,\n    ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n      const transformedParams = await doTransform({ params, type: 'generate' });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapGenerate\n        ? wrapGenerate({\n            doGenerate,\n            doStream,\n            params: transformedParams,\n            model,\n          })\n        : doGenerate();\n    },\n\n    async doStream(\n      params: LanguageModelV1CallOptions,\n    ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n      const transformedParams = await doTransform({ params, type: 'stream' });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapStream\n        ? wrapStream({ doGenerate, doStream, params: transformedParams, model })\n        : doStream();\n    },\n  };\n};\n\n/**\n * @deprecated Use `wrapLanguageModel` instead.\n */\n// TODO remove in v5\nexport const experimental_wrapLanguageModel = wrapLanguageModel;\n", "import { Message } from '@ai-sdk/ui-utils';\n\n/**\n * Appends a client message to the messages array.\n * If the last message in the array has the same id as the new message, it will be replaced.\n * Otherwise, the new message will be appended.\n */\nexport function appendClientMessage({\n  messages,\n  message,\n}: {\n  messages: Message[];\n  message: Message;\n}) {\n  return [\n    ...(messages.length > 0 && messages[messages.length - 1].id === message.id\n      ? messages.slice(0, -1)\n      : messages),\n    message,\n  ];\n}\n", "import {\n  extractMaxToolInvocationStep,\n  FileUIPart,\n  Message,\n  ReasoningUIPart,\n  StepStartUIPart,\n  TextUIPart,\n  ToolInvocation,\n  ToolInvocationUIPart,\n} from '@ai-sdk/ui-utils';\nimport { ResponseMessage } from '../generate-text/step-result';\nimport { convertDataContentToBase64String } from './data-content';\nimport { AISDKError } from '@ai-sdk/provider';\n\n/**\n * Appends the ResponseMessage[] from the response to a Message[] (for useChat).\n * The messages are converted to Messages before being appended.\n * Timestamps are generated for the new messages.\n *\n * @returns A new Message[] with the response messages appended.\n */\nexport function appendResponseMessages({\n  messages,\n  responseMessages,\n  _internal: { currentDate = () => new Date() } = {},\n}: {\n  messages: Message[];\n  responseMessages: ResponseMessage[];\n\n  /**\nInternal. For test use only. May change without notice.\n     */\n  _internal?: {\n    currentDate?: () => Date;\n  };\n}): Message[] {\n  const clonedMessages = structuredClone(messages);\n\n  for (const message of responseMessages) {\n    const role = message.role;\n\n    // check if the last message is an assistant message:\n    const lastMessage = clonedMessages[clonedMessages.length - 1];\n    const isLastMessageAssistant = lastMessage.role === 'assistant';\n\n    switch (role) {\n      case 'assistant': {\n        function getToolInvocations(step: number) {\n          return (\n            typeof message.content === 'string'\n              ? []\n              : message.content.filter(part => part.type === 'tool-call')\n          ).map(call => ({\n            state: 'call' as const,\n            step,\n            args: call.args,\n            toolCallId: call.toolCallId,\n            toolName: call.toolName,\n          }));\n        }\n\n        const parts: Array<\n          | TextUIPart\n          | ReasoningUIPart\n          | ToolInvocationUIPart\n          | FileUIPart\n          | StepStartUIPart\n        > = [{ type: 'step-start' as const }]; // always start with a step-start part\n        let textContent = '';\n        let reasoningTextContent = undefined;\n\n        if (typeof message.content === 'string') {\n          textContent = message.content;\n          parts.push({\n            type: 'text' as const,\n            text: message.content,\n          });\n        } else {\n          let reasoningPart: ReasoningUIPart | undefined = undefined;\n          for (const part of message.content) {\n            switch (part.type) {\n              case 'text': {\n                reasoningPart = undefined; // reset the reasoning part\n\n                textContent += part.text;\n                parts.push({\n                  type: 'text' as const,\n                  text: part.text,\n                });\n                break;\n              }\n              case 'reasoning': {\n                if (reasoningPart == null) {\n                  reasoningPart = {\n                    type: 'reasoning' as const,\n                    reasoning: '',\n                    details: [],\n                  };\n                  parts.push(reasoningPart);\n                }\n\n                reasoningTextContent = (reasoningTextContent ?? '') + part.text;\n                reasoningPart.reasoning += part.text;\n                reasoningPart.details.push({\n                  type: 'text' as const,\n                  text: part.text,\n                  signature: part.signature,\n                });\n                break;\n              }\n              case 'redacted-reasoning': {\n                if (reasoningPart == null) {\n                  reasoningPart = {\n                    type: 'reasoning' as const,\n                    reasoning: '',\n                    details: [],\n                  };\n                  parts.push(reasoningPart);\n                }\n\n                reasoningPart.details.push({\n                  type: 'redacted' as const,\n                  data: part.data,\n                });\n                break;\n              }\n              case 'tool-call':\n                break;\n              case 'file':\n                if (part.data instanceof URL) {\n                  throw new AISDKError({\n                    name: 'InvalidAssistantFileData',\n                    message: 'File data cannot be a URL',\n                  });\n                }\n                parts.push({\n                  type: 'file' as const,\n                  mimeType: part.mimeType,\n                  data: convertDataContentToBase64String(part.data),\n                });\n                break;\n            }\n          }\n        }\n\n        if (isLastMessageAssistant) {\n          const maxStep = extractMaxToolInvocationStep(\n            lastMessage.toolInvocations,\n          );\n\n          lastMessage.parts ??= [];\n\n          lastMessage.content = textContent;\n          lastMessage.reasoning = reasoningTextContent;\n          lastMessage.parts.push(...parts);\n\n          lastMessage.toolInvocations = [\n            ...(lastMessage.toolInvocations ?? []),\n            ...getToolInvocations(maxStep === undefined ? 0 : maxStep + 1),\n          ];\n\n          getToolInvocations(maxStep === undefined ? 0 : maxStep + 1)\n            .map(call => ({\n              type: 'tool-invocation' as const,\n              toolInvocation: call,\n            }))\n            .forEach(part => {\n              lastMessage.parts!.push(part);\n            });\n        } else {\n          // last message was a user message, add the assistant message:\n          clonedMessages.push({\n            role: 'assistant',\n            id: message.id,\n            createdAt: currentDate(), // generate a createdAt date for the message, will be overridden by the client\n            content: textContent,\n            reasoning: reasoningTextContent,\n            toolInvocations: getToolInvocations(0),\n            parts: [\n              ...parts,\n              ...getToolInvocations(0).map(call => ({\n                type: 'tool-invocation' as const,\n                toolInvocation: call,\n              })),\n            ],\n          });\n        }\n\n        break;\n      }\n\n      case 'tool': {\n        // for tool call results, add the result to previous message:\n        lastMessage.toolInvocations ??= []; // ensure the toolInvocations array exists\n\n        if (lastMessage.role !== 'assistant') {\n          throw new Error(\n            `Tool result must follow an assistant message: ${lastMessage.role}`,\n          );\n        }\n\n        lastMessage.parts ??= [];\n\n        for (const contentPart of message.content) {\n          // find the tool call in the previous message:\n          const toolCall = lastMessage.toolInvocations.find(\n            call => call.toolCallId === contentPart.toolCallId,\n          );\n          const toolCallPart: ToolInvocationUIPart | undefined =\n            lastMessage.parts.find(\n              (part): part is ToolInvocationUIPart =>\n                part.type === 'tool-invocation' &&\n                part.toolInvocation.toolCallId === contentPart.toolCallId,\n            );\n\n          if (!toolCall) {\n            throw new Error('Tool call not found in previous message');\n          }\n\n          // add the result to the tool call:\n          toolCall.state = 'result';\n          const toolResult = toolCall as ToolInvocation & { state: 'result' };\n          toolResult.result = contentPart.result;\n\n          if (toolCallPart) {\n            toolCallPart.toolInvocation = toolResult;\n          } else {\n            lastMessage.parts.push({\n              type: 'tool-invocation' as const,\n              toolInvocation: toolResult,\n            });\n          }\n        }\n\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported message role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return clonedMessages;\n}\n", "import { NoSuchModelError, ProviderV1 } from '@ai-sdk/provider';\nimport { EmbeddingModel, ImageModel, LanguageModel, Provider } from '../types';\n\n/**\n * Creates a custom provider with specified language models, text embedding models, and an optional fallback provider.\n *\n * @param {Object} options - The options for creating the custom provider.\n * @param {Record<string, LanguageModel>} [options.languageModels] - A record of language models, where keys are model IDs and values are LanguageModel instances.\n * @param {Record<string, EmbeddingModel<string>>} [options.textEmbeddingModels] - A record of text embedding models, where keys are model IDs and values are EmbeddingModel<string> instances.\n * @param {Record<string, ImageModel>} [options.imageModels] - A record of image models, where keys are model IDs and values are ImageModel instances.\n * @param {Provider} [options.fallbackProvider] - An optional fallback provider to use when a requested model is not found in the custom provider.\n * @returns {Provider} A Provider object with languageModel, textEmbeddingModel, and imageModel methods.\n *\n * @throws {NoSuchModelError} Throws when a requested model is not found and no fallback provider is available.\n */\nexport function customProvider<\n  LANGUAGE_MODELS extends Record<string, LanguageModel>,\n  EMBEDDING_MODELS extends Record<string, EmbeddingModel<string>>,\n  IMAGE_MODELS extends Record<string, ImageModel>,\n>({\n  languageModels,\n  textEmbeddingModels,\n  imageModels,\n  fallbackProvider,\n}: {\n  languageModels?: LANGUAGE_MODELS;\n  textEmbeddingModels?: EMBEDDING_MODELS;\n  imageModels?: IMAGE_MODELS;\n  fallbackProvider?: ProviderV1;\n}): Provider & {\n  languageModel(modelId: ExtractModelId<LANGUAGE_MODELS>): LanguageModel;\n  textEmbeddingModel(\n    modelId: ExtractModelId<EMBEDDING_MODELS>,\n  ): EmbeddingModel<string>;\n  imageModel(modelId: ExtractModelId<IMAGE_MODELS>): ImageModel;\n} {\n  return {\n    languageModel(modelId: ExtractModelId<LANGUAGE_MODELS>): LanguageModel {\n      if (languageModels != null && modelId in languageModels) {\n        return languageModels[modelId];\n      }\n\n      if (fallbackProvider) {\n        return fallbackProvider.languageModel(modelId);\n      }\n\n      throw new NoSuchModelError({ modelId, modelType: 'languageModel' });\n    },\n\n    textEmbeddingModel(\n      modelId: ExtractModelId<EMBEDDING_MODELS>,\n    ): EmbeddingModel<string> {\n      if (textEmbeddingModels != null && modelId in textEmbeddingModels) {\n        return textEmbeddingModels[modelId];\n      }\n\n      if (fallbackProvider) {\n        return fallbackProvider.textEmbeddingModel(modelId);\n      }\n\n      throw new NoSuchModelError({ modelId, modelType: 'textEmbeddingModel' });\n    },\n\n    imageModel(modelId: ExtractModelId<IMAGE_MODELS>): ImageModel {\n      if (imageModels != null && modelId in imageModels) {\n        return imageModels[modelId];\n      }\n\n      if (fallbackProvider?.imageModel) {\n        return fallbackProvider.imageModel(modelId);\n      }\n\n      throw new NoSuchModelError({ modelId, modelType: 'imageModel' });\n    },\n  };\n}\n\n/**\n * @deprecated Use `customProvider` instead.\n */\nexport const experimental_customProvider = customProvider;\n\ntype ExtractModelId<MODELS extends Record<string, unknown>> = Extract<\n  keyof MODELS,\n  string\n>;\n", "import { AISDKError, NoSuchModelError } from '@ai-sdk/provider';\n\nconst name = 'AI_NoSuchProviderError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchProviderError extends NoSuchModelError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly providerId: string;\n  readonly availableProviders: string[];\n\n  constructor({\n    modelId,\n    modelType,\n    providerId,\n    availableProviders,\n    message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})`,\n  }: {\n    modelId: string;\n    modelType: 'languageModel' | 'textEmbeddingModel';\n    providerId: string;\n    availableProviders: string[];\n    message?: string;\n  }) {\n    super({ errorName: name, modelId, modelType, message });\n\n    this.providerId = providerId;\n    this.availableProviders = availableProviders;\n  }\n\n  static isInstance(error: unknown): error is NoSuchProviderError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { NoSuchModelError, ProviderV1 } from '@ai-sdk/provider';\nimport { EmbeddingModel, ImageModel, LanguageModel } from '../types';\nimport { NoSuchProviderError } from './no-such-provider-error';\n\ntype ExtractLiteralUnion<T> = T extends string\n  ? string extends T\n    ? never\n    : T\n  : never;\n\nexport interface ProviderRegistryProvider<\n  PROVIDERS extends Record<string, ProviderV1> = Record<string, ProviderV1>,\n  SEPARATOR extends string = ':',\n> {\n  languageModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string\n      ? `${KEY & string}${SEPARATOR}${ExtractLiteralUnion<Parameters<NonNullable<PROVIDERS[KEY]['languageModel']>>[0]>}`\n      : never,\n  ): LanguageModel;\n  languageModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string ? `${KEY & string}${SEPARATOR}${string}` : never,\n  ): LanguageModel;\n\n  textEmbeddingModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string\n      ? `${KEY & string}${SEPARATOR}${ExtractLiteralUnion<Parameters<NonNullable<PROVIDERS[KEY]['textEmbeddingModel']>>[0]>}`\n      : never,\n  ): EmbeddingModel<string>;\n  textEmbeddingModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string ? `${KEY & string}${SEPARATOR}${string}` : never,\n  ): EmbeddingModel<string>;\n\n  imageModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string\n      ? `${KEY & string}${SEPARATOR}${ExtractLiteralUnion<Parameters<NonNullable<PROVIDERS[KEY]['imageModel']>>[0]>}`\n      : never,\n  ): ImageModel;\n  imageModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string ? `${KEY & string}${SEPARATOR}${string}` : never,\n  ): ImageModel;\n}\n\n/**\n * Creates a registry for the given providers.\n */\nexport function createProviderRegistry<\n  PROVIDERS extends Record<string, ProviderV1>,\n  SEPARATOR extends string = ':',\n>(\n  providers: PROVIDERS,\n  {\n    separator = ':' as SEPARATOR,\n  }: {\n    separator?: SEPARATOR;\n  } = {},\n): ProviderRegistryProvider<PROVIDERS, SEPARATOR> {\n  const registry = new DefaultProviderRegistry<PROVIDERS, SEPARATOR>({\n    separator,\n  });\n\n  for (const [id, provider] of Object.entries(providers)) {\n    registry.registerProvider({ id, provider } as {\n      id: keyof PROVIDERS;\n      provider: PROVIDERS[keyof PROVIDERS];\n    });\n  }\n\n  return registry;\n}\n\n/**\n * @deprecated Use `createProviderRegistry` instead.\n */\nexport const experimental_createProviderRegistry = createProviderRegistry;\n\nclass DefaultProviderRegistry<\n  PROVIDERS extends Record<string, ProviderV1>,\n  SEPARATOR extends string,\n> implements ProviderRegistryProvider<PROVIDERS, SEPARATOR>\n{\n  private providers: PROVIDERS = {} as PROVIDERS;\n  private separator: SEPARATOR;\n\n  constructor({ separator }: { separator: SEPARATOR }) {\n    this.separator = separator;\n  }\n\n  registerProvider<K extends keyof PROVIDERS>({\n    id,\n    provider,\n  }: {\n    id: K;\n    provider: PROVIDERS[K];\n  }): void {\n    this.providers[id] = provider;\n  }\n\n  private getProvider(id: string): ProviderV1 {\n    const provider = this.providers[id as keyof PROVIDERS];\n\n    if (provider == null) {\n      throw new NoSuchProviderError({\n        modelId: id,\n        modelType: 'languageModel',\n        providerId: id,\n        availableProviders: Object.keys(this.providers),\n      });\n    }\n\n    return provider;\n  }\n\n  private splitId(\n    id: string,\n    modelType: 'languageModel' | 'textEmbeddingModel' | 'imageModel',\n  ): [string, string] {\n    const index = id.indexOf(this.separator);\n\n    if (index === -1) {\n      throw new NoSuchModelError({\n        modelId: id,\n        modelType,\n        message:\n          `Invalid ${modelType} id for registry: ${id} ` +\n          `(must be in the format \"providerId${this.separator}modelId\")`,\n      });\n    }\n\n    return [id.slice(0, index), id.slice(index + this.separator.length)];\n  }\n\n  languageModel<KEY extends keyof PROVIDERS>(\n    id: `${KEY & string}${SEPARATOR}${string}`,\n  ): LanguageModel {\n    const [providerId, modelId] = this.splitId(id, 'languageModel');\n    const model = this.getProvider(providerId).languageModel?.(modelId);\n\n    if (model == null) {\n      throw new NoSuchModelError({ modelId: id, modelType: 'languageModel' });\n    }\n\n    return model;\n  }\n\n  textEmbeddingModel<KEY extends keyof PROVIDERS>(\n    id: `${KEY & string}${SEPARATOR}${string}`,\n  ): EmbeddingModel<string> {\n    const [providerId, modelId] = this.splitId(id, 'textEmbeddingModel');\n    const provider = this.getProvider(providerId);\n\n    const model = provider.textEmbeddingModel?.(modelId);\n\n    if (model == null) {\n      throw new NoSuchModelError({\n        modelId: id,\n        modelType: 'textEmbeddingModel',\n      });\n    }\n\n    return model;\n  }\n\n  imageModel<KEY extends keyof PROVIDERS>(\n    id: `${KEY & string}${SEPARATOR}${string}`,\n  ): ImageModel {\n    const [providerId, modelId] = this.splitId(id, 'imageModel');\n    const provider = this.getProvider(providerId);\n\n    const model = provider.imageModel?.(modelId);\n\n    if (model == null) {\n      throw new NoSuchModelError({ modelId: id, modelType: 'imageModel' });\n    }\n\n    return model;\n  }\n}\n", "import { JSONSchema7 } from '@ai-sdk/provider';\nimport { jsonSchema } from '@ai-sdk/ui-utils';\nimport { z, ZodType } from 'zod';\nimport { MCPClientError } from '../../../errors';\nimport { inferParameters, tool, Tool, ToolExecutionOptions } from '../tool';\nimport {\n  JSONRPCError,\n  JSONRPCNotification,\n  JSONRPCRequest,\n  JSONRPCResponse,\n} from './json-rpc-message';\nimport {\n  createMcpTransport,\n  isCustomMcpTransport,\n  MCPTransport,\n  MCPTransportConfig,\n} from './mcp-transport';\nimport {\n  CallToolResult,\n  CallToolResultSchema,\n  Configuration as ClientConfiguration,\n  InitializeResultSchema,\n  LATEST_PROTOCOL_VERSION,\n  ListToolsResult,\n  ListToolsResultSchema,\n  McpToolSet,\n  Notification,\n  PaginatedRequest,\n  Request,\n  RequestOptions,\n  ServerCapabilities,\n  SUPPORTED_PROTOCOL_VERSIONS,\n  ToolSchemas,\n} from './types';\n\nconst CLIENT_VERSION = '1.0.0';\n\ninterface MCPClientConfig {\n  /** Transport configuration for connecting to the MCP server */\n  transport: MCPTransportConfig | MCPTransport;\n  /** Optional callback for uncaught errors */\n  onUncaughtError?: (error: unknown) => void;\n  /** Optional client name, defaults to 'ai-sdk-mcp-client' */\n  name?: string;\n}\n\nexport async function createMCPClient(\n  config: MCPClientConfig,\n): Promise<MCPClient> {\n  const client = new MCPClient(config);\n  await client.init();\n  return client;\n}\n\n/**\n * A lightweight MCP Client implementation\n *\n * The primary purpose of this client is tool conversion between MCP<>AI SDK\n * but can later be extended to support other MCP features\n *\n * Tool parameters are automatically inferred from the server's JSON schema\n * if not explicitly provided in the tools configuration\n *\n * This client is meant to be used to communicate with a single server. To communicate and fetch tools across multiple servers, it's recommended to create a new client instance per server.\n *\n * Not supported:\n * - Client options (e.g. sampling, roots) as they are not needed for tool conversion\n * - Accepting notifications\n * - Session management (when passing a sessionId to an instance of the Streamable HTTP transport)\n * - Resumable SSE streams\n */\nclass MCPClient {\n  private transport: MCPTransport;\n  private onUncaughtError?: (error: unknown) => void;\n  private clientInfo: ClientConfiguration;\n  private requestMessageId = 0;\n  private responseHandlers: Map<\n    number,\n    (response: JSONRPCResponse | Error) => void\n  > = new Map();\n  private serverCapabilities: ServerCapabilities = {};\n  private isClosed = true;\n\n  constructor({\n    transport: transportConfig,\n    name = 'ai-sdk-mcp-client',\n    onUncaughtError,\n  }: MCPClientConfig) {\n    this.onUncaughtError = onUncaughtError;\n\n    if (isCustomMcpTransport(transportConfig)) {\n      this.transport = transportConfig;\n    } else {\n      this.transport = createMcpTransport(transportConfig);\n    }\n\n    this.transport.onclose = () => this.onClose();\n    this.transport.onerror = (error: Error) => this.onError(error);\n    this.transport.onmessage = message => {\n      if ('method' in message) {\n        // This lightweight client implementation does not support\n        // receiving notifications or requests from server.\n        // If we get an unsupported message, we can safely ignore it and pass to the onError handler:\n        this.onError(\n          new MCPClientError({\n            message: 'Unsupported message type',\n          }),\n        );\n        return;\n      }\n\n      this.onResponse(message);\n    };\n\n    this.clientInfo = {\n      name,\n      version: CLIENT_VERSION,\n    };\n  }\n\n  async init(): Promise<this> {\n    try {\n      await this.transport.start();\n      this.isClosed = false;\n\n      const result = await this.request({\n        request: {\n          method: 'initialize',\n          params: {\n            protocolVersion: LATEST_PROTOCOL_VERSION,\n            capabilities: {},\n            clientInfo: this.clientInfo,\n          },\n        },\n        resultSchema: InitializeResultSchema,\n      });\n\n      if (result === undefined) {\n        throw new MCPClientError({\n          message: 'Server sent invalid initialize result',\n        });\n      }\n\n      if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {\n        throw new MCPClientError({\n          message: `Server's protocol version is not supported: ${result.protocolVersion}`,\n        });\n      }\n\n      this.serverCapabilities = result.capabilities;\n\n      // Complete initialization handshake:\n      await this.notification({\n        method: 'notifications/initialized',\n      });\n\n      return this;\n    } catch (error) {\n      await this.close();\n      throw error;\n    }\n  }\n\n  async close(): Promise<void> {\n    if (this.isClosed) return;\n    await this.transport?.close();\n    this.onClose();\n  }\n\n  private assertCapability(method: string): void {\n    switch (method) {\n      case 'initialize':\n        break;\n      case 'tools/list':\n      case 'tools/call':\n        if (!this.serverCapabilities.tools) {\n          throw new MCPClientError({\n            message: `Server does not support tools`,\n          });\n        }\n        break;\n      default:\n        throw new MCPClientError({\n          message: `Unsupported method: ${method}`,\n        });\n    }\n  }\n\n  private async request<T extends ZodType<object>>({\n    request,\n    resultSchema,\n    options,\n  }: {\n    request: Request;\n    resultSchema: T;\n    options?: RequestOptions;\n  }): Promise<z.infer<T>> {\n    return new Promise((resolve, reject) => {\n      if (this.isClosed) {\n        return reject(\n          new MCPClientError({\n            message: 'Attempted to send a request from a closed client',\n          }),\n        );\n      }\n\n      this.assertCapability(request.method);\n\n      const signal = options?.signal;\n      signal?.throwIfAborted();\n\n      const messageId = this.requestMessageId++;\n      const jsonrpcRequest: JSONRPCRequest = {\n        ...request,\n        jsonrpc: '2.0',\n        id: messageId,\n      };\n\n      const cleanup = () => {\n        this.responseHandlers.delete(messageId);\n      };\n\n      this.responseHandlers.set(messageId, response => {\n        if (signal?.aborted) {\n          return reject(\n            new MCPClientError({\n              message: 'Request was aborted',\n              cause: signal.reason,\n            }),\n          );\n        }\n\n        if (response instanceof Error) {\n          return reject(response);\n        }\n\n        try {\n          const result = resultSchema.parse(response.result);\n          resolve(result);\n        } catch (error) {\n          const parseError = new MCPClientError({\n            message: 'Failed to parse server response',\n            cause: error,\n          });\n          reject(parseError);\n        }\n      });\n\n      this.transport.send(jsonrpcRequest).catch(error => {\n        cleanup();\n        reject(error);\n      });\n    });\n  }\n\n  private async listTools({\n    params,\n    options,\n  }: {\n    params?: PaginatedRequest['params'];\n    options?: RequestOptions;\n  } = {}): Promise<ListToolsResult> {\n    try {\n      return this.request({\n        request: { method: 'tools/list', params },\n        resultSchema: ListToolsResultSchema,\n        options,\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private async callTool({\n    name,\n    args,\n    options,\n  }: {\n    name: string;\n    args: Record<string, unknown>;\n    options?: ToolExecutionOptions;\n  }): Promise<CallToolResult> {\n    try {\n      return this.request({\n        request: { method: 'tools/call', params: { name, arguments: args } },\n        resultSchema: CallToolResultSchema,\n        options: {\n          signal: options?.abortSignal,\n        },\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private async notification(notification: Notification): Promise<void> {\n    const jsonrpcNotification: JSONRPCNotification = {\n      ...notification,\n      jsonrpc: '2.0',\n    };\n    await this.transport.send(jsonrpcNotification);\n  }\n\n  /**\n   * Returns a set of AI SDK tools from the MCP server\n   * @returns A record of tool names to their implementations\n   */\n  async tools<TOOL_SCHEMAS extends ToolSchemas = 'automatic'>({\n    schemas = 'automatic',\n  }: {\n    schemas?: TOOL_SCHEMAS;\n  } = {}): Promise<McpToolSet<TOOL_SCHEMAS>> {\n    const tools: Record<string, Tool> = {};\n\n    try {\n      const listToolsResult = await this.listTools();\n\n      for (const { name, description, inputSchema } of listToolsResult.tools) {\n        if (schemas !== 'automatic' && !(name in schemas)) {\n          continue;\n        }\n\n        const parameters =\n          schemas === 'automatic'\n            ? jsonSchema({\n                ...inputSchema,\n                properties: inputSchema.properties ?? {},\n                additionalProperties: false,\n              } as JSONSchema7)\n            : schemas[name].parameters;\n\n        const self = this;\n        const toolWithExecute = tool({\n          description,\n          parameters,\n          execute: async (\n            args: inferParameters<typeof parameters>,\n            options: ToolExecutionOptions,\n          ): Promise<CallToolResult> => {\n            options?.abortSignal?.throwIfAborted();\n\n            return self.callTool({\n              name,\n              args,\n              options,\n            });\n          },\n        });\n\n        tools[name] = toolWithExecute;\n      }\n\n      return tools as McpToolSet<TOOL_SCHEMAS>;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private onClose(): void {\n    if (this.isClosed) return;\n\n    this.isClosed = true;\n    const error = new MCPClientError({\n      message: 'Connection closed',\n    });\n\n    for (const handler of this.responseHandlers.values()) {\n      handler(error);\n    }\n\n    this.responseHandlers.clear();\n  }\n\n  private onError(error: unknown): void {\n    if (this.onUncaughtError) {\n      this.onUncaughtError(error);\n    }\n  }\n\n  private onResponse(response: JSONRPCResponse | JSONRPCError): void {\n    const messageId = Number(response.id);\n    const handler = this.responseHandlers.get(messageId);\n\n    if (handler === undefined) {\n      throw new MCPClientError({\n        message: `Protocol error: Received a response for an unknown message ID: ${JSON.stringify(\n          response,\n        )}`,\n      });\n    }\n\n    this.responseHandlers.delete(messageId);\n\n    handler(\n      'result' in response\n        ? response\n        : new MCPClientError({\n            message: response.error.message,\n            cause: response.error,\n          }),\n    );\n  }\n}\n", "import { Schema } from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { ToolResultContent } from '../prompt/tool-result-content';\nimport { CoreMessage } from '../prompt/message';\n\nexport type ToolParameters = z.ZodTypeAny | Schema<any>;\n\nexport type inferParameters<PARAMETERS extends ToolParameters> =\n  PARAMETERS extends Schema<any>\n    ? PARAMETERS['_type']\n    : PARAMETERS extends z.ZodTypeAny\n      ? z.infer<PARAMETERS>\n      : never;\n\nexport interface ToolExecutionOptions {\n  /**\n   * The ID of the tool call. You can use it e.g. when sending tool-call related information with stream data.\n   */\n  toolCallId: string;\n\n  /**\n   * Messages that were sent to the language model to initiate the response that contained the tool call.\n   * The messages **do not** include the system prompt nor the assistant response that contained the tool call.\n   */\n  messages: CoreMessage[];\n\n  /**\n   * An optional abort signal that indicates that the overall operation should be aborted.\n   */\n  abortSignal?: AbortSignal;\n}\n\n/**\nA tool contains the description and the schema of the input that the tool expects.\nThis enables the language model to generate the input.\n\nThe tool can also contain an optional execute function for the actual execution function of the tool.\n */\nexport type Tool<PARAMETERS extends ToolParameters = any, RESULT = any> = {\n  /**\nThe schema of the input that the tool expects. The language model will use this to generate the input.\nIt is also used to validate the output of the language model.\nUse descriptions to make the input understandable for the language model.\n   */\n  parameters: PARAMETERS;\n\n  /**\nAn optional description of what the tool does.\nWill be used by the language model to decide whether to use the tool.\nNot used for provider-defined tools.\n   */\n  description?: string;\n\n  /**\nOptional conversion function that maps the tool result to multi-part tool content for LLMs.\n   */\n  experimental_toToolResultContent?: (result: RESULT) => ToolResultContent;\n\n  /**\nAn async function that is called with the arguments from the tool call and produces a result.\nIf not provided, the tool will not be executed automatically.\n\n@args is the input of the tool call.\n@options.abortSignal is a signal that can be used to abort the tool call.\n   */\n  execute?: (\n    args: inferParameters<PARAMETERS>,\n    options: ToolExecutionOptions,\n  ) => PromiseLike<RESULT>;\n} & (\n  | {\n      /**\nFunction tool.\n       */\n      type?: undefined | 'function';\n    }\n  | {\n      /**\nProvider-defined tool.\n       */\n      type: 'provider-defined';\n\n      /**\nThe ID of the tool. Should follow the format `<provider-name>.<tool-name>`.\n       */\n      id: `${string}.${string}`;\n\n      /**\nThe arguments for configuring the tool. Must match the expected arguments defined by the provider for this tool.\n       */\n      args: Record<string, unknown>;\n    }\n);\n\n/**\n * @deprecated Use `Tool` instead.\n */\n// TODO remove in v5\nexport type CoreTool<\n  PARAMETERS extends ToolParameters = any,\n  RESULT = any,\n> = Tool<PARAMETERS, RESULT>;\n\n/**\nHelper function for inferring the execute args of a tool.\n */\n// Note: special type inference is needed for the execute function args to make sure they are inferred correctly.\nexport function tool<PARAMETERS extends ToolParameters, RESULT>(\n  tool: Tool<PARAMETERS, RESULT> & {\n    execute: (\n      args: inferParameters<PARAMETERS>,\n      options: ToolExecutionOptions,\n    ) => PromiseLike<RESULT>;\n  },\n): Tool<PARAMETERS, RESULT> & {\n  execute: (\n    args: inferParameters<PARAMETERS>,\n    options: ToolExecutionOptions,\n  ) => PromiseLike<RESULT>;\n};\nexport function tool<PARAMETERS extends ToolParameters, RESULT>(\n  tool: Tool<PARAMETERS, RESULT> & {\n    execute?: undefined;\n  },\n): Tool<PARAMETERS, RESULT> & {\n  execute: undefined;\n};\nexport function tool<PARAMETERS extends ToolParameters, RESULT = any>(\n  tool: Tool<PARAMETERS, RESULT>,\n): Tool<PARAMETERS, RESULT> {\n  return tool;\n}\n", "import { createEventSourceParserStream } from '@ai-sdk/provider-utils';\nimport { MCPClientError } from '../../../errors';\nimport { JSONRPCMessage, JSONRPCMessageSchema } from './json-rpc-message';\nimport { MCPTransport } from './mcp-transport';\n\nexport class SseMCPTransport implements MCPTransport {\n  private endpoint?: URL;\n  private abortController?: AbortController;\n  private url: URL;\n  private connected = false;\n  private sseConnection?: {\n    close: () => void;\n  };\n  private headers?: Record<string, string>;\n\n  onclose?: () => void;\n  onerror?: (error: unknown) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n\n  constructor({\n    url,\n    headers,\n  }: {\n    url: string;\n    headers?: Record<string, string>;\n  }) {\n    this.url = new URL(url);\n    this.headers = headers;\n  }\n\n  async start(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      if (this.connected) {\n        return resolve();\n      }\n\n      this.abortController = new AbortController();\n\n      const establishConnection = async () => {\n        try {\n          const headers = new Headers(this.headers);\n          headers.set('Accept', 'text/event-stream');\n          const response = await fetch(this.url.href, {\n            headers,\n            signal: this.abortController?.signal,\n          });\n\n          if (!response.ok || !response.body) {\n            const error = new MCPClientError({\n              message: `MCP SSE Transport Error: ${response.status} ${response.statusText}`,\n            });\n            this.onerror?.(error);\n            return reject(error);\n          }\n\n          const stream = response.body\n            .pipeThrough(new TextDecoderStream())\n            .pipeThrough(createEventSourceParserStream());\n\n          const reader = stream.getReader();\n\n          const processEvents = async () => {\n            try {\n              while (true) {\n                const { done, value } = await reader.read();\n\n                if (done) {\n                  if (this.connected) {\n                    this.connected = false;\n                    throw new MCPClientError({\n                      message:\n                        'MCP SSE Transport Error: Connection closed unexpectedly',\n                    });\n                  }\n                  return;\n                }\n\n                const { event, data } = value;\n\n                if (event === 'endpoint') {\n                  this.endpoint = new URL(data, this.url);\n\n                  if (this.endpoint.origin !== this.url.origin) {\n                    throw new MCPClientError({\n                      message: `MCP SSE Transport Error: Endpoint origin does not match connection origin: ${this.endpoint.origin}`,\n                    });\n                  }\n\n                  this.connected = true;\n                  resolve();\n                } else if (event === 'message') {\n                  try {\n                    const message = JSONRPCMessageSchema.parse(\n                      JSON.parse(data),\n                    );\n                    this.onmessage?.(message);\n                  } catch (error) {\n                    const e = new MCPClientError({\n                      message:\n                        'MCP SSE Transport Error: Failed to parse message',\n                      cause: error,\n                    });\n                    this.onerror?.(e);\n                    // We do not throw here so we continue processing events after reporting the error\n                  }\n                }\n              }\n            } catch (error) {\n              if (error instanceof Error && error.name === 'AbortError') {\n                return;\n              }\n\n              this.onerror?.(error);\n              reject(error);\n            }\n          };\n\n          this.sseConnection = {\n            close: () => reader.cancel(),\n          };\n\n          processEvents();\n        } catch (error) {\n          if (error instanceof Error && error.name === 'AbortError') {\n            return;\n          }\n\n          this.onerror?.(error);\n          reject(error);\n        }\n      };\n\n      establishConnection();\n    });\n  }\n\n  async close(): Promise<void> {\n    this.connected = false;\n    this.sseConnection?.close();\n    this.abortController?.abort();\n    this.onclose?.();\n  }\n\n  async send(message: JSONRPCMessage): Promise<void> {\n    if (!this.endpoint || !this.connected) {\n      throw new MCPClientError({\n        message: 'MCP SSE Transport Error: Not connected',\n      });\n    }\n\n    try {\n      const headers = new Headers(this.headers);\n      headers.set('Content-Type', 'application/json');\n      const init = {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(message),\n        signal: this.abortController?.signal,\n      };\n\n      const response = await fetch(this.endpoint, init);\n\n      if (!response.ok) {\n        const text = await response.text().catch(() => null);\n        const error = new MCPClientError({\n          message: `MCP SSE Transport Error: POSTing to endpoint (HTTP ${response.status}): ${text}`,\n        });\n        this.onerror?.(error);\n        return;\n      }\n    } catch (error) {\n      this.onerror?.(error);\n      return;\n    }\n  }\n}\n\nexport function deserializeMessage(line: string): JSONRPCMessage {\n  return JSONRPCMessageSchema.parse(JSON.parse(line));\n}\n", "import { z } from 'zod';\nimport { BaseParamsSchema, RequestSchema, ResultSchema } from './types';\n\nconst JSONRPC_VERSION = '2.0';\n\nconst JSONRPCRequestSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: z.union([z.string(), z.number().int()]),\n  })\n  .merge(RequestSchema)\n  .strict();\n\nexport type JSONRPCRequest = z.infer<typeof JSONRPCRequestSchema>;\n\nconst JSONRPCResponseSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: z.union([z.string(), z.number().int()]),\n    result: ResultSchema,\n  })\n  .strict();\n\nexport type JSONRPCResponse = z.infer<typeof JSONRPCResponseSchema>;\n\nconst JSONRPCErrorSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: z.union([z.string(), z.number().int()]),\n    error: z.object({\n      code: z.number().int(),\n      message: z.string(),\n      data: z.optional(z.unknown()),\n    }),\n  })\n  .strict();\n\nexport type JSONRPCError = z.infer<typeof JSONRPCErrorSchema>;\n\nconst JSONRPCNotificationSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n  })\n  .merge(\n    z.object({\n      method: z.string(),\n      params: z.optional(BaseParamsSchema),\n    }),\n  )\n  .strict();\n\nexport type JSONRPCNotification = z.infer<typeof JSONRPCNotificationSchema>;\n\nexport const JSONRPCMessageSchema = z.union([\n  JSONRPCRequestSchema,\n  JSONRPCNotificationSchema,\n  JSONRPCResponseSchema,\n  JSONRPCErrorSchema,\n]);\n\nexport type JSONRPCMessage = z.infer<typeof JSONRPCMessageSchema>;\n", "import { z } from 'zod';\nimport {\n  inferParameters,\n  Tool,\n  ToolExecutionOptions,\n  ToolParameters,\n} from '../tool';\n\nexport const LATEST_PROTOCOL_VERSION = '2024-11-05';\nexport const SUPPORTED_PROTOCOL_VERSIONS = [\n  LATEST_PROTOCOL_VERSION,\n  '2024-10-07',\n];\n\nexport type ToolSchemas =\n  | Record<string, { parameters: ToolParameters }>\n  | 'automatic'\n  | undefined;\n\nexport type McpToolSet<TOOL_SCHEMAS extends ToolSchemas = 'automatic'> =\n  TOOL_SCHEMAS extends Record<string, { parameters: ToolParameters }>\n    ? {\n        [K in keyof TOOL_SCHEMAS]: Tool<\n          TOOL_SCHEMAS[K]['parameters'],\n          CallToolResult\n        > & {\n          execute: (\n            args: inferParameters<TOOL_SCHEMAS[K]['parameters']>,\n            options: ToolExecutionOptions,\n          ) => PromiseLike<CallToolResult>;\n        };\n      }\n    : {\n        [k: string]: Tool<z.ZodUnknown, CallToolResult> & {\n          execute: (\n            args: unknown,\n            options: ToolExecutionOptions,\n          ) => PromiseLike<CallToolResult>;\n        };\n      };\n\nconst ClientOrServerImplementationSchema = z\n  .object({\n    name: z.string(),\n    version: z.string(),\n  })\n  .passthrough();\nexport type Configuration = z.infer<typeof ClientOrServerImplementationSchema>;\n\nexport const BaseParamsSchema = z\n  .object({\n    _meta: z.optional(z.object({}).passthrough()),\n  })\n  .passthrough();\ntype BaseParams = z.infer<typeof BaseParamsSchema>;\nexport const ResultSchema = BaseParamsSchema;\n\nexport const RequestSchema = z.object({\n  method: z.string(),\n  params: z.optional(BaseParamsSchema),\n});\nexport type Request = z.infer<typeof RequestSchema>;\nexport type RequestOptions = {\n  signal?: AbortSignal;\n  timeout?: number;\n  maxTotalTimeout?: number;\n};\n\nexport type Notification = z.infer<typeof RequestSchema>;\n\nconst ServerCapabilitiesSchema = z\n  .object({\n    experimental: z.optional(z.object({}).passthrough()),\n    logging: z.optional(z.object({}).passthrough()),\n    prompts: z.optional(\n      z\n        .object({\n          listChanged: z.optional(z.boolean()),\n        })\n        .passthrough(),\n    ),\n    resources: z.optional(\n      z\n        .object({\n          subscribe: z.optional(z.boolean()),\n          listChanged: z.optional(z.boolean()),\n        })\n        .passthrough(),\n    ),\n    tools: z.optional(\n      z\n        .object({\n          listChanged: z.optional(z.boolean()),\n        })\n        .passthrough(),\n    ),\n  })\n  .passthrough();\nexport type ServerCapabilities = z.infer<typeof ServerCapabilitiesSchema>;\n\nexport const InitializeResultSchema = ResultSchema.extend({\n  protocolVersion: z.string(),\n  capabilities: ServerCapabilitiesSchema,\n  serverInfo: ClientOrServerImplementationSchema,\n  instructions: z.optional(z.string()),\n});\nexport type InitializeResult = z.infer<typeof InitializeResultSchema>;\n\nexport type PaginatedRequest = Request & {\n  params?: BaseParams & {\n    cursor?: string;\n  };\n};\n\nconst PaginatedResultSchema = ResultSchema.extend({\n  nextCursor: z.optional(z.string()),\n});\n\nconst ToolSchema = z\n  .object({\n    name: z.string(),\n    description: z.optional(z.string()),\n    inputSchema: z\n      .object({\n        type: z.literal('object'),\n        properties: z.optional(z.object({}).passthrough()),\n      })\n      .passthrough(),\n  })\n  .passthrough();\nexport type MCPTool = z.infer<typeof ToolSchema>;\nexport const ListToolsResultSchema = PaginatedResultSchema.extend({\n  tools: z.array(ToolSchema),\n});\nexport type ListToolsResult = z.infer<typeof ListToolsResultSchema>;\n\nconst TextContentSchema = z\n  .object({\n    type: z.literal('text'),\n    text: z.string(),\n  })\n  .passthrough();\nconst ImageContentSchema = z\n  .object({\n    type: z.literal('image'),\n    data: z.string().base64(),\n    mimeType: z.string(),\n  })\n  .passthrough();\nconst ResourceContentsSchema = z\n  .object({\n    /**\n     * The URI of this resource.\n     */\n    uri: z.string(),\n    /**\n     * The MIME type of this resource, if known.\n     */\n    mimeType: z.optional(z.string()),\n  })\n  .passthrough();\nconst TextResourceContentsSchema = ResourceContentsSchema.extend({\n  text: z.string(),\n});\nconst BlobResourceContentsSchema = ResourceContentsSchema.extend({\n  blob: z.string().base64(),\n});\nconst EmbeddedResourceSchema = z\n  .object({\n    type: z.literal('resource'),\n    resource: z.union([TextResourceContentsSchema, BlobResourceContentsSchema]),\n  })\n  .passthrough();\n\nexport const CallToolResultSchema = ResultSchema.extend({\n  content: z.array(\n    z.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema]),\n  ),\n  isError: z.boolean().default(false).optional(),\n}).or(\n  ResultSchema.extend({\n    toolResult: z.unknown(),\n  }),\n);\nexport type CallToolResult = z.infer<typeof CallToolResultSchema>;\n", "import { MCPClientError } from '../../../errors';\nimport { JSONRPCMessage } from './json-rpc-message';\nimport { SseMCPTransport } from './mcp-sse-transport';\n\n/**\n * Transport interface for MCP (Model Context Protocol) communication.\n * Maps to the `Transport` interface in the MCP spec.\n */\nexport interface MCPTransport {\n  /**\n   * Initialize and start the transport\n   */\n  start(): Promise<void>;\n\n  /**\n   * Send a JSON-RPC message through the transport\n   * @param message The JSON-RPC message to send\n   */\n  send(message: JSONRPCMessage): Promise<void>;\n\n  /**\n   * Clean up and close the transport\n   */\n  close(): Promise<void>;\n\n  /**\n   * Event handler for transport closure\n   */\n  onclose?: () => void;\n\n  /**\n   * Event handler for transport errors\n   */\n  onerror?: (error: Error) => void;\n\n  /**\n   * Event handler for received messages\n   */\n  onmessage?: (message: JSONRPCMessage) => void;\n}\n\nexport type MCPTransportConfig = {\n  type: 'sse';\n\n  /**\n   * The URL of the MCP server.\n   */\n  url: string;\n\n  /**\n   * Additional HTTP headers to be sent with requests.\n   */\n  headers?: Record<string, string>;\n};\n\nexport function createMcpTransport(config: MCPTransportConfig): MCPTransport {\n  if (config.type !== 'sse') {\n    throw new MCPClientError({\n      message:\n        'Unsupported or invalid transport configuration. If you are using a custom transport, make sure it implements the MCPTransport interface.',\n    });\n  }\n\n  return new SseMCPTransport(config);\n}\n\nexport function isCustomMcpTransport(\n  transport: MCPTransportConfig | MCPTransport,\n): transport is MCPTransport {\n  return (\n    'start' in transport &&\n    typeof transport.start === 'function' &&\n    'send' in transport &&\n    typeof transport.send === 'function' &&\n    'close' in transport &&\n    typeof transport.close === 'function'\n  );\n}\n", "import { InvalidArgumentError } from '../../errors/invalid-argument-error';\n\n/**\n * Calculates the cosine similarity between two vectors. This is a useful metric for\n * comparing the similarity of two vectors such as embeddings.\n *\n * @param vector1 - The first vector.\n * @param vector2 - The second vector.\n * @param options - Optional configuration.\n * @param options.throwErrorForEmptyVectors - If true, throws an error for empty vectors. Default: false.\n *\n * @returns The cosine similarity between vector1 and vector2.\n * @returns 0 if either vector is the zero vector.\n *\n * @throws {InvalidArgumentError} If throwErrorForEmptyVectors is true and vectors are empty.\n * @throws {InvalidArgumentError} If the vectors do not have the same length.\n */\nexport function cosineSimilarity(\n  vector1: number[],\n  vector2: number[],\n  // TODO remove throw option in 5.0\n  options?: {\n    /**\n     * @deprecated will be removed in 5.0\n     */\n    throwErrorForEmptyVectors?: boolean;\n  },\n): number {\n  if (vector1.length !== vector2.length) {\n    throw new InvalidArgumentError({\n      parameter: 'vector1,vector2',\n      value: { vector1Length: vector1.length, vector2Length: vector2.length },\n      message: `Vectors must have the same length`,\n    });\n  }\n\n  const n = vector1.length;\n\n  if (n === 0) {\n    if (options?.throwErrorForEmptyVectors) {\n      throw new InvalidArgumentError({\n        parameter: 'vector1',\n        value: vector1,\n        message: 'Vectors cannot be empty',\n      });\n    }\n\n    return 0; // Return 0 for empty vectors if no error is thrown\n  }\n\n  let magnitudeSquared1 = 0;\n  let magnitudeSquared2 = 0;\n  let dotProduct = 0;\n\n  for (let i = 0; i < n; i++) {\n    const value1 = vector1[i];\n    const value2 = vector2[i];\n\n    magnitudeSquared1 += value1 * value1;\n    magnitudeSquared2 += value2 * value2;\n    dotProduct += value1 * value2;\n  }\n\n  return magnitudeSquared1 === 0 || magnitudeSquared2 === 0\n    ? 0\n    : dotProduct /\n        (Math.sqrt(magnitudeSquared1) * Math.sqrt(magnitudeSquared2));\n}\n", "import { delay as delayFunction } from '@ai-sdk/provider-utils';\n\n/**\n * Creates a ReadableStream that emits the provided values with an optional delay between each value.\n *\n * @param options - The configuration options\n * @param options.chunks - Array of values to be emitted by the stream\n * @param options.initialDelayInMs - Optional initial delay in milliseconds before emitting the first value (default: 0). Can be set to `null` to skip the initial delay. The difference between `initialDelayInMs: null` and `initialDelayInMs: 0` is that `initialDelayInMs: null` will emit the values without any delay, while `initialDelayInMs: 0` will emit the values with a delay of 0 milliseconds.\n * @param options.chunkDelayInMs - Optional delay in milliseconds between emitting each value (default: 0). Can be set to `null` to skip the delay. The difference between `chunkDelayInMs: null` and `chunkDelayInMs: 0` is that `chunkDelayInMs: null` will emit the values without any delay, while `chunkDelayInMs: 0` will emit the values with a delay of 0 milliseconds.\n * @returns A ReadableStream that emits the provided values\n */\nexport function simulateReadableStream<T>({\n  chunks,\n  initialDelayInMs = 0,\n  chunkDelayInMs = 0,\n  _internal,\n}: {\n  chunks: T[];\n  initialDelayInMs?: number | null;\n  chunkDelayInMs?: number | null;\n  _internal?: {\n    delay?: (ms: number | null) => Promise<void>;\n  };\n}): ReadableStream<T> {\n  const delay = _internal?.delay ?? delayFunction;\n\n  let index = 0;\n\n  return new ReadableStream({\n    async pull(controller) {\n      if (index < chunks.length) {\n        await delay(index === 0 ? initialDelayInMs : chunkDelayInMs);\n        controller.enqueue(chunks[index++]);\n      } else {\n        controller.close();\n      }\n    },\n  });\n}\n", "import {\n  AssistantMessage,\n  DataMessage,\n  formatAssistantStreamPart,\n} from '@ai-sdk/ui-utils';\n\n/**\nYou can pass the thread and the latest message into the `AssistantResponse`. This establishes the context for the response.\n */\ntype AssistantResponseSettings = {\n  /**\nThe thread ID that the response is associated with.\n   */\n  threadId: string;\n\n  /**\nThe ID of the latest message that the response is associated with.\n */\n  messageId: string;\n};\n\n/**\nThe process parameter is a callback in which you can run the assistant on threads, and send messages and data messages to the client.\n */\ntype AssistantResponseCallback = (options: {\n  /**\nForwards an assistant message (non-streaming) to the client.\n   */\n  sendMessage: (message: AssistantMessage) => void;\n\n  /**\nSend a data message to the client. You can use this to provide information for rendering custom UIs while the assistant is processing the thread.\n */\n  sendDataMessage: (message: DataMessage) => void;\n\n  /**\nForwards the assistant response stream to the client. Returns the `Run` object after it completes, or when it requires an action.\n   */\n  forwardStream: (stream: any) => Promise<any | undefined>;\n}) => Promise<void>;\n\n/**\nThe `AssistantResponse` allows you to send a stream of assistant update to `useAssistant`.\nIt is designed to facilitate streaming assistant responses to the `useAssistant` hook.\nIt receives an assistant thread and a current message, and can send messages and data messages to the client.\n */\nexport function AssistantResponse(\n  { threadId, messageId }: AssistantResponseSettings,\n  process: AssistantResponseCallback,\n): Response {\n  const stream = new ReadableStream({\n    async start(controller) {\n      const textEncoder = new TextEncoder();\n\n      const sendMessage = (message: AssistantMessage) => {\n        controller.enqueue(\n          textEncoder.encode(\n            formatAssistantStreamPart('assistant_message', message),\n          ),\n        );\n      };\n\n      const sendDataMessage = (message: DataMessage) => {\n        controller.enqueue(\n          textEncoder.encode(\n            formatAssistantStreamPart('data_message', message),\n          ),\n        );\n      };\n\n      const sendError = (errorMessage: string) => {\n        controller.enqueue(\n          textEncoder.encode(formatAssistantStreamPart('error', errorMessage)),\n        );\n      };\n\n      const forwardStream = async (stream: any) => {\n        let result: any | undefined = undefined;\n\n        for await (const value of stream) {\n          switch (value.event) {\n            case 'thread.message.created': {\n              controller.enqueue(\n                textEncoder.encode(\n                  formatAssistantStreamPart('assistant_message', {\n                    id: value.data.id,\n                    role: 'assistant',\n                    content: [{ type: 'text', text: { value: '' } }],\n                  }),\n                ),\n              );\n              break;\n            }\n\n            case 'thread.message.delta': {\n              const content = value.data.delta.content?.[0];\n\n              if (content?.type === 'text' && content.text?.value != null) {\n                controller.enqueue(\n                  textEncoder.encode(\n                    formatAssistantStreamPart('text', content.text.value),\n                  ),\n                );\n              }\n\n              break;\n            }\n\n            case 'thread.run.completed':\n            case 'thread.run.requires_action': {\n              result = value.data;\n              break;\n            }\n          }\n        }\n\n        return result;\n      };\n\n      // send the threadId and messageId as the first message:\n      controller.enqueue(\n        textEncoder.encode(\n          formatAssistantStreamPart('assistant_control_data', {\n            threadId,\n            messageId,\n          }),\n        ),\n      );\n\n      try {\n        await process({\n          sendMessage,\n          sendDataMessage,\n          forwardStream,\n        });\n      } catch (error) {\n        sendError((error as any).message ?? `${error}`);\n      } finally {\n        controller.close();\n      }\n    },\n    pull(controller) {},\n    cancel() {},\n  });\n\n  return new Response(stream, {\n    status: 200,\n    headers: {\n      'Content-Type': 'text/plain; charset=utf-8',\n    },\n  });\n}\n", "import { formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { DataStreamWriter } from '../core/data-stream/data-stream-writer';\nimport { mergeStreams } from '../core/util/merge-streams';\nimport { prepareResponseHeaders } from '../core/util/prepare-response-headers';\nimport {\n  createCallbacksTransformer,\n  StreamCallbacks,\n} from './stream-callbacks';\nimport { StreamData } from './stream-data';\n\ntype LangChainImageDetail = 'auto' | 'low' | 'high';\n\ntype LangChainMessageContentText = {\n  type: 'text';\n  text: string;\n};\n\ntype LangChainMessageContentImageUrl = {\n  type: 'image_url';\n  image_url:\n    | string\n    | {\n        url: string;\n        detail?: LangChainImageDetail;\n      };\n};\n\ntype LangChainMessageContentComplex =\n  | LangChainMessageContentText\n  | LangChainMessageContentImageUrl\n  | (Record<string, any> & {\n      type?: 'text' | 'image_url' | string;\n    })\n  | (Record<string, any> & {\n      type?: never;\n    });\n\ntype LangChainMessageContent = string | LangChainMessageContentComplex[];\n\ntype LangChainAIMessageChunk = {\n  content: LangChainMessageContent;\n};\n\n// LC stream event v2\ntype LangChainStreamEvent = {\n  event: string;\n  data: any;\n};\n\nfunction toDataStreamInternal(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  callbacks?: StreamCallbacks,\n) {\n  return stream\n    .pipeThrough(\n      new TransformStream<\n        LangChainStreamEvent | LangChainAIMessageChunk | string\n      >({\n        transform: async (value, controller) => {\n          // text stream:\n          if (typeof value === 'string') {\n            controller.enqueue(value);\n            return;\n          }\n\n          // LC stream events v2:\n          if ('event' in value) {\n            // chunk is AIMessage Chunk for on_chat_model_stream event:\n            if (value.event === 'on_chat_model_stream') {\n              forwardAIMessageChunk(\n                value.data?.chunk as LangChainAIMessageChunk,\n                controller,\n              );\n            }\n            return;\n          }\n\n          // AI Message chunk stream:\n          forwardAIMessageChunk(value, controller);\n        },\n      }),\n    )\n    .pipeThrough(createCallbacksTransformer(callbacks))\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(\n      new TransformStream({\n        transform: async (chunk, controller) => {\n          controller.enqueue(formatDataStreamPart('text', chunk));\n        },\n      }),\n    );\n}\n\n/**\nConverts LangChain output streams to an AI SDK Data Stream.\n\nThe following streams are supported:\n- `LangChainAIMessageChunk` streams (LangChain `model.stream` output)\n- `string` streams (LangChain `StringOutputParser` output)\n */\nexport function toDataStream(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  callbacks?: StreamCallbacks,\n) {\n  return toDataStreamInternal(stream, callbacks).pipeThrough(\n    new TextEncoderStream(),\n  );\n}\n\nexport function toDataStreamResponse(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  options?: {\n    init?: ResponseInit;\n    data?: StreamData;\n    callbacks?: StreamCallbacks;\n  },\n) {\n  const dataStream = toDataStreamInternal(\n    stream,\n    options?.callbacks,\n  ).pipeThrough(new TextEncoderStream());\n  const data = options?.data;\n  const init = options?.init;\n\n  const responseStream = data\n    ? mergeStreams(data.stream, dataStream)\n    : dataStream;\n\n  return new Response(responseStream, {\n    status: init?.status ?? 200,\n    statusText: init?.statusText,\n    headers: prepareResponseHeaders(init?.headers, {\n      contentType: 'text/plain; charset=utf-8',\n      dataStreamVersion: 'v1',\n    }),\n  });\n}\n\nexport function mergeIntoDataStream(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  options: { dataStream: DataStreamWriter; callbacks?: StreamCallbacks },\n) {\n  options.dataStream.merge(toDataStreamInternal(stream, options.callbacks));\n}\n\nfunction forwardAIMessageChunk(\n  chunk: LangChainAIMessageChunk,\n  controller: TransformStreamDefaultController<any>,\n) {\n  if (typeof chunk.content === 'string') {\n    controller.enqueue(chunk.content);\n  } else {\n    const content: LangChainMessageContentComplex[] = chunk.content;\n    for (const item of content) {\n      if (item.type === 'text') {\n        controller.enqueue(item.text);\n      }\n    }\n  }\n}\n", "/**\n * Configuration options and helper callback methods for stream lifecycle events.\n */\nexport interface StreamCallbacks {\n  /** `onStart`: Called once when the stream is initialized. */\n  onStart?: () => Promise<void> | void;\n\n  /**\n   * `onCompletion`: Called for each tokenized message.\n   *\n   * @deprecated Use `onFinal` instead.\n   */\n  onCompletion?: (completion: string) => Promise<void> | void;\n\n  /** `onFinal`: Called once when the stream is closed with the final completion message. */\n  onFinal?: (completion: string) => Promise<void> | void;\n\n  /** `onToken`: Called for each tokenized message. */\n  onToken?: (token: string) => Promise<void> | void;\n\n  /** `onText`: Called for each text chunk. */\n  onText?: (text: string) => Promise<void> | void;\n}\n\n/**\n * Creates a transform stream that encodes input messages and invokes optional callback functions.\n * The transform stream uses the provided callbacks to execute custom logic at different stages of the stream's lifecycle.\n * - `onStart`: Called once when the stream is initialized.\n * - `onToken`: Called for each tokenized message.\n * - `onCompletion`: Called every time a completion message is received. This can occur multiple times when using e.g. OpenAI functions\n * - `onFinal`: Called once when the stream is closed with the final completion message.\n *\n * This function is useful when you want to process a stream of messages and perform specific actions during the stream's lifecycle.\n *\n * @param {StreamCallbacks} [callbacks] - An object containing the callback functions.\n * @return {TransformStream<string, Uint8Array>} A transform stream that encodes input messages as Uint8Array and allows the execution of custom logic through callbacks.\n *\n * @example\n * const callbacks = {\n *   onStart: async () => console.log('Stream started'),\n *   onToken: async (token) => console.log(`Token: ${token}`),\n *   onCompletion: async (completion) => console.log(`Completion: ${completion}`)\n *   onFinal: async () => data.close()\n * };\n * const transformer = createCallbacksTransformer(callbacks);\n */\nexport function createCallbacksTransformer(\n  callbacks: StreamCallbacks | undefined = {},\n): TransformStream<string, Uint8Array> {\n  const textEncoder = new TextEncoder();\n  let aggregatedResponse = '';\n\n  return new TransformStream({\n    async start(): Promise<void> {\n      if (callbacks.onStart) await callbacks.onStart();\n    },\n\n    async transform(message, controller): Promise<void> {\n      controller.enqueue(textEncoder.encode(message));\n\n      aggregatedResponse += message;\n\n      if (callbacks.onToken) await callbacks.onToken(message);\n      if (callbacks.onText && typeof message === 'string') {\n        await callbacks.onText(message);\n      }\n    },\n\n    async flush(): Promise<void> {\n      if (callbacks.onCompletion) {\n        await callbacks.onCompletion(aggregatedResponse);\n      }\n      if (callbacks.onFinal) {\n        await callbacks.onFinal(aggregatedResponse);\n      }\n    },\n  });\n}\n", "import { convertAsyncIteratorToReadableStream } from '@ai-sdk/provider-utils';\nimport { formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { DataStreamWriter } from '../core/data-stream/data-stream-writer';\nimport { mergeStreams } from '../core/util/merge-streams';\nimport { prepareResponseHeaders } from '../core/util/prepare-response-headers';\nimport {\n  createCallbacksTransformer,\n  StreamCallbacks,\n} from './stream-callbacks';\nimport { StreamData } from './stream-data';\n\ntype EngineResponse = {\n  delta: string;\n};\n\nfunction toDataStreamInternal(\n  stream: AsyncIterable<EngineResponse>,\n  callbacks?: StreamCallbacks,\n) {\n  const trimStart = trimStartOfStream();\n\n  return convertAsyncIteratorToReadableStream(stream[Symbol.asyncIterator]())\n    .pipeThrough(\n      new TransformStream({\n        async transform(message, controller): Promise<void> {\n          controller.enqueue(trimStart(message.delta));\n        },\n      }),\n    )\n    .pipeThrough(createCallbacksTransformer(callbacks))\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(\n      new TransformStream({\n        transform: async (chunk, controller) => {\n          controller.enqueue(formatDataStreamPart('text', chunk));\n        },\n      }),\n    );\n}\n\nexport function toDataStream(\n  stream: AsyncIterable<EngineResponse>,\n  callbacks?: StreamCallbacks,\n) {\n  return toDataStreamInternal(stream, callbacks).pipeThrough(\n    new TextEncoderStream(),\n  );\n}\n\nexport function toDataStreamResponse(\n  stream: AsyncIterable<EngineResponse>,\n  options: {\n    init?: ResponseInit;\n    data?: StreamData;\n    callbacks?: StreamCallbacks;\n  } = {},\n) {\n  const { init, data, callbacks } = options;\n  const dataStream = toDataStreamInternal(stream, callbacks).pipeThrough(\n    new TextEncoderStream(),\n  );\n  const responseStream = data\n    ? mergeStreams(data.stream, dataStream)\n    : dataStream;\n\n  return new Response(responseStream, {\n    status: init?.status ?? 200,\n    statusText: init?.statusText,\n    headers: prepareResponseHeaders(init?.headers, {\n      contentType: 'text/plain; charset=utf-8',\n      dataStreamVersion: 'v1',\n    }),\n  });\n}\n\nexport function mergeIntoDataStream(\n  stream: AsyncIterable<EngineResponse>,\n  options: {\n    dataStream: DataStreamWriter;\n    callbacks?: StreamCallbacks;\n  },\n) {\n  options.dataStream.merge(toDataStreamInternal(stream, options.callbacks));\n}\n\nfunction trimStartOfStream(): (text: string) => string {\n  let isStreamStart = true;\n\n  return (text: string): string => {\n    if (isStreamStart) {\n      text = text.trimStart();\n      if (text) isStreamStart = false;\n    }\n    return text;\n  };\n}\n", "import { JSONValue, formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { HANGING_STREAM_WARNING_TIME_MS } from '../util/constants';\n\n/**\n * A stream wrapper to send custom JSON-encoded data back to the client.\n *\n * @deprecated Please use `createDataStream`, `createDataStreamResponse`, and `pipeDataStreamToResponse` instead.\n */\nexport class StreamData {\n  private encoder = new TextEncoder();\n\n  private controller: ReadableStreamController<Uint8Array> | null = null;\n  public stream: ReadableStream<Uint8Array>;\n\n  private isClosed: boolean = false;\n  private warningTimeout: NodeJS.Timeout | null = null;\n\n  constructor() {\n    const self = this;\n\n    this.stream = new ReadableStream({\n      start: async controller => {\n        self.controller = controller;\n\n        // Set a timeout to show a warning if the stream is not closed within 3 seconds\n        if (process.env.NODE_ENV === 'development') {\n          self.warningTimeout = setTimeout(() => {\n            console.warn(\n              'The data stream is hanging. Did you forget to close it with `data.close()`?',\n            );\n          }, HANGING_STREAM_WARNING_TIME_MS);\n        }\n      },\n      pull: controller => {\n        // No-op: we don't need to do anything special on pull\n      },\n      cancel: reason => {\n        this.isClosed = true;\n      },\n    });\n  }\n\n  async close(): Promise<void> {\n    if (this.isClosed) {\n      throw new Error('Data Stream has already been closed.');\n    }\n\n    if (!this.controller) {\n      throw new Error('Stream controller is not initialized.');\n    }\n\n    this.controller.close();\n    this.isClosed = true;\n\n    // Clear the warning timeout if the stream is closed\n    if (this.warningTimeout) {\n      clearTimeout(this.warningTimeout);\n    }\n  }\n\n  append(value: JSONValue): void {\n    if (this.isClosed) {\n      throw new Error('Data Stream has already been closed.');\n    }\n\n    if (!this.controller) {\n      throw new Error('Stream controller is not initialized.');\n    }\n\n    this.controller.enqueue(\n      this.encoder.encode(formatDataStreamPart('data', [value])),\n    );\n  }\n\n  appendMessageAnnotation(value: JSONValue): void {\n    if (this.isClosed) {\n      throw new Error('Data Stream has already been closed.');\n    }\n\n    if (!this.controller) {\n      throw new Error('Stream controller is not initialized.');\n    }\n\n    this.controller.enqueue(\n      this.encoder.encode(formatDataStreamPart('message_annotations', [value])),\n    );\n  }\n}\n", "/**\n * Warning time for notifying developers that a stream is hanging in dev mode\n * using a console.warn.\n */\nexport const HANGING_STREAM_WARNING_TIME_MS = 15 * 1000;\n", "// src/index.ts\nimport { z } from \"zod\";\nfunction convertJsonSchemaToZod(schema) {\n  function addMetadata(zodSchema, jsonSchema) {\n    if (jsonSchema.description) {\n      zodSchema = zodSchema.describe(jsonSchema.description);\n    }\n    return zodSchema;\n  }\n  if (schema.const !== void 0) {\n    if (typeof schema.const === \"string\") {\n      return addMetadata(z.literal(schema.const), schema);\n    } else if (typeof schema.const === \"number\") {\n      return addMetadata(z.literal(schema.const), schema);\n    } else if (typeof schema.const === \"boolean\") {\n      return addMetadata(z.literal(schema.const), schema);\n    } else if (schema.const === null) {\n      return addMetadata(z.null(), schema);\n    }\n    return addMetadata(z.literal(schema.const), schema);\n  }\n  if (schema.type) {\n    switch (schema.type) {\n      case \"string\": {\n        if (schema.enum) {\n          if (schema.enum.length === 0) {\n            return addMetadata(z.string(), schema);\n          }\n          return addMetadata(z.enum(schema.enum), schema);\n        }\n        let stringSchema = z.string();\n        if (schema.minLength !== void 0) {\n          stringSchema = stringSchema.min(schema.minLength);\n        }\n        if (schema.maxLength !== void 0) {\n          stringSchema = stringSchema.max(schema.maxLength);\n        }\n        if (schema.pattern !== void 0) {\n          const regex = new RegExp(schema.pattern);\n          stringSchema = stringSchema.regex(regex);\n        }\n        return addMetadata(stringSchema, schema);\n      }\n      case \"number\":\n      case \"integer\": {\n        if (schema.enum) {\n          if (schema.enum.length === 0) {\n            return addMetadata(z.number(), schema);\n          }\n          const options = schema.enum.map((val) => z.literal(val));\n          if (options.length === 1) {\n            return addMetadata(options[0], schema);\n          }\n          if (options.length >= 2) {\n            const unionSchema = z.union([options[0], options[1], ...options.slice(2)]);\n            return addMetadata(unionSchema, schema);\n          }\n        }\n        let numberSchema = schema.type === \"integer\" ? z.number().int() : z.number();\n        if (schema.minimum !== void 0) {\n          numberSchema = numberSchema.min(schema.minimum);\n        }\n        if (schema.maximum !== void 0) {\n          numberSchema = numberSchema.max(schema.maximum);\n        }\n        if (schema.exclusiveMinimum !== void 0) {\n          numberSchema = numberSchema.gt(schema.exclusiveMinimum);\n        }\n        if (schema.exclusiveMaximum !== void 0) {\n          numberSchema = numberSchema.lt(schema.exclusiveMaximum);\n        }\n        if (schema.multipleOf !== void 0) {\n          numberSchema = numberSchema.multipleOf(schema.multipleOf);\n        }\n        return addMetadata(numberSchema, schema);\n      }\n      case \"boolean\":\n        if (schema.enum) {\n          if (schema.enum.length === 0) {\n            return addMetadata(z.boolean(), schema);\n          }\n          const options = schema.enum.map((val) => z.literal(val));\n          if (options.length === 1) {\n            return addMetadata(options[0], schema);\n          }\n          if (options.length >= 2) {\n            const unionSchema = z.union([options[0], options[1], ...options.slice(2)]);\n            return addMetadata(unionSchema, schema);\n          }\n        }\n        return addMetadata(z.boolean(), schema);\n      case \"null\":\n        return addMetadata(z.null(), schema);\n      case \"object\":\n        if (schema.properties) {\n          const shape = {};\n          for (const [key, propSchema] of Object.entries(\n            schema.properties\n          )) {\n            shape[key] = convertJsonSchemaToZod(propSchema);\n          }\n          if (schema.required && Array.isArray(schema.required)) {\n            const required = new Set(schema.required);\n            for (const key of Object.keys(shape)) {\n              if (!required.has(key)) {\n                shape[key] = shape[key].optional();\n              }\n            }\n          } else {\n            for (const key of Object.keys(shape)) {\n              shape[key] = shape[key].optional();\n            }\n          }\n          let zodSchema;\n          if (schema.additionalProperties !== false) {\n            zodSchema = z.object(shape).passthrough();\n          } else {\n            zodSchema = z.object(shape);\n          }\n          return addMetadata(zodSchema, schema);\n        }\n        return addMetadata(z.object({}), schema);\n      case \"array\": {\n        let arraySchema;\n        if (schema.items) {\n          arraySchema = z.array(convertJsonSchemaToZod(schema.items));\n        } else {\n          arraySchema = z.array(z.any());\n        }\n        if (schema.minItems !== void 0) {\n          arraySchema = arraySchema.min(schema.minItems);\n        }\n        if (schema.maxItems !== void 0) {\n          arraySchema = arraySchema.max(schema.maxItems);\n        }\n        if (schema.uniqueItems === true) {\n          arraySchema = arraySchema.refine(\n            (items) => {\n              const seen = /* @__PURE__ */ new Set();\n              return items.every((item) => {\n                if (typeof item === \"string\" || typeof item === \"number\" || typeof item === \"boolean\") {\n                  if (seen.has(item)) return false;\n                  seen.add(item);\n                  return true;\n                }\n                const serialized = JSON.stringify(item);\n                if (seen.has(serialized)) return false;\n                seen.add(serialized);\n                return true;\n              });\n            },\n            { message: \"Array items must be unique\" }\n          );\n        }\n        return addMetadata(arraySchema, schema);\n      }\n    }\n  }\n  if (schema.enum) {\n    if (schema.enum.length === 0) {\n      return addMetadata(z.never(), schema);\n    }\n    const allStrings = schema.enum.every((val) => typeof val === \"string\");\n    if (allStrings) {\n      return addMetadata(z.enum(schema.enum), schema);\n    } else {\n      const options = schema.enum.map((val) => z.literal(val));\n      if (options.length === 1) {\n        return addMetadata(options[0], schema);\n      }\n      if (options.length >= 2) {\n        const unionSchema = z.union([options[0], options[1], ...options.slice(2)]);\n        return addMetadata(unionSchema, schema);\n      }\n    }\n  }\n  if (schema.anyOf && schema.anyOf.length >= 2) {\n    const schemas = schema.anyOf.map(convertJsonSchemaToZod);\n    return addMetadata(\n      z.union([schemas[0], schemas[1], ...schemas.slice(2)]),\n      schema\n    );\n  }\n  if (schema.allOf) {\n    return addMetadata(\n      schema.allOf.reduce(\n        (acc, s) => z.intersection(acc, convertJsonSchemaToZod(s)),\n        z.object({})\n      ),\n      schema\n    );\n  }\n  if (schema.oneOf && schema.oneOf.length >= 2) {\n    const schemas = schema.oneOf.map(convertJsonSchemaToZod);\n    return addMetadata(\n      z.union([schemas[0], schemas[1], ...schemas.slice(2)]),\n      schema\n    );\n  }\n  return addMetadata(z.any(), schema);\n}\nfunction jsonSchemaObjectToZodRawShape(schema) {\n  var _a;\n  let raw = {};\n  for (const [key, value] of Object.entries((_a = schema.properties) != null ? _a : {})) {\n    raw[key] = convertJsonSchemaToZod(value);\n  }\n  return raw;\n}\nexport {\n  convertJsonSchemaToZod,\n  jsonSchemaObjectToZodRawShape\n};\n", "// src/hooks/mitt.ts\nfunction mitt(all) {\n  all = all || /* @__PURE__ */ new Map();\n  return {\n    /**\n     * A Map of event names to registered handler functions.\n     */\n    all,\n    /**\n     * Register an event handler for the given type.\n     * @param {string|symbol} type Type of event to listen for, or `'*'` for all events\n     * @param {Function} handler Function to call in response to given event\n     * @memberOf mitt\n     */\n    on(type, handler) {\n      const handlers = all.get(type);\n      if (handlers) {\n        handlers.push(handler);\n      } else {\n        all.set(type, [handler]);\n      }\n    },\n    /**\n     * Remove an event handler for the given type.\n     * If `handler` is omitted, all handlers of the given type are removed.\n     * @param {string|symbol} type Type of event to unregister `handler` from (`'*'` to remove a wildcard handler)\n     * @param {Function} [handler] Handler function to remove\n     * @memberOf mitt\n     */\n    off(type, handler) {\n      const handlers = all.get(type);\n      if (handlers) {\n        if (handler) {\n          handlers.splice(handlers.indexOf(handler) >>> 0, 1);\n        } else {\n          all.set(type, []);\n        }\n      }\n    },\n    /**\n     * Invoke all handlers for the given type.\n     * If present, `'*'` handlers are invoked after type-matched handlers.\n     *\n     * Note: Manually firing '*' handlers is not supported.\n     *\n     * @param {string|symbol} type The event type to invoke\n     * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler\n     * @memberOf mitt\n     */\n    emit(type, evt) {\n      let handlers = all.get(type);\n      if (handlers) {\n        handlers.slice().map((handler) => {\n          handler(evt);\n        });\n      }\n      handlers = all.get(\"*\");\n      if (handlers) {\n        handlers.slice().map((handler) => {\n          handler(type, evt);\n        });\n      }\n    }\n  };\n}\n\n// src/hooks/index.ts\nvar AvailableHooks = /* @__PURE__ */ ((AvailableHooks2) => {\n  AvailableHooks2[\"ON_EVALUATION\"] = \"onEvaluation\";\n  AvailableHooks2[\"ON_GENERATION\"] = \"onGeneration\";\n  return AvailableHooks2;\n})(AvailableHooks || {});\nvar hooks = mitt();\nfunction registerHook(hook, action) {\n  hooks.on(hook, action);\n}\nfunction executeHook(hook, data) {\n  setImmediate(() => {\n    hooks.emit(hook, data);\n  });\n}\n\nexport { AvailableHooks, executeHook, registerHook };\n", "import { delay } from './chunk-IBKM5CLQ.js';\nimport { MastraError } from './chunk-6UNGH46J.js';\nimport { MastraBase } from './chunk-5IEKR756.js';\nimport { RegisteredLogger } from './chunk-5YDTZN2X.js';\nimport { OpenAIReasoningSchemaCompatLayer, OpenAISchemaCompatLayer, GoogleSchemaCompatLayer, AnthropicSchemaCompatLayer, DeepSeekSchemaCompatLayer, MetaSchemaCompatLayer, applyCompatLayer } from '@mastra/schema-compat';\nimport { jsonSchema, generateText, Output, generateObject, streamText, streamObject } from 'ai';\nimport { z } from 'zod';\n\n// src/llm/model/base.ts\nvar MastraLLMBase = class extends MastraBase {\n  constructor({ name }) {\n    super({\n      component: RegisteredLogger.LLM,\n      name\n    });\n  }\n  convertToMessages(messages) {\n    if (Array.isArray(messages)) {\n      return messages.map((m) => {\n        if (typeof m === \"string\") {\n          return {\n            role: \"user\",\n            content: m\n          };\n        }\n        return m;\n      });\n    }\n    return [\n      {\n        role: \"user\",\n        content: messages\n      }\n    ];\n  }\n  __registerPrimitives(p) {\n    if (p.telemetry) {\n      this.__setTelemetry(p.telemetry);\n    }\n    if (p.logger) {\n      this.__setLogger(p.logger);\n    }\n  }\n};\n\n// src/llm/model/model.ts\nvar MastraLLM = class extends MastraLLMBase {\n  #model;\n  #mastra;\n  constructor({ model, mastra }) {\n    super({ name: \"aisdk\" });\n    this.#model = model;\n    if (mastra) {\n      this.#mastra = mastra;\n      if (mastra.getLogger()) {\n        this.__setLogger(this.#mastra.getLogger());\n      }\n    }\n  }\n  __registerPrimitives(p) {\n    if (p.telemetry) {\n      this.__setTelemetry(p.telemetry);\n    }\n    if (p.logger) {\n      this.__setLogger(p.logger);\n    }\n  }\n  __registerMastra(p) {\n    this.#mastra = p;\n  }\n  getProvider() {\n    return this.#model.provider;\n  }\n  getModelId() {\n    return this.#model.modelId;\n  }\n  getModel() {\n    return this.#model;\n  }\n  _applySchemaCompat(schema) {\n    const model = this.#model;\n    const schemaCompatLayers = [];\n    if (model) {\n      schemaCompatLayers.push(\n        new OpenAIReasoningSchemaCompatLayer(model),\n        new OpenAISchemaCompatLayer(model),\n        new GoogleSchemaCompatLayer(model),\n        new AnthropicSchemaCompatLayer(model),\n        new DeepSeekSchemaCompatLayer(model),\n        new MetaSchemaCompatLayer(model)\n      );\n    }\n    return applyCompatLayer({\n      schema,\n      compatLayers: schemaCompatLayers,\n      mode: \"aiSdkSchema\"\n    });\n  }\n  async __text({\n    runId,\n    messages,\n    maxSteps = 5,\n    tools = {},\n    temperature,\n    toolChoice = \"auto\",\n    onStepFinish,\n    experimental_output,\n    telemetry,\n    threadId,\n    resourceId,\n    memory,\n    runtimeContext,\n    ...rest\n  }) {\n    const model = this.#model;\n    this.logger.debug(`[LLM] - Generating text`, {\n      runId,\n      messages,\n      maxSteps,\n      threadId,\n      resourceId,\n      tools: Object.keys(tools)\n    });\n    const argsForExecute = {\n      model,\n      temperature,\n      tools: {\n        ...tools\n      },\n      toolChoice,\n      maxSteps,\n      onStepFinish: async (props) => {\n        try {\n          await onStepFinish?.(props);\n        } catch (e) {\n          const mastraError = new MastraError(\n            {\n              id: \"LLM_TEXT_ON_STEP_FINISH_CALLBACK_EXECUTION_FAILED\",\n              domain: \"LLM\" /* LLM */,\n              category: \"USER\" /* USER */,\n              details: {\n                modelId: model.modelId,\n                modelProvider: model.provider,\n                runId: runId ?? \"unknown\",\n                threadId: threadId ?? \"unknown\",\n                resourceId: resourceId ?? \"unknown\",\n                finishReason: props?.finishReason,\n                toolCalls: props?.toolCalls ? JSON.stringify(props.toolCalls) : \"\",\n                toolResults: props?.toolResults ? JSON.stringify(props.toolResults) : \"\",\n                usage: props?.usage ? JSON.stringify(props.usage) : \"\"\n              }\n            },\n            e\n          );\n          throw mastraError;\n        }\n        this.logger.debug(\"[LLM] - Step Change:\", {\n          text: props?.text,\n          toolCalls: props?.toolCalls,\n          toolResults: props?.toolResults,\n          finishReason: props?.finishReason,\n          usage: props?.usage,\n          runId\n        });\n        if (props?.response?.headers?.[\"x-ratelimit-remaining-tokens\"] && parseInt(props?.response?.headers?.[\"x-ratelimit-remaining-tokens\"], 10) < 2e3) {\n          this.logger.warn(\"Rate limit approaching, waiting 10 seconds\", { runId });\n          await delay(10 * 1e3);\n        }\n      },\n      ...rest\n    };\n    let schema;\n    if (experimental_output) {\n      this.logger.debug(\"[LLM] - Using experimental output\", {\n        runId\n      });\n      if (typeof experimental_output.parse === \"function\") {\n        schema = experimental_output;\n        if (schema instanceof z.ZodArray) {\n          schema = schema._def.type;\n        }\n      } else {\n        schema = jsonSchema(experimental_output);\n      }\n    }\n    try {\n      return await generateText({\n        messages,\n        ...argsForExecute,\n        experimental_telemetry: {\n          ...this.experimental_telemetry,\n          ...telemetry\n        },\n        experimental_output: schema ? Output.object({\n          schema\n        }) : void 0\n      });\n    } catch (e) {\n      const mastraError = new MastraError(\n        {\n          id: \"LLM_GENERATE_TEXT_AI_SDK_EXECUTION_FAILED\",\n          domain: \"LLM\" /* LLM */,\n          category: \"THIRD_PARTY\" /* THIRD_PARTY */,\n          details: {\n            modelId: model.modelId,\n            modelProvider: model.provider,\n            runId: runId ?? \"unknown\",\n            threadId: threadId ?? \"unknown\",\n            resourceId: resourceId ?? \"unknown\"\n          }\n        },\n        e\n      );\n      throw mastraError;\n    }\n  }\n  async __textObject({\n    messages,\n    onStepFinish,\n    maxSteps = 5,\n    tools = {},\n    structuredOutput,\n    runId,\n    temperature,\n    toolChoice = \"auto\",\n    telemetry,\n    threadId,\n    resourceId,\n    memory,\n    runtimeContext,\n    ...rest\n  }) {\n    const model = this.#model;\n    this.logger.debug(`[LLM] - Generating a text object`, { runId });\n    const argsForExecute = {\n      model,\n      temperature,\n      tools: {\n        ...tools\n      },\n      maxSteps,\n      toolChoice,\n      onStepFinish: async (props) => {\n        try {\n          await onStepFinish?.(props);\n        } catch (e) {\n          const mastraError = new MastraError(\n            {\n              id: \"LLM_TEXT_OBJECT_ON_STEP_FINISH_CALLBACK_EXECUTION_FAILED\",\n              domain: \"LLM\" /* LLM */,\n              category: \"USER\" /* USER */,\n              details: {\n                runId: runId ?? \"unknown\",\n                threadId: threadId ?? \"unknown\",\n                resourceId: resourceId ?? \"unknown\",\n                finishReason: props?.finishReason,\n                toolCalls: props?.toolCalls ? JSON.stringify(props.toolCalls) : \"\",\n                toolResults: props?.toolResults ? JSON.stringify(props.toolResults) : \"\",\n                usage: props?.usage ? JSON.stringify(props.usage) : \"\"\n              }\n            },\n            e\n          );\n          throw mastraError;\n        }\n        this.logger.debug(\"[LLM] - Step Change:\", {\n          text: props?.text,\n          toolCalls: props?.toolCalls,\n          toolResults: props?.toolResults,\n          finishReason: props?.finishReason,\n          usage: props?.usage,\n          runId\n        });\n        if (props?.response?.headers?.[\"x-ratelimit-remaining-tokens\"] && parseInt(props?.response?.headers?.[\"x-ratelimit-remaining-tokens\"], 10) < 2e3) {\n          this.logger.warn(\"Rate limit approaching, waiting 10 seconds\", { runId });\n          await delay(10 * 1e3);\n        }\n      },\n      ...rest\n    };\n    let output = \"object\";\n    if (structuredOutput instanceof z.ZodArray) {\n      output = \"array\";\n      structuredOutput = structuredOutput._def.type;\n    }\n    try {\n      const processedSchema = this._applySchemaCompat(structuredOutput);\n      return await generateObject({\n        messages,\n        ...argsForExecute,\n        output,\n        schema: processedSchema,\n        experimental_telemetry: {\n          ...this.experimental_telemetry,\n          ...telemetry\n        }\n      });\n    } catch (e) {\n      const mastraError = new MastraError(\n        {\n          id: \"LLM_GENERATE_OBJECT_AI_SDK_EXECUTION_FAILED\",\n          domain: \"LLM\" /* LLM */,\n          category: \"THIRD_PARTY\" /* THIRD_PARTY */,\n          details: {\n            modelId: model.modelId,\n            modelProvider: model.provider,\n            runId: runId ?? \"unknown\",\n            threadId: threadId ?? \"unknown\",\n            resourceId: resourceId ?? \"unknown\"\n          }\n        },\n        e\n      );\n      throw mastraError;\n    }\n  }\n  __stream({\n    messages,\n    onStepFinish,\n    onFinish,\n    maxSteps = 5,\n    tools = {},\n    runId,\n    temperature,\n    toolChoice = \"auto\",\n    experimental_output,\n    telemetry,\n    threadId,\n    resourceId,\n    memory,\n    runtimeContext,\n    ...rest\n  }) {\n    const model = this.#model;\n    this.logger.debug(`[LLM] - Streaming text`, {\n      runId,\n      threadId,\n      resourceId,\n      messages,\n      maxSteps,\n      tools: Object.keys(tools || {})\n    });\n    const argsForExecute = {\n      model,\n      temperature,\n      tools: {\n        ...tools\n      },\n      maxSteps,\n      toolChoice,\n      onStepFinish: async (props) => {\n        try {\n          await onStepFinish?.(props);\n        } catch (e) {\n          const mastraError = new MastraError(\n            {\n              id: \"LLM_STREAM_ON_STEP_FINISH_CALLBACK_EXECUTION_FAILED\",\n              domain: \"LLM\" /* LLM */,\n              category: \"USER\" /* USER */,\n              details: {\n                modelId: model.modelId,\n                modelProvider: model.provider,\n                runId: runId ?? \"unknown\",\n                threadId: threadId ?? \"unknown\",\n                resourceId: resourceId ?? \"unknown\",\n                finishReason: props?.finishReason,\n                toolCalls: props?.toolCalls ? JSON.stringify(props.toolCalls) : \"\",\n                toolResults: props?.toolResults ? JSON.stringify(props.toolResults) : \"\",\n                usage: props?.usage ? JSON.stringify(props.usage) : \"\"\n              }\n            },\n            e\n          );\n          this.logger.trackException(mastraError);\n          throw mastraError;\n        }\n        this.logger.debug(\"[LLM] - Stream Step Change:\", {\n          text: props?.text,\n          toolCalls: props?.toolCalls,\n          toolResults: props?.toolResults,\n          finishReason: props?.finishReason,\n          usage: props?.usage,\n          runId\n        });\n        if (props?.response?.headers?.[\"x-ratelimit-remaining-tokens\"] && parseInt(props?.response?.headers?.[\"x-ratelimit-remaining-tokens\"], 10) < 2e3) {\n          this.logger.warn(\"Rate limit approaching, waiting 10 seconds\", { runId });\n          await delay(10 * 1e3);\n        }\n      },\n      onFinish: async (props) => {\n        try {\n          await onFinish?.(props);\n        } catch (e) {\n          const mastraError = new MastraError(\n            {\n              id: \"LLM_STREAM_ON_FINISH_CALLBACK_EXECUTION_FAILED\",\n              domain: \"LLM\" /* LLM */,\n              category: \"USER\" /* USER */,\n              details: {\n                modelId: model.modelId,\n                modelProvider: model.provider,\n                runId: runId ?? \"unknown\",\n                threadId: threadId ?? \"unknown\",\n                resourceId: resourceId ?? \"unknown\",\n                finishReason: props?.finishReason,\n                toolCalls: props?.toolCalls ? JSON.stringify(props.toolCalls) : \"\",\n                toolResults: props?.toolResults ? JSON.stringify(props.toolResults) : \"\",\n                usage: props?.usage ? JSON.stringify(props.usage) : \"\"\n              }\n            },\n            e\n          );\n          this.logger.trackException(mastraError);\n          throw mastraError;\n        }\n        this.logger.debug(\"[LLM] - Stream Finished:\", {\n          text: props?.text,\n          toolCalls: props?.toolCalls,\n          toolResults: props?.toolResults,\n          finishReason: props?.finishReason,\n          usage: props?.usage,\n          runId,\n          threadId,\n          resourceId\n        });\n      },\n      ...rest\n    };\n    let schema;\n    if (experimental_output) {\n      this.logger.debug(\"[LLM] - Using experimental output\", {\n        runId\n      });\n      if (typeof experimental_output.parse === \"function\") {\n        schema = experimental_output;\n        if (schema instanceof z.ZodArray) {\n          schema = schema._def.type;\n        }\n      } else {\n        schema = jsonSchema(experimental_output);\n      }\n    }\n    try {\n      return streamText({\n        messages,\n        ...argsForExecute,\n        experimental_telemetry: {\n          ...this.experimental_telemetry,\n          ...telemetry\n        },\n        experimental_output: schema ? Output.object({\n          schema\n        }) : void 0\n      });\n    } catch (e) {\n      const mastraError = new MastraError(\n        {\n          id: \"LLM_STREAM_TEXT_AI_SDK_EXECUTION_FAILED\",\n          domain: \"LLM\" /* LLM */,\n          category: \"THIRD_PARTY\" /* THIRD_PARTY */,\n          details: {\n            modelId: model.modelId,\n            modelProvider: model.provider,\n            runId: runId ?? \"unknown\",\n            threadId: threadId ?? \"unknown\",\n            resourceId: resourceId ?? \"unknown\"\n          }\n        },\n        e\n      );\n      throw mastraError;\n    }\n  }\n  __streamObject({\n    messages,\n    runId,\n    tools = {},\n    maxSteps = 5,\n    toolChoice = \"auto\",\n    runtimeContext,\n    threadId,\n    resourceId,\n    memory,\n    temperature,\n    onStepFinish,\n    onFinish,\n    structuredOutput,\n    telemetry,\n    ...rest\n  }) {\n    const model = this.#model;\n    this.logger.debug(`[LLM] - Streaming structured output`, {\n      runId,\n      messages,\n      maxSteps,\n      tools: Object.keys(tools || {})\n    });\n    const finalTools = tools;\n    const argsForExecute = {\n      model,\n      temperature,\n      tools: {\n        ...finalTools\n      },\n      maxSteps,\n      toolChoice,\n      onStepFinish: async (props) => {\n        try {\n          await onStepFinish?.(props);\n        } catch (e) {\n          const mastraError = new MastraError(\n            {\n              id: \"LLM_STREAM_OBJECT_ON_STEP_FINISH_CALLBACK_EXECUTION_FAILED\",\n              domain: \"LLM\" /* LLM */,\n              category: \"USER\" /* USER */,\n              details: {\n                modelId: model.modelId,\n                modelProvider: model.provider,\n                runId: runId ?? \"unknown\",\n                threadId: threadId ?? \"unknown\",\n                resourceId: resourceId ?? \"unknown\",\n                usage: props?.usage ? JSON.stringify(props.usage) : \"\",\n                toolCalls: props?.toolCalls ? JSON.stringify(props.toolCalls) : \"\",\n                toolResults: props?.toolResults ? JSON.stringify(props.toolResults) : \"\",\n                finishReason: props?.finishReason\n              }\n            },\n            e\n          );\n          this.logger.trackException(mastraError);\n          throw mastraError;\n        }\n        this.logger.debug(\"[LLM] - Stream Step Change:\", {\n          text: props?.text,\n          toolCalls: props?.toolCalls,\n          toolResults: props?.toolResults,\n          finishReason: props?.finishReason,\n          usage: props?.usage,\n          runId,\n          threadId,\n          resourceId\n        });\n        if (props?.response?.headers?.[\"x-ratelimit-remaining-tokens\"] && parseInt(props?.response?.headers?.[\"x-ratelimit-remaining-tokens\"], 10) < 2e3) {\n          this.logger.warn(\"Rate limit approaching, waiting 10 seconds\", { runId });\n          await delay(10 * 1e3);\n        }\n      },\n      onFinish: async (props) => {\n        try {\n          await onFinish?.(props);\n        } catch (e) {\n          const mastraError = new MastraError(\n            {\n              id: \"LLM_STREAM_OBJECT_ON_FINISH_CALLBACK_EXECUTION_FAILED\",\n              domain: \"LLM\" /* LLM */,\n              category: \"USER\" /* USER */,\n              details: {\n                modelId: model.modelId,\n                modelProvider: model.provider,\n                runId: runId ?? \"unknown\",\n                threadId: threadId ?? \"unknown\",\n                resourceId: resourceId ?? \"unknown\",\n                toolCalls: props?.toolCalls ? JSON.stringify(props.toolCalls) : \"\",\n                toolResults: props?.toolResults ? JSON.stringify(props.toolResults) : \"\",\n                finishReason: props?.finishReason,\n                usage: props?.usage ? JSON.stringify(props.usage) : \"\"\n              }\n            },\n            e\n          );\n          this.logger.trackException(mastraError);\n          throw mastraError;\n        }\n        this.logger.debug(\"[LLM] - Stream Finished:\", {\n          text: props?.text,\n          toolCalls: props?.toolCalls,\n          toolResults: props?.toolResults,\n          finishReason: props?.finishReason,\n          usage: props?.usage,\n          runId,\n          threadId,\n          resourceId\n        });\n      },\n      ...rest\n    };\n    let output = \"object\";\n    if (structuredOutput instanceof z.ZodArray) {\n      output = \"array\";\n      structuredOutput = structuredOutput._def.type;\n    }\n    try {\n      const processedSchema = this._applySchemaCompat(structuredOutput);\n      return streamObject({\n        messages,\n        ...argsForExecute,\n        output,\n        schema: processedSchema,\n        experimental_telemetry: {\n          ...this.experimental_telemetry,\n          ...telemetry\n        }\n      });\n    } catch (e) {\n      const mastraError = new MastraError(\n        {\n          id: \"LLM_STREAM_OBJECT_AI_SDK_EXECUTION_FAILED\",\n          domain: \"LLM\" /* LLM */,\n          category: \"THIRD_PARTY\" /* THIRD_PARTY */,\n          details: {\n            modelId: model.modelId,\n            modelProvider: model.provider,\n            runId: runId ?? \"unknown\",\n            threadId: threadId ?? \"unknown\",\n            resourceId: resourceId ?? \"unknown\"\n          }\n        },\n        e\n      );\n      throw mastraError;\n    }\n  }\n  async generate(messages, { maxSteps = 5, output, ...rest }) {\n    const msgs = this.convertToMessages(messages);\n    if (!output) {\n      return await this.__text({\n        messages: msgs,\n        maxSteps,\n        ...rest\n      });\n    }\n    return await this.__textObject({\n      messages: msgs,\n      structuredOutput: output,\n      maxSteps,\n      ...rest\n    });\n  }\n  stream(messages, { maxSteps = 5, output, ...rest }) {\n    const msgs = this.convertToMessages(messages);\n    if (!output) {\n      return this.__stream({\n        messages: msgs,\n        maxSteps,\n        ...rest\n      });\n    }\n    return this.__streamObject({\n      messages: msgs,\n      structuredOutput: output,\n      maxSteps,\n      ...rest\n    });\n  }\n};\n\nexport { MastraLLM };\n", "import {\n  EmbeddingModelV1,\n  ImageModelV1,\n  TranscriptionModelV1,\n  LanguageModelV1,\n  ProviderV1,\n  SpeechModelV1,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  loadApiKey,\n  withoutTrailingSlash,\n} from '@ai-sdk/provider-utils';\nimport { OpenAIChatLanguageModel } from './openai-chat-language-model';\nimport { OpenAIChatModelId, OpenAIChatSettings } from './openai-chat-settings';\nimport { OpenAICompletionLanguageModel } from './openai-completion-language-model';\nimport {\n  OpenAICompletionModelId,\n  OpenAICompletionSettings,\n} from './openai-completion-settings';\nimport { OpenAIEmbeddingModel } from './openai-embedding-model';\nimport {\n  OpenAIEmbeddingModelId,\n  OpenAIEmbeddingSettings,\n} from './openai-embedding-settings';\nimport { OpenAIImageModel } from './openai-image-model';\nimport {\n  OpenAIImageModelId,\n  OpenAIImageSettings,\n} from './openai-image-settings';\nimport { OpenAITranscriptionModel } from './openai-transcription-model';\nimport { OpenAITranscriptionModelId } from './openai-transcription-settings';\nimport { OpenAIResponsesLanguageModel } from './responses/openai-responses-language-model';\nimport { OpenAIResponsesModelId } from './responses/openai-responses-settings';\nimport { openaiTools } from './openai-tools';\nimport { OpenAISpeechModel } from './openai-speech-model';\nimport { OpenAISpeechModelId } from './openai-speech-settings';\n\nexport interface OpenAIProvider extends ProviderV1 {\n  (\n    modelId: 'gpt-3.5-turbo-instruct',\n    settings?: OpenAICompletionSettings,\n  ): OpenAICompletionLanguageModel;\n  (modelId: OpenAIChatModelId, settings?: OpenAIChatSettings): LanguageModelV1;\n\n  /**\nCreates an OpenAI model for text generation.\n   */\n  languageModel(\n    modelId: 'gpt-3.5-turbo-instruct',\n    settings?: OpenAICompletionSettings,\n  ): OpenAICompletionLanguageModel;\n  languageModel(\n    modelId: OpenAIChatModelId,\n    settings?: OpenAIChatSettings,\n  ): LanguageModelV1;\n\n  /**\nCreates an OpenAI chat model for text generation.\n   */\n  chat(\n    modelId: OpenAIChatModelId,\n    settings?: OpenAIChatSettings,\n  ): LanguageModelV1;\n\n  /**\nCreates an OpenAI responses API model for text generation.\n   */\n  responses(modelId: OpenAIResponsesModelId): LanguageModelV1;\n\n  /**\nCreates an OpenAI completion model for text generation.\n   */\n  completion(\n    modelId: OpenAICompletionModelId,\n    settings?: OpenAICompletionSettings,\n  ): LanguageModelV1;\n\n  /**\nCreates a model for text embeddings.\n   */\n  embedding(\n    modelId: OpenAIEmbeddingModelId,\n    settings?: OpenAIEmbeddingSettings,\n  ): EmbeddingModelV1<string>;\n\n  /**\nCreates a model for text embeddings.\n\n@deprecated Use `textEmbeddingModel` instead.\n   */\n  textEmbedding(\n    modelId: OpenAIEmbeddingModelId,\n    settings?: OpenAIEmbeddingSettings,\n  ): EmbeddingModelV1<string>;\n\n  /**\nCreates a model for text embeddings.\n   */\n  textEmbeddingModel(\n    modelId: OpenAIEmbeddingModelId,\n    settings?: OpenAIEmbeddingSettings,\n  ): EmbeddingModelV1<string>;\n\n  /**\nCreates a model for image generation.\n   */\n  image(\n    modelId: OpenAIImageModelId,\n    settings?: OpenAIImageSettings,\n  ): ImageModelV1;\n\n  /**\nCreates a model for image generation.\n   */\n  imageModel(\n    modelId: OpenAIImageModelId,\n    settings?: OpenAIImageSettings,\n  ): ImageModelV1;\n\n  /**\nCreates a model for transcription.\n   */\n  transcription(modelId: OpenAITranscriptionModelId): TranscriptionModelV1;\n\n  /**\nCreates a model for speech generation.\n   */\n  speech(modelId: OpenAISpeechModelId): SpeechModelV1;\n\n  /**\nOpenAI-specific tools.\n   */\n  tools: typeof openaiTools;\n}\n\nexport interface OpenAIProviderSettings {\n  /**\nBase URL for the OpenAI API calls.\n     */\n  baseURL?: string;\n\n  /**\nAPI key for authenticating requests.\n     */\n  apiKey?: string;\n\n  /**\nOpenAI Organization.\n     */\n  organization?: string;\n\n  /**\nOpenAI project.\n     */\n  project?: string;\n\n  /**\nCustom headers to include in the requests.\n     */\n  headers?: Record<string, string>;\n\n  /**\nOpenAI compatibility mode. Should be set to `strict` when using the OpenAI API,\nand `compatible` when using 3rd party providers. In `compatible` mode, newer\ninformation such as streamOptions are not being sent. Defaults to 'compatible'.\n   */\n  compatibility?: 'strict' | 'compatible';\n\n  /**\nProvider name. Overrides the `openai` default name for 3rd party providers.\n   */\n  name?: string;\n\n  /**\nCustom fetch implementation. You can use it as a middleware to intercept requests,\nor to provide a custom fetch implementation for e.g. testing.\n    */\n  fetch?: FetchFunction;\n}\n\n/**\nCreate an OpenAI provider instance.\n */\nexport function createOpenAI(\n  options: OpenAIProviderSettings = {},\n): OpenAIProvider {\n  const baseURL =\n    withoutTrailingSlash(options.baseURL) ?? 'https://api.openai.com/v1';\n\n  // we default to compatible, because strict breaks providers like Groq:\n  const compatibility = options.compatibility ?? 'compatible';\n\n  const providerName = options.name ?? 'openai';\n\n  const getHeaders = () => ({\n    Authorization: `Bearer ${loadApiKey({\n      apiKey: options.apiKey,\n      environmentVariableName: 'OPENAI_API_KEY',\n      description: 'OpenAI',\n    })}`,\n    'OpenAI-Organization': options.organization,\n    'OpenAI-Project': options.project,\n    ...options.headers,\n  });\n\n  const createChatModel = (\n    modelId: OpenAIChatModelId,\n    settings: OpenAIChatSettings = {},\n  ) =>\n    new OpenAIChatLanguageModel(modelId, settings, {\n      provider: `${providerName}.chat`,\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      compatibility,\n      fetch: options.fetch,\n    });\n\n  const createCompletionModel = (\n    modelId: OpenAICompletionModelId,\n    settings: OpenAICompletionSettings = {},\n  ) =>\n    new OpenAICompletionLanguageModel(modelId, settings, {\n      provider: `${providerName}.completion`,\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      compatibility,\n      fetch: options.fetch,\n    });\n\n  const createEmbeddingModel = (\n    modelId: OpenAIEmbeddingModelId,\n    settings: OpenAIEmbeddingSettings = {},\n  ) =>\n    new OpenAIEmbeddingModel(modelId, settings, {\n      provider: `${providerName}.embedding`,\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const createImageModel = (\n    modelId: OpenAIImageModelId,\n    settings: OpenAIImageSettings = {},\n  ) =>\n    new OpenAIImageModel(modelId, settings, {\n      provider: `${providerName}.image`,\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const createTranscriptionModel = (modelId: OpenAITranscriptionModelId) =>\n    new OpenAITranscriptionModel(modelId, {\n      provider: `${providerName}.transcription`,\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const createSpeechModel = (modelId: OpenAISpeechModelId) =>\n    new OpenAISpeechModel(modelId, {\n      provider: `${providerName}.speech`,\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const createLanguageModel = (\n    modelId: OpenAIChatModelId | OpenAICompletionModelId,\n    settings?: OpenAIChatSettings | OpenAICompletionSettings,\n  ) => {\n    if (new.target) {\n      throw new Error(\n        'The OpenAI model function cannot be called with the new keyword.',\n      );\n    }\n\n    if (modelId === 'gpt-3.5-turbo-instruct') {\n      return createCompletionModel(\n        modelId,\n        settings as OpenAICompletionSettings,\n      );\n    }\n\n    return createChatModel(modelId, settings as OpenAIChatSettings);\n  };\n\n  const createResponsesModel = (modelId: OpenAIResponsesModelId) => {\n    return new OpenAIResponsesLanguageModel(modelId, {\n      provider: `${providerName}.responses`,\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n  };\n\n  const provider = function (\n    modelId: OpenAIChatModelId | OpenAICompletionModelId,\n    settings?: OpenAIChatSettings | OpenAICompletionSettings,\n  ) {\n    return createLanguageModel(modelId, settings);\n  };\n\n  provider.languageModel = createLanguageModel;\n  provider.chat = createChatModel;\n  provider.completion = createCompletionModel;\n  provider.responses = createResponsesModel;\n  provider.embedding = createEmbeddingModel;\n  provider.textEmbedding = createEmbeddingModel;\n  provider.textEmbeddingModel = createEmbeddingModel;\n\n  provider.image = createImageModel;\n  provider.imageModel = createImageModel;\n\n  provider.transcription = createTranscriptionModel;\n  provider.transcriptionModel = createTranscriptionModel;\n\n  provider.speech = createSpeechModel;\n  provider.speechModel = createSpeechModel;\n\n  provider.tools = openaiTools;\n\n  return provider as OpenAIProvider;\n}\n\n/**\nDefault OpenAI provider instance. It uses 'strict' compatibility mode.\n */\nexport const openai = createOpenAI({\n  compatibility: 'strict', // strict for OpenAI API\n});\n", "import {\n  InvalidResponseDataError,\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  LanguageModelV1FinishReason,\n  LanguageModelV1LogProbs,\n  LanguageModelV1ProviderMetadata,\n  LanguageModelV1StreamPart,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  ParseResult,\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonResponseHandler,\n  generateId,\n  isParsableJson,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { convertToOpenAIChatMessages } from './convert-to-openai-chat-messages';\nimport { mapOpenAIChatLogProbsOutput } from './map-openai-chat-logprobs';\nimport { mapOpenAIFinishReason } from './map-openai-finish-reason';\nimport { OpenAIChatModelId, OpenAIChatSettings } from './openai-chat-settings';\nimport {\n  openaiErrorDataSchema,\n  openaiFailedResponseHandler,\n} from './openai-error';\nimport { getResponseMetadata } from './get-response-metadata';\nimport { prepareTools } from './openai-prepare-tools';\n\ntype OpenAIChatConfig = {\n  provider: string;\n  compatibility: 'strict' | 'compatible';\n  headers: () => Record<string, string | undefined>;\n  url: (options: { modelId: string; path: string }) => string;\n  fetch?: FetchFunction;\n};\n\nexport class OpenAIChatLanguageModel implements LanguageModelV1 {\n  readonly specificationVersion = 'v1';\n\n  readonly modelId: OpenAIChatModelId;\n  readonly settings: OpenAIChatSettings;\n\n  private readonly config: OpenAIChatConfig;\n\n  constructor(\n    modelId: OpenAIChatModelId,\n    settings: OpenAIChatSettings,\n    config: OpenAIChatConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  get supportsStructuredOutputs(): boolean {\n    // enable structured outputs for reasoning models by default:\n    // TODO in the next major version, remove this and always use json mode for models\n    // that support structured outputs (blacklist other models)\n    return this.settings.structuredOutputs ?? isReasoningModel(this.modelId);\n  }\n\n  get defaultObjectGenerationMode() {\n    // audio models don't support structured outputs:\n    if (isAudioModel(this.modelId)) {\n      return 'tool';\n    }\n\n    return this.supportsStructuredOutputs ? 'json' : 'tool';\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  get supportsImageUrls(): boolean {\n    // image urls can be sent if downloadImages is disabled (default):\n    return !this.settings.downloadImages;\n  }\n\n  private getArgs({\n    mode,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences,\n    responseFormat,\n    seed,\n    providerMetadata,\n  }: Parameters<LanguageModelV1['doGenerate']>[0]) {\n    const type = mode.type;\n\n    const warnings: LanguageModelV1CallWarning[] = [];\n\n    if (topK != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'topK',\n      });\n    }\n\n    if (\n      responseFormat?.type === 'json' &&\n      responseFormat.schema != null &&\n      !this.supportsStructuredOutputs\n    ) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'responseFormat',\n        details:\n          'JSON response format schema is only supported with structuredOutputs',\n      });\n    }\n\n    const useLegacyFunctionCalling = this.settings.useLegacyFunctionCalling;\n\n    if (useLegacyFunctionCalling && this.settings.parallelToolCalls === true) {\n      throw new UnsupportedFunctionalityError({\n        functionality: 'useLegacyFunctionCalling with parallelToolCalls',\n      });\n    }\n\n    if (useLegacyFunctionCalling && this.supportsStructuredOutputs) {\n      throw new UnsupportedFunctionalityError({\n        functionality: 'structuredOutputs with useLegacyFunctionCalling',\n      });\n    }\n\n    const { messages, warnings: messageWarnings } = convertToOpenAIChatMessages(\n      {\n        prompt,\n        useLegacyFunctionCalling,\n        systemMessageMode: getSystemMessageMode(this.modelId),\n      },\n    );\n\n    warnings.push(...messageWarnings);\n\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n\n      // model specific settings:\n      logit_bias: this.settings.logitBias,\n      logprobs:\n        this.settings.logprobs === true ||\n        typeof this.settings.logprobs === 'number'\n          ? true\n          : undefined,\n      top_logprobs:\n        typeof this.settings.logprobs === 'number'\n          ? this.settings.logprobs\n          : typeof this.settings.logprobs === 'boolean'\n            ? this.settings.logprobs\n              ? 0\n              : undefined\n            : undefined,\n      user: this.settings.user,\n      parallel_tool_calls: this.settings.parallelToolCalls,\n\n      // standardized settings:\n      max_tokens: maxTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      response_format:\n        responseFormat?.type === 'json'\n          ? this.supportsStructuredOutputs && responseFormat.schema != null\n            ? {\n                type: 'json_schema',\n                json_schema: {\n                  schema: responseFormat.schema,\n                  strict: true,\n                  name: responseFormat.name ?? 'response',\n                  description: responseFormat.description,\n                },\n              }\n            : { type: 'json_object' }\n          : undefined,\n      stop: stopSequences,\n      seed,\n\n      // openai specific settings:\n      // TODO remove in next major version; we auto-map maxTokens now\n      max_completion_tokens: providerMetadata?.openai?.maxCompletionTokens,\n      store: providerMetadata?.openai?.store,\n      metadata: providerMetadata?.openai?.metadata,\n      prediction: providerMetadata?.openai?.prediction,\n      reasoning_effort:\n        providerMetadata?.openai?.reasoningEffort ??\n        this.settings.reasoningEffort,\n\n      // messages:\n      messages,\n    };\n\n    if (isReasoningModel(this.modelId)) {\n      // remove unsupported settings for reasoning models\n      // see https://platform.openai.com/docs/guides/reasoning#limitations\n      if (baseArgs.temperature != null) {\n        baseArgs.temperature = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'temperature',\n          details: 'temperature is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.top_p != null) {\n        baseArgs.top_p = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'topP',\n          details: 'topP is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.frequency_penalty != null) {\n        baseArgs.frequency_penalty = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'frequencyPenalty',\n          details: 'frequencyPenalty is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.presence_penalty != null) {\n        baseArgs.presence_penalty = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'presencePenalty',\n          details: 'presencePenalty is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.logit_bias != null) {\n        baseArgs.logit_bias = undefined;\n        warnings.push({\n          type: 'other',\n          message: 'logitBias is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.logprobs != null) {\n        baseArgs.logprobs = undefined;\n        warnings.push({\n          type: 'other',\n          message: 'logprobs is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.top_logprobs != null) {\n        baseArgs.top_logprobs = undefined;\n        warnings.push({\n          type: 'other',\n          message: 'topLogprobs is not supported for reasoning models',\n        });\n      }\n\n      // reasoning models use max_completion_tokens instead of max_tokens:\n      if (baseArgs.max_tokens != null) {\n        if (baseArgs.max_completion_tokens == null) {\n          baseArgs.max_completion_tokens = baseArgs.max_tokens;\n        }\n        baseArgs.max_tokens = undefined;\n      }\n    } else if (\n      this.modelId.startsWith('gpt-4o-search-preview') ||\n      this.modelId.startsWith('gpt-4o-mini-search-preview')\n    ) {\n      if (baseArgs.temperature != null) {\n        baseArgs.temperature = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'temperature',\n          details:\n            'temperature is not supported for the search preview models and has been removed.',\n        });\n      }\n    }\n    switch (type) {\n      case 'regular': {\n        const { tools, tool_choice, functions, function_call, toolWarnings } =\n          prepareTools({\n            mode,\n            useLegacyFunctionCalling,\n            structuredOutputs: this.supportsStructuredOutputs,\n          });\n\n        return {\n          args: {\n            ...baseArgs,\n            tools,\n            tool_choice,\n            functions,\n            function_call,\n          },\n          warnings: [...warnings, ...toolWarnings],\n        };\n      }\n\n      case 'object-json': {\n        return {\n          args: {\n            ...baseArgs,\n            response_format:\n              this.supportsStructuredOutputs && mode.schema != null\n                ? {\n                    type: 'json_schema',\n                    json_schema: {\n                      schema: mode.schema,\n                      strict: true,\n                      name: mode.name ?? 'response',\n                      description: mode.description,\n                    },\n                  }\n                : { type: 'json_object' },\n          },\n          warnings,\n        };\n      }\n\n      case 'object-tool': {\n        return {\n          args: useLegacyFunctionCalling\n            ? {\n                ...baseArgs,\n                function_call: {\n                  name: mode.tool.name,\n                },\n                functions: [\n                  {\n                    name: mode.tool.name,\n                    description: mode.tool.description,\n                    parameters: mode.tool.parameters,\n                  },\n                ],\n              }\n            : {\n                ...baseArgs,\n                tool_choice: {\n                  type: 'function',\n                  function: { name: mode.tool.name },\n                },\n                tools: [\n                  {\n                    type: 'function',\n                    function: {\n                      name: mode.tool.name,\n                      description: mode.tool.description,\n                      parameters: mode.tool.parameters,\n                      strict: this.supportsStructuredOutputs ? true : undefined,\n                    },\n                  },\n                ],\n              },\n          warnings,\n        };\n      }\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n    const { args: body, warnings } = this.getArgs(options);\n\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse,\n    } = await postJsonToApi({\n      url: this.config.url({\n        path: '/chat/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        openaiChatResponseSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { messages: rawPrompt, ...rawSettings } = body;\n    const choice = response.choices[0];\n\n    // provider metadata:\n    const completionTokenDetails = response.usage?.completion_tokens_details;\n    const promptTokenDetails = response.usage?.prompt_tokens_details;\n    const providerMetadata: LanguageModelV1ProviderMetadata = { openai: {} };\n    if (completionTokenDetails?.reasoning_tokens != null) {\n      providerMetadata.openai.reasoningTokens =\n        completionTokenDetails?.reasoning_tokens;\n    }\n    if (completionTokenDetails?.accepted_prediction_tokens != null) {\n      providerMetadata.openai.acceptedPredictionTokens =\n        completionTokenDetails?.accepted_prediction_tokens;\n    }\n    if (completionTokenDetails?.rejected_prediction_tokens != null) {\n      providerMetadata.openai.rejectedPredictionTokens =\n        completionTokenDetails?.rejected_prediction_tokens;\n    }\n    if (promptTokenDetails?.cached_tokens != null) {\n      providerMetadata.openai.cachedPromptTokens =\n        promptTokenDetails?.cached_tokens;\n    }\n\n    return {\n      text: choice.message.content ?? undefined,\n      toolCalls:\n        this.settings.useLegacyFunctionCalling && choice.message.function_call\n          ? [\n              {\n                toolCallType: 'function',\n                toolCallId: generateId(),\n                toolName: choice.message.function_call.name,\n                args: choice.message.function_call.arguments,\n              },\n            ]\n          : choice.message.tool_calls?.map(toolCall => ({\n              toolCallType: 'function',\n              toolCallId: toolCall.id ?? generateId(),\n              toolName: toolCall.function.name,\n              args: toolCall.function.arguments!,\n            })),\n      finishReason: mapOpenAIFinishReason(choice.finish_reason),\n      usage: {\n        promptTokens: response.usage?.prompt_tokens ?? NaN,\n        completionTokens: response.usage?.completion_tokens ?? NaN,\n      },\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders, body: rawResponse },\n      request: { body: JSON.stringify(body) },\n      response: getResponseMetadata(response),\n      warnings,\n      logprobs: mapOpenAIChatLogProbsOutput(choice.logprobs),\n      providerMetadata,\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV1['doStream']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n    if (this.settings.simulateStreaming) {\n      const result = await this.doGenerate(options);\n\n      const simulatedStream = new ReadableStream<LanguageModelV1StreamPart>({\n        start(controller) {\n          controller.enqueue({ type: 'response-metadata', ...result.response });\n          if (result.text) {\n            controller.enqueue({\n              type: 'text-delta',\n              textDelta: result.text,\n            });\n          }\n          if (result.toolCalls) {\n            for (const toolCall of result.toolCalls) {\n              controller.enqueue({\n                type: 'tool-call-delta',\n                toolCallType: 'function',\n                toolCallId: toolCall.toolCallId,\n                toolName: toolCall.toolName,\n                argsTextDelta: toolCall.args,\n              });\n\n              controller.enqueue({\n                type: 'tool-call',\n                ...toolCall,\n              });\n            }\n          }\n          controller.enqueue({\n            type: 'finish',\n            finishReason: result.finishReason,\n            usage: result.usage,\n            logprobs: result.logprobs,\n            providerMetadata: result.providerMetadata,\n          });\n          controller.close();\n        },\n      });\n      return {\n        stream: simulatedStream,\n        rawCall: result.rawCall,\n        rawResponse: result.rawResponse,\n        warnings: result.warnings,\n      };\n    }\n\n    const { args, warnings } = this.getArgs(options);\n\n    const body = {\n      ...args,\n      stream: true,\n\n      // only include stream_options when in strict compatibility mode:\n      stream_options:\n        this.config.compatibility === 'strict'\n          ? { include_usage: true }\n          : undefined,\n    };\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: this.config.url({\n        path: '/chat/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        openaiChatChunkSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { messages: rawPrompt, ...rawSettings } = args;\n\n    const toolCalls: Array<{\n      id: string;\n      type: 'function';\n      function: {\n        name: string;\n        arguments: string;\n      };\n      hasFinished: boolean;\n    }> = [];\n\n    let finishReason: LanguageModelV1FinishReason = 'unknown';\n    let usage: {\n      promptTokens: number | undefined;\n      completionTokens: number | undefined;\n    } = {\n      promptTokens: undefined,\n      completionTokens: undefined,\n    };\n    let logprobs: LanguageModelV1LogProbs;\n    let isFirstChunk = true;\n\n    const { useLegacyFunctionCalling } = this.settings;\n\n    const providerMetadata: LanguageModelV1ProviderMetadata = { openai: {} };\n\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<z.infer<typeof openaiChatChunkSchema>>,\n          LanguageModelV1StreamPart\n        >({\n          transform(chunk, controller) {\n            // handle failed chunk parsing / validation:\n            if (!chunk.success) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: chunk.error });\n              return;\n            }\n\n            const value = chunk.value;\n\n            // handle error chunks:\n            if ('error' in value) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: value.error });\n              return;\n            }\n\n            if (isFirstChunk) {\n              isFirstChunk = false;\n\n              controller.enqueue({\n                type: 'response-metadata',\n                ...getResponseMetadata(value),\n              });\n            }\n\n            if (value.usage != null) {\n              const {\n                prompt_tokens,\n                completion_tokens,\n                prompt_tokens_details,\n                completion_tokens_details,\n              } = value.usage;\n\n              usage = {\n                promptTokens: prompt_tokens ?? undefined,\n                completionTokens: completion_tokens ?? undefined,\n              };\n\n              if (completion_tokens_details?.reasoning_tokens != null) {\n                providerMetadata.openai.reasoningTokens =\n                  completion_tokens_details?.reasoning_tokens;\n              }\n              if (\n                completion_tokens_details?.accepted_prediction_tokens != null\n              ) {\n                providerMetadata.openai.acceptedPredictionTokens =\n                  completion_tokens_details?.accepted_prediction_tokens;\n              }\n              if (\n                completion_tokens_details?.rejected_prediction_tokens != null\n              ) {\n                providerMetadata.openai.rejectedPredictionTokens =\n                  completion_tokens_details?.rejected_prediction_tokens;\n              }\n              if (prompt_tokens_details?.cached_tokens != null) {\n                providerMetadata.openai.cachedPromptTokens =\n                  prompt_tokens_details?.cached_tokens;\n              }\n            }\n\n            const choice = value.choices[0];\n\n            if (choice?.finish_reason != null) {\n              finishReason = mapOpenAIFinishReason(choice.finish_reason);\n            }\n\n            if (choice?.delta == null) {\n              return;\n            }\n\n            const delta = choice.delta;\n\n            if (delta.content != null) {\n              controller.enqueue({\n                type: 'text-delta',\n                textDelta: delta.content,\n              });\n            }\n\n            const mappedLogprobs = mapOpenAIChatLogProbsOutput(\n              choice?.logprobs,\n            );\n            if (mappedLogprobs?.length) {\n              if (logprobs === undefined) logprobs = [];\n              logprobs.push(...mappedLogprobs);\n            }\n\n            const mappedToolCalls: typeof delta.tool_calls =\n              useLegacyFunctionCalling && delta.function_call != null\n                ? [\n                    {\n                      type: 'function',\n                      id: generateId(),\n                      function: delta.function_call,\n                      index: 0,\n                    },\n                  ]\n                : delta.tool_calls;\n\n            if (mappedToolCalls != null) {\n              for (const toolCallDelta of mappedToolCalls) {\n                const index = toolCallDelta.index;\n\n                // Tool call start. OpenAI returns all information except the arguments in the first chunk.\n                if (toolCalls[index] == null) {\n                  if (toolCallDelta.type !== 'function') {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function' type.`,\n                    });\n                  }\n\n                  if (toolCallDelta.id == null) {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'id' to be a string.`,\n                    });\n                  }\n\n                  if (toolCallDelta.function?.name == null) {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function.name' to be a string.`,\n                    });\n                  }\n\n                  toolCalls[index] = {\n                    id: toolCallDelta.id,\n                    type: 'function',\n                    function: {\n                      name: toolCallDelta.function.name,\n                      arguments: toolCallDelta.function.arguments ?? '',\n                    },\n                    hasFinished: false,\n                  };\n\n                  const toolCall = toolCalls[index];\n\n                  if (\n                    toolCall.function?.name != null &&\n                    toolCall.function?.arguments != null\n                  ) {\n                    // send delta if the argument text has already started:\n                    if (toolCall.function.arguments.length > 0) {\n                      controller.enqueue({\n                        type: 'tool-call-delta',\n                        toolCallType: 'function',\n                        toolCallId: toolCall.id,\n                        toolName: toolCall.function.name,\n                        argsTextDelta: toolCall.function.arguments,\n                      });\n                    }\n\n                    // check if tool call is complete\n                    // (some providers send the full tool call in one chunk):\n                    if (isParsableJson(toolCall.function.arguments)) {\n                      controller.enqueue({\n                        type: 'tool-call',\n                        toolCallType: 'function',\n                        toolCallId: toolCall.id ?? generateId(),\n                        toolName: toolCall.function.name,\n                        args: toolCall.function.arguments,\n                      });\n                      toolCall.hasFinished = true;\n                    }\n                  }\n\n                  continue;\n                }\n\n                // existing tool call, merge if not finished\n                const toolCall = toolCalls[index];\n\n                if (toolCall.hasFinished) {\n                  continue;\n                }\n\n                if (toolCallDelta.function?.arguments != null) {\n                  toolCall.function!.arguments +=\n                    toolCallDelta.function?.arguments ?? '';\n                }\n\n                // send delta\n                controller.enqueue({\n                  type: 'tool-call-delta',\n                  toolCallType: 'function',\n                  toolCallId: toolCall.id,\n                  toolName: toolCall.function.name,\n                  argsTextDelta: toolCallDelta.function.arguments ?? '',\n                });\n\n                // check if tool call is complete\n                if (\n                  toolCall.function?.name != null &&\n                  toolCall.function?.arguments != null &&\n                  isParsableJson(toolCall.function.arguments)\n                ) {\n                  controller.enqueue({\n                    type: 'tool-call',\n                    toolCallType: 'function',\n                    toolCallId: toolCall.id ?? generateId(),\n                    toolName: toolCall.function.name,\n                    args: toolCall.function.arguments,\n                  });\n                  toolCall.hasFinished = true;\n                }\n              }\n            }\n          },\n\n          flush(controller) {\n            controller.enqueue({\n              type: 'finish',\n              finishReason,\n              logprobs,\n              usage: {\n                promptTokens: usage.promptTokens ?? NaN,\n                completionTokens: usage.completionTokens ?? NaN,\n              },\n              ...(providerMetadata != null ? { providerMetadata } : {}),\n            });\n          },\n        }),\n      ),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      request: { body: JSON.stringify(body) },\n      warnings,\n    };\n  }\n}\n\nconst openaiTokenUsageSchema = z\n  .object({\n    prompt_tokens: z.number().nullish(),\n    completion_tokens: z.number().nullish(),\n    prompt_tokens_details: z\n      .object({\n        cached_tokens: z.number().nullish(),\n      })\n      .nullish(),\n    completion_tokens_details: z\n      .object({\n        reasoning_tokens: z.number().nullish(),\n        accepted_prediction_tokens: z.number().nullish(),\n        rejected_prediction_tokens: z.number().nullish(),\n      })\n      .nullish(),\n  })\n  .nullish();\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiChatResponseSchema = z.object({\n  id: z.string().nullish(),\n  created: z.number().nullish(),\n  model: z.string().nullish(),\n  choices: z.array(\n    z.object({\n      message: z.object({\n        role: z.literal('assistant').nullish(),\n        content: z.string().nullish(),\n        function_call: z\n          .object({\n            arguments: z.string(),\n            name: z.string(),\n          })\n          .nullish(),\n        tool_calls: z\n          .array(\n            z.object({\n              id: z.string().nullish(),\n              type: z.literal('function'),\n              function: z.object({\n                name: z.string(),\n                arguments: z.string(),\n              }),\n            }),\n          )\n          .nullish(),\n      }),\n      index: z.number(),\n      logprobs: z\n        .object({\n          content: z\n            .array(\n              z.object({\n                token: z.string(),\n                logprob: z.number(),\n                top_logprobs: z.array(\n                  z.object({\n                    token: z.string(),\n                    logprob: z.number(),\n                  }),\n                ),\n              }),\n            )\n            .nullable(),\n        })\n        .nullish(),\n      finish_reason: z.string().nullish(),\n    }),\n  ),\n  usage: openaiTokenUsageSchema,\n});\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiChatChunkSchema = z.union([\n  z.object({\n    id: z.string().nullish(),\n    created: z.number().nullish(),\n    model: z.string().nullish(),\n    choices: z.array(\n      z.object({\n        delta: z\n          .object({\n            role: z.enum(['assistant']).nullish(),\n            content: z.string().nullish(),\n            function_call: z\n              .object({\n                name: z.string().optional(),\n                arguments: z.string().optional(),\n              })\n              .nullish(),\n            tool_calls: z\n              .array(\n                z.object({\n                  index: z.number(),\n                  id: z.string().nullish(),\n                  type: z.literal('function').nullish(),\n                  function: z.object({\n                    name: z.string().nullish(),\n                    arguments: z.string().nullish(),\n                  }),\n                }),\n              )\n              .nullish(),\n          })\n          .nullish(),\n        logprobs: z\n          .object({\n            content: z\n              .array(\n                z.object({\n                  token: z.string(),\n                  logprob: z.number(),\n                  top_logprobs: z.array(\n                    z.object({\n                      token: z.string(),\n                      logprob: z.number(),\n                    }),\n                  ),\n                }),\n              )\n              .nullable(),\n          })\n          .nullish(),\n        finish_reason: z.string().nullish(),\n        index: z.number(),\n      }),\n    ),\n    usage: openaiTokenUsageSchema,\n  }),\n  openaiErrorDataSchema,\n]);\n\nfunction isReasoningModel(modelId: string) {\n  return modelId.startsWith('o') || modelId.startsWith('gpt-5');\n}\n\nfunction isAudioModel(modelId: string) {\n  return modelId.startsWith('gpt-4o-audio-preview');\n}\n\nfunction getSystemMessageMode(modelId: string) {\n  if (!isReasoningModel(modelId)) {\n    return 'system';\n  }\n\n  return (\n    reasoningModels[modelId as keyof typeof reasoningModels]\n      ?.systemMessageMode ?? 'developer'\n  );\n}\n\nconst reasoningModels = {\n  'o1-mini': {\n    systemMessageMode: 'remove',\n  },\n  'o1-mini-2024-09-12': {\n    systemMessageMode: 'remove',\n  },\n  'o1-preview': {\n    systemMessageMode: 'remove',\n  },\n  'o1-preview-2024-09-12': {\n    systemMessageMode: 'remove',\n  },\n  o3: {\n    systemMessageMode: 'developer',\n  },\n  'o3-2025-04-16': {\n    systemMessageMode: 'developer',\n  },\n  'o3-mini': {\n    systemMessageMode: 'developer',\n  },\n  'o3-mini-2025-01-31': {\n    systemMessageMode: 'developer',\n  },\n  'o4-mini': {\n    systemMessageMode: 'developer',\n  },\n  'o4-mini-2025-04-16': {\n    systemMessageMode: 'developer',\n  },\n} as const;\n", "import {\n  LanguageModelV1CallWarning,\n  LanguageModelV1Prompt,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { convertUint8ArrayToBase64 } from '@ai-sdk/provider-utils';\nimport { OpenAIChatPrompt } from './openai-chat-prompt';\n\nexport function convertToOpenAIChatMessages({\n  prompt,\n  useLegacyFunctionCalling = false,\n  systemMessageMode = 'system',\n}: {\n  prompt: LanguageModelV1Prompt;\n  useLegacyFunctionCalling?: boolean;\n  systemMessageMode?: 'system' | 'developer' | 'remove';\n}): {\n  messages: OpenAIChatPrompt;\n  warnings: Array<LanguageModelV1CallWarning>;\n} {\n  const messages: OpenAIChatPrompt = [];\n  const warnings: Array<LanguageModelV1CallWarning> = [];\n\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case 'system': {\n        switch (systemMessageMode) {\n          case 'system': {\n            messages.push({ role: 'system', content });\n            break;\n          }\n          case 'developer': {\n            messages.push({ role: 'developer', content });\n            break;\n          }\n          case 'remove': {\n            warnings.push({\n              type: 'other',\n              message: 'system messages are removed for this model',\n            });\n            break;\n          }\n          default: {\n            const _exhaustiveCheck: never = systemMessageMode;\n            throw new Error(\n              `Unsupported system message mode: ${_exhaustiveCheck}`,\n            );\n          }\n        }\n        break;\n      }\n\n      case 'user': {\n        if (content.length === 1 && content[0].type === 'text') {\n          messages.push({ role: 'user', content: content[0].text });\n          break;\n        }\n\n        messages.push({\n          role: 'user',\n          content: content.map((part, index) => {\n            switch (part.type) {\n              case 'text': {\n                return { type: 'text', text: part.text };\n              }\n              case 'image': {\n                return {\n                  type: 'image_url',\n                  image_url: {\n                    url:\n                      part.image instanceof URL\n                        ? part.image.toString()\n                        : `data:${\n                            part.mimeType ?? 'image/jpeg'\n                          };base64,${convertUint8ArrayToBase64(part.image)}`,\n\n                    // OpenAI specific extension: image detail\n                    detail: part.providerMetadata?.openai?.imageDetail,\n                  },\n                };\n              }\n              case 'file': {\n                if (part.data instanceof URL) {\n                  throw new UnsupportedFunctionalityError({\n                    functionality:\n                      \"'File content parts with URL data' functionality not supported.\",\n                  });\n                }\n\n                switch (part.mimeType) {\n                  case 'audio/wav': {\n                    return {\n                      type: 'input_audio',\n                      input_audio: { data: part.data, format: 'wav' },\n                    };\n                  }\n                  case 'audio/mp3':\n                  case 'audio/mpeg': {\n                    return {\n                      type: 'input_audio',\n                      input_audio: { data: part.data, format: 'mp3' },\n                    };\n                  }\n                  case 'application/pdf': {\n                    return {\n                      type: 'file',\n                      file: {\n                        filename: part.filename ?? `part-${index}.pdf`,\n                        file_data: `data:application/pdf;base64,${part.data}`,\n                      },\n                    };\n                  }\n                  default: {\n                    throw new UnsupportedFunctionalityError({\n                      functionality: `File content part type ${part.mimeType} in user messages`,\n                    });\n                  }\n                }\n              }\n            }\n          }),\n        });\n\n        break;\n      }\n\n      case 'assistant': {\n        let text = '';\n        const toolCalls: Array<{\n          id: string;\n          type: 'function';\n          function: { name: string; arguments: string };\n        }> = [];\n\n        for (const part of content) {\n          switch (part.type) {\n            case 'text': {\n              text += part.text;\n              break;\n            }\n            case 'tool-call': {\n              toolCalls.push({\n                id: part.toolCallId,\n                type: 'function',\n                function: {\n                  name: part.toolName,\n                  arguments: JSON.stringify(part.args),\n                },\n              });\n              break;\n            }\n          }\n        }\n\n        if (useLegacyFunctionCalling) {\n          if (toolCalls.length > 1) {\n            throw new UnsupportedFunctionalityError({\n              functionality:\n                'useLegacyFunctionCalling with multiple tool calls in one message',\n            });\n          }\n\n          messages.push({\n            role: 'assistant',\n            content: text,\n            function_call:\n              toolCalls.length > 0 ? toolCalls[0].function : undefined,\n          });\n        } else {\n          messages.push({\n            role: 'assistant',\n            content: text,\n            tool_calls: toolCalls.length > 0 ? toolCalls : undefined,\n          });\n        }\n\n        break;\n      }\n\n      case 'tool': {\n        for (const toolResponse of content) {\n          if (useLegacyFunctionCalling) {\n            messages.push({\n              role: 'function',\n              name: toolResponse.toolName,\n              content: JSON.stringify(toolResponse.result),\n            });\n          } else {\n            messages.push({\n              role: 'tool',\n              tool_call_id: toolResponse.toolCallId,\n              content: JSON.stringify(toolResponse.result),\n            });\n          }\n        }\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return { messages, warnings };\n}\n", "import { LanguageModelV1LogProbs } from '@ai-sdk/provider';\n\ntype OpenAIChatLogProbs = {\n  content:\n    | {\n        token: string;\n        logprob: number;\n        top_logprobs:\n          | {\n              token: string;\n              logprob: number;\n            }[]\n          | null;\n      }[]\n    | null;\n};\n\nexport function mapOpenAIChatLogProbsOutput(\n  logprobs: OpenAIChatLogProbs | null | undefined,\n): LanguageModelV1LogProbs | undefined {\n  return (\n    logprobs?.content?.map(({ token, logprob, top_logprobs }) => ({\n      token,\n      logprob,\n      topLogprobs: top_logprobs\n        ? top_logprobs.map(({ token, logprob }) => ({\n            token,\n            logprob,\n          }))\n        : [],\n    })) ?? undefined\n  );\n}\n", "import { LanguageModelV1FinishReason } from '@ai-sdk/provider';\n\nexport function mapOpenAIFinishReason(\n  finishReason: string | null | undefined,\n): LanguageModelV1FinishReason {\n  switch (finishReason) {\n    case 'stop':\n      return 'stop';\n    case 'length':\n      return 'length';\n    case 'content_filter':\n      return 'content-filter';\n    case 'function_call':\n    case 'tool_calls':\n      return 'tool-calls';\n    default:\n      return 'unknown';\n  }\n}\n", "import { z } from 'zod';\nimport { createJsonErrorResponseHandler } from '@ai-sdk/provider-utils';\n\nexport const openaiErrorDataSchema = z.object({\n  error: z.object({\n    message: z.string(),\n\n    // The additional information below is handled loosely to support\n    // OpenAI-compatible providers that have slightly different error\n    // responses:\n    type: z.string().nullish(),\n    param: z.any().nullish(),\n    code: z.union([z.string(), z.number()]).nullish(),\n  }),\n});\n\nexport type OpenAIErrorData = z.infer<typeof openaiErrorDataSchema>;\n\nexport const openaiFailedResponseHandler = createJsonErrorResponseHandler({\n  errorSchema: openaiErrorDataSchema,\n  errorToMessage: data => data.error.message,\n});\n", "export function getResponseMetadata({\n  id,\n  model,\n  created,\n}: {\n  id?: string | undefined | null;\n  created?: number | undefined | null;\n  model?: string | undefined | null;\n}) {\n  return {\n    id: id ?? undefined,\n    modelId: model ?? undefined,\n    timestamp: created != null ? new Date(created * 1000) : undefined,\n  };\n}\n", "import {\n  JSONSchema7,\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\n\nexport function prepareTools({\n  mode,\n  useLegacyFunctionCalling = false,\n  structuredOutputs,\n}: {\n  mode: Parameters<LanguageModelV1['doGenerate']>[0]['mode'] & {\n    type: 'regular';\n  };\n  useLegacyFunctionCalling: boolean | undefined;\n  structuredOutputs: boolean;\n}): {\n  tools?: {\n    type: 'function';\n    function: {\n      name: string;\n      description: string | undefined;\n      parameters: JSONSchema7;\n      strict?: boolean;\n    };\n  }[];\n  tool_choice?:\n    | 'auto'\n    | 'none'\n    | 'required'\n    | { type: 'function'; function: { name: string } };\n\n  // legacy support\n  functions?: {\n    name: string;\n    description: string | undefined;\n    parameters: JSONSchema7;\n  }[];\n  function_call?: { name: string };\n  toolWarnings: Array<LanguageModelV1CallWarning>;\n} {\n  // when the tools array is empty, change it to undefined to prevent errors:\n  const tools = mode.tools?.length ? mode.tools : undefined;\n\n  const toolWarnings: LanguageModelV1CallWarning[] = [];\n\n  if (tools == null) {\n    return { tools: undefined, tool_choice: undefined, toolWarnings };\n  }\n\n  const toolChoice = mode.toolChoice;\n\n  if (useLegacyFunctionCalling) {\n    const openaiFunctions: Array<{\n      name: string;\n      description: string | undefined;\n      parameters: JSONSchema7;\n    }> = [];\n\n    for (const tool of tools) {\n      if (tool.type === 'provider-defined') {\n        toolWarnings.push({ type: 'unsupported-tool', tool });\n      } else {\n        openaiFunctions.push({\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.parameters,\n        });\n      }\n    }\n\n    if (toolChoice == null) {\n      return {\n        functions: openaiFunctions,\n        function_call: undefined,\n        toolWarnings,\n      };\n    }\n\n    const type = toolChoice.type;\n\n    switch (type) {\n      case 'auto':\n      case 'none':\n      case undefined:\n        return {\n          functions: openaiFunctions,\n          function_call: undefined,\n          toolWarnings,\n        };\n      case 'required':\n        throw new UnsupportedFunctionalityError({\n          functionality: 'useLegacyFunctionCalling and toolChoice: required',\n        });\n      default:\n        return {\n          functions: openaiFunctions,\n          function_call: { name: toolChoice.toolName },\n          toolWarnings,\n        };\n    }\n  }\n\n  const openaiTools: Array<{\n    type: 'function';\n    function: {\n      name: string;\n      description: string | undefined;\n      parameters: JSONSchema7;\n      strict: boolean | undefined;\n    };\n  }> = [];\n\n  for (const tool of tools) {\n    if (tool.type === 'provider-defined') {\n      toolWarnings.push({ type: 'unsupported-tool', tool });\n    } else {\n      openaiTools.push({\n        type: 'function',\n        function: {\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.parameters,\n          strict: structuredOutputs ? true : undefined,\n        },\n      });\n    }\n  }\n\n  if (toolChoice == null) {\n    return { tools: openaiTools, tool_choice: undefined, toolWarnings };\n  }\n\n  const type = toolChoice.type;\n\n  switch (type) {\n    case 'auto':\n    case 'none':\n    case 'required':\n      return { tools: openaiTools, tool_choice: type, toolWarnings };\n    case 'tool':\n      return {\n        tools: openaiTools,\n        tool_choice: {\n          type: 'function',\n          function: {\n            name: toolChoice.toolName,\n          },\n        },\n        toolWarnings,\n      };\n    default: {\n      const _exhaustiveCheck: never = type;\n      throw new UnsupportedFunctionalityError({\n        functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`,\n      });\n    }\n  }\n}\n", "import {\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  LanguageModelV1FinishReason,\n  LanguageModelV1LogProbs,\n  LanguageModelV1StreamPart,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  ParseResult,\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonResponseHandler,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { convertToOpenAICompletionPrompt } from './convert-to-openai-completion-prompt';\nimport { mapOpenAICompletionLogProbs } from './map-openai-completion-logprobs';\nimport { mapOpenAIFinishReason } from './map-openai-finish-reason';\nimport {\n  OpenAICompletionModelId,\n  OpenAICompletionSettings,\n} from './openai-completion-settings';\nimport {\n  openaiErrorDataSchema,\n  openaiFailedResponseHandler,\n} from './openai-error';\nimport { getResponseMetadata } from './get-response-metadata';\n\ntype OpenAICompletionConfig = {\n  provider: string;\n  compatibility: 'strict' | 'compatible';\n  headers: () => Record<string, string | undefined>;\n  url: (options: { modelId: string; path: string }) => string;\n  fetch?: FetchFunction;\n};\n\nexport class OpenAICompletionLanguageModel implements LanguageModelV1 {\n  readonly specificationVersion = 'v1';\n  readonly defaultObjectGenerationMode = undefined;\n\n  readonly modelId: OpenAICompletionModelId;\n  readonly settings: OpenAICompletionSettings;\n\n  private readonly config: OpenAICompletionConfig;\n\n  constructor(\n    modelId: OpenAICompletionModelId,\n    settings: OpenAICompletionSettings,\n    config: OpenAICompletionConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  private getArgs({\n    mode,\n    inputFormat,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences: userStopSequences,\n    responseFormat,\n    seed,\n  }: Parameters<LanguageModelV1['doGenerate']>[0]) {\n    const type = mode.type;\n\n    const warnings: LanguageModelV1CallWarning[] = [];\n\n    if (topK != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'topK',\n      });\n    }\n\n    if (responseFormat != null && responseFormat.type !== 'text') {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'responseFormat',\n        details: 'JSON response format is not supported.',\n      });\n    }\n\n    const { prompt: completionPrompt, stopSequences } =\n      convertToOpenAICompletionPrompt({ prompt, inputFormat });\n\n    const stop = [...(stopSequences ?? []), ...(userStopSequences ?? [])];\n\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n\n      // model specific settings:\n      echo: this.settings.echo,\n      logit_bias: this.settings.logitBias,\n      logprobs:\n        typeof this.settings.logprobs === 'number'\n          ? this.settings.logprobs\n          : typeof this.settings.logprobs === 'boolean'\n            ? this.settings.logprobs\n              ? 0\n              : undefined\n            : undefined,\n      suffix: this.settings.suffix,\n      user: this.settings.user,\n\n      // standardized settings:\n      max_tokens: maxTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      seed,\n\n      // prompt:\n      prompt: completionPrompt,\n\n      // stop sequences:\n      stop: stop.length > 0 ? stop : undefined,\n    };\n\n    switch (type) {\n      case 'regular': {\n        if (mode.tools?.length) {\n          throw new UnsupportedFunctionalityError({\n            functionality: 'tools',\n          });\n        }\n\n        if (mode.toolChoice) {\n          throw new UnsupportedFunctionalityError({\n            functionality: 'toolChoice',\n          });\n        }\n\n        return { args: baseArgs, warnings };\n      }\n\n      case 'object-json': {\n        throw new UnsupportedFunctionalityError({\n          functionality: 'object-json mode',\n        });\n      }\n\n      case 'object-tool': {\n        throw new UnsupportedFunctionalityError({\n          functionality: 'object-tool mode',\n        });\n      }\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n    const { args, warnings } = this.getArgs(options);\n\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse,\n    } = await postJsonToApi({\n      url: this.config.url({\n        path: '/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        openaiCompletionResponseSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { prompt: rawPrompt, ...rawSettings } = args;\n    const choice = response.choices[0];\n\n    return {\n      text: choice.text,\n      usage: {\n        promptTokens: response.usage.prompt_tokens,\n        completionTokens: response.usage.completion_tokens,\n      },\n      finishReason: mapOpenAIFinishReason(choice.finish_reason),\n      logprobs: mapOpenAICompletionLogProbs(choice.logprobs),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders, body: rawResponse },\n      response: getResponseMetadata(response),\n      warnings,\n      request: { body: JSON.stringify(args) },\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV1['doStream']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n    const { args, warnings } = this.getArgs(options);\n\n    const body = {\n      ...args,\n      stream: true,\n\n      // only include stream_options when in strict compatibility mode:\n      stream_options:\n        this.config.compatibility === 'strict'\n          ? { include_usage: true }\n          : undefined,\n    };\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: this.config.url({\n        path: '/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        openaiCompletionChunkSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { prompt: rawPrompt, ...rawSettings } = args;\n\n    let finishReason: LanguageModelV1FinishReason = 'unknown';\n    let usage: { promptTokens: number; completionTokens: number } = {\n      promptTokens: Number.NaN,\n      completionTokens: Number.NaN,\n    };\n    let logprobs: LanguageModelV1LogProbs;\n    let isFirstChunk = true;\n\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<z.infer<typeof openaiCompletionChunkSchema>>,\n          LanguageModelV1StreamPart\n        >({\n          transform(chunk, controller) {\n            // handle failed chunk parsing / validation:\n            if (!chunk.success) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: chunk.error });\n              return;\n            }\n\n            const value = chunk.value;\n\n            // handle error chunks:\n            if ('error' in value) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: value.error });\n              return;\n            }\n\n            if (isFirstChunk) {\n              isFirstChunk = false;\n\n              controller.enqueue({\n                type: 'response-metadata',\n                ...getResponseMetadata(value),\n              });\n            }\n\n            if (value.usage != null) {\n              usage = {\n                promptTokens: value.usage.prompt_tokens,\n                completionTokens: value.usage.completion_tokens,\n              };\n            }\n\n            const choice = value.choices[0];\n\n            if (choice?.finish_reason != null) {\n              finishReason = mapOpenAIFinishReason(choice.finish_reason);\n            }\n\n            if (choice?.text != null) {\n              controller.enqueue({\n                type: 'text-delta',\n                textDelta: choice.text,\n              });\n            }\n\n            const mappedLogprobs = mapOpenAICompletionLogProbs(\n              choice?.logprobs,\n            );\n            if (mappedLogprobs?.length) {\n              if (logprobs === undefined) logprobs = [];\n              logprobs.push(...mappedLogprobs);\n            }\n          },\n\n          flush(controller) {\n            controller.enqueue({\n              type: 'finish',\n              finishReason,\n              logprobs,\n              usage,\n            });\n          },\n        }),\n      ),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      warnings,\n      request: { body: JSON.stringify(body) },\n    };\n  }\n}\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiCompletionResponseSchema = z.object({\n  id: z.string().nullish(),\n  created: z.number().nullish(),\n  model: z.string().nullish(),\n  choices: z.array(\n    z.object({\n      text: z.string(),\n      finish_reason: z.string(),\n      logprobs: z\n        .object({\n          tokens: z.array(z.string()),\n          token_logprobs: z.array(z.number()),\n          top_logprobs: z.array(z.record(z.string(), z.number())).nullable(),\n        })\n        .nullish(),\n    }),\n  ),\n  usage: z.object({\n    prompt_tokens: z.number(),\n    completion_tokens: z.number(),\n  }),\n});\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiCompletionChunkSchema = z.union([\n  z.object({\n    id: z.string().nullish(),\n    created: z.number().nullish(),\n    model: z.string().nullish(),\n    choices: z.array(\n      z.object({\n        text: z.string(),\n        finish_reason: z.string().nullish(),\n        index: z.number(),\n        logprobs: z\n          .object({\n            tokens: z.array(z.string()),\n            token_logprobs: z.array(z.number()),\n            top_logprobs: z.array(z.record(z.string(), z.number())).nullable(),\n          })\n          .nullish(),\n      }),\n    ),\n    usage: z\n      .object({\n        prompt_tokens: z.number(),\n        completion_tokens: z.number(),\n      })\n      .nullish(),\n  }),\n  openaiErrorDataSchema,\n]);\n", "import {\n  InvalidPromptError,\n  LanguageModelV1Prompt,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\n\nexport function convertToOpenAICompletionPrompt({\n  prompt,\n  inputFormat,\n  user = 'user',\n  assistant = 'assistant',\n}: {\n  prompt: LanguageModelV1Prompt;\n  inputFormat: 'prompt' | 'messages';\n  user?: string;\n  assistant?: string;\n}): {\n  prompt: string;\n  stopSequences?: string[];\n} {\n  // When the user supplied a prompt input, we don't transform it:\n  if (\n    inputFormat === 'prompt' &&\n    prompt.length === 1 &&\n    prompt[0].role === 'user' &&\n    prompt[0].content.length === 1 &&\n    prompt[0].content[0].type === 'text'\n  ) {\n    return { prompt: prompt[0].content[0].text };\n  }\n\n  // otherwise transform to a chat message format:\n  let text = '';\n\n  // if first message is a system message, add it to the text:\n  if (prompt[0].role === 'system') {\n    text += `${prompt[0].content}\\n\\n`;\n    prompt = prompt.slice(1);\n  }\n\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case 'system': {\n        throw new InvalidPromptError({\n          message: 'Unexpected system message in prompt: ${content}',\n          prompt,\n        });\n      }\n\n      case 'user': {\n        const userMessage = content\n          .map(part => {\n            switch (part.type) {\n              case 'text': {\n                return part.text;\n              }\n              case 'image': {\n                throw new UnsupportedFunctionalityError({\n                  functionality: 'images',\n                });\n              }\n            }\n          })\n          .join('');\n\n        text += `${user}:\\n${userMessage}\\n\\n`;\n        break;\n      }\n\n      case 'assistant': {\n        const assistantMessage = content\n          .map(part => {\n            switch (part.type) {\n              case 'text': {\n                return part.text;\n              }\n              case 'tool-call': {\n                throw new UnsupportedFunctionalityError({\n                  functionality: 'tool-call messages',\n                });\n              }\n            }\n          })\n          .join('');\n\n        text += `${assistant}:\\n${assistantMessage}\\n\\n`;\n        break;\n      }\n\n      case 'tool': {\n        throw new UnsupportedFunctionalityError({\n          functionality: 'tool messages',\n        });\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  // Assistant message prefix:\n  text += `${assistant}:\\n`;\n\n  return {\n    prompt: text,\n    stopSequences: [`\\n${user}:`],\n  };\n}\n", "import { LanguageModelV1LogProbs } from '@ai-sdk/provider';\n\ntype OpenAICompletionLogProps = {\n  tokens: string[];\n  token_logprobs: number[];\n  top_logprobs: Record<string, number>[] | null;\n};\n\nexport function mapOpenAICompletionLogProbs(\n  logprobs: OpenAICompletionLogProps | null | undefined,\n): LanguageModelV1LogProbs | undefined {\n  return logprobs?.tokens.map((token, index) => ({\n    token,\n    logprob: logprobs.token_logprobs[index],\n    topLogprobs: logprobs.top_logprobs\n      ? Object.entries(logprobs.top_logprobs[index]).map(\n          ([token, logprob]) => ({\n            token,\n            logprob,\n          }),\n        )\n      : [],\n  }));\n}\n", "import {\n  EmbeddingModelV1,\n  TooManyEmbeddingValuesForCallError,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createJsonResponseHandler,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { OpenAIConfig } from './openai-config';\nimport {\n  OpenAIEmbeddingModelId,\n  OpenAIEmbeddingSettings,\n} from './openai-embedding-settings';\nimport { openaiFailedResponseHandler } from './openai-error';\n\nexport class OpenAIEmbeddingModel implements EmbeddingModelV1<string> {\n  readonly specificationVersion = 'v1';\n  readonly modelId: OpenAIEmbeddingModelId;\n\n  private readonly config: OpenAIConfig;\n  private readonly settings: OpenAIEmbeddingSettings;\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  get maxEmbeddingsPerCall(): number {\n    return this.settings.maxEmbeddingsPerCall ?? 2048;\n  }\n\n  get supportsParallelCalls(): boolean {\n    return this.settings.supportsParallelCalls ?? true;\n  }\n\n  constructor(\n    modelId: OpenAIEmbeddingModelId,\n    settings: OpenAIEmbeddingSettings,\n    config: OpenAIConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  async doEmbed({\n    values,\n    headers,\n    abortSignal,\n  }: Parameters<EmbeddingModelV1<string>['doEmbed']>[0]): Promise<\n    Awaited<ReturnType<EmbeddingModelV1<string>['doEmbed']>>\n  > {\n    if (values.length > this.maxEmbeddingsPerCall) {\n      throw new TooManyEmbeddingValuesForCallError({\n        provider: this.provider,\n        modelId: this.modelId,\n        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n        values,\n      });\n    }\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: this.config.url({\n        path: '/embeddings',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), headers),\n      body: {\n        model: this.modelId,\n        input: values,\n        encoding_format: 'float',\n        dimensions: this.settings.dimensions,\n        user: this.settings.user,\n      },\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        openaiTextEmbeddingResponseSchema,\n      ),\n      abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    return {\n      embeddings: response.data.map(item => item.embedding),\n      usage: response.usage\n        ? { tokens: response.usage.prompt_tokens }\n        : undefined,\n      rawResponse: { headers: responseHeaders },\n    };\n  }\n}\n\n// minimal version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiTextEmbeddingResponseSchema = z.object({\n  data: z.array(z.object({ embedding: z.array(z.number()) })),\n  usage: z.object({ prompt_tokens: z.number() }).nullish(),\n});\n", "import { ImageModelV1, ImageModelV1CallWarning } from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createJsonResponseHandler,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { OpenAIConfig } from './openai-config';\nimport { openaiFailedResponseHandler } from './openai-error';\nimport {\n  OpenAIImageModelId,\n  OpenAIImageSettings,\n  modelMaxImagesPerCall,\n  hasDefaultResponseFormat,\n} from './openai-image-settings';\n\ninterface OpenAIImageModelConfig extends OpenAIConfig {\n  _internal?: {\n    currentDate?: () => Date;\n  };\n}\n\nexport class OpenAIImageModel implements ImageModelV1 {\n  readonly specificationVersion = 'v1';\n\n  get maxImagesPerCall(): number {\n    return (\n      this.settings.maxImagesPerCall ?? modelMaxImagesPerCall[this.modelId] ?? 1\n    );\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  constructor(\n    readonly modelId: OpenAIImageModelId,\n    private readonly settings: OpenAIImageSettings,\n    private readonly config: OpenAIImageModelConfig,\n  ) {}\n\n  async doGenerate({\n    prompt,\n    n,\n    size,\n    aspectRatio,\n    seed,\n    providerOptions,\n    headers,\n    abortSignal,\n  }: Parameters<ImageModelV1['doGenerate']>[0]): Promise<\n    Awaited<ReturnType<ImageModelV1['doGenerate']>>\n  > {\n    const warnings: Array<ImageModelV1CallWarning> = [];\n\n    if (aspectRatio != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'aspectRatio',\n        details:\n          'This model does not support aspect ratio. Use `size` instead.',\n      });\n    }\n\n    if (seed != null) {\n      warnings.push({ type: 'unsupported-setting', setting: 'seed' });\n    }\n\n    const currentDate = this.config._internal?.currentDate?.() ?? new Date();\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: '/images/generations',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), headers),\n      body: {\n        model: this.modelId,\n        prompt,\n        n,\n        size,\n        ...(providerOptions.openai ?? {}),\n        ...(!hasDefaultResponseFormat.has(this.modelId)\n          ? { response_format: 'b64_json' }\n          : {}),\n      },\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        openaiImageResponseSchema,\n      ),\n      abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    return {\n      images: response.data.map(item => item.b64_json),\n      warnings,\n      response: {\n        timestamp: currentDate,\n        modelId: this.modelId,\n        headers: responseHeaders,\n      },\n    };\n  }\n}\n\n// minimal version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiImageResponseSchema = z.object({\n  data: z.array(z.object({ b64_json: z.string() })),\n});\n", "export type OpenAIImageModelId =\n  | 'gpt-image-1'\n  | 'dall-e-3'\n  | 'dall-e-2'\n  | (string & {});\n\n// https://platform.openai.com/docs/guides/images\nexport const modelMaxImagesPerCall: Record<OpenAIImageModelId, number> = {\n  'dall-e-3': 1,\n  'dall-e-2': 10,\n  'gpt-image-1': 10,\n};\n\nexport const hasDefaultResponseFormat = new Set(['gpt-image-1']);\n\nexport interface OpenAIImageSettings {\n  /**\nOverride the maximum number of images per call (default is dependent on the\nmodel, or 1 for an unknown model).\n   */\n  maxImagesPerCall?: number;\n}\n", "import {\n  TranscriptionModelV1,\n  TranscriptionModelV1CallOptions,\n  TranscriptionModelV1CallWarning,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  convertBase64ToUint8Array,\n  createJsonResponseHandler,\n  parseProviderOptions,\n  postFormDataToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { OpenAIConfig } from './openai-config';\nimport { openaiFailedResponseHandler } from './openai-error';\nimport {\n  OpenAITranscriptionModelId,\n  OpenAITranscriptionModelOptions,\n} from './openai-transcription-settings';\n\n// https://platform.openai.com/docs/api-reference/audio/createTranscription\nconst openAIProviderOptionsSchema = z.object({\n  include: z.array(z.string()).nullish(),\n  language: z.string().nullish(),\n  prompt: z.string().nullish(),\n  temperature: z.number().min(0).max(1).nullish().default(0),\n  timestampGranularities: z\n    .array(z.enum(['word', 'segment']))\n    .nullish()\n    .default(['segment']),\n});\n\nexport type OpenAITranscriptionCallOptions = Omit<\n  TranscriptionModelV1CallOptions,\n  'providerOptions'\n> & {\n  providerOptions?: {\n    openai?: z.infer<typeof openAIProviderOptionsSchema>;\n  };\n};\n\ninterface OpenAITranscriptionModelConfig extends OpenAIConfig {\n  _internal?: {\n    currentDate?: () => Date;\n  };\n}\n\n// https://platform.openai.com/docs/guides/speech-to-text#supported-languages\nconst languageMap = {\n  afrikaans: 'af',\n  arabic: 'ar',\n  armenian: 'hy',\n  azerbaijani: 'az',\n  belarusian: 'be',\n  bosnian: 'bs',\n  bulgarian: 'bg',\n  catalan: 'ca',\n  chinese: 'zh',\n  croatian: 'hr',\n  czech: 'cs',\n  danish: 'da',\n  dutch: 'nl',\n  english: 'en',\n  estonian: 'et',\n  finnish: 'fi',\n  french: 'fr',\n  galician: 'gl',\n  german: 'de',\n  greek: 'el',\n  hebrew: 'he',\n  hindi: 'hi',\n  hungarian: 'hu',\n  icelandic: 'is',\n  indonesian: 'id',\n  italian: 'it',\n  japanese: 'ja',\n  kannada: 'kn',\n  kazakh: 'kk',\n  korean: 'ko',\n  latvian: 'lv',\n  lithuanian: 'lt',\n  macedonian: 'mk',\n  malay: 'ms',\n  marathi: 'mr',\n  maori: 'mi',\n  nepali: 'ne',\n  norwegian: 'no',\n  persian: 'fa',\n  polish: 'pl',\n  portuguese: 'pt',\n  romanian: 'ro',\n  russian: 'ru',\n  serbian: 'sr',\n  slovak: 'sk',\n  slovenian: 'sl',\n  spanish: 'es',\n  swahili: 'sw',\n  swedish: 'sv',\n  tagalog: 'tl',\n  tamil: 'ta',\n  thai: 'th',\n  turkish: 'tr',\n  ukrainian: 'uk',\n  urdu: 'ur',\n  vietnamese: 'vi',\n  welsh: 'cy',\n};\n\nexport class OpenAITranscriptionModel implements TranscriptionModelV1 {\n  readonly specificationVersion = 'v1';\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  constructor(\n    readonly modelId: OpenAITranscriptionModelId,\n    private readonly config: OpenAITranscriptionModelConfig,\n  ) {}\n\n  private getArgs({\n    audio,\n    mediaType,\n    providerOptions,\n  }: OpenAITranscriptionCallOptions) {\n    const warnings: TranscriptionModelV1CallWarning[] = [];\n\n    // Parse provider options\n    const openAIOptions = parseProviderOptions({\n      provider: 'openai',\n      providerOptions,\n      schema: openAIProviderOptionsSchema,\n    });\n\n    // Create form data with base fields\n    const formData = new FormData();\n    const blob =\n      audio instanceof Uint8Array\n        ? new Blob([audio])\n        : new Blob([convertBase64ToUint8Array(audio)]);\n\n    formData.append('model', this.modelId);\n    formData.append('file', new File([blob], 'audio', { type: mediaType }));\n\n    // Add provider-specific options\n    if (openAIOptions) {\n      const transcriptionModelOptions: OpenAITranscriptionModelOptions = {\n        include: openAIOptions.include ?? undefined,\n        language: openAIOptions.language ?? undefined,\n        prompt: openAIOptions.prompt ?? undefined,\n        temperature: openAIOptions.temperature ?? undefined,\n        timestamp_granularities:\n          openAIOptions.timestampGranularities ?? undefined,\n      };\n\n      for (const key in transcriptionModelOptions) {\n        const value =\n          transcriptionModelOptions[\n            key as keyof OpenAITranscriptionModelOptions\n          ];\n        if (value !== undefined) {\n          formData.append(key, String(value));\n        }\n      }\n    }\n\n    return {\n      formData,\n      warnings,\n    };\n  }\n\n  async doGenerate(\n    options: OpenAITranscriptionCallOptions,\n  ): Promise<Awaited<ReturnType<TranscriptionModelV1['doGenerate']>>> {\n    const currentDate = this.config._internal?.currentDate?.() ?? new Date();\n    const { formData, warnings } = this.getArgs(options);\n\n    const {\n      value: response,\n      responseHeaders,\n      rawValue: rawResponse,\n    } = await postFormDataToApi({\n      url: this.config.url({\n        path: '/audio/transcriptions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      formData,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        openaiTranscriptionResponseSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const language =\n      response.language != null && response.language in languageMap\n        ? languageMap[response.language as keyof typeof languageMap]\n        : undefined;\n\n    return {\n      text: response.text,\n      segments:\n        response.words?.map(word => ({\n          text: word.word,\n          startSecond: word.start,\n          endSecond: word.end,\n        })) ?? [],\n      language,\n      durationInSeconds: response.duration ?? undefined,\n      warnings,\n      response: {\n        timestamp: currentDate,\n        modelId: this.modelId,\n        headers: responseHeaders,\n        body: rawResponse,\n      },\n    };\n  }\n}\n\nconst openaiTranscriptionResponseSchema = z.object({\n  text: z.string(),\n  language: z.string().nullish(),\n  duration: z.number().nullish(),\n  words: z\n    .array(\n      z.object({\n        word: z.string(),\n        start: z.number(),\n        end: z.number(),\n      }),\n    )\n    .nullish(),\n});\n", "import {\n  APICallError,\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  LanguageModelV1FinishReason,\n  LanguageModelV1StreamPart,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonResponseHandler,\n  generateId,\n  parseProviderOptions,\n  ParseResult,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { OpenAIConfig } from '../openai-config';\nimport { openaiFailedResponseHandler } from '../openai-error';\nimport { convertToOpenAIResponsesMessages } from './convert-to-openai-responses-messages';\nimport { mapOpenAIResponseFinishReason } from './map-openai-responses-finish-reason';\nimport { prepareResponsesTools } from './openai-responses-prepare-tools';\nimport { OpenAIResponsesModelId } from './openai-responses-settings';\n\nexport class OpenAIResponsesLanguageModel implements LanguageModelV1 {\n  readonly specificationVersion = 'v1';\n  readonly defaultObjectGenerationMode = 'json';\n  readonly supportsStructuredOutputs = true;\n\n  readonly modelId: OpenAIResponsesModelId;\n\n  private readonly config: OpenAIConfig;\n\n  constructor(modelId: OpenAIResponsesModelId, config: OpenAIConfig) {\n    this.modelId = modelId;\n    this.config = config;\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  private getArgs({\n    mode,\n    maxTokens,\n    temperature,\n    stopSequences,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    seed,\n    prompt,\n    providerMetadata,\n    responseFormat,\n  }: Parameters<LanguageModelV1['doGenerate']>[0]) {\n    const warnings: LanguageModelV1CallWarning[] = [];\n    const modelConfig = getResponsesModelConfig(this.modelId);\n    const type = mode.type;\n\n    if (topK != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'topK',\n      });\n    }\n\n    if (seed != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'seed',\n      });\n    }\n\n    if (presencePenalty != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'presencePenalty',\n      });\n    }\n\n    if (frequencyPenalty != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'frequencyPenalty',\n      });\n    }\n\n    if (stopSequences != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'stopSequences',\n      });\n    }\n\n    const { messages, warnings: messageWarnings } =\n      convertToOpenAIResponsesMessages({\n        prompt,\n        systemMessageMode: modelConfig.systemMessageMode,\n      });\n\n    warnings.push(...messageWarnings);\n\n    const openaiOptions = parseProviderOptions({\n      provider: 'openai',\n      providerOptions: providerMetadata,\n      schema: openaiResponsesProviderOptionsSchema,\n    });\n\n    const isStrict = openaiOptions?.strictSchemas ?? true;\n\n    const baseArgs = {\n      model: this.modelId,\n      input: messages,\n      temperature,\n      top_p: topP,\n      max_output_tokens: maxTokens,\n\n      ...(responseFormat?.type === 'json' && {\n        text: {\n          format:\n            responseFormat.schema != null\n              ? {\n                  type: 'json_schema',\n                  strict: isStrict,\n                  name: responseFormat.name ?? 'response',\n                  description: responseFormat.description,\n                  schema: responseFormat.schema,\n                }\n              : { type: 'json_object' },\n        },\n      }),\n\n      // provider options:\n      metadata: openaiOptions?.metadata,\n      parallel_tool_calls: openaiOptions?.parallelToolCalls,\n      previous_response_id: openaiOptions?.previousResponseId,\n      store: openaiOptions?.store,\n      user: openaiOptions?.user,\n      instructions: openaiOptions?.instructions,\n\n      // model-specific settings:\n      ...(modelConfig.isReasoningModel &&\n        (openaiOptions?.reasoningEffort != null ||\n          openaiOptions?.reasoningSummary != null) && {\n          reasoning: {\n            ...(openaiOptions?.reasoningEffort != null && {\n              effort: openaiOptions.reasoningEffort,\n            }),\n            ...(openaiOptions?.reasoningSummary != null && {\n              summary: openaiOptions.reasoningSummary,\n            }),\n          },\n        }),\n      ...(modelConfig.requiredAutoTruncation && {\n        truncation: 'auto',\n      }),\n    };\n\n    if (modelConfig.isReasoningModel) {\n      // remove unsupported settings for reasoning models\n      // see https://platform.openai.com/docs/guides/reasoning#limitations\n      if (baseArgs.temperature != null) {\n        baseArgs.temperature = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'temperature',\n          details: 'temperature is not supported for reasoning models',\n        });\n      }\n\n      if (baseArgs.top_p != null) {\n        baseArgs.top_p = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'topP',\n          details: 'topP is not supported for reasoning models',\n        });\n      }\n    }\n\n    switch (type) {\n      case 'regular': {\n        const { tools, tool_choice, toolWarnings } = prepareResponsesTools({\n          mode,\n          strict: isStrict, // TODO support provider options on tools\n        });\n\n        return {\n          args: {\n            ...baseArgs,\n            tools,\n            tool_choice,\n          },\n          warnings: [...warnings, ...toolWarnings],\n        };\n      }\n\n      case 'object-json': {\n        return {\n          args: {\n            ...baseArgs,\n            text: {\n              format:\n                mode.schema != null\n                  ? {\n                      type: 'json_schema',\n                      strict: isStrict,\n                      name: mode.name ?? 'response',\n                      description: mode.description,\n                      schema: mode.schema,\n                    }\n                  : { type: 'json_object' },\n            },\n          },\n          warnings,\n        };\n      }\n\n      case 'object-tool': {\n        return {\n          args: {\n            ...baseArgs,\n            tool_choice: { type: 'function', name: mode.tool.name },\n            tools: [\n              {\n                type: 'function',\n                name: mode.tool.name,\n                description: mode.tool.description,\n                parameters: mode.tool.parameters,\n                strict: isStrict,\n              },\n            ],\n          },\n          warnings,\n        };\n      }\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n    const { args: body, warnings } = this.getArgs(options);\n    const url = this.config.url({\n      path: '/responses',\n      modelId: this.modelId,\n    });\n\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse,\n    } = await postJsonToApi({\n      url,\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        z.object({\n          id: z.string(),\n          created_at: z.number(),\n          error: z\n            .object({\n              message: z.string(),\n              code: z.string(),\n            })\n            .nullish(),\n          model: z.string(),\n          output: z.array(\n            z.discriminatedUnion('type', [\n              z.object({\n                type: z.literal('message'),\n                role: z.literal('assistant'),\n                content: z.array(\n                  z.object({\n                    type: z.literal('output_text'),\n                    text: z.string(),\n                    annotations: z.array(\n                      z.object({\n                        type: z.literal('url_citation'),\n                        start_index: z.number(),\n                        end_index: z.number(),\n                        url: z.string(),\n                        title: z.string(),\n                      }),\n                    ),\n                  }),\n                ),\n              }),\n              z.object({\n                type: z.literal('function_call'),\n                call_id: z.string(),\n                name: z.string(),\n                arguments: z.string(),\n              }),\n              z.object({\n                type: z.literal('web_search_call'),\n              }),\n              z.object({\n                type: z.literal('computer_call'),\n              }),\n              z.object({\n                type: z.literal('reasoning'),\n                summary: z.array(\n                  z.object({\n                    type: z.literal('summary_text'),\n                    text: z.string(),\n                  }),\n                ),\n              }),\n            ]),\n          ),\n          incomplete_details: z.object({ reason: z.string() }).nullable(),\n          usage: usageSchema,\n        }),\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    if (response.error) {\n      throw new APICallError({\n        message: response.error.message,\n        url,\n        requestBodyValues: body,\n        statusCode: 400,\n        responseHeaders,\n        responseBody: rawResponse as string,\n        isRetryable: false,\n      });\n    }\n\n    const outputTextElements = response.output\n      .filter(output => output.type === 'message')\n      .flatMap(output => output.content)\n      .filter(content => content.type === 'output_text');\n\n    const toolCalls = response.output\n      .filter(output => output.type === 'function_call')\n      .map(output => ({\n        toolCallType: 'function' as const,\n        toolCallId: output.call_id,\n        toolName: output.name,\n        args: output.arguments,\n      }));\n\n    const reasoningSummary =\n      response.output.find(item => item.type === 'reasoning')?.summary ?? null;\n\n    return {\n      text: outputTextElements.map(content => content.text).join('\\n'),\n      sources: outputTextElements.flatMap(content =>\n        content.annotations.map(annotation => ({\n          sourceType: 'url',\n          id: this.config.generateId?.() ?? generateId(),\n          url: annotation.url,\n          title: annotation.title,\n        })),\n      ),\n      finishReason: mapOpenAIResponseFinishReason({\n        finishReason: response.incomplete_details?.reason,\n        hasToolCalls: toolCalls.length > 0,\n      }),\n      toolCalls: toolCalls.length > 0 ? toolCalls : undefined,\n      reasoning: reasoningSummary\n        ? reasoningSummary.map(summary => ({\n            type: 'text' as const,\n            text: summary.text,\n          }))\n        : undefined,\n      usage: {\n        promptTokens: response.usage.input_tokens,\n        completionTokens: response.usage.output_tokens,\n      },\n      rawCall: {\n        rawPrompt: undefined,\n        rawSettings: {},\n      },\n      rawResponse: {\n        headers: responseHeaders,\n        body: rawResponse,\n      },\n      request: {\n        body: JSON.stringify(body),\n      },\n      response: {\n        id: response.id,\n        timestamp: new Date(response.created_at * 1000),\n        modelId: response.model,\n      },\n      providerMetadata: {\n        openai: {\n          responseId: response.id,\n          cachedPromptTokens:\n            response.usage.input_tokens_details?.cached_tokens ?? null,\n          reasoningTokens:\n            response.usage.output_tokens_details?.reasoning_tokens ?? null,\n        },\n      },\n      warnings,\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV1['doStream']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n    const { args: body, warnings } = this.getArgs(options);\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: this.config.url({\n        path: '/responses',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: {\n        ...body,\n        stream: true,\n      },\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        openaiResponsesChunkSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const self = this;\n\n    let finishReason: LanguageModelV1FinishReason = 'unknown';\n    let promptTokens = NaN;\n    let completionTokens = NaN;\n    let cachedPromptTokens: number | null = null;\n    let reasoningTokens: number | null = null;\n    let responseId: string | null = null;\n    const ongoingToolCalls: Record<\n      number,\n      { toolName: string; toolCallId: string } | undefined\n    > = {};\n    let hasToolCalls = false;\n\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<z.infer<typeof openaiResponsesChunkSchema>>,\n          LanguageModelV1StreamPart\n        >({\n          transform(chunk, controller) {\n            // handle failed chunk parsing / validation:\n            if (!chunk.success) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: chunk.error });\n              return;\n            }\n\n            const value = chunk.value;\n\n            if (isResponseOutputItemAddedChunk(value)) {\n              if (value.item.type === 'function_call') {\n                ongoingToolCalls[value.output_index] = {\n                  toolName: value.item.name,\n                  toolCallId: value.item.call_id,\n                };\n\n                controller.enqueue({\n                  type: 'tool-call-delta',\n                  toolCallType: 'function',\n                  toolCallId: value.item.call_id,\n                  toolName: value.item.name,\n                  argsTextDelta: value.item.arguments,\n                });\n              }\n            } else if (isResponseFunctionCallArgumentsDeltaChunk(value)) {\n              const toolCall = ongoingToolCalls[value.output_index];\n\n              if (toolCall != null) {\n                controller.enqueue({\n                  type: 'tool-call-delta',\n                  toolCallType: 'function',\n                  toolCallId: toolCall.toolCallId,\n                  toolName: toolCall.toolName,\n                  argsTextDelta: value.delta,\n                });\n              }\n            } else if (isResponseCreatedChunk(value)) {\n              responseId = value.response.id;\n              controller.enqueue({\n                type: 'response-metadata',\n                id: value.response.id,\n                timestamp: new Date(value.response.created_at * 1000),\n                modelId: value.response.model,\n              });\n            } else if (isTextDeltaChunk(value)) {\n              controller.enqueue({\n                type: 'text-delta',\n                textDelta: value.delta,\n              });\n            } else if (isResponseReasoningSummaryTextDeltaChunk(value)) {\n              controller.enqueue({\n                type: 'reasoning',\n                textDelta: value.delta,\n              });\n            } else if (\n              isResponseOutputItemDoneChunk(value) &&\n              value.item.type === 'function_call'\n            ) {\n              ongoingToolCalls[value.output_index] = undefined;\n              hasToolCalls = true;\n              controller.enqueue({\n                type: 'tool-call',\n                toolCallType: 'function',\n                toolCallId: value.item.call_id,\n                toolName: value.item.name,\n                args: value.item.arguments,\n              });\n            } else if (isResponseFinishedChunk(value)) {\n              finishReason = mapOpenAIResponseFinishReason({\n                finishReason: value.response.incomplete_details?.reason,\n                hasToolCalls,\n              });\n              promptTokens = value.response.usage.input_tokens;\n              completionTokens = value.response.usage.output_tokens;\n              cachedPromptTokens =\n                value.response.usage.input_tokens_details?.cached_tokens ??\n                cachedPromptTokens;\n              reasoningTokens =\n                value.response.usage.output_tokens_details?.reasoning_tokens ??\n                reasoningTokens;\n            } else if (isResponseAnnotationAddedChunk(value)) {\n              controller.enqueue({\n                type: 'source',\n                source: {\n                  sourceType: 'url',\n                  id: self.config.generateId?.() ?? generateId(),\n                  url: value.annotation.url,\n                  title: value.annotation.title,\n                },\n              });\n            } else if (isErrorChunk(value)) {\n              controller.enqueue({ type: 'error', error: value });\n            }\n          },\n\n          flush(controller) {\n            controller.enqueue({\n              type: 'finish',\n              finishReason,\n              usage: { promptTokens, completionTokens },\n              ...((cachedPromptTokens != null || reasoningTokens != null) && {\n                providerMetadata: {\n                  openai: {\n                    responseId,\n                    cachedPromptTokens,\n                    reasoningTokens,\n                  },\n                },\n              }),\n            });\n          },\n        }),\n      ),\n      rawCall: {\n        rawPrompt: undefined,\n        rawSettings: {},\n      },\n      rawResponse: { headers: responseHeaders },\n      request: { body: JSON.stringify(body) },\n      warnings,\n    };\n  }\n}\n\nconst usageSchema = z.object({\n  input_tokens: z.number(),\n  input_tokens_details: z\n    .object({ cached_tokens: z.number().nullish() })\n    .nullish(),\n  output_tokens: z.number(),\n  output_tokens_details: z\n    .object({ reasoning_tokens: z.number().nullish() })\n    .nullish(),\n});\n\nconst textDeltaChunkSchema = z.object({\n  type: z.literal('response.output_text.delta'),\n  delta: z.string(),\n});\n\nconst responseFinishedChunkSchema = z.object({\n  type: z.enum(['response.completed', 'response.incomplete']),\n  response: z.object({\n    incomplete_details: z.object({ reason: z.string() }).nullish(),\n    usage: usageSchema,\n  }),\n});\n\nconst responseCreatedChunkSchema = z.object({\n  type: z.literal('response.created'),\n  response: z.object({\n    id: z.string(),\n    created_at: z.number(),\n    model: z.string(),\n  }),\n});\n\nconst responseOutputItemDoneSchema = z.object({\n  type: z.literal('response.output_item.done'),\n  output_index: z.number(),\n  item: z.discriminatedUnion('type', [\n    z.object({\n      type: z.literal('message'),\n    }),\n    z.object({\n      type: z.literal('function_call'),\n      id: z.string(),\n      call_id: z.string(),\n      name: z.string(),\n      arguments: z.string(),\n      status: z.literal('completed'),\n    }),\n  ]),\n});\n\nconst responseFunctionCallArgumentsDeltaSchema = z.object({\n  type: z.literal('response.function_call_arguments.delta'),\n  item_id: z.string(),\n  output_index: z.number(),\n  delta: z.string(),\n});\n\nconst responseOutputItemAddedSchema = z.object({\n  type: z.literal('response.output_item.added'),\n  output_index: z.number(),\n  item: z.discriminatedUnion('type', [\n    z.object({\n      type: z.literal('message'),\n    }),\n    z.object({\n      type: z.literal('function_call'),\n      id: z.string(),\n      call_id: z.string(),\n      name: z.string(),\n      arguments: z.string(),\n    }),\n  ]),\n});\n\nconst responseAnnotationAddedSchema = z.object({\n  type: z.literal('response.output_text.annotation.added'),\n  annotation: z.object({\n    type: z.literal('url_citation'),\n    url: z.string(),\n    title: z.string(),\n  }),\n});\n\nconst responseReasoningSummaryTextDeltaSchema = z.object({\n  type: z.literal('response.reasoning_summary_text.delta'),\n  item_id: z.string(),\n  output_index: z.number(),\n  summary_index: z.number(),\n  delta: z.string(),\n});\n\nconst errorChunkSchema = z.object({\n  type: z.literal('error'),\n  code: z.string(),\n  message: z.string(),\n  param: z.string().nullish(),\n  sequence_number: z.number(),\n});\n\nconst openaiResponsesChunkSchema = z.union([\n  textDeltaChunkSchema,\n  responseFinishedChunkSchema,\n  responseCreatedChunkSchema,\n  responseOutputItemDoneSchema,\n  responseFunctionCallArgumentsDeltaSchema,\n  responseOutputItemAddedSchema,\n  responseAnnotationAddedSchema,\n  responseReasoningSummaryTextDeltaSchema,\n  errorChunkSchema,\n  z.object({ type: z.string() }).passthrough(), // fallback for unknown chunks\n]);\n\nfunction isTextDeltaChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof textDeltaChunkSchema> {\n  return chunk.type === 'response.output_text.delta';\n}\n\nfunction isResponseOutputItemDoneChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseOutputItemDoneSchema> {\n  return chunk.type === 'response.output_item.done';\n}\n\nfunction isResponseFinishedChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseFinishedChunkSchema> {\n  return (\n    chunk.type === 'response.completed' || chunk.type === 'response.incomplete'\n  );\n}\n\nfunction isResponseCreatedChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseCreatedChunkSchema> {\n  return chunk.type === 'response.created';\n}\n\nfunction isResponseFunctionCallArgumentsDeltaChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseFunctionCallArgumentsDeltaSchema> {\n  return chunk.type === 'response.function_call_arguments.delta';\n}\n\nfunction isResponseOutputItemAddedChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseOutputItemAddedSchema> {\n  return chunk.type === 'response.output_item.added';\n}\n\nfunction isResponseAnnotationAddedChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseAnnotationAddedSchema> {\n  return chunk.type === 'response.output_text.annotation.added';\n}\n\nfunction isResponseReasoningSummaryTextDeltaChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseReasoningSummaryTextDeltaSchema> {\n  return chunk.type === 'response.reasoning_summary_text.delta';\n}\n\nfunction isErrorChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof errorChunkSchema> {\n  return chunk.type === 'error';\n}\n\ntype ResponsesModelConfig = {\n  isReasoningModel: boolean;\n  systemMessageMode: 'remove' | 'system' | 'developer';\n  requiredAutoTruncation: boolean;\n};\n\nfunction getResponsesModelConfig(modelId: string): ResponsesModelConfig {\n  // o series reasoning models:\n  if (modelId.startsWith('o') || modelId.startsWith('gpt-5')) {\n    if (modelId.startsWith('o1-mini') || modelId.startsWith('o1-preview')) {\n      return {\n        isReasoningModel: true,\n        systemMessageMode: 'remove',\n        requiredAutoTruncation: false,\n      };\n    }\n\n    return {\n      isReasoningModel: true,\n      systemMessageMode: 'developer',\n      requiredAutoTruncation: false,\n    };\n  }\n\n  // gpt models:\n  return {\n    isReasoningModel: false,\n    systemMessageMode: 'system',\n    requiredAutoTruncation: false,\n  };\n}\n\nconst openaiResponsesProviderOptionsSchema = z.object({\n  metadata: z.any().nullish(),\n  parallelToolCalls: z.boolean().nullish(),\n  previousResponseId: z.string().nullish(),\n  store: z.boolean().nullish(),\n  user: z.string().nullish(),\n  reasoningEffort: z.string().nullish(),\n  strictSchemas: z.boolean().nullish(),\n  instructions: z.string().nullish(),\n  reasoningSummary: z.string().nullish(),\n});\n\nexport type OpenAIResponsesProviderOptions = z.infer<\n  typeof openaiResponsesProviderOptionsSchema\n>;\n", "import {\n  LanguageModelV1CallWarning,\n  LanguageModelV1Prompt,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { convertUint8ArrayToBase64 } from '@ai-sdk/provider-utils';\nimport { OpenAIResponsesPrompt } from './openai-responses-api-types';\n\nexport function convertToOpenAIResponsesMessages({\n  prompt,\n  systemMessageMode,\n}: {\n  prompt: LanguageModelV1Prompt;\n  systemMessageMode: 'system' | 'developer' | 'remove';\n}): {\n  messages: OpenAIResponsesPrompt;\n  warnings: Array<LanguageModelV1CallWarning>;\n} {\n  const messages: OpenAIResponsesPrompt = [];\n  const warnings: Array<LanguageModelV1CallWarning> = [];\n\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case 'system': {\n        switch (systemMessageMode) {\n          case 'system': {\n            messages.push({ role: 'system', content });\n            break;\n          }\n          case 'developer': {\n            messages.push({ role: 'developer', content });\n            break;\n          }\n          case 'remove': {\n            warnings.push({\n              type: 'other',\n              message: 'system messages are removed for this model',\n            });\n            break;\n          }\n          default: {\n            const _exhaustiveCheck: never = systemMessageMode;\n            throw new Error(\n              `Unsupported system message mode: ${_exhaustiveCheck}`,\n            );\n          }\n        }\n        break;\n      }\n\n      case 'user': {\n        messages.push({\n          role: 'user',\n          content: content.map((part, index) => {\n            switch (part.type) {\n              case 'text': {\n                return { type: 'input_text', text: part.text };\n              }\n              case 'image': {\n                return {\n                  type: 'input_image',\n                  image_url:\n                    part.image instanceof URL\n                      ? part.image.toString()\n                      : `data:${\n                          part.mimeType ?? 'image/jpeg'\n                        };base64,${convertUint8ArrayToBase64(part.image)}`,\n\n                  // OpenAI specific extension: image detail\n                  detail: part.providerMetadata?.openai?.imageDetail,\n                };\n              }\n              case 'file': {\n                if (part.data instanceof URL) {\n                  // The AI SDK automatically downloads files for user file parts with URLs\n                  throw new UnsupportedFunctionalityError({\n                    functionality: 'File URLs in user messages',\n                  });\n                }\n\n                switch (part.mimeType) {\n                  case 'application/pdf': {\n                    return {\n                      type: 'input_file',\n                      filename: part.filename ?? `part-${index}.pdf`,\n                      file_data: `data:application/pdf;base64,${part.data}`,\n                    };\n                  }\n                  default: {\n                    throw new UnsupportedFunctionalityError({\n                      functionality:\n                        'Only PDF files are supported in user messages',\n                    });\n                  }\n                }\n              }\n            }\n          }),\n        });\n\n        break;\n      }\n\n      case 'assistant': {\n        for (const part of content) {\n          switch (part.type) {\n            case 'text': {\n              messages.push({\n                role: 'assistant',\n                content: [{ type: 'output_text', text: part.text }],\n              });\n              break;\n            }\n            case 'tool-call': {\n              messages.push({\n                type: 'function_call',\n                call_id: part.toolCallId,\n                name: part.toolName,\n                arguments: JSON.stringify(part.args),\n              });\n              break;\n            }\n          }\n        }\n\n        break;\n      }\n\n      case 'tool': {\n        for (const part of content) {\n          messages.push({\n            type: 'function_call_output',\n            call_id: part.toolCallId,\n            output: JSON.stringify(part.result),\n          });\n        }\n\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return { messages, warnings };\n}\n", "import { LanguageModelV1FinishReason } from '@ai-sdk/provider';\n\nexport function mapOpenAIResponseFinishReason({\n  finishReason,\n  hasToolCalls,\n}: {\n  finishReason: string | null | undefined;\n  hasToolCalls: boolean;\n}): LanguageModelV1FinishReason {\n  switch (finishReason) {\n    case undefined:\n    case null:\n      return hasToolCalls ? 'tool-calls' : 'stop';\n    case 'max_output_tokens':\n      return 'length';\n    case 'content_filter':\n      return 'content-filter';\n    default:\n      return hasToolCalls ? 'tool-calls' : 'unknown';\n  }\n}\n", "import {\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { OpenAIResponsesTool } from './openai-responses-api-types';\n\nexport function prepareResponsesTools({\n  mode,\n  strict,\n}: {\n  mode: Parameters<LanguageModelV1['doGenerate']>[0]['mode'] & {\n    type: 'regular';\n  };\n  strict: boolean;\n}): {\n  tools?: Array<OpenAIResponsesTool>;\n  tool_choice?:\n    | 'auto'\n    | 'none'\n    | 'required'\n    | { type: 'web_search_preview' }\n    | { type: 'function'; name: string };\n  toolWarnings: LanguageModelV1CallWarning[];\n} {\n  // when the tools array is empty, change it to undefined to prevent errors:\n  const tools = mode.tools?.length ? mode.tools : undefined;\n\n  const toolWarnings: LanguageModelV1CallWarning[] = [];\n\n  if (tools == null) {\n    return { tools: undefined, tool_choice: undefined, toolWarnings };\n  }\n\n  const toolChoice = mode.toolChoice;\n\n  const openaiTools: Array<OpenAIResponsesTool> = [];\n\n  for (const tool of tools) {\n    switch (tool.type) {\n      case 'function':\n        openaiTools.push({\n          type: 'function',\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.parameters,\n          strict: strict ? true : undefined,\n        });\n        break;\n      case 'provider-defined':\n        switch (tool.id) {\n          case 'openai.web_search_preview':\n            openaiTools.push({\n              type: 'web_search_preview',\n              search_context_size: tool.args.searchContextSize as\n                | 'low'\n                | 'medium'\n                | 'high',\n              user_location: tool.args.userLocation as {\n                type: 'approximate';\n                city: string;\n                region: string;\n              },\n            });\n            break;\n          default:\n            toolWarnings.push({ type: 'unsupported-tool', tool });\n            break;\n        }\n        break;\n      default:\n        toolWarnings.push({ type: 'unsupported-tool', tool });\n        break;\n    }\n  }\n\n  if (toolChoice == null) {\n    return { tools: openaiTools, tool_choice: undefined, toolWarnings };\n  }\n\n  const type = toolChoice.type;\n\n  switch (type) {\n    case 'auto':\n    case 'none':\n    case 'required':\n      return { tools: openaiTools, tool_choice: type, toolWarnings };\n    case 'tool': {\n      if (toolChoice.toolName === 'web_search_preview') {\n        return {\n          tools: openaiTools,\n          tool_choice: {\n            type: 'web_search_preview',\n          },\n          toolWarnings,\n        };\n      }\n      return {\n        tools: openaiTools,\n        tool_choice: {\n          type: 'function',\n          name: toolChoice.toolName,\n        },\n        toolWarnings,\n      };\n    }\n    default: {\n      const _exhaustiveCheck: never = type;\n      throw new UnsupportedFunctionalityError({\n        functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`,\n      });\n    }\n  }\n}\n", "import { z } from 'zod';\n\nconst WebSearchPreviewParameters = z.object({});\n\nfunction webSearchPreviewTool({\n  searchContextSize,\n  userLocation,\n}: {\n  searchContextSize?: 'low' | 'medium' | 'high';\n  userLocation?: {\n    type?: 'approximate';\n    city?: string;\n    region?: string;\n    country?: string;\n    timezone?: string;\n  };\n} = {}): {\n  type: 'provider-defined';\n  id: 'openai.web_search_preview';\n  args: {};\n  parameters: typeof WebSearchPreviewParameters;\n} {\n  return {\n    type: 'provider-defined',\n    id: 'openai.web_search_preview',\n    args: {\n      searchContextSize,\n      userLocation,\n    },\n    parameters: WebSearchPreviewParameters,\n  };\n}\n\nexport const openaiTools = {\n  webSearchPreview: webSearchPreviewTool,\n};\n", "import { SpeechModelV1, SpeechModelV1CallWarning } from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createBinaryResponseHandler,\n  parseProviderOptions,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { OpenAIConfig } from './openai-config';\nimport { openaiFailedResponseHandler } from './openai-error';\nimport { OpenAISpeechModelId } from './openai-speech-settings';\nimport { OpenAISpeechAPITypes } from './openai-api-types';\n\n// https://platform.openai.com/docs/api-reference/audio/createSpeech\nconst OpenAIProviderOptionsSchema = z.object({\n  instructions: z.string().nullish(),\n  speed: z.number().min(0.25).max(4.0).default(1.0).nullish(),\n});\n\nexport type OpenAISpeechCallOptions = z.infer<\n  typeof OpenAIProviderOptionsSchema\n>;\n\ninterface OpenAISpeechModelConfig extends OpenAIConfig {\n  _internal?: {\n    currentDate?: () => Date;\n  };\n}\n\nexport class OpenAISpeechModel implements SpeechModelV1 {\n  readonly specificationVersion = 'v1';\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  constructor(\n    readonly modelId: OpenAISpeechModelId,\n    private readonly config: OpenAISpeechModelConfig,\n  ) {}\n\n  private getArgs({\n    text,\n    voice = 'alloy',\n    outputFormat = 'mp3',\n    speed,\n    instructions,\n    providerOptions,\n  }: Parameters<SpeechModelV1['doGenerate']>[0]) {\n    const warnings: SpeechModelV1CallWarning[] = [];\n\n    // Parse provider options\n    const openAIOptions = parseProviderOptions({\n      provider: 'openai',\n      providerOptions,\n      schema: OpenAIProviderOptionsSchema,\n    });\n\n    // Create request body\n    const requestBody: Record<string, unknown> = {\n      model: this.modelId,\n      input: text,\n      voice,\n      response_format: 'mp3',\n      speed,\n      instructions,\n    };\n\n    if (outputFormat) {\n      if (['mp3', 'opus', 'aac', 'flac', 'wav', 'pcm'].includes(outputFormat)) {\n        requestBody.response_format = outputFormat;\n      } else {\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'outputFormat',\n          details: `Unsupported output format: ${outputFormat}. Using mp3 instead.`,\n        });\n      }\n    }\n\n    // Add provider-specific options\n    if (openAIOptions) {\n      const speechModelOptions: OpenAISpeechAPITypes = {};\n\n      for (const key in speechModelOptions) {\n        const value = speechModelOptions[key as keyof OpenAISpeechAPITypes];\n        if (value !== undefined) {\n          requestBody[key] = value;\n        }\n      }\n    }\n\n    return {\n      requestBody,\n      warnings,\n    };\n  }\n\n  async doGenerate(\n    options: Parameters<SpeechModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<SpeechModelV1['doGenerate']>>> {\n    const currentDate = this.config._internal?.currentDate?.() ?? new Date();\n    const { requestBody, warnings } = this.getArgs(options);\n\n    const {\n      value: audio,\n      responseHeaders,\n      rawValue: rawResponse,\n    } = await postJsonToApi({\n      url: this.config.url({\n        path: '/audio/speech',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: requestBody,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createBinaryResponseHandler(),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    return {\n      audio,\n      warnings,\n      request: {\n        body: JSON.stringify(requestBody),\n      },\n      response: {\n        timestamp: currentDate,\n        modelId: this.modelId,\n        headers: responseHeaders,\n        body: rawResponse,\n      },\n    };\n  }\n}\n", "import type { Agent } from \"@mastra/core/agent\";\nimport type { AiService } from \"../../domain/infra/aiService\";\n\nexport const createAiService = (\n  keywordAgent: Agent,\n  searchAgent: Agent\n): AiService => ({\n  suggestKeywords: async (title, startAt) => {\n    const result = await keywordAgent.generate([\n      {\n        role: \"user\",\n        content: `\u30BF\u30A4\u30C8\u30EB: ${title}\\n\u65E5\u6642: ${startAt}`,\n      },\n    ]);\n\n    try {\n      // \u30EC\u30B9\u30DD\u30F3\u30B9\u304B\u3089JSON\u914D\u5217\u3092\u62BD\u51FA\n      const text = result.text.trim();\n      const jsonMatch = text.match(/\\[[\\s\\S]*\\]/);\n      if (jsonMatch) {\n        return JSON.parse(jsonMatch[0]);\n      }\n      return JSON.parse(text);\n    } catch {\n      // \u30D1\u30FC\u30B9\u306B\u5931\u6557\u3057\u305F\u5834\u5408\u306F\u7A7A\u914D\u5217\u3092\u8FD4\u3059\n      console.error(\"Failed to parse keywords:\", result.text);\n      return [];\n    }\n  },\n\n  searchWithKeywords: async (title, startAt, keywords) => {\n    const result = await searchAgent.generate([\n      {\n        role: \"user\",\n        content: `\u4EE5\u4E0B\u306E\u4E88\u5B9A\u306B\u3064\u3044\u3066\u3001\u9078\u629E\u3055\u308C\u305F\u30AD\u30FC\u30EF\u30FC\u30C9\u306B\u95A2\u9023\u3059\u308B\u60C5\u5831\u3092\u691C\u7D22\u3057\u3066\u307E\u3068\u3081\u3066\u304F\u3060\u3055\u3044\u3002\n\n\u30BF\u30A4\u30C8\u30EB: ${title}\n\u65E5\u6642: ${startAt}\n\u8ABF\u3079\u305F\u3044\u3053\u3068: ${keywords.join(\", \")}`,\n      },\n    ]);\n\n    return result.text;\n  },\n});\n", "import type { AiService } from \"../../domain/infra/aiService\";\n\nexport const createMockAiService = (): AiService => ({\n  suggestKeywords: async (title, _startAt) => {\n    // \u30E2\u30C3\u30AF\u306E\u9045\u5EF6\u3092\u30B7\u30DF\u30E5\u30EC\u30FC\u30C8\n    await new Promise((resolve) => setTimeout(resolve, 500));\n\n    // \u30BF\u30A4\u30C8\u30EB\u306B\u57FA\u3065\u3044\u3066\u30E2\u30C3\u30AF\u30AD\u30FC\u30EF\u30FC\u30C9\u3092\u751F\u6210\n    const mockKeywords: Record<string, string[]> = {\n      default: [\"\u5929\u6C17\", \"\u30A2\u30AF\u30BB\u30B9\", \"\u5468\u8FBA\u60C5\u5831\", \"\u53E3\u30B3\u30DF\", \"\u55B6\u696D\u6642\u9593\"],\n    };\n\n    // \u30BF\u30A4\u30C8\u30EB\u306B\u7279\u5B9A\u306E\u30AD\u30FC\u30EF\u30FC\u30C9\u304C\u542B\u307E\u308C\u3066\u3044\u308B\u5834\u5408\n    if (title.includes(\"\u30EC\u30B9\u30C8\u30E9\u30F3\") || title.includes(\"\u98DF\u4E8B\")) {\n      return [\"\u30E1\u30CB\u30E5\u30FC\", \"\u4E88\u7D04\u65B9\u6CD5\", \"\u53E3\u30B3\u30DF\", \"\u30A2\u30AF\u30BB\u30B9\", \"\u55B6\u696D\u6642\u9593\"];\n    }\n    if (title.includes(\"\u4F1A\u8B70\") || title.includes(\"\u30DF\u30FC\u30C6\u30A3\u30F3\u30B0\")) {\n      return [\"\u8B70\u984C\", \"\u53C2\u52A0\u8005\", \"\u4E8B\u524D\u6E96\u5099\", \"\u4F1A\u8B70\u5BA4\", \"\u8CC7\u6599\"];\n    }\n    if (title.includes(\"\u65C5\u884C\") || title.includes(\"\u89B3\u5149\")) {\n      return [\"\u89B3\u5149\u30B9\u30DD\u30C3\u30C8\", \"\u5929\u6C17\", \"\u4EA4\u901A\u624B\u6BB5\", \"\u30DB\u30C6\u30EB\", \"\u30B0\u30EB\u30E1\"];\n    }\n\n    return mockKeywords.default;\n  },\n\n  searchWithKeywords: async (title, startAt, keywords) => {\n    // \u30E2\u30C3\u30AF\u306E\u9045\u5EF6\u3092\u30B7\u30DF\u30E5\u30EC\u30FC\u30C8\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n\n    const keywordList = keywords.join(\"\u3001\");\n\n    return `## ${title} \u306B\u95A2\u3059\u308B\u60C5\u5831\n\n### \u691C\u7D22\u30AD\u30FC\u30EF\u30FC\u30C9\n${keywordList}\n\n### \u6982\u8981\n\u3053\u308C\u306F\u30E2\u30C3\u30AF\u30EC\u30B9\u30DD\u30F3\u30B9\u3067\u3059\u3002\u5B9F\u969B\u306EAI\u691C\u7D22\u7D50\u679C\u306F\u3053\u3053\u306B\u8868\u793A\u3055\u308C\u307E\u3059\u3002\n\n### \u65E5\u6642\u60C5\u5831\n- \u4E88\u5B9A\u65E5\u6642: ${startAt}\n\n### \u95A2\u9023\u60C5\u5831\n${keywords.map((kw) => `- **${kw}**: ${kw}\u306B\u95A2\u3059\u308B\u8A73\u7D30\u60C5\u5831\u304C\u3053\u3053\u306B\u8868\u793A\u3055\u308C\u307E\u3059\u3002`).join(\"\\n\")}\n\n---\n*\u3053\u306E\u30EC\u30B9\u30DD\u30F3\u30B9\u306F\u30E2\u30C3\u30AF\u30C7\u30FC\u30BF\u3067\u3059\u3002\u672C\u756A\u74B0\u5883\u3067\u306F\u5B9F\u969B\u306EAI\u691C\u7D22\u7D50\u679C\u304C\u8868\u793A\u3055\u308C\u307E\u3059\u3002*`;\n  },\n});\n", "import type { AiService } from \"../../../domain/infra/aiService\";\nimport { type Result, ok, err } from \"../../../shared/result\";\nimport { createAiError } from \"../../../shared/errors\";\n\nexport const createSuggestKeywordsUseCase = (aiService: AiService) => {\n  return async (title: string, startAt: string): Promise<Result<string[]>> => {\n    try {\n      const keywords = await aiService.suggestKeywords(title, startAt);\n      return ok(keywords);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : \"Unknown error\";\n      return err(createAiError(message));\n    }\n  };\n};\n\nexport type SuggestKeywordsUseCase = ReturnType<typeof createSuggestKeywordsUseCase>;\n", "import type { AiService } from \"../../../domain/infra/aiService\";\nimport type { SupplementRepo } from \"../../../domain/infra/supplementRepo\";\nimport type { ScheduleRepo } from \"../../../domain/infra/scheduleRepo\";\nimport { createSupplement, type Supplement } from \"../../../domain/model/supplement\";\nimport { type Result, ok, err } from \"../../../shared/result\";\nimport { createAiError, createNotFoundError } from \"../../../shared/errors\";\n\nexport const createSearchWithKeywordsUseCase = (\n  aiService: AiService,\n  supplementRepo: SupplementRepo,\n  scheduleRepo: ScheduleRepo\n) => {\n  return async (\n    scheduleId: string,\n    title: string,\n    startAt: string,\n    keywords: string[]\n  ): Promise<Result<Supplement>> => {\n    try {\n      // \u30B9\u30B1\u30B8\u30E5\u30FC\u30EB\u306E\u5B58\u5728\u78BA\u8A8D\n      const schedule = await scheduleRepo.findById(scheduleId);\n      if (!schedule) {\n        return err(createNotFoundError(\"\u30B9\u30B1\u30B8\u30E5\u30FC\u30EB\"));\n      }\n\n      // AI\u691C\u7D22\u5B9F\u884C\n      const aiResult = await aiService.searchWithKeywords(title, startAt, keywords);\n\n      // \u65E2\u5B58\u306E\u88DC\u8DB3\u60C5\u5831\u304C\u3042\u308C\u3070\u66F4\u65B0\u3001\u306A\u3051\u308C\u3070\u65B0\u898F\u4F5C\u6210\n      const existing = await supplementRepo.findByScheduleId(scheduleId);\n      if (existing) {\n        const updated: Supplement = {\n          ...existing,\n          keywords,\n          aiResult,\n          updatedAt: new Date().toISOString(),\n        };\n        await supplementRepo.update(updated);\n        return ok(updated);\n      }\n\n      const supplement = createSupplement({\n        scheduleId,\n        keywords,\n        aiResult,\n      });\n      await supplementRepo.save(supplement);\n      return ok(supplement);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : \"Unknown error\";\n      return err(createAiError(message));\n    }\n  };\n};\n\nexport type SearchWithKeywordsUseCase = ReturnType<typeof createSearchWithKeywordsUseCase>;\n", "import type { Context } from \"hono\";\nimport { suggestKeywordsInputSchema } from \"@ai-scheduler/shared\";\nimport type { SuggestKeywordsUseCase } from \"../usecase/suggestKeywords\";\nimport { createValidationError } from \"../../../shared/errors\";\nimport { getStatusCode } from \"../../../shared/http\";\n\nexport const createSuggestKeywordsHandler = (\n  suggestKeywords: SuggestKeywordsUseCase\n) => {\n  return async (c: Context) => {\n    const body = await c.req.json();\n\n    const parsed = suggestKeywordsInputSchema.safeParse(body);\n    if (!parsed.success) {\n      return c.json(createValidationError(parsed.error), 400);\n    }\n\n    const result = await suggestKeywords(parsed.data.title, parsed.data.startAt);\n\n    if (!result.ok) {\n      return c.json(result.error, getStatusCode(result.error.code));\n    }\n\n    return c.json({ keywords: result.value });\n  };\n};\n", "import type { Context } from \"hono\";\nimport { searchInputSchema } from \"@ai-scheduler/shared\";\nimport type { SearchWithKeywordsUseCase } from \"../usecase/searchWithKeywords\";\nimport { createValidationError } from \"../../../shared/errors\";\nimport { getStatusCode } from \"../../../shared/http\";\n\nexport const createSearchHandler = (\n  searchWithKeywords: SearchWithKeywordsUseCase\n) => {\n  return async (c: Context) => {\n    const body = await c.req.json();\n\n    const parsed = searchInputSchema.safeParse(body);\n    if (!parsed.success) {\n      return c.json(createValidationError(parsed.error), 400);\n    }\n\n    const { scheduleId, title, startAt, keywords } = parsed.data;\n    const result = await searchWithKeywords(scheduleId, title, startAt, keywords);\n\n    if (!result.ok) {\n      return c.json(result.error, getStatusCode(result.error.code));\n    }\n\n    return c.json({ result: result.value.aiResult });\n  };\n};\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n"],
  "mappings": "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A,cAAc,OAAO,OAAO,OAAO;AAAA,QAClC,cAAc;AAAA,QACd,KAAK;AAAA,QACL,UAAU;AAAA,QACV,WAAW;AAAA,QACX,UAAU;AAAA,MACX,IAAI,EAAE,KAAK,MAAM,EAAE,CAAC;AAAA,MACpB,aAAa;AAAA,MACb,SAAS;AAAA,MACT,OAAO;AAAA,MACP,WAAW;AAAA,MACX,UAAU;AAAA,MACV,UAAU;AAAA,MACV,UAAU;AAAA,MACV,SAAS;AAAA,MACT,YAAY;AAAA,MACZ,SAAS;AAAA,MACT,UAAU;AAAA,MACV,UAAU;AAAA,MACV,SAAS;AAAA,MACT,YAAY;AAAA,MACZ,SAAS;AAAA,MACT,UAAU;AAAA,MACV,eAAe;AAAA,MACf,WAAW;AAAA,MACX,gBAAgB;AAAA,MAChB,YAAY;AAAA,MACZ,gBAAgB;AAAA,MAChB,kBAAkB;AAAA,MAClB,oBAAoB;AAAA,MACpB,qBAAqB;AAAA,MACrB,QAAQ;AAAA,MACR,mBAAmB;AAAA,MACnB,YAAY;AAAA,MACZ,6BAA6B;AAAA,MAC7B,4BAA4B;AAAA,MAC5B,gBAAgB;AAAA,MAChB,cAAc;AAAA,MACd,eAAe;AAAA,MACf,kBAAkB;AAAA,MAClB,WAAW;AAAA,MACX,QAAQ;AAAA,MACR,iBAAiB;AAAA,IAClB;AAzNa;AAAA;AAAA;;;ACHb,IAEM,eACO,kBACE,MAAM,UAAU,UAGzB,cAMJ,OACA,aACA,6BACA,qCACA,qCACA,aACA,mBACA,MACA,MACA,OACA,OACA,QACA,WACA,mBACA,iBACA,UACA,KACA,WACA,QACA,YACA,MACA,aACA,KACA,YACA,UACA,UACA,cACA,UACA,wBACA,iBACAC,SACA,MACA,WACA,eACA,aACA,IACA,KACA,MACA,KACA,MACA,iBACA,qBACA,cACA,SACA,oBACA,gBACA,QACA,eACA,iBACA,sBACA,QACA,OACA,QACA,OACA,kBACA,kBACA,OACA,QACA,SACA,UACA,QACA,YACA,gBACA,YACA,WACAC,SACA,SACA,MACA,UACA,SACA,SACA,SACA,QACA,WACA,QACA,SACA,SACA,QACA,WACA,QACA,YACA,YACA,SACA,cACA,UACA,eACA,WACA,eACA,iBACA,mBACA,oBACA,OACA,kBACA,WACA,4BACA,2BACA,eACA,aACA,cACA,iBACA,UACA,OACA,gBAEI,UA8GC;AAnOP,IAAAC,gBAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAC;AAAA;AACA;AACA,IAAM,gBAAgB,WAAW,SAAS;AACnC,IAAM,mBAAmB,cAAc;AACvC,KAAM,EAAE,MAAM,UAAU,aAAa;AAAA,MAC1C;AAAA,IACF;AACA,IAAM,eAAe,IAAI,QAAa;AAAA,MACpC,KAAK,cAAc;AAAA,MACnB;AAAA,MACA;AAAA,IACF,CAAC;AACM,KAAM;AAAA,MACX;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAAH;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAAC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,QACE;AACJ,IAAM,WAAW;AAAA,MACf;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAAD;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA;AAAA,MAEA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAAC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MAC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",
  "names": ["name", "init_performance", "init_performance", "name", "PerformanceMark", "init_performance", "init_performance", "init_performance", "init_performance", "clear", "count", "countReset", "createTask", "debug", "dir", "dirxml", "error", "group", "groupCollapsed", "groupEnd", "info", "log", "profile", "profileEnd", "table", "time", "timeEnd", "timeLog", "timeStamp", "trace", "warn", "init_console", "init_performance", "init_console", "init_performance", "hrtime", "now", "init_performance", "Socket", "init_performance", "dir", "env", "count", "init_performance", "init_performance", "cwd", "hrtime", "assert", "init_process", "init_performance", "init_process", "init_performance", "_a", "err", "DiagLogLevel", "self", "err", "_a", "self", "context", "ValueType", "context", "TraceFlags", "context", "_a", "name", "context", "name", "version", "context", "tracer", "name", "version", "_a", "SamplingDecision", "SpanKind", "SpanStatusCode", "name", "version", "context", "context", "context", "name", "version", "init_performance", "text", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "context", "err", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "match", "name", "name", "raw", "text", "init_performance", "context", "name", "text", "object", "init_performance", "init_performance", "err", "app", "env", "context", "init_performance", "init_performance", "init_performance", "init_performance", "context", "name", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "Node", "_Node", "name", "Node", "Hono", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "_a", "config", "init_performance", "init_performance", "init_performance", "_a", "name", "table", "init_performance", "_a", "table", "config", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "_a", "name", "init_performance", "_a", "config", "name", "table", "init_performance", "init_performance", "table", "_a", "name", "init_performance", "value", "startFrom", "_a", "name", "config", "table", "ref", "actions", "_a", "name", "table", "config", "init_performance", "_a", "sql", "init_performance", "init_performance", "version", "name", "version", "otel", "rawTracer", "init_performance", "_a", "config", "_a", "param", "sql", "raw", "placeholder", "name", "SQL", "_a", "_a", "name", "result", "name", "table", "table", "_a", "_a", "name", "table", "init_performance", "init_performance", "_a", "table", "config", "relations", "table", "config", "init_performance", "init_performance", "init_performance", "_a", "table", "_a", "config", "init_performance", "init_performance", "_a", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "_a", "ForeignKeyBuilder", "config", "name", "table", "ForeignKey", "init_performance", "uniqueKeyName", "table", "_a", "UniqueConstraintBuilder", "name", "table", "UniqueConstraint", "UniqueOnConstraintBuilder", "uniqueKeyName", "_a", "name", "config", "table", "ref", "actions", "ForeignKeyBuilder", "uniqueKeyName", "_a", "name", "table", "config", "init_performance", "_a", "name", "table", "config", "init_performance", "_a", "name", "config", "table", "init_performance", "_a", "name", "table", "init_performance", "_a", "name", "table", "init_performance", "_a", "name", "config", "table", "InlineForeignKeys", "_a", "name", "table", "_a", "table", "init_performance", "init_performance", "init_performance", "init_performance", "_a", "table", "init_performance", "_a", "init_performance", "_a", "_a", "config", "name", "table", "select", "sql", "joinOn", "field", "init_performance", "init_performance", "_a", "_a", "config", "table", "on", "_a", "self", "_a", "table", "config", "init_performance", "_a", "table", "on", "init_performance", "_a", "init_performance", "_a", "table", "config", "init_performance", "_a", "_a", "self", "table", "config", "init_performance", "init_performance", "_a", "err", "sql", "_a", "builtQuery", "config", "err", "_a", "config", "init_performance", "init_performance", "init_performance", "toRow", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "now", "init_performance", "error", "init_performance", "schedules", "init_performance", "init_performance", "error", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "util", "object", "objectUtil", "error", "init_performance", "init_performance", "init_performance", "errorUtil", "error", "errorMap", "err", "version", "ctx", "result", "issues", "elements", "processed", "result", "r", "ZodFirstPartyTypeKind", "init_performance", "init_performance", "init_performance", "init_performance", "createSchedule", "init_performance", "init_performance", "init_performance", "updateSchedule", "init_performance", "Hono", "init_performance", "init_performance", "init_performance", "now", "init_performance", "Hono", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "error", "tracer", "error", "init_performance", "init_performance", "name", "init_performance", "__create", "__defProp", "__getOwnPropDesc", "__getOwnPropNames", "__getProtoOf", "__hasOwnProp", "name", "symbol", "__defNormalProp", "__name", "__commonJS", "__copyProps", "except", "desc", "__toESM", "self", "_a", "name", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "webcrypto", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "schema", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "schema", "init_performance", "init_performance", "init_performance", "schema", "init_performance", "init_performance", "custom", "name", "init_performance", "_a", "_AISDKError", "name", "error", "marker", "symbol", "text", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "error", "_TypeValidationError", "init_performance", "error", "resolve", "generateId", "getErrorMessage", "zodSchema", "validator", "error", "text", "SecureJSON", "TypeValidationError", "InvalidArgumentError", "getOriginalFetch", "fetch", "APICallError", "APICallError", "APICallError", "error", "atob", "init_performance", "init_performance", "init_performance", "name", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "emojiRegex", "init_performance", "object", "init_performance", "init_performance", "init_performance", "init_performance", "types", "x", "base", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "selectParser", "selectParser", "jsonSchema", "init_performance", "init_performance", "name", "schema", "title", "esm_default", "textStreamPart", "errorStreamPart", "validCodes", "NEWLINE", "zodSchema", "_a", "esm_default", "jsonSchema", "import_api", "error", "name", "marker", "symbol", "_a", "InvalidArgumentError", "AISDKError", "error", "getErrorMessage", "tracer", "attributes", "name", "marker", "symbol", "_a", "_a", "symbol", "convertBase64ToUint8Array", "name", "marker", "symbol", "_a", "AISDKError", "text", "error", "convertUint8ArrayToBase64", "convertBase64ToUint8Array", "InvalidArgumentError", "processBlock", "content", "tool", "i", "z", "context", "safeValidateTypes", "generateId", "tracer", "span", "_b", "_c", "_d", "result", "object", "TypeValidationError", "originalGenerateId", "createIdGenerator", "now", "self", "doStreamSpan", "getErrorMessage", "asSchema", "match", "safeParseJSON", "_e", "_f", "__export", "_a", "symbol", "text", "asSchema", "parsePartialJson", "context", "safeParseJSON", "safeValidateTypes", "error", "result", "tracer", "tool", "generateId", "originalGenerateId", "createIdGenerator", "originalGenerateMessageId", "now", "text", "_a", "InvalidArgumentError", "AISDKError", "self", "stepType", "stream", "doStreamSpan", "stepReasoning", "stepFiles", "activeReasoningText", "getErrorMessage", "formatDataStreamPart", "name", "marker", "symbol", "_a", "_a", "symbol", "z", "__export", "_a", "formatDataStreamPart", "mergeIntoDataStream", "toDataStream", "toDataStreamResponse", "toDataStreamInternal", "text", "init_performance", "zodSchema", "jsonSchema", "zodSchema", "isNull", "error", "err", "delay", "isZodType", "detectSingleMessageCharacteristics", "attachmentsToParts", "convertDataContentToBase64String", "exists", "now", "error", "init_performance", "init_performance", "name", "delay", "EventEmitter", "__commonJS", "__toESM", "_a", "err", "now", "_init", "config", "text", "context", "title", "context", "_a", "text", "token", "logprob", "type", "UnsupportedFunctionalityError", "openaiTools", "config", "generateId", "toolCall", "z", "postJsonToApi", "combineHeaders", "createJsonResponseHandler", "createEventSourceResponseHandler", "blob", "convertUint8ArrayToBase64", "parseProviderOptions", "_b", "_c", "self", "init_performance", "title", "text", "init_performance", "title", "init_performance", "title", "error", "init_performance", "title", "error", "init_performance", "init_performance", "title", "Hono", "Hono", "Hono", "init_performance", "env", "init_performance", "env", "error", "init_performance", "env", "env"]
}
